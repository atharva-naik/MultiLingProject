{
    "accuracy": 0.0013651877133105802,
    "bleu": {
        "bleu": 0.1395660808496478,
        "precisions": [
            0.5452253067224515,
            0.27677360009198576,
            0.1651833226127127,
            0.10932889100428367
        ],
        "brevity_penalty": 0.6108427604532574,
        "length_ratio": 0.6698301849635678,
        "translation_length": 88435,
        "reference_length": 132026
    },
    "codebleu": 0.213021165064045,
    "preds": [
        "func (f *File) DeleteWorksheet(sheet string) error {\n\txlsx, err := f.workSheetReader(sheet)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = f.workSheetReaderWriter(xlsx, sheet)\n\treturn err\n}",
        "func (f *File) DeleteWorksheetByCID(cid int) error {\n\treturn f.deleteWorksheet(cid, true)\n}",
        "func (c *Client) FetchContactGroup(cid string) (*ContactGroup, error) {\n\tvar contactGroup ContactGroup\n\terr := c.get(`contact/group?cid=`+cid, &contactGroup)\n\treturn &contactGroup, err\n}",
        "func (c *Client) FetchContactGroups(token string) ([]ContactGroup, error) {\n\tvar contactGroups []ContactGroup\n\tpath := fmt.Sprintf(\"/users/token/%s/contact-groups\", token)\n\terr := c.Get(path, &contactGroups)\n\treturn contactGroups, err\n}",
        "func (c *Client) UpdateContactGroup(contactGroup ContactGroup) (*ContactGroup, error) {\n\tparams := struct {\n\t\tContactGroup ContactGroup `json:\"contact_group\"`\n\t}{\n\t\tContactGroup: contactGroup,\n\t}\n\tvar contactGroupRes ContactGroup\n\treturn &contactGroupRes, c.Patch(&contactGroupRes, \"/contact_groups\", params)\n}",
        "func (c *Client) CreateContactGroup(group *ContactGroup) error {\n\treturn c.Post(\"/contact_groups\", group, group)\n}",
        "func (c *Client) DeleteContactGroup(group string) error {\n\treturn c.Delete(\"/contact-groups/\" + group)\n}",
        "func (s *Service) FetchBroker(w http.ResponseWriter, r *http.Request) {\n\tcid, err := paramID(\"id\", r)\n\tif err != nil {\n\t\tError(w, http.StatusUnprocessableEntity, err.Error(), s.Logger)\n\t\treturn\n\t}\n\n\tctx := r.Context()\n\tbroker, err := s.Store.Brokers(ctx).Get(ctx, cid)\n\tif err != nil {\n\t\tnotFound(w, cid, s.Logger)\n\t\treturn\n\t}\n\n\tres := newBrokerResponse(broker)\n\tencodeJSON(w, http.StatusOK, res, s.Logger)\n}",
        "func (c *Client) FetchBrokers(ctx context.Context) ([]string, error) {\n\tvar brokers []string\n\terr := c.fetch(ctx, \"/brokers\", &brokers)\n\treturn brokers, err\n}",
        "func (a *Agent) ActivateMetric(metric string) error {\n\ta.logger.Printf(\"[INFO] agent: activating metric %s\", metric)\n\treturn a.client.ActivateMetric(metric)\n}",
        "func (c *CheckBundle) AddMetricTags(tags map[string]string) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tfor k, v := range tags {\n\t\tc.metricTags[k] = v\n\t}\n}",
        "func (c *CheckBundle) addNewMetrics(m *Metrics) {\n\tc.Metrics = append(c.Metrics, m)\n}",
        "func (c *CheckBundle) inventoryMetrics() []*Metric {\n\tmetrics := make([]*Metric, 0, len(c.Metrics))\n\tfor _, m := range c.Metrics {\n\t\tmetrics = append(metrics, m)\n\t}\n\treturn metrics\n}",
        "func (f *File) countNewTags(tags []string) int {\n\tvar count int\n\tfor _, tag := range tags {\n\t\tif _, ok := f.newTags[tag]; !ok {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}",
        "func (ns *Namespace) Plural(word string) (string, error) {\n\tword = strings.ToLower(word)\n\tif ns.pluralForms == nil {\n\t\treturn \"\", errors.New(\"no plural forms\")\n\t}\n\tfor _, f := range ns.pluralForms {\n\t\tif f == word {\n\t\t\treturn f, nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no plural form for \" + word)\n}",
        "func (ns *Namespace) Plural(word string) (string, error) {\n\tword = strings.ToLower(word)\n\tif ns.plural == nil {\n\t\treturn \"\", errors.New(\"No plural rules found for \" + word)\n\t}\n\tfor _, rule := range ns.plural {\n\t\tif rule.Match(word) {\n\t\t\treturn rule.Singular, nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No plural rule found for \" + word)\n}",
        "func (s *Scanner) uppercaseFirst() {\n\tif s.pos == 0 {\n\t\treturn\n\t}\n\ts.pos--\n\ts.buf[s.pos] = unicode.ToUpper(s.buf[s.pos])\n}",
        "func (p *Parser) parseDinoParty() (*DinoParty, error) {\n\tvar err error\n\tvar dinoParty *DinoParty\n\n\tdinoParty, err = p.parseParty()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn dinoParty, nil\n}",
        "func getSuitableAlgFromCurve(curve *elliptic.Curve) jwt.Algorithm {\n\tswitch curve.Params().N.BitLen() {\n\tcase curveParamsN.BitLen64:\n\t\treturn jwt.RSA\n\tcase curveParamsN.BitLen384:\n\t\treturn jwt.RSA\n\tcase curveParamsN.BitLen512:\n\t\treturn jwt.RSA\n\tdefault:\n\t\treturn jwt.ECDSA\n\t}\n}",
        "func getAlgFromKeyData(keyData []byte) jwt.Algorithm {\n\tvar alg jwt.Algorithm\n\tfor _, key := range keyData {\n\t\tswitch key.Type {\n\t\tcase \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA PRIVATE KEY\", \"RSA",
        "func buildEncArgs(args []string) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tfor _, arg := range args {\n\t\tif len(arg) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif buf.Len() > 0 {\n\t\t\tbuf.WriteByte('&')\n\t\t}\n\t\tbuf.WriteString(arg)\n\t}\n\treturn buf.Bytes(), nil\n}",
        "func doDec(in string) (*jwt.Token, error) {\n\tt, err := jwt.Parse(in, func(t *jwt.Token) (interface{}, error) {\n\t\tif t.Method != \"RS256\" {\n\t\t\treturn nil, fmt.Errorf(\"unsupported method: %s\", t.Method)\n\t\t}\n\t\treturn t.Claims, nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn t, nil\n}",
        "func doEnc(c context.Context, in *jwt.Token) (*jwt.Token, error) {\n\t// Encode the token.\n\tvar buf bytes.Buffer\n\tif err := json.NewEncoder(&buf).Encode(in); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a JWT token with the header and payload.\n\treturn jwt.NewWithClaims(c, &jwt.Claims{\n\t\tSubject:     in.Subject,\n\t\tIssuer:      in.Issuer,\n\t\tNotBefore:  in.NotBefore,\n\t\tNotAfter:   in.NotAfter,\n\t\tAudience:   in.Audience,\n\t\tSubjectType: in.SubjectType,\n\t\tIssuerType:  in.IssuerType,\n\t\tIssuedAt:    in.IssuedAt,\n\t\tExpiresAt:   in",
        "func Transport(transport http.RoundTripper) GServiceAccountOption {\n\treturn func(s *serviceAccount) {\n\t\ts.transport = transport\n\t}\n}",
        "func Proxy(proxy string) GServiceAccountOption {\n\treturn func(s *serviceAccount) error {\n\t\ts.proxy = proxy\n\t\treturn nil\n\t}\n}",
        "func Expiration(expiration time.Duration) GServiceAccountOption {\n\treturn func(s *serviceAccount) {\n\t\ts.expiration = expiration\n\t}\n}",
        "func Encode(token *jwt.Token) (string, error) {\n\treturn EncodeWithClaims(token, Claims{})\n}",
        "func (b *JWTBuf) PeekHeaderField(field string) (string, error) {\n\tif len(b.header) == 0 {\n\t\treturn \"\", errors.New(\"no header found\")\n\t}\n\treturn b.header[field], nil\n}",
        "func PeekAlgorithm(buf []byte) (Algorithm, error) {\n\tif len(buf) == 0 {\n\t\treturn \"\", errors.New(\"no payload\")\n\t}\n\tif buf[0] != 'A' {\n\t\treturn \"\", errors.New(\"invalid header\")\n\t}\n\tif len(buf) < 2 {\n\t\treturn \"\", errors.New(\"no algorithm found\")\n\t}\n\talg := buf[1]\n\tswitch alg {\n\tcase \"RS256\", \"RS384\", \"RS512\", \"ES256\", \"ES384\", \"ES512\", \"ES256WITHRSA\", \"ES384WITHRSA\", \"ES512WITHRSA\", \"ES256WITHRSAWITHRSA\", \"ES384WITHRSAWITHRSA\", \"ES512WITHRSAWITHRSA\", \"ES256WITHRSAWITHRSA\", \"ES384WITHRSAWITHRSA\", \"ES512WITHRSAWITHRSA\",",
        "func (p *Parser) PeekAlgorithmAndIssuer() (Algorithm, string, error) {\n\tif p.err != nil {\n\t\treturn \"\", \"\", p.err\n\t}\n\n\tif alg, ok := p.header.(Algorithm); !ok {\n\t\treturn \"\", \"\", fmt.Errorf(\"header does not contain a valid JWT algorithm\")\n\t} else if iss, ok := p.header.(Issuer); !ok {\n\t\treturn \"\", \"\", fmt.Errorf(\"header does not contain a valid JWT issuer\")\n\t} else {\n\t\treturn alg, iss, nil\n\t}\n}",
        "func NewEllipticSigner(curve elliptic.Curve) Signer {\n\treturn &ellipticSigner{\n\t\tcurve: curve,\n\t\tkey:   curve.PublicKey(),\n\t}\n}",
        "func NewTokenSource(ctx context.Context, tokenURL string, signer *jwt.Signer, claim *Claim) oauth2.TokenSource {\n\treturn &tokenSource{\n\t\tctx:     ctx,\n\t\ttokenURL: tokenURL,\n\t\tsigner:  signer,\n\t\tclaim:   claim,\n\t}\n}",
        "func (t *Token) Client() (*http.Client, error) {\n\tif t.client == nil {\n\t\tvar err error\n\t\tt.client, err = http.DefaultClient, nil\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn t.client, nil\n}",
        "func (s *Signer) Sign(buf []byte) ([]byte, error) {\n\tif s.priv == nil {\n\t\treturn nil, errors.New(\"no private key provided\")\n\t}\n\tif s.hash == nil {\n\t\treturn nil, errors.New(\"no hash provided\")\n\t}\n\tif len(buf) == 0 {\n\t\treturn nil, errors.New(\"no data provided\")\n\t}\n\n\t// Generate random key\n\trand.Read(s.priv[:])\n\n\t// Hash data\n\thash := s.hash.New()\n\thash.Write(buf)\n\ts.hash.Write(s.priv[:])\n\ts.hash.Write(s.priv[:])\n\ts.hash.Write(s.priv[:])\n\ts.hash.Write(s.priv[:])\n\ts.hash",
        "func (sig *Signature) Verify(pub *PublicKey, hash *Hash, hashData []byte) error {\n\tif sig.Hash == nil {\n\t\treturn errors.New(\"no hash function specified\")\n\t}\n\tif sig.Hash.Size() != sig.Hash.Size()+len(hashData) {\n\t\treturn errors.New(\"hash function size mismatch\")\n\t}\n\tif sig.Hash.Size() == 0 {\n\t\treturn errors.New(\"hash function is nil\")\n\t}\n\n\t// The signature is a single byte.\n\tif sig.Hash.Size() == 1 {\n\t\treturn sig.Hash.Write(sig.HashData)\n\t}\n\n\t// The signature is a multi-byte.\n\tvar buf [4]byte\n\tcopy(buf[:], sig.HashData)\n\tfor i := 0; i < sig",
        "func NewRSASigner(alg SignerAlgorithm, rsa *rsa.PublicKey) (Signer, error) {\n\tswitch alg {\n\tcase RSA_SHA1:\n\t\treturn &rsaSigner{\n\t\t\trsa: rsa,\n\t\t}, nil\n\tcase RSA_SHA256:\n\t\treturn &rsaSigner{\n\t\t\trsa: rsa,\n\t\t}, nil\n\tcase RSA_SHA384:\n\t\treturn &rsaSigner{\n\t\t\trsa: rsa,\n\t\t}, nil\n\tcase RSA_SHA512:\n\t\treturn &rsaSigner{\n\t\t\trsa: rsa,\n\t\t}, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown RSA algorithm: %s\", alg)\n\t}\n}",
        "func getFieldWithTag(obj map[string]interface{}, tagName string) (interface{}, error) {\n\tif obj == nil {\n\t\treturn nil, nil\n\t}\n\tif t, ok := obj[tagName]; ok {\n\t\treturn t, nil\n\t}\n\treturn nil, fmt.Errorf(\"no tag with name %s found\", tagName)\n}",
        "func decodeToObjOrFieldWithTag(buf []byte, defaultObj interface{}, tagName string) error {\n\tif defaultObj == nil {\n\t\treturn fmt.Errorf(\"defaultObj cannot be nil\")\n\t}\n\tif len(buf) == 0 {\n\t\treturn fmt.Errorf(\"buf cannot be nil\")\n\t}\n\tif tagName == \"\" {\n\t\treturn fmt.Errorf(\"tagName cannot be nil\")\n\t}\n\tif _, ok := defaultObj.(map[string]interface{}); !ok {\n\t\treturn fmt.Errorf(\"defaultObj must be a map[string]interface{}\")\n\t}\n\tif _, ok := defaultObj.(map[string]interface{})[tagName]; !ok {\n\t\treturn fmt.Errorf(\"defaultObj must have a map[string]interface{}\")\n\t}\n\tif _, ok := defaultObj",
        "func grabEncodeTargets(obj runtime.Object) (map[string]string, error) {\n\tif obj == nil {\n\t\treturn nil, nil\n\t}\n\tif _, ok := obj.(*runtime.Unknown); ok {\n\t\treturn nil, nil\n\t}\n\tif _, ok := obj.(*runtime.UnknownList); ok {\n\t\treturn nil, nil\n\t}\n\tif _, ok := obj.(*runtime.UnknownMap); ok {\n\t\treturn nil, nil\n\t}\n\tif _, ok := obj.(*runtime.UnknownSet); ok {\n\t\treturn nil, nil\n\t}\n\tif _, ok := obj.(*runtime.UnknownString); ok {\n\t\treturn nil, nil\n\t}\n\tif _, ok := obj.(*runtime.UnknownBool); ok {\n\t\treturn nil, nil\n\t}",
        "func encodeTargets(targets []*api.Target) []*api.Target {\n\tvar result []*api.Target\n\tfor _, t := range targets {\n\t\tresult = append(result, t)\n\t}\n\treturn result\n}",
        "func peekField(pos int, fieldName string) (string, error) {\n\tvar buf bytes.Buffer\n\t_, err := io.ReadFull(buf, ioutil.NopCloser(bytes.NewReader(peek(pos, fieldName))))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn buf.String(), nil\n}",
        "func ExpiresIn(d time.Duration) Option {\n\treturn func(o *Options) error {\n\t\tif d < 0 {\n\t\t\treturn fmt.Errorf(\"expires in must be positive\")\n\t\t}\n\t\to.ExpiresIn = d\n\t\treturn nil\n\t}\n}",
        "func Claim(claim string) Option {\n\treturn func(t *Token) error {\n\t\tt.claims = append(t.claims, claim)\n\t\treturn nil\n\t}\n}",
        "func Transport(t *http.Transport) Option {\n\treturn func(c *Client) error {\n\t\tc.transport = t\n\t\treturn nil\n\t}\n}",
        "func NewHMACSigner(alg string, key []byte) (Signer, error) {\n\tswitch alg {\n\tcase \"HS256\":\n\t\treturn &hmacSigner{alg: \"HS256\", key: key}, nil\n\tcase \"HS384\":\n\t\treturn &hmacSigner{alg: \"HS384\", key: key}, nil\n\tcase \"HS512\":\n\t\treturn &hmacSigner{alg: \"HS512\", key: key}, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported HMAC algorithm: %s\", alg)\n\t}\n}",
        "func FromJSON(buf []byte) (*ServiceAccount, error) {\n\tvar creds struct {\n\t\tClientID string `json:\"client_id\"`\n\t\tClientSecret string `json:\"client_secret\"`\n\t\tScopes       []string `json:\"scopes\"`\n\t}\n\tif err := json.Unmarshal(buf, &creds); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &ServiceAccount{\n\t\tClientID: creds.ClientID,\n\t\tClientSecret: creds.ClientSecret,\n\t\tScopes:       creds.Scopes,\n\t}, nil\n}",
        "func FromReader(r io.Reader) (*Credentials, error) {\n\tvar creds Credentials\n\tif err := json.NewDecoder(r).Decode(&creds); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &creds, nil\n}",
        "func FromFile(file io.Reader) (*Credentials, error) {\n\tvar creds Credentials\n\tif err := json.NewDecoder(file).Decode(&creds); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &creds, nil\n}",
        "func (j *JWT) Signer() jwt.Signer {\n\treturn jwt.New(jwt.GetSigningMethod(j.SigningAlgorithm), j.Key)\n}",
        "func (j *JWT) Encode() (string, error) {\n\tif j.Algorithm != AlgorithmRSA && j.Algorithm != AlgorithmDSA {\n\t\treturn \"\", fmt.Errorf(\"unsupported algorithm: %s\", j.Algorithm)\n\t}\n\n\tif j.Signer == nil {\n\t\treturn \"\", fmt.Errorf(\"no signer provided\")\n\t}\n\n\tif j.Expires.IsZero() {\n\t\treturn \"\", fmt.Errorf(\"no expiration time provided\")\n\t}\n\n\tif j.Subject == \"\" {\n\t\treturn \"\", fmt.Errorf(\"no subject provided\")\n\t}\n\n\tif j.Header == nil {\n\t\treturn \"\", fmt.Errorf(\"no header provided\")\n\t}\n\n\tif j.Body == nil {\n\t\treturn \"\", fmt.Errorf(\"no body provided\")\n\t}\n\n\treturn j.Signer.Sign(j.",
        "func (a *Algorithm) UnmarshalText(buf []byte) error {\n\tvar s string\n\tif err := json.Unmarshal(buf, &s); err != nil {\n\t\treturn err\n\t}\n\n\tswitch s {\n\tcase \"sha1\":\n\t\ta.Algorithm = sha1.New\n\tcase \"sha256\":\n\t\ta.Algorithm = sha256.New\n\tcase \"sha512\":\n\t\ta.Algorithm = sha512.New\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown algorithm: %s\", s)\n\t}\n\n\treturn nil\n}",
        "func DecodeUnverifiedToken(token string, u *UnverifiedToken) error {\n\tif len(token) == 0 {\n\t\treturn nil\n\t}\n\n\tparts := strings.SplitN(token, \".\", 2)\n\tif len(parts) != 2 {\n\t\treturn fmt.Errorf(\"malformed token: %q\", token)\n\t}\n\n\tu.Username = parts[0]\n\tu.Email = parts[1]\n\n\treturn nil\n}",
        "func (ks *KeyStore) PublicKey() ([]byte, error) {\n\tif ks.publicKey == nil {\n\t\tif ks.privateKey == nil {\n\t\t\treturn nil, errors.New(\"no public key supplied\")\n\t\t}\n\t\treturn ks.privateKey, nil\n\t}\n\treturn ks.publicKey, nil\n}",
        "func (ks *KeyStore) PrivateKey() ([]byte, error) {\n\tif ks.privateKey == nil {\n\t\treturn nil, errors.New(\"no private key stored\")\n\t}\n\treturn ks.privateKey, nil\n}",
        "func RegisterLocation(path string, url string) {\n\tif _, ok := locations[path]; ok {\n\t\tpanic(\"RegisterLocation called twice for the same path\")\n\t}\n\tlocations[path] = url\n}",
        "func NewArena(size int) *Arena {\n\treturn &Arena{\n\t\tsize:     size,\n\t\telements: make([]interface{}, size),\n\t}\n}",
        "func NewSkiplist(arena arena.Allocator) *Skiplist {\n\treturn &Skiplist{\n\t\tnodes: make(map[string]*Node),\n\t\tkeys:  make(map[string]string),\n\t\tvalues: make(map[string]Value),\n\t\tarena: arena,\n\t}\n}",
        "func (it *Iterator) Init(ctx context.Context, s *skiplist.Skiplist) {\n\tit.ctx = ctx\n\tit.s = s\n\tit.next()\n}",
        "func (p *parser) Value() (interface{}, error) {\n\tif p.pos >= len(p.buf) {\n\t\treturn nil, fmt.Errorf(\"parser.Value: past EOF\")\n\t}\n\treturn p.buf[p.pos], nil\n}",
        "func (iter *Iterator) Set(value []byte) error {\n\tif iter.err != nil {\n\t\treturn iter.err\n\t}\n\n\tif iter.record.Value == value {\n\t\treturn nil\n\t}\n\n\tif iter.record.Deleted {\n\t\treturn ErrRecordDeleted\n\t}\n\n\tif iter.record.Updated {\n\t\treturn ErrRecordUpdated\n\t}\n\n\titer.record.Value = value\n\treturn iter.update()\n}",
        "func (iter *Iterator) SetMeta(meta []byte) error {\n\tif iter.err != nil {\n\t\treturn iter.err\n\t}\n\n\tif len(meta) == 0 {\n\t\treturn nil\n\t}\n\n\tif iter.current == nil {\n\t\titer.current = &record{\n\t\t\tkey:     meta,\n\t\t\tvalue:   nil,\n\t\t\tmeta:    meta,\n\t\t\thash:    iter.hash,\n\t\t\thashType: iter.hashType,\n\t\t}\n\t} else {\n\t\tif bytes.Equal(iter.current.key, meta) {\n\t\t\titer.current.value = iter.current.value\n\t\t\titer.current.meta = iter.current.meta[:len(iter.current.meta)]\n\t\t\treturn nil\n\t\t}\n\n\t\tif bytes.Equal",
        "func (it *Iterator) Delete() error {\n\tif it.err != nil {\n\t\treturn it.err\n\t}\n\n\tif it.current.deleted {\n\t\treturn ErrRecordDeleted\n\t}\n\n\tit.current.deleted = true\n\tit.current.key = nil\n\tit.current.value = nil\n\n\treturn nil\n}",
        "func IsSameArray(a, b [][]byte) bool {\n\tif len(a) == 0 && len(b) == 0 {\n\t\treturn true\n\t}\n\tif len(a) == 0 {\n\t\treturn false\n\t}\n\tif len(b) == 0 {\n\t\treturn false\n\t}\n\tif !reflect.DeepEqual(a, b) {\n\t\treturn false\n\t}\n\treturn true\n}",
        "func New(url string, opts ...Option) (*Client, error) {\n\tc := &Client{\n\t\turl: url,\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(c); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif c.url == \"\" {\n\t\treturn nil, errors.New(\"api url is empty\")\n\t}\n\n\tif c.client == nil {\n\t\tc.client = &http.Client{}\n\t}\n\n\treturn c, nil\n}",
        "func (w *Writer) WriteIndentedN(s string, n int) {\n\tfor i := 0; i < n; i++ {\n\t\tw.Write(w.indent)\n\t}\n\tw.Write(s)\n}",
        "func (w *Writer) WriteIndented(s string, indent int) {\n\tfor i := 0; i < indent; i++ {\n\t\tw.WriteByte(' ')\n\t}\n\tw.Write(s)\n}",
        "func NewReporter(transport http.RoundTripper, bufferSize int, poolSize int) *Reporter {\n\treturn &Reporter{\n\t\tbufferSize: bufferSize,\n\t\tpoolSize:   poolSize,\n\t\ttransport: transport,\n\t\tquit:      make(chan struct{}),\n\t}\n}",
        "func (s *Server) PostCount(stat string, value int64) {\n\tDefaultReporter.PostCount(s, stat, value)\n}",
        "func (s *Server) PostCount(stat string, value int64, tags map[string]string, rate float64) {\n\ts.DefaultReporter.PostCount(stat, value, tags, rate)\n}",
        "func Post(stat string, value interface{}) {\n\tDefaultReporter.Post(stat, value)\n}",
        "func (s *Server) Post(ctx context.Context, stat string, value interface{}, time time.Time) error {\n\treturn s.DefaultReporter.Post(ctx, stat, value, time)\n}",
        "func Report(stat string, count int64, tags map[string]string, rate float64) {\n\tDefaultReporter.Report(stat, count, tags, rate)\n}",
        "func Report(stat string, value int64, time time.Time) {\n\tDefaultReporter.Report(stat, value, time)\n}",
        "func Post(stat string, value interface{}) {\n\tDefaultReporter.Post(stat, value)\n}",
        "func Post(stat string, value interface{}, time time.Time) {\n\tDefaultReporter.Post(stat, value, time)\n}",
        "func (c *Client) Stat(ctx context.Context, name string, value int64, tags map[string]string, rate float64) error {\n\treturn c.post(ctx, \"/stats/\"+name, value, tags, rate)\n}",
        "func (c *Client) Stat(stat string, value int64, time time.Time) error {\n\treturn c.Post(stat, value, time, \"/stats\")\n}",
        "func (c *Client) Stat(ctx context.Context, name string, value int64, tags map[string]string, rate float64) error {\n\treturn c.post(ctx, \"/stats/\"+name, value, tags, rate)\n}",
        "func (c *Client) Stat(ctx context.Context, name string, value interface{}) error {\n\treturn c.stat(ctx, name, value, \"POST\")\n}",
        "func (c *Client) Stat(stat string, value interface{}, t time.Time) error {\n\treturn c.Post(stat, value, t, \"/stats\")\n}",
        "func (c *Client) Stat(name string, value int64) error {\n\treturn c.Post(fmt.Sprintf(\"/stats/%s\", name), &Stat{Value: value, Type: \"count\"})\n}",
        "func (c *Client) Count(stat string, value int64) error {\n\treturn c.Post(stat, fmt.Sprintf(\"count(%d)\", value), nil)\n}",
        "func (c *Client) Stat(stat string, value int64, time time.Time) error {\n\treturn c.Post(fmt.Sprintf(\"/stats/%s\", stat), value, time)\n}",
        "func (c *Client) Stat(stat string, value interface{}) error {\n\treturn c.Post(stat, value, \"stat\")\n}",
        "func (c *Client) Stat(stat string, value interface{}, time time.Time) error {\n\treturn c.Post(stat, value, time, \"/stats\")\n}",
        "func NewBatchReporter(interval time.Duration) *BatchReporter {\n\treturn &BatchReporter{\n\t\tinterval: interval,\n\t\tstats:    make(map[string]*BatchStat),\n\t}\n}",
        "func cleanHost(rawHost string) string {\n\t// Remove the port if it exists\n\tif i := strings.Index(rawHost, \":\"); i != -1 {\n\t\trawHost = rawHost[:i]\n\t}\n\n\t// Remove the hostname if it exists\n\tif i := strings.Index(rawHost, \"@\"); i != -1 {\n\t\trawHost = rawHost[:i]\n\t}\n\n\t// Remove the port if it exists\n\tif i := strings.Index(rawHost, \":\"); i != -1 {\n\t\trawHost = rawHost[:i]\n\t}\n\n\t// Remove the port if it exists\n\tif i := strings.Index(rawHost, \"@\"); i != -1 {\n\t\trawHost = rawHost[:i]\n\t}\n\n\t// Remove the hostname if it exists\n\tif i := strings.",
        "func (c *Client) GetHost(host string) (*Host, bool) {\n\tvar hostResp Host\n\tvar ok bool\n\n\tif host == \"\" {\n\t\thostResp, ok = c.GetHostByHostname()\n\t} else {\n\t\thostResp, ok = c.GetHostByIP(host)\n\t}\n\n\treturn &hostResp, ok\n}",
        "func (r *Scanner) scanTarget(target string) (*Result, error) {\n\tr.target = target\n\tr.start = 0\n\tr.end = 0\n\tr.pos = 0\n\tr.line = 1\n\tr.column = 1\n\tr.lineType = 0\n\tr.columnType = 0\n\tr.err = nil\n\tr.eof = false\n\tr.eof = false\n\tr.lineType = 0\n\tr.columnType = 0\n\tr.err = nil\n\tr.eof = false\n\tr.err = nil\n\tr.pos = 0\n\tr.line = 1\n\tr.column = 1\n\tr.pos = 0\n\tr.lineType = 0\n\tr.columnType = 0\n\treturn r.scan()\n}",
        "func (h *Host) Diff(arg *Host) (int, int) {\n\tif h == arg {\n\t\treturn 0, 0\n\t}\n\n\th.Lock()\n\tdefer h.Unlock()\n\n\tadded := h.ports.Difference(arg.ports)\n\tremoved := arg.ports.Difference(h.ports)\n\n\treturn added.Size(), removed.Size()\n}",
        "func (h *Host) ToString() string {\n\treturn fmt.Sprintf(\"%s:%d\", h.IP, h.Port)\n}",
        "func (s *Scan) Init(hosts map[string]string) {\n\ts.Hosts = hosts\n\ts.MaxRows = -1\n\ts.MaxFields = -1\n\ts.MaxFieldsPerRecord = -1\n\ts.MaxFieldsPerRecordList = -1\n\ts.MaxFieldsPerRecordSet = -1\n\ts.MaxFieldsPerRecordSetList = -1\n\ts.MaxFieldsPerRecordSetSet = -1\n\ts.MaxFieldsPerRecordSetList = -1\n\ts.MaxFieldsPerRecordSetMap = -1\n\ts.MaxFieldsPerRecordSetMapList = -1\n\ts.MaxFieldsPerRecordMap = -1\n\ts.MaxFieldsPerRecordMapList = -1\n\ts.MaxFieldsPerRecordMapSet = -1\n\ts.MaxFieldsPerRecordMapSetList = -1\n\ts.",
        "func (s *Scanner) AddHosts(hosts []string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.hosts = append(s.hosts, hosts...)\n}",
        "func (s *Server) SetHosts(hosts []string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.hosts = hosts\n}",
        "func (s *PortsScanner) AddPorts(ports []string) {\n\ts.Lock()\n\tdefer s.Unlock()\n\ts.ports = append(s.ports, ports)\n}",
        "func (p *Pod) SetPorts(ports []string) *Pod {\n\tp.Spec.Ports = ports\n\treturn p\n}",
        "func (s *PortScanner) SetTCPPorts(ports []string) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\ts.tcpPorts = ports\n}",
        "func (s *Scanner) SetUDPPort(port int) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.udpPort = port\n}",
        "func (c *Command) AddFlags(flags []*Flag) {\n\tfor _, f := range flags {\n\t\tc.AddFlag(f)\n\t}\n}",
        "func (s *Server) IntenseAllTCPPorts(ctx context.Context, req *pb.IntenseAllTCPPortsRequest) (resp *pb.IntenseAllTCPPortsResponse, err error) {\n\tdefer s.HandlePanic(&err)\n\n\t// Intense all the ports\n\tfor _, port := range req.Ports {\n\t\tif err := s.IntenseTCPPort(ctx, port); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &pb.IntenseAllTCPPortsResponse{}, nil\n}",
        "func (h *Hosts) ToString() string {\n\tvar buf bytes.Buffer\n\tfor _, host := range *h {\n\t\tbuf.WriteString(host.String())\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\treturn buf.String()\n}",
        "func CreateNmapArgs(scan *Scan) []string {\n\targs := make([]string, 0, len(scan.Args))\n\tfor _, arg := range scan.Args {\n\t\targs = append(args, fmt.Sprintf(\"%s=%s\", arg.Key, arg.Value))\n\t}\n\treturn args\n}",
        "func uint16ListToStringList(list []uint16) []string {\n\tvar out []string\n\tfor _, v := range list {\n\t\tout = append(out, fmt.Sprintf(\"%v\", v))\n\t}\n\treturn out\n}",
        "func (p Port) ToString() string {\n\treturn fmt.Sprintf(\"%d:%d\", p.Protocol, p.Port)\n}",
        "func (otp *OTP) Counter() uint64 {\n\totp.mtx.Lock()\n\tdefer otp.mtx.Unlock()\n\treturn otp.counter\n}",
        "func (otp *OTP) Increment() error {\n\tif otp.counter == 0 {\n\t\treturn fmt.Errorf(\"OTP counter is not set\")\n\t}\n\n\totp.counter++\n\n\treturn nil\n}",
        "func NewHOTP(key string, digits int) *HOTP {\n\treturn &HOTP{\n\t\tkey:     key,\n\t\tdigits: digits,\n\t\tstate:   make(map[string]int),\n\t}\n}",
        "func (otp *OTP) URL(label string) string {\n\treturn fmt.Sprintf(\"%s/oauth2/token?client_id=%s&redirect_uri=%s&scope=%s&state=%s\",\n\t\totp.Config.Endpoint, otp.ClientID, otp.RedirectURI, otp.Scope, otp.State)\n}",
        "func QR(data []byte) ([]byte, error) {\n\tqr := qrcode.New()\n\tqr.Level = qrcode.LevelQ\n\tqr.OutFormat = qrcode.OutFormatPNG\n\tqr.OutWidth = 256\n\tqr.OutHeight = 256\n\tqr.OutMode = qrcode.OutModePNG\n\tqr.Image = data\n\tqr.ErrorCorrectionLevel = qrcode.LevelQ\n\treturn qr.Encode()\n}",
        "func truncate(hash []byte, length int) []byte {\n\tif length < 0 {\n\t\tpanic(\"truncate: length must be >= 0\")\n\t}\n\tif length > maxLength {\n\t\tpanic(\"truncate: length must be <= \" + strconv.Itoa(maxLength))\n\t}\n\tif length == 0 {\n\t\treturn hash\n\t}\n\tif length < 4 {\n\t\treturn append(hash, 0)\n\t}\n\treturn append(hash, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
        "func FromURL(url string) (otp, label string, err error) {\n\totp = \"\"\n\tlabel = \"\"\n\tif url == \"\" {\n\t\treturn\n\t}\n\tif !strings.HasPrefix(url, \"otp://\") {\n\t\treturn\n\t}\n\turl = url[len(\"otp://\"):]\n\tparts := strings.Split(url, \"/\")\n\tif len(parts) != 3 {\n\t\treturn\n\t}\n\totp = parts[0]\n\tlabel = parts[1]\n\tif otp == \"\" {\n\t\treturn\n\t}\n\tif !strings.HasSuffix(otp, \"/\") {\n\t\totp += \"/\"\n\t}\n\treturn\n}",
        "func GenerateHOTP(secret string, randCounter bool) (string, error) {\n\tif randCounter {\n\t\treturn generateRandomHOTP(secret)\n\t}\n\treturn generateHOTP(secret)\n}",
        "func YubiKey(otp string) (otpCode, token string, valid bool) {\n\t// Split the OATH-HOTP string into parts.\n\tparts := strings.Split(otp, \".\")\n\tif len(parts) != 3 {\n\t\treturn \"\", \"\", false\n\t}\n\n\t// Extract the token identifier.\n\ttoken = parts[0]\n\n\t// Extract the OATH-HOTP code.\n\totpCode = parts[1]\n\n\t// Check if the code is valid.\n\tif !yubiKeyValid(otpCode) {\n\t\treturn \"\", \"\", false\n\t}\n\n\treturn otpCode, token, true\n}",
        "func (c *Client) IntegrityCheck() (string, int, error) {\n\tvar result struct {\n\t\tOTP string `json:\"otp\"`\n\t\tC   int    `json:\"counter\"`\n\t}\n\tif err := c.get(`integrity/check`, &result); err != nil {\n\t\treturn \"\", 0, err\n\t}\n\treturn result.OTP, result.C, nil\n}",
        "func (otp *OTP) Check(code string) bool {\n\totp.mtx.Lock()\n\tdefer otp.mtx.Unlock()\n\n\tif otp.counter == 0 {\n\t\treturn false\n\t}\n\n\tif otp.counter > otp.MaxCounter {\n\t\treturn false\n\t}\n\n\tif otp.counter > otp.MaxCounter {\n\t\totp.counter = 0\n\t}\n\n\tif otp.counter < otp.MinCounter {\n\t\totp.counter = otp.MinCounter\n\t}\n\n\tif otp.counter > otp.MaxCounter {\n\t\treturn false\n\t}\n\n\tif otp.counter < otp.MinCounter {\n\t\totp.counter = otp.MaxCounter\n\t}\n\n\treturn otp.otp.Check(code)\n}",
        "func (k *OTPKey) Marshal() ([]byte, error) {\n\tif k.Algorithm != AlgorithmOTP {\n\t\treturn nil, fmt.Errorf(\"invalid HOTP key type: %d\", k.Algorithm)\n\t}\n\n\tvar buf bytes.Buffer\n\tif _, err := buf.Write(k.Key); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buf.Bytes(), nil\n}",
        "func (k *OTPKey) Unmarshal(data []byte) error {\n\tif len(data) != len(k) {\n\t\treturn fmt.Errorf(\"invalid HOTP key length: %d != %d\", len(data), len(k))\n\t}\n\n\tcopy(k[:], data)\n\treturn nil\n}",
        "func NewWriterPool(maxRate, maxBurst int, writers ...io.Writer) *WriterPool {\n\treturn &WriterPool{\n\t\tmaxRate: maxRate,\n\t\tmaxBurst: maxBurst,\n\t\twriters: writers,\n\t}\n}",
        "func throttledWriter(w io.Writer) io.Writer {\n\tif w == nil {\n\t\treturn nil\n\t}\n\treturn &throttledWriter{\n\t\tw:   w,\n\t\tdone: make(chan struct{}),\n\t}\n}",
        "func (t *throttledWriters) Len() int {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn len(t.writers)\n}",
        "func NewReaderPool(maxRate, maxBurst int, readers ...io.Reader) io.ReaderPool {\n\treturn &throttledReaderPool{\n\t\tmaxRate: maxRate,\n\t\tmaxBurst: maxBurst,\n\t\treaders: readers,\n\t}\n}",
        "func throttledReader(r io.Reader) io.Reader {\n\treturn &throttledReader{\n\t\tr:   r,\n\t\tdone: make(chan struct{}),\n\t}\n}",
        "func (p *Pool) SetRate(rate int) int {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\n\toldRate := p.rate\n\tp.rate = rate\n\tfor _, outReader := range p.outReaders {\n\t\toutReader.SetRate(rate)\n\t}\n\treturn oldRate\n}",
        "func (t *ThrottledReadWriterPool) Len() int {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn len(t.readers)\n}",
        "func NewMeasuredWriter(w io.Writer, m time.Duration) io.Writer {\n\treturn &measuredWriter{\n\t\tw:   w,\n\t\tm:   m,\n\t\tstart: time.Now(),\n\t}\n}",
        "func (m *Measurement) BytesPerSec() float64 {\n\tm.mtx.RLock()\n\tdefer m.mtx.RUnlock()\n\treturn float64(m.bytesPerSec)\n}",
        "func NewMeasuredReader(r io.Reader, duration time.Duration) io.Reader {\n\treturn &measuredReader{\n\t\tr:   r,\n\t\tduration: duration,\n\t}\n}",
        "func (r *ReadStats) BytesPerSecond() float64 {\n\treturn float64(r.BytesRead) / float64(time.Second)\n}",
        "func (m *Measurement) BytesPerSec() float64 {\n\tm.mtx.RLock()\n\tdefer m.mtx.RUnlock()\n\treturn float64(m.bytesRead) / float64(time.Second)\n}",
        "func ThrottledReader(r io.Reader, rate, maxBurst time.Duration) io.Reader {\n\treturn &throttledReader{\n\t\tr:   r,\n\t\trate: rate,\n\t\tmaxBurst: maxBurst,\n\t}\n}",
        "func ThrottledWriter(w io.Writer, rate, maxBurst time.Duration) io.Writer {\n\treturn &throttledWriter{\n\t\tw:       w,\n\t\trate:    rate,\n\t\tmaxBurst: maxBurst,\n\t}\n}",
        "func New(domain string) (*DNS, error) {\n\tif domain == \"\" {\n\t\treturn nil, fmt.Errorf(\"DNS domain cannot be empty\")\n\t}\n\n\tif strings.Contains(domain, \".\") {\n\t\treturn nil, fmt.Errorf(\"DNS domain cannot contain dot\")\n\t}\n\n\treturn &DNS{\n\t\tdomain: domain,\n\t}, nil\n}",
        "func validateSRVName(name string) error {\n\tif len(name) == 0 {\n\t\treturn fmt.Errorf(\"SRV name cannot be empty\")\n\t}\n\tif !strings.HasPrefix(name, \"http://\") && !strings.HasPrefix(name, \"https://\") {\n\t\treturn fmt.Errorf(\"SRV name must start with http:// or https://\")\n\t}\n\tif len(name) > 255 {\n\t\treturn fmt.Errorf(\"SRV name must be no more than 255 characters\")\n\t}\n\treturn nil\n}",
        "func (d *DNSServer) rewriteHosts(hostEntries []string) {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\tfor _, hostEntry := range hostEntries {\n\t\tif _, ok := d.domains[hostEntry]; !ok {\n\t\t\td.domains[hostEntry] = &domain{\n\t\t\t\tentries: make(map[string]*hostEntry),\n\t\t\t}\n\t\t}\n\t\td.domains[hostEntry].entries[hostEntry] = nil\n\t}\n}",
        "func (r *DNSProvider) lookupA(fqdn string) (*dns.A, error) {\n\tvar a *dns.A\n\tvar err error\n\n\tif a, err = r.lookup(fqdn); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif a != nil {\n\t\treturn a, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"no A record found for %s\", fqdn)\n}",
        "func (r *Request) SetHost(host string) *Request {\n\tr.Host = host\n\treturn r\n}",
        "func (api *HostsAPI) Delete(id string) (task *Task, err error) {\n\tres, err := api.client.restClient.Delete(api.client.Endpoint+hostUrl+\"/\"+id, api.client.options.TokenOptions)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\ttask, err = getTask(getError(res))\n\treturn\n}",
        "func (_class SRVClass) Set(sessionID SessionRef, self SRVRef, service string, protocol string) (_err error) {\n\t_method := \"SRV.set\"\n\t_sessionIDArg, _err := convertSessionRefToXen(fmt.Sprintf(\"%s(%s)\", _method, \"session_id\"), sessionID)\n\tif _err != nil {\n\t\treturn\n\t}\n\t_selfArg, _err := convertSRVRefToXen(fmt.Sprintf(\"%s(%s)\", _method, \"self\"), self)\n\tif _err != nil {\n\t\treturn\n\t}\n\t_serviceArg, _err := convertStringToXen(fmt.Sprintf(\"%s(%s)\", _method, \"service\"), service)\n\tif _err != nil {\n\t\treturn\n\t}\n\t_protocolArg, _err := convertStringToXen(fmt.Sprintf",
        "func (c *Client) DeleteSRVRecord(service, protocol, name string) error {\n\tvalues := url.Values{\n\t\t\"service\":   {service},\n\t\t\"protocol\": {protocol},\n\t\t\"name\":      {name},\n\t}\n\n\tif err := c.post(`server/delete_srv_record`, values, nil); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "func NewTypedHelper(data []byte) (*TypedHelper, error) {\n\tvar helper TypedHelper\n\tif err := json.Unmarshal(data, &helper); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &helper, nil\n}",
        "func NewTyped(data []byte) *Typed {\n\tt := &Typed{}\n\terr := json.Unmarshal(data, t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn t\n}",
        "func NewTypedHelper(data []byte) (*TypedHelper, error) {\n\tvar helper TypedHelper\n\tif err := json.Unmarshal(data, &helper); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &helper, nil\n}",
        "func (f *File) Typed(name string) (*Typed, error) {\n\tdata, err := ioutil.ReadFile(f.Path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn f.TypedFrom(string(data))\n}",
        "func typedHelpers(root interface{}) []*TypedHelper {\n\tif root == nil {\n\t\treturn nil\n\t}\n\tif t, ok := root.(map[string]interface{}); ok {\n\t\thelpers := make([]*TypedHelper, 0)\n\t\tfor k, v := range t {\n\t\t\thelpers = append(helpers, &TypedHelper{\n\t\t\t\tKey:    k,\n\t\t\t\tValue: v,\n\t\t\t})\n\t\t}\n\t\treturn helpers\n\t}\n\tif t, ok := root.([]interface{}); ok {\n\t\thelpers := make([]*TypedHelper, 0)\n\t\tfor _, v := range t {\n\t\t\thelpers = append(helpers, typedHelpers(v)...)\n\t\t}\n\t\treturn helpers\n\t}\n\treturn []*TypedHelper{\n\t\t&TypedHelper{\n",
        "func TypedHelpersFromFile(path string) (helpers []TypedHelper, err error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\treturn TypedHelpersFromReader(f)\n}",
        "func (c *Config) Bool(key string) bool {\n\tif v, ok := c.Get(key); ok {\n\t\tif b, ok := v.(bool); ok {\n\t\t\treturn b\n\t\t}\n\t}\n\treturn false\n}",
        "func (c *Config) Bool(key string, defaultValue bool) bool {\n\tif v, ok := c.Get(key); ok {\n\t\tif b, ok := v.(bool); ok {\n\t\t\treturn b\n\t\t}\n\t}\n\n\treturn defaultValue\n}",
        "func (self *Mock) Bool(key string) bool {\n\tval := self.Get(key)\n\tif val == nil {\n\t\tpanic(fmt.Sprintf(\"Key %s not found\", key))\n\t}\n\treturn val.(bool)\n}",
        "func (c *Config) Bool(key string) (bool, bool) {\n\tval, ok := c.Get(key)\n\tif !ok {\n\t\treturn false, false\n\t}\n\n\tb, ok := val.(bool)\n\treturn b, ok\n}",
        "func (c *Config) Int(key string, defaultValue int) int {\n\tif v, ok := c.Int64(key); ok {\n\t\treturn v\n\t}\n\n\treturn defaultValue\n}",
        "func (r *Rabbus) Int(name string) int {\n\tval, err := r.Read(name)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn val.(int)\n}",
        "func (c *Config) Int(key string) (int, bool) {\n\ti, ok := c.IntOk(key)\n\tif !ok {\n\t\treturn 0, false\n\t}\n\treturn i, true\n}",
        "func (c *Config) Float(key string, defaultValue float64) float64 {\n\tif f, ok := c.Float64(key); ok {\n\t\treturn f\n\t}\n\n\treturn defaultValue\n}",
        "func (f Float) Float() float64 {\n\tval := f.val\n\tif val == 0 {\n\t\treturn 0\n\t}\n\treturn val\n}",
        "func (c *Config) Float(key string) (float64, bool) {\n\tf, ok := c.Float64(key)\n\treturn f, ok\n}",
        "func (c *Config) String(key string, defaultValue string) string {\n\tif v, ok := c.Get(key); ok {\n\t\tif s, ok := v.(string); ok {\n\t\t\treturn s\n\t\t}\n\t}\n\n\treturn defaultValue\n}",
        "func (r *Response) String() string {\n\tif r.Error != nil {\n\t\treturn r.Error.Error()\n\t}\n\treturn r.Body\n}",
        "func (c *Config) Time(key string, defaultValue time.Time) time.Time {\n\tif val, ok := c.GetTime(key); ok {\n\t\treturn val\n\t}\n\treturn defaultValue\n}",
        "func Now() time.Time {\n\tt, err := time.Parse(time.RFC3339, time.Now().Format(time.RFC3339))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn t\n}",
        "func (c *Config) Time(key string) (time.Time, bool) {\n\tval, ok := c.TimeOk(key)\n\tif !ok {\n\t\treturn time.Time{}, false\n\t}\n\treturn val.(time.Time), true\n}",
        "func (self *Mock) Return(val interface{}) {\n\tif val == nil {\n\t\tpanic(\"Return value cannot be nil\")\n\t}\n\tself.ReturnVal = val\n}",
        "func (c *Config) String(key string, defaultValue string) string {\n\tif v, ok := c.Get(key); ok {\n\t\tif s, ok := v.(string); ok {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn defaultValue\n}",
        "func (r *MockResponse) Return(val interface{}) {\n\tif r.ReturnErr != nil {\n\t\tpanic(r.ReturnErr)\n\t}\n\tr.ReturnVal = val\n}",
        "func (m *Mrb) String(key string) (string, bool) {\n\tvalue := m.Get(key)\n\tif value == nil {\n\t\treturn \"\", false\n\t}\n\treturn value.String(), true\n}",
        "func (b *Bools) All() []bool {\n\tif b == nil {\n\t\treturn nil\n\t}\n\tb.mtx.RLock()\n\tdefer b.mtx.RUnlock()\n\treturn b.all\n}",
        "func BoolSlice(slice interface{}) []bool {\n\tif slice == nil {\n\t\treturn nil\n\t}\n\n\tswitch s := slice.(type) {\n\tcase []bool:\n\t\treturn s\n\tcase []interface{}:\n\t\tfor _, v := range s {\n\t\t\tif v == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tswitch v.(type) {\n\t\t\tcase []bool:\n\t\t\t\treturn v.([]bool)\n\t\t\tcase []interface{}:\n\t\t\t\tfor _, v2 := range v.([]interface{}) {\n\t\t\t\t\tif v2 == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch v2.(type) {\n\t\t\t\t\tcase []bool:\n\t\t\t\t\t\treturn v2.([]bool)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t",
        "func IntSlice(v interface{}) ([]int, error) {\n\tvar s []int\n\tif err := json.Unmarshal(v.([]byte), &s); err != nil {\n\t\treturn nil, err\n\t}\n\treturn s, nil\n}",
        "func Ints(v interface{}) ([]int64, error) {\n\tif v == nil {\n\t\treturn nil, nil\n\t}\n\n\tswitch v.(type) {\n\tcase []int64:\n\t\treturn v.([]int64), nil\n\tcase []interface{}:\n\t\treturn Ints(v.([]interface{}))\n\tcase []string:\n\t\ts := make([]int64, len(v.([]string)))\n\t\tfor i, s := range v.([]string) {\n\t\t\ti, err := strconv.ParseInt(s, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ts[i] = i\n\t\t}\n\t\treturn s, nil\n\tcase []float64:\n\t\ts := make([]int64",
        "func (f Floats) FloatSlice() []float64 {\n\tif len(f) == 0 {\n\t\treturn nil\n\t}\n\tout := make([]float64, len(f))\n\tfor i, v := range f {\n\t\tout[i] = v\n\t}\n\treturn out\n}",
        "func (s *StringSlice) Slice() []string {\n\tif s == nil {\n\t\treturn nil\n\t}\n\ts.lock.RLock()\n\tdefer s.lock.RUnlock()\n\treturn s.slice\n}",
        "func (t *TypedHelpers) TypedHelpers() []TypedHelper {\n\tif t.helpers == nil {\n\t\treturn nil\n\t}\n\treturn t.helpers\n}",
        "func (h *TypedHelpers) TypedHelpers() (helpers []*TypedHelper, ok bool) {\n\th.mutex.RLock()\n\tdefer h.mutex.RUnlock()\n\tfor _, helper := range h.helpers {\n\t\tif helper.IsTyped() {\n\t\t\thelpers = append(helpers, helper)\n\t\t}\n\t}\n\treturn\n}",
        "func (c *Client) GetSessions() ([]Session, error) {\n\tout, err := c.Get(c.Endpoint(\"sessions\"), url.Values{})\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tvar sessions []Session\n\tif err := json.Unmarshal(out.Bytes(), &sessions); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn sessions, nil\n}",
        "func (c *Client) ObjectChange(ctx context.Context, objectType, objectName string, changeChan chan<- *ObjectChange) error {\n\treturn c.objectChange(ctx, objectType, objectName, changeChan, nil)\n}",
        "func AutoOfferingPopUp(offerings []*ct.Offering, balance *ct.Amount) ([]Job, error) {\n\tjobs := make([]Job, len(offerings))\n\tfor i, offering := range offerings {\n\t\tjob, err := NewAgentPreOfferingPopUp(offering, balance)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tjobs[i] = job\n\t}\n\treturn jobs, nil\n}",
        "func (t *T) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(struct {\n\t\tType Type `json:\"type\"`\n\t\tValue interface{} `json:\"value\"`\n\t}{\n\t\tType: Type(t.Type),\n\t\tValue: t.Value,\n\t})\n}",
        "func (s *LogTopics) Scan(src interface{}) error {\n\tvar b bytes.Buffer\n\tif err := gob.NewEncoder(&b).Encode(src); err != nil {\n\t\treturn err\n\t}\n\treturn gob.NewDecoder(&b).Decode(s)\n}",
        "func NewWorker(config Config) (worker.Worker, error) {\n\tif err := config.Validate(); err != nil {\n\t\treturn nil, errors.Trace(err)\n\t}\n\tw := &worker{\n\t\tconfig: config,\n\t}\n\tw.tomb.Go(func() error {\n\t\treturn w.loop()\n\t})\n\treturn w, nil\n}",
        "func NewLoggerBase(name string, level Level, format string, timeFormat string, out io.Writer) *LoggerBase {\n\treturn &LoggerBase{\n\t\tname:         name,\n\t\tlevel:        level,\n\t\tformat:       format,\n\t\ttimeFormat:   timeFormat,\n\t\tout:          out,\n\t\tstackDepth:   -1,\n\t\tstackDepthStr: \"\",\n\t}\n}",
        "func (l *Logger) Log(level Level, msg string) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.log(level, msg)\n}",
        "func (s *PrivateAccountAPI) PreAccountAddBalanceApprove(ctx context.Context, account string, amount *big.Int) (bool, error) {\n\treturn s.b.PreAccountAddBalanceApprove(ctx, account, amount)\n}",
        "func (db *DB) PreAccountAddBalance(account uint64, balance *big.Int) error {\n\treturn db.PreAccountAddBalanceAsync(account, balance).Receive()\n}",
        "func (w *WalletState) AfterAccountAddBalance(mctx libkb.MetaContext, account *AccountState, psc, ptc int64) error {\n\tmctx.Debug(\"WalletState.AfterAccountAddBalance(%v, %v, %v)\", account.AccountID, psc, ptc)\n\tif psc < 0 || ptc < 0 {\n\t\treturn fmt.Errorf(\"invalid balance: %v\", psc)\n\t}\n\tif psc > account.Balance {\n\t\treturn fmt.Errorf(\"balance too high: %v\", psc)\n\t}\n\tif ptc > account.Balance {\n\t\treturn fmt.Errorf(\"balance too low: %v\", ptc)\n\t}\n\tif psc == 0 && ptc == 0 {\n\t\treturn nil\n\t}\n\tif psc == 0 {\n\t\treturn w.UpdateBalance(mctx",
        "func (w *WalletState) AfterAccountReturnBalance(account uint32, psc, ptc uint64) {\n\tw.mtx.Lock()\n\tdefer w.mtx.Unlock()\n\n\tw.afterAccountReturnBalance[account] = &afterAccountReturnBalance{\n\t\tpsc: psc,\n\t\tptc: ptc,\n\t}\n}",
        "func (c *Client) AccountUpdateBalances(accountID string, psc, eth uint64) (*AccountUpdateBalancesResult, error) {\n\tvar result AccountUpdateBalancesResult\n\tparams := struct {\n\t\tPsc    uint64 `json:\"psc\"`\n\t\tEth   uint64 `json:\"eth\"`\n\t\tAccountID string `json:\"account_id\"`\n\t}{\n\t\tPsc:    psc,\n\t\tEth:   eth,\n\t\tAccountID: accountID,\n\t}\n\terr := c.Post(`account/update_balances`, params, &result)\n\treturn &result, err\n}",
        "func PreAccountReturnBalance(psc *preaccount.PreAccount, ptc *preaccount.PreAccount) (btcutil.Amount, error) {\n\treturn psc.ReturnBalance, nil\n}",
        "func (c *Client) GetOfferingUsage(offeringID string) (int, error) {\n\toffering, err := c.GetOffering(offeringID)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn offering.Usage, nil\n}",
        "func (c *Client) GetProductUsage(productID string) (int, error) {\n\treturn c.get(fmt.Sprintf(\"/products/%s/usage\", productID), nil)\n}",
        "func (s *Service) AddMapping(port int, service string, interfaceIP net.IP) error {\n\treturn s.addMapping(port, service, interfaceIP, true)\n}",
        "func (p *PortAllocator) DeleteMapping(port int) error {\n\tp.Lock()\n\tdefer p.Unlock()\n\n\tif p.alloc == nil {\n\t\treturn fmt.Errorf(\"port allocator is not initialized\")\n\t}\n\n\tif _, ok := p.alloc.PortToInterface[port]; !ok {\n\t\treturn fmt.Errorf(\"port %d is not mapped to an UPnP interface\", port)\n\t}\n\n\tdelete(p.alloc.PortToInterface, port)\n\treturn nil\n}",
        "func (c *Client) PostCheque(ctx context.Context, paymentHash []byte, amount btcutil.Amount, cheque []byte) (*PaymentResponse, error) {\n\treturn c.PostChequeAsync(ctx, paymentHash, amount, cheque).Receive()\n}",
        "func NewHTTPClient(sock string) *HTTPClient {\n\treturn &HTTPClient{\n\t\tsock: sock,\n\t\tconn: &http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tProxy: http.ProxyFromEnvironment,\n\t\t\t},\n\t\t\tTimeout: time.Second * 5,\n\t\t},\n\t}\n}",
        "func NewServer(cfg *Config) *Server {\n\ts := &Server{\n\t\tcfg: cfg,\n\t}\n\ts.initHandlers()\n\treturn s\n}",
        "func (c *Client) AddHandler(namespace string, handler rpc.Handler) {\n\tc.handlers[namespace] = handler\n}",
        "func (s *Server) ListenAndServe() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif s.listener != nil {\n\t\treturn errors.New(\"server already running\")\n\t}\n\n\ts.listener, err := net.Listen(\"tcp\", s.Addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.listener = s.listener.(*net.TCPListener)\n\n\ts.logger.Printf(\"[INFO] consul: listening on %s\", s.Addr)\n\n\ts.serve()\n\n\treturn nil\n}",
        "func (c *Controller) Recover() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.state == controllerStateStopped {\n\t\treturn\n\t}\n\tc.state = controllerStateRecovering\n\tc.mu.Unlock()\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.mu.Unlock()\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.mu.Unlock()\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.mu.Unlock()\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.mu.Unlock()\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.mu.Unlock()\n\tc.mu.Lock()\n\t",
        "func (c *Conn) ConnStr() string {\n\tif c.connStr == \"\" {\n\t\treturn fmt.Sprintf(\"%s:%s\", c.Host, c.Port)\n\t}\n\treturn c.connStr\n}",
        "func NewDBFromConnStr(db string, opts ...Option) (*DB, error) {\n\tc, err := sql.Open(\"mysql\", db)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewDB(c, opts...)\n}",
        "func NewDB(dbType, dbPath string) (*DB, error) {\n\tdb, err := sql.Open(dbType, dbPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &DB{\n\t\tdb: db,\n\t}, nil\n}",
        "func GetCountry(ip string) (string, error) {\n\tresp, err := http.Get(fmt.Sprintf(\"%s/json/country/%s\", APIURL, ip))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tvar country struct {\n\t\tCode string `json:\"code\"`\n\t}\n\tif err = json.Unmarshal(data, &country); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn country.Code, nil\n}",
        "func (c *Client) Endpoint(channel, key string) (*EndpointMsg, error) {\n\treturn c.EndpointAsync(channel, key).Receive()\n}",
        "func NewServer(cfg *Config) *Server {\n\ts := &Server{\n\t\tcfg: cfg,\n\t}\n\n\ts.mtx = &sync.Mutex{}\n\ts.quit = make(chan struct{})\n\ts.quitCh = make(chan struct{})\n\n\ts.server = &http.Server{\n\t\tHandler: s,\n\t}\n\n\ts.server.Addr = fmt.Sprintf(\":%d\", cfg.Port)\n\ts.server.TLSConfig = &tls.Config{\n\t\tInsecureSkipVerify: cfg.InsecureSkipVerify,\n\t}\n\n\treturn s\n}",
        "func NewMonitor(chain consensus.ChainReader, config *Config) *Monitor {\n\treturn &Monitor{\n\t\tchain: chain,\n\t\tconfig: config,\n\t}\n}",
        "func (ethash *Ethash) initLastProcessedBlock(initialBlocks int64) (*types.Block, error) {\n\t// If user role is client and value of \"eth.event.lastProcessedBlock\" is 0,\n\t// then calculate the difference between the last Ethereum block and a\n\t// InitialBlocks value.\n\tif ethash.config.ClientRole == common.RoleClient &&\n\t\tinitialBlocks == 0 {\n\n\t\tlastProcessedBlock := ethash.config.LastProcessedBlock\n\t\tif lastProcessedBlock == nil {\n\t\t\treturn nil, fmt.Errorf(\"lastProcessedBlock is nil\")\n\t\t}\n\n\t\t// If the last Ethereum block is 0, then calculate the difference\n\t\t// between the last Ethereum block and a InitialBlocks value.\n\t\tif lastProcessedBlock.Height == 0 {\n\t\t\tlastProcessedBlock",
        "func (s *Scanner) Start() error {\n\ts.stopCh = make(chan struct{})\n\ts.wg.Add(1)\n\tgo s.run()\n\treturn nil\n}",
        "func newClient(config *Config) (*Client, error) {\n\tif config.APIKey == \"\" {\n\t\treturn nil, fmt.Errorf(\"Ethereum API key is required\")\n\t}\n\tif config.APISecret == \"\" {\n\t\treturn nil, fmt.Errorf(\"Ethereum API secret is required\")\n\t}\n\tif config.APIAddress == \"\" {\n\t\treturn nil, fmt.Errorf(\"Ethereum API address is required\")\n\t}\n\tif config.RPCPort == 0 {\n\t\tconfig.RPCPort = defaultRPCPort\n\t}\n\tif config.RPCTimeout == 0 {\n\t\tconfig.RPCTimeout = defaultRPCTimeout\n\t}\n\tif config.RPCMaxRetries == 0 {\n\t\tconfig.RPCMaxRetries = defaultRPCMaxRetries\n\t}\n\tif config.RPCRetryInterval == 0 {\n\t\tconfig.",
        "func (j *Job) Loop(f func(*Job) error) error {\n\tj.mu.Lock()\n\tdefer j.mu.Unlock()\n\n\tif j.state == StateRunning {\n\t\treturn fmt.Errorf(\"cannot loop job while it is running\")\n\t}\n\n\tif j.state == StateStopped {\n\t\treturn fmt.Errorf(\"cannot loop job while it is stopped\")\n\t}\n\n\tif j.state == StatePaused {\n\t\treturn fmt.Errorf(\"cannot loop job while it is paused\")\n\t}\n\n\tif j.state == StateDead {\n\t\treturn fmt.Errorf(\"cannot loop job while it is dead\")\n\t}\n\n\tif j.state == StateDead && f != nil {\n\t\treturn f(j)\n\t}\n\n\tj.state = StateRunning\n\tgo j.loop()\n\t",
        "func (c *Client) Offering(msg *Offering) error {\n\treturn c.Send(msg, true)\n}",
        "func (c *Client) Endpoint(endpoint string) (*Endpoint, error) {\n\tmsg := &Endpoint{\n\t\tEndpoint: endpoint,\n\t}\n\tif err := c.Send(msg); err != nil {\n\t\treturn nil, err\n\t}\n\treturn msg, nil\n}",
        "func (e *Enpoint) Ping() error {\n\te.RLock()\n\tdefer e.RUnlock()\n\n\tif e.state != enpointStateConnected {\n\t\treturn ErrEnpointNotConnected\n\t}\n\n\treturn nil\n}",
        "func (rpc *EthRPC) GetEthTransactions(obj *GetTransactionsObj) ([]Transaction, error) {\n\tvar transactions []Transaction\n\terr := rpc.call(\"eth_getTransactions\", &transactions, obj)\n\treturn transactions, err\n}",
        "func (c *Client) AgentSeal(msg []byte) ([]byte, error) {\n\treturn c.Seal(msg, c.PublicKey)\n}",
        "func (c *Client) ClientOpen(msg []byte) ([]byte, error) {\n\treturn c.ClientOpenWithKey(msg, c.agent.Key)\n}",
        "func PackWithSignature(msg *Message, signature []byte) ([]byte, error) {\n\tif len(signature) == 0 {\n\t\treturn nil, errors.New(\"signature is empty\")\n\t}\n\tif len(signature) != msg.SignatureLength {\n\t\treturn nil, errors.New(\"signature length is not equal to message length\")\n\t}\n\treturn msg.PackWithSignature(signature)\n}",
        "func (msg *SignedGossipMessage) UnpackSignature(signature []byte) error {\n\tif len(signature) != SignatureSize {\n\t\treturn errors.New(\"signature size mismatch\")\n\t}\n\n\t// Unmarshal signature.\n\tvar signatureMsg Signature\n\tif err := proto.Unmarshal(signature, &signatureMsg); err != nil {\n\t\treturn err\n\t}\n\n\t// Check signature.\n\tif !bytes.Equal(signatureMsg.Msg, msg.Msg) {\n\t\treturn errors.New(\"signature mismatch\")\n\t}\n\n\t// Check signature.\n\tif !bytes.Equal(signatureMsg.Signature, msg.Signature) {\n\t\treturn errors.New(\"signature mismatch\")\n\t}\n\n\treturn nil\n}",
        "func VerifySignature(signature, signatureKey, signatureValue []byte) bool {\n\tif len(signature) != SignatureLength {\n\t\treturn false\n\t}\n\tif len(signatureKey) != SignatureKeyLength {\n\t\treturn false\n\t}\n\tif len(signatureValue) != SignatureValueLength {\n\t\treturn false\n\t}\n\treturn subtle.ConstantTimeCompare(signature, signatureKey, signatureValue) == 1\n}",
        "func (c *Client) signature(method, path string, body []byte) (string, error) {\n\tif c.token == \"\" {\n\t\treturn \"\", fmt.Errorf(\"no token\")\n\t}\n\n\t// Compute signature.\n\tsig, err := c.computeSignature(method, path, body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn sig, nil\n}",
        "func (c *Connection) GetObject(bucketName, objectName, id string) ([]byte, error) {\n\tbucket := c.getBucket(bucketName)\n\tobject := bucket.Object(objectName)\n\n\tif err := object.Get(id, nil); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn object.Get(id, nil)\n}",
        "func (c *Connection) GetObjectByHash(bucketName, objectName, hash string) ([]byte, error) {\n\tbucket := c.GetBucket(bucketName)\n\tif bucket == nil {\n\t\treturn nil, ErrBucketNotFound\n\t}\n\n\tobject := bucket.Object(objectName)\n\tif object == nil {\n\t\treturn nil, ErrObjectNotFound\n\t}\n\n\tif hash == \"\" {\n\t\treturn object.GetRawJSON()\n\t}\n\n\treturn object.GetObject(hash)\n}",
        "func ToError(err error) *Error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif e, ok := err.(*Error); ok {\n\t\treturn e\n\t}\n\treturn &Error{\n\t\tMessage: err.Error(),\n\t\tCode:    int(err.Error()),\n\t}\n}",
        "func (s *Service) SetPassword(password string) error {\n\tif s.password != \"\" {\n\t\treturn trace.BadParameter(\"password already set\")\n\t}\n\ts.password = password\n\treturn nil\n}",
        "func (c *Client) UpdatePassword(ctx context.Context, name string, password string) error {\n\treturn c.put(ctx, \"/user/\"+name+\"/password\", password, nil)\n}",
        "func (s *Service) GetToken(ctx context.Context, password string) (string, error) {\n\tif password == \"\" {\n\t\treturn \"\", trace.BadParameter(\"missing password\")\n\t}\n\ttoken, err := s.GetTokenF(ctx, password)\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\tif !s.VerifyToken(ctx, token) {\n\t\treturn \"\", trace.BadParameter(\"invalid token\")\n\t}\n\treturn token, nil\n}",
        "func NewProcessor(p *Processor) *Processor {\n\treturn &Processor{\n\t\tp:          p,\n\t\tqueue:      make(chan *Message, p.queueSize),\n\t\tstopChan:   make(chan struct{}),\n\t\tstopChanChan: make(chan struct{}),\n\t}\n}",
        "func NewConfig() *Config {\n\treturn &Config{\n\t\tMaxConcurrentJobs:     defaultMaxConcurrentJobs,\n\t\tMaxConcurrentJobsPerHost: defaultMaxConcurrentJobsPerHost,\n\t\tMaxConcurrentJobsPerHostID: defaultMaxConcurrentJobsPerHostID,\n\t\tMaxConcurrentJobsPerHostIDID: defaultMaxConcurrentJobsPerHostIDID,\n\t\tMaxConcurrentJobsPerHostIDIDID: defaultMaxConcurrentJobsPerHostIDIDID,\n\t\tMaxConcurrentJobsPerHostIDIDID: defaultMaxConcurrentJobsPerHostIDIDID,\n\t\tMaxConcurrentJobsPerHostIDIDID: defaultMaxConcurrentJobsPerHostIDIDID,\n\t\tMaxConcurrentJobsPerHostIDIDID: defaultMaxConcurrentJobsPerHostIDIDID,\n\t\tMaxConcurrentJobs:        defaultMaxConcurrentJobs,\n\t\tMaxConcurrentJobsPerHostID:     defaultMaxConcurrentJobsPerHost",
        "func NewQueue(name string, opts ...QueueOption) (*Queue, error) {\n\tq := &Queue{\n\t\tname: name,\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(q); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif q.name == \"\" {\n\t\treturn nil, errors.New(\"queue name must be specified\")\n\t}\n\n\tif q.client == nil {\n\t\treturn nil, errors.New(\"client must be specified\")\n\t}\n\n\treturn q, nil\n}",
        "func (j *Jobs) AddWithDataAndDelay(data []byte, delay time.Duration) (*Job, error) {\n\treturn j.AddWithData(data, nil, delay)\n}",
        "func (j *Jobs) AddWithData(data map[string]interface{}) (*Job, error) {\n\tjob := Job{\n\t\tData: data,\n\t}\n\treturn j.Add(job)\n}",
        "func (j *Jobs) AddSimple(job Job) error {\n\treturn j.Add(job, nil)\n}",
        "func (j *Jobs) AddWithDelay(delay time.Duration, job Job) {\n\tj.Add(job)\n\ttime.AfterFunc(delay, func() {\n\t\tj.Remove(job)\n\t})\n}",
        "func (j *Job) Subscribe(keys []string, subID string) error {\n\tif len(keys) == 0 {\n\t\treturn nil\n\t}\n\tif len(keys) > 1 {\n\t\treturn fmt.Errorf(\"cannot subscribe to multiple job result notifications for %v\", keys)\n\t}\n\tif len(keys) == 1 {\n\t\tif keys[0] == \"job\" {\n\t\t\treturn fmt.Errorf(\"cannot subscribe to job result notifications for job %v\", keys[0])\n\t\t}\n\t\treturn fmt.Errorf(\"cannot subscribe to job result notifications for job id %v\", keys[0])\n\t}\n\tif subID == \"\" {\n\t\treturn fmt.Errorf(\"subID must be specified\")\n\t}\n\tif j.subscriptions == nil {\n\t\tj.subscriptions = make(map[string]map[string]",
        "func (j *Job) Unsubscribe(subID string) error {\n\treturn j.c.delete(fmt.Sprintf(\"/jobs/%s/subscriptions/%s\", j.ID, subID))\n}",
        "func (j *JobClient) TopUpChannel(channelID string) error {\n\treturn j.Post(fmt.Sprintf(\"/channels/%s/top-up\", channelID), nil, nil)\n}",
        "func (s *Server) ChangeChannelStatus(ctx context.Context, req *lnrpc.ChannelStatusRequest) (*lnrpc.ChannelStatusResponse, error) {\n\tchannel, err := s.cfg.ChannelService().GetChannel(req.ChannelID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchannel.Status = req.Status\n\n\treturn &lnrpc.ChannelStatusResponse{\n\t\tChannelID: channel.ID,\n\t\tStatus:    req.Status,\n\t}, nil\n}",
        "func (c *Client) GetAgentChannels(agentID string) ([]string, error) {\n\tvar channels []string\n\tif err := c.get(`server/channels?agent_id=`+agentID, &channels); err != nil {\n\t\treturn nil, err\n\t}\n\treturn channels, nil\n}",
        "func (c *Client) GetChannelsUsage() (*ChannelUsage, error) {\n\tvar channelUsage ChannelUsage\n\terr := c.get(`channel/usage`, &channelUsage)\n\treturn &channelUsage, err\n}",
        "func (api *Client) GetClientChannels(channelID string) (*Channel, error) {\n\treturn api.GetClientChannelsContext(context.Background(), channelID)\n}",
        "func (c *Config) ReadSetting(name string) (string, error) {\n\tif c.Settings == nil {\n\t\treturn \"\", errors.New(\"no settings\")\n\t}\n\tif v, ok := c.Settings[name]; ok {\n\t\treturn v, nil\n\t}\n\treturn \"\", errors.New(\"no setting\")\n}",
        "func (db *DB) ReadUintSetting(key []byte, offset int, dest *uint) error {\n\tc := db.c\n\tif err := checkKeySize(key); err != nil {\n\t\treturn err\n\t}\n\n\tt := c.bucket.Txn(true)\n\tdefer t.Abort()\n\n\tv := c.get(bucketKey(key), bucketItem(offset))\n\tif v == nil {\n\t\treturn ErrNotFound\n\t}\n\n\t*dest = v.(*uint)\n\treturn nil\n}",
        "func (c *FileConfig) ReadBoolSetting(key string) (bool, error) {\n\tval, err := c.readSetting(key)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn val.(bool), nil\n}",
        "func (s *Swarm) SuspendChannel(chanID lnwire.ChannelID) error {\n\treturn s.suspendChannel(chanID, false)\n}",
        "func (s *Server) ActivateChannel(channelID string) error {\n\treturn s.f.ActivateChannel(s.context(), channelID)\n}",
        "func (s *Server) TerminateChannel(ctx context.Context, req *pb.TerminateChannelRequest) (resp *pb.TerminateChannelResponse, err error) {\n\tdefer s.handlePanic(&err)\n\n\t// Check that the channel exists.\n\tch, err := s.f.Channel(ctx, req.ChannelId)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif ch == nil {\n\t\treturn nil, errors.New(\"channel does not exist\")\n\t}\n\n\t// Check that the user is allowed to terminate it.\n\tif err := s.checkChannelAdmin(ctx, ch); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Terminate the channel.\n\tif err := ch.Terminate(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &pb.Terminate",
        "func (w *Wallet) ExportPrivateKey(accountID string) ([]byte, error) {\n\tvar privKeyBytes []byte\n\terr := walletdb.View(w.db, func(tx walletdb.ReadTx) error {\n\t\taddrmgrNs := tx.ReadBucket(waddrmgrNamespaceKey)\n\t\treturn w.Manager.ForEachAccount(addrmgrNs, accountID, func(k, v []byte) error {\n\t\t\tprivKeyBytes = append(privKeyBytes, k...)\n\t\t\treturn nil\n\t\t})\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn privKeyBytes, nil\n}",
        "func (c *Client) GetAccounts() ([]Account, error) {\n\tvar accounts []Account\n\tif err := c.get(`account/list`, &accounts); err != nil {\n\t\treturn nil, err\n\t}\n\treturn accounts, nil\n}",
        "func GenerateAccount(mctx libkb.MetaContext, g *libkb.GlobalContext) (res *libkb.Account, err error) {\n\tdefer mctx.TraceTimed(\"GenerateAccount\", func() error { return err })()\n\n\t// Generate a new private key and account.\n\tprivKey, err := GeneratePrivateKey(mctx, g)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres, err = NewAccount(mctx, g, privKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, nil\n}",
        "func (w *Wallet) ImportAccountFromHex(account, hex string) (*Account, error) {\n\taccountKey, err := w.ImportPrivateKeyFromHex(hex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn w.ImportAccount(accountKey)\n}",
        "func ImportAccountFromJSON(accountID, privateKey, password string) (*Account, error) {\n\taccount := &Account{\n\t\tAccountID: accountID,\n\t}\n\tif err := account.ImportPrivateKeyFromJSON(privateKey, password); err != nil {\n\t\treturn nil, err\n\t}\n\treturn account, account.InitAccountUpdateBalances()\n}",
        "func (j *JobPreAccountTransfer) TransferTokens(accountID string, accountBalance *big.Int, direction TransferDirection) error {\n\treturn j.transferTokens(accountID, accountBalance, direction, j.PreAccountAddBalanceApprove, j.PreAccountReturnBalance)\n}",
        "func (w *WalletState) UpdateBalance(account uint32, balance *btcutil.Amount) error {\n\treturn w.db.Update(func(tx *bbolt.Tx) error {\n\t\tbucket := tx.Bucket(waddrmgrNamespaceKey)\n\t\tif bucket == nil {\n\t\t\treturn ErrStateCorrupted\n\t\t}\n\n\t\t// Get the current balance bucket.\n\t\tvar b bytes.Buffer\n\t\tif err := bucket.Get(waddrmgrBucketKey, &b); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Create a new bucket with the new balance key.\n\t\tvar bkey []byte\n\t\tif err := bucket.CreateBucketIfNotExists(waddrmgrBucketKey); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Write the new balance key.\n\t\t",
        "func (s *Server) UpdateAccount(ctx context.Context, req *api.UpdateAccountRequest) (*api.UpdateAccountResponse, error) {\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceAccounts, rbacpolicy.ActionUpdate, req.Account); err != nil {\n\t\treturn nil, err\n\t}\n\n\taccount := &api.Account{\n\t\tID:        req.Account.ID,\n\t\tName:      req.Account.Name,\n\t\tEmail:     req.Account.Email,\n\t\tProvider: req.Account.Provider,\n\t\tScopes:    req.Account.Scopes,\n\t\tExpiresAt: req.Account.ExpiresAt,\n\t}\n\n\tif err := s.store.UpdateAccount(ctx, account); err != nil {\n\t\treturn nil, err\n",
        "func (db *DB) GetLastBlockNumber() (int64, error) {\n\tvar number int64\n\terr := db.QueryRow(db.getLastBlockNumberSQL).Scan(&number)\n\treturn number, err\n}",
        "func (c *Client) GetEndpoint(key string) (*Endpoint, error) {\n\tendpoint := &Endpoint{}\n\terr := c.Get(c.EndpointPath(key), endpoint)\n\treturn endpoint, err\n}",
        "func (c *Client) SetProductConfig(i *SetProductConfigInput) error {\n\tif i.Service == \"\" {\n\t\treturn ErrMissingService\n\t}\n\n\tif i.Version == 0 {\n\t\treturn ErrMissingVersion\n\t}\n\n\tif i.Name == \"\" {\n\t\treturn ErrMissingName\n\t}\n\n\tpath := fmt.Sprintf(\"/service/%s/version/%d/logging/product/%s/config\", i.Service, i.Version, i.Name)\n\tresp, err := c.PutForm(path, i, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar r *SetProductConfigResponse\n\tif err := decodeJSON(&r, resp.Body); err != nil {\n\t\treturn err\n\t}\n\treturn r.Err\n}",
        "func NewWriterLogger(w io.Writer, level Level) *WriterLogger {\n\treturn &WriterLogger{\n\t\tw:   w,\n\t\tlevel: level,\n\t}\n}",
        "func NewFileLogger(filename string, level LevelInfo) (*FileLogger, error) {\n\tf, err := os.OpenFile(filename, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0600)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &FileLogger{\n\t\tfile: f,\n\t\tlevel: level,\n\t}, nil\n}",
        "func NewClient(t Type, data []byte) *Client {\n\treturn &Client{\n\t\tType: t,\n\t\tData: data,\n\t}\n}",
        "func Parse(s string) (*NAT, error) {\n\tif s == \"\" {\n\t\treturn nil, nil\n\t}\n\n\tvar (\n\t\tip, port, proto, protoPort, protoIP string\n\t\terr                 error\n\t)\n\n\tif ip = strings.TrimSpace(s); ip == \"\" {\n\t\treturn nil, fmt.Errorf(\"empty IP\")\n\t}\n\n\tif port = strings.TrimSpace(s); port == \"\" {\n\t\treturn nil, fmt.Errorf(\"empty port\")\n\t}\n\n\tif proto = strings.TrimSpace(s); proto == \"\" {\n\t\treturn nil, fmt.Errorf(\"empty proto\")\n\t}\n\n\tif protoPort = strings.TrimSpace(s); protoPort == \"\" {\n\t\treturn nil, fmt.Errorf(\"empty protoPort\")\n\t}\n\n\tif",
        "func (n *NAT) Map(port int, protocol string, addr net.IP, portRange *net.IPNet) error {\n\tif err := n.mapPort(port, protocol, addr, portRange); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "func (s *Service) AddMapping(port int, serviceID string, externalPort int, localPort int) error {\n\treturn s.st.UpdateServiceMapping(s.ID, &service.Mapping{\n\t\tExternalPort: externalPort,\n\t\tLocalPort:    localPort,\n\t\tServiceID:   serviceID,\n\t})\n}",
        "func (s *Service) DeleteMapping(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\tid, err := paramID(\"id\", r)\n\tif err != nil {\n\t\tError(w, http.StatusUnprocessableEntity, err.Error(), s.Logger)\n\t\treturn\n\t}\n\n\tm, err := s.Store.PortMappings(ctx).Get(ctx, id)\n\tif err != nil {\n\t\tnotFound(w, id, s.Logger)\n\t\treturn\n\t}\n\n\tif err := s.Store.PortMappings(ctx).Delete(ctx, m); err != nil {\n\t\tinvalidJSON(w, s.Logger)\n\t\treturn\n\t}\n\n\tif err := s.Store.PortMappings(ctx).Write(ctx, m); err != nil",
        "func (f *Filesystem) ReadFile(name string) ([]byte, error) {\n\treturn ioutil.ReadFile(f.Path(name))\n}",
        "func (c *Client) GetUserRole(user string) (string, error) {\n\tout, err := c.Get(c.Endpoint(\"users\", user, \"roles\"), url.Values{})\n\tif err != nil {\n\t\treturn \"\", trace.Wrap(err)\n\t}\n\treturn out.String(\"role\"), nil\n}",
        "func NewHandler(c *Config) *Handler {\n\th := &Handler{\n\t\tconfig: c,\n\t}\n\n\th.handler = http.HandlerFunc(h.handle)\n\th.handler.MaxHeaderBytes = int64(c.MaxHeaderBytes)\n\th.handler.CheckRedirect = c.CheckRedirect\n\th.handler.TLSClientConfig = &tls.Config{\n\t\tInsecureSkipVerify: c.InsecureSkipVerify,\n\t}\n\n\treturn h\n}",
        "func NewBackend(ctx context.Context, config *Config) (*Backend, error) {\n\tif config == nil {\n\t\treturn nil, errors.New(\"config is nil\")\n\t}\n\n\tif config.Network == \"\" {\n\t\treturn nil, errors.New(\"network is empty\")\n\t}\n\n\tif config.Address == \"\" {\n\t\treturn nil, errors.New(\"address is empty\")\n\t}\n\n\tif config.Chain == \"\" {\n\t\treturn nil, errors.New(\"chain is empty\")\n\t}\n\n\tif config.ChainID == \"\" {\n\t\treturn nil, errors.New(\"chainID is empty\")\n\t}\n\n\tif config.Timeout == 0 {\n\t\tconfig.Timeout = defaultTimeout\n\t}\n\n\tif config.Logger == nil {\n\t\tconfig.Logger = log.New(i",
        "func addTimeout(ctx context.Context, timeout time.Duration) context.Context {\n\treturn context.WithValue(ctx, timeoutKey, timeout)\n}",
        "func (ec *EthereumClient) PendingNonceAt(ctx *Context, account *Address) (nonce uint64, _ error) {\n\trawNonce, _ := ec.client.PendingNonceAt(ctx.context, account.address)\n\treturn uint64(rawNonce), nil\n}",
        "func (p *peer) SuggestGasPrice() (*big.Int, error) {\n\tp.log.Tracef(\"Suggesting gas price\")\n\treturn p.server.suggestGasPrice()\n}",
        "func (b *Backend) EstimateGas(ctx context.Context, tx *types.Transaction) (uint64, error) {\n\t// If the transaction is not yet in the pending state, then we can't estimate\n\t// the gas.\n\tif tx.Pending() {\n\t\treturn 0, nil\n\t}\n\n\t// Otherwise, we'll attempt to estimate the gas needed to execute the\n\t// transaction based on the current pending state of the backend blockchain.\n\treturn b.estimateGas(ctx, tx)\n}",
        "func (c *Client) CooperativeClose(ctx context.Context, arg *CooperativeCloseArg) (res *CooperativeCloseRes, err error) {\n\terr = c.Call(ctx, \"CooperativeClose\", arg, &res)\n\treturn\n}",
        "func (s *PublicTransactionPoolAPI) TransactionByHash(ctx context.Context, hash common.Hash) (*types.Transaction, error) {\n\ttx, err := s.b.TransactionByHash(ctx, hash)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tx.ToTransaction(), nil\n}",
        "func (c *Client) RegisterServiceOffering(offering *ServiceOffering) (*ServiceOffering, error) {\n\targs := struct {\n\t\tOffering *ServiceOffering `json:\"offering\"`\n\t}{\n\t\tOffering: offering,\n\t}\n\tvar reply ServiceOffering\n\terr := c.Call(\"registerServiceOffering\", args, &reply)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &reply, nil\n}",
        "func (b *BtcWallet) PTCBalanceOf(address common.Address) (*big.Int, error) {\n\treturn b.contract.PTCBalanceOf(address)\n}",
        "func (b *BtcWallet) PTCIncreaseApproval(token *btcutil.Token, amount btcutil.Amount) (*btcjson.ResultPTCIncreaseApprovalResult, error) {\n\treturn b.pcb.IncreaseApproval(token, amount)\n}",
        "func (e *engineImpl) PSCBalanceOf(ctx context.Context, args *PSCBalanceOfArgs) (reply *PSCBalanceOfReply, err error) {\n\treply = new(PSCBalanceOfReply)\n\tif args != nil {\n\t\terr = e.invokeMethod(ctx, \"balanceOf\", args, reply, true)\n\t} else {\n\t\terr = e.invokeMethod(ctx, \"balanceOf\", nil, reply, true)\n\t}\n\tif err != nil {\n\t\terr = &internal.OpError{Domain: \"Privatix\", Op: \"PSCBalanceOf\", Err: err}\n\t}\n\treturn\n}",
        "func PSCAddBalanceERC20(ctx context.Context, addr common.Address, amount *big.Int, account *string, contract *string) (res *big.Int, err error) {\n\terr = client.Call(ctx, \"addBalanceERC20\", addr, amount, account, contract, &res)\n\treturn\n}",
        "func PSCGetOfferingInfo(ctx context.Context, contractAddress common.Address) (*offering.OfferingInfo, error) {\n\tcontract, err := contract.New(ctx, contractAddress)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn contract.GetOfferingInfo()\n}",
        "func (e *engineImpl) PSCGetChannelInfo(ctx context.Context, channelID string) (*psc.ChannelInfo, error) {\n\tcontract, err := e.contract(ctx, e.contractName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn contract.PSCGetChannelInfo(ctx, channelID)\n}",
        "func (rpc *EthRPC) EthBalanceAt(account string) (float64, error) {\n\tvar balance float64\n\terr := rpc.call(\"eth_balanceAt\", &balance, account)\n\treturn balance, err\n}",
        "func (e *Engine) PSCSettle(ctx context.Context, req *psc.SettleRequest) (*psc.SettleResponse, error) {\n\treturn e.client.Settle(ctx, req)\n}",
        "func (e *Engine) PSCRemoveServiceOffering(offeringID string) error {\n\treturn e.client.Call(\"PSCRemoveServiceOffering\", offeringID, nil)\n}",
        "func (e *Engine) PSCPopupServiceOffering(ctx context.Context, offer *pb.ServiceOffering) (resp *pb.Response, err error) {\n\tcontract, err := e.contract(ctx, offer.Contract)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn contract.PSCPopupServiceOffering(ctx, offer)\n}",
        "func (c *Client) FilterLogs(ctx context.Context, filter *types.Filter, limit int) (*types.Log, error) {\n\treturn c.FilterLogsAsync(ctx, filter, limit).Receive()\n}",
        "func (ec *EthereumClient) HeaderByNumber(ctx *Context, number *big.Int) (*Header, error) {\n\trawHeader, err := ec.client.HeaderByNumber(ctx.context, number)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseHeader(rawHeader), nil\n}",
        "func (c *Client) PTCAddress() (common.Address, error) {\n\tvar address common.Address\n\terr := c.facade.FacadeCall(\"PTCAddress\", nil, &address)\n\treturn address, err\n}",
        "func (c *Client) PSCAddress() (common.Address, error) {\n\tvar addr common.Address\n\terr := c.facade.FacadeCall(\"PSCAddress\", nil, &addr)\n\treturn addr, err\n}",
        "func NewHandler(s *Server, c *rpc.Client) *Handler {\n\treturn &Handler{\n\t\tServer: s,\n\t\tClient: c,\n\t}\n}",
        "func keyFromChannelData(channelData *lnwire.ChannelData) ([]byte, error) {\n\t// The key is the first 32 bytes of the channel data.\n\tkey := make([]byte, 32)\n\n\t// The first 32 bytes of the channel data are the channel ID.\n\tcopy(key[0:4], channelData.ChannelID[:])\n\n\t// The next 32 bytes of the channel data are the channel data hash.\n\tcopy(key[4:8], channelData.ChannelDataHash[:])\n\n\t// The next 32 bytes of the channel data are the channel data hash\n\t// itself.\n\tcopy(key[8:12], channelData.ChannelDataHashSelf[:])\n\n\treturn key, nil\n}",
        "func (c *Client) AgentAfterChannelCreate(agentID, channelName string) error {\n\treturn c.Post(fmt.Sprintf(\"/agents/%s/channels\", agentID), &ChannelCreateRequest{\n\t\tChannelName: channelName,\n\t})\n}",
        "func (c *Client) AgentAfterChannelTopUp(agentID, channelID string) error {\n\treturn c.EditAgent(agentID, channelID, agent.AgentAfterChannelTopUp)\n}",
        "func (c *Channel) AgentAfterUncooperativeCloseRequest(status *ChannelStatus) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tc.agentAfterUncooperativeCloseRequest = status\n}",
        "func (c *Channel) AgentAfterUncooperativeClose(err error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\tc.agentAfterUncooperativeClose = err\n}",
        "func (c *Channel) AgentAfterCooperativeClose() {\n\tc.Lock()\n\tdefer c.Unlock()\n\tc.closed = true\n}",
        "func (c *Controller) AgentPreServiceSuspend(agentID, serviceID string) error {\n\treturn c.preServiceSuspend(agentID, serviceID)\n}",
        "func (c *Controller) AgentPreServiceUnsuspend(serviceID string) error {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tservice, ok := c.agentPreServices[serviceID]\n\tif !ok {\n\t\treturn fmt.Errorf(\"service %s not found\", serviceID)\n\t}\n\n\tif service.State != agent.ServiceStateActive {\n\t\treturn fmt.Errorf(\"service %s is not active\", serviceID)\n\t}\n\n\tservice.State = agent.ServiceStateSuspended\n\tc.agentPreServices[serviceID] = service\n\n\treturn nil\n}",
        "func (c *Controller) AgentPreServiceTerminate(serviceID string) error {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tservice, ok := c.agentPreServices[serviceID]\n\tif !ok {\n\t\treturn fmt.Errorf(\"service %s not found\", serviceID)\n\t}\n\n\tif err := service.Terminate(); err != nil {\n\t\treturn err\n\t}\n\n\tdelete(c.agentPreServices, serviceID)\n\treturn nil\n}",
        "func (c *Client) AgentAfterOfferingMsgBCPublish(offeringID string, msg *somc.PublishMessage) error {\n\treturn c.Put(fmt.Sprintf(\"/offering/%s/msg-bcpublish\", offeringID), msg, nil)\n}",
        "func AgentAfterOfferingDelete(agent *Agent, offering *offering.Offering) error {\n\toffering.Status = \"remove\"\n\treturn agent.UpdateOffering(offering)\n}",
        "func (c *Client) AgentPreOfferingDelete(offeringID string) error {\n\treturn c.Call(\"AgentPreOfferingDelete\", offeringID, nil)\n}",
        "func (c *offeringController) checkInPeriod(offering *v1.Offering, periodKey string) error {\n\tif periodKey == \"\" {\n\t\treturn nil\n\t}\n\tperiod, err := c.periodLister.Get(periodKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif period.Spec.StartPeriod.IsZero() {\n\t\treturn fmt.Errorf(\"period %q has no start period\", periodKey)\n\t}\n\tif period.Spec.EndPeriod.IsZero() {\n\t\treturn fmt.Errorf(\"period %q has no end period\", periodKey)\n\t}\n\tif period.Spec.StartPeriod.Before(offering.Spec.StartPeriod) {\n\t\treturn fmt.Errorf(\"period %q is before start period %q\", periodKey, offering.Spec.StartPeriod)\n\t}",
        "func (st *State) AgentPreOfferingPopUp(offeringUUID string) error {\n\top := \"agent_pre_offering_pop_up\"\n\tdoc := agentPreOfferingDoc{\n\t\tOfferingUUID: offeringUUID,\n\t}\n\treturn st.db().RunTransaction([]txn.Op{\n\t\t{\n\t\t\tC:      agentsC,\n\t\t\tId:     offeringDocID(offeringUUID),\n\t\t\tRemove: true,\n\t\t},\n\t})\n}",
        "func (c *Controller) AgentAfterOfferingPopUp(agent *agent.Agent, offering *offering.Offering) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tif c.blockNumber != 0 {\n\t\t// We are updating the block number, so we need to update the\n\t\t// offering's block number.\n\t\toffering.BlockNumber = c.blockNumber\n\t}\n}",
        "func Print(v ...interface{}) {\n\tfmt.Fprintf(os.Stderr, \"%s\\n\", fmt.Sprint(v...))\n\tos.Exit(0)\n}",
        "func Error(err error) string {\n\tif err == nil {\n\t\treturn \"\"\n\t}\n\tif e, ok := err.(*Error); ok {\n\t\treturn e.Message\n\t}\n\treturn fmt.Sprintf(\"error: %v\", err)\n}",
        "func Message(code ErrorCode) string {\n\tswitch code {\n\tcase NoError:\n\t\treturn \"No error\"\n\tcase InvalidArgument:\n\t\treturn \"Invalid argument\"\n\tcase AlreadyExists:\n\t\treturn \"Already exists\"\n\tcase NotImplemented:\n\t\treturn \"Not implemented\"\n\tcase Internal:\n\t\treturn \"Internal error\"\n\tcase NotImplemented:\n\t\treturn \"Not implemented\"\n\tcase PermissionDenied:\n\t\treturn \"Permission denied\"\n\tcase ResourceExhausted:\n\t\treturn \"Resource exhausted\"\n\tcase Unauthenticated:\n\t\treturn \"Unauthenticated\"\n\tcase BadGateway:\n\t\treturn \"Bad gateway\"\n\tcase ServiceUnavailable:\n\t\treturn \"Service unavailable\"\n\tcase GatewayTimeout:\n\t\treturn \"Gateway timeout\"\n\tcase HTTPVersionNotSupported:\n\t\treturn \"HTTP version not supported",
        "func (c *Client) RespondResult(result interface{}) error {\n\treturn c.Respond(Result{Result: result})\n}",
        "func (c *Client) RespondError(err error) {\n\tc.Respond(&Response{\n\t\tError: err,\n\t})\n}",
        "func (b *BtcWallet) handlePay(mctx libkb.MetaContext, arg keybase1.PayArg) error {\n\t// TODO: check if we can pay\n\treturn nil\n}",
        "func getOpenBlockNumber(log *ethlog.Log) (uint64, bool) {\n\tvar number uint64\n\tfor _, field := range log.Fields {\n\t\tif field.Name == \"Open_block_number\" {\n\t\t\tnumber = field.Value\n\t\t\treturn number, true\n\t\t}\n\t}\n\treturn 0, false\n}",
        "func (c *Client) Offering(hash common.Hash) ([]byte, error) {\n\treturn c.OfferingAsync(hash).Receive()\n}",
        "func (j *Job) HandlersMap() map[string]interface{} {\n\thandlers := make(map[string]interface{})\n\tfor _, handler := range j.handlers {\n\t\thandlers[handler.Name] = handler.Handler\n\t}\n\treturn handlers\n}",
        "func (db *DB) Version() (int, error) {\n\tvar version int\n\terr := db.QueryRow(`SELECT version FROM schema_version ORDER BY version DESC LIMIT 1`).Scan(&version)\n\treturn version, err\n}",
        "func Migrate(db *sql.DB, migrations []Migration) error {\n\tfor _, migration := range migrations {\n\t\tif err := migrate(db, migration); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "func NewMonitor(interval time.Duration) *Monitor {\n\treturn &Monitor{\n\t\tinterval: interval,\n\t\tstop:     make(chan struct{}),\n\t\tstopCh:   make(chan struct{}),\n\t\tstopCh2:  make(chan struct{}),\n\t\tstopCh3:  make(chan struct{}),\n\t\tstopCh4:  make(chan struct{}),\n\t\tstopCh5:  make(chan struct{}),\n\t\tstopCh6:  make(chan struct{}),\n\t\tstopCh7:  make(chan struct{}),\n\t\tstopCh8:  make(chan struct{}),\n\t\tstopCh9:  make(chan struct{}),\n\t\tstopCh10: make(chan struct{}),\n\t\tstopCh11: make(chan struct{}),\n\t\tstopCh12: make(chan",
        "func (m *Monitor) Run() {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tif m.stopped {\n\t\treturn\n\t}\n\n\tm.stopped = true\n\n\tfor _, ch := range m.channels {\n\t\tgo m.monitorChannel(ch)\n\t}\n}",
        "func (s *Server) VerifyBillingLags(ctx context.Context,\n\tin *lnrpc.VerifyBillingLagsRequest) (*lnrpc.VerifyBillingLagsResponse, error) {\n\n\t// First, we'll check to see if we have any active channels.\n\tactiveChannels, err := s.cfg.ChannelService.ActiveChannels(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Next, we'll check to see if we have any active channels that are\n\t// currently suffering from billing lags.\n\tsuspendedChannels, err := s.cfg.ChannelService.SuspendedChannels(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Finally, we'll check to see if we have any active channels that\n\t// are currently suspending from billing lags.\n\t",
        "func (s *SuspendedChannel) VerifySuspendedChannelsAndTryToUnsuspend(ctx context.Context) error {\n\t// First, we'll check if the channel is suspended.\n\tif err := s.isSuspended(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t// Next, we'll scan all channels and check if any of them are suspended.\n\tfor _, ch := range s.channels {\n\t\tif err := ch.VerifySuspendedChannelsAndTryToUnsuspend(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
        "func (s *Server) VerifyChannelsForInactivity(ctx context.Context, req *pb.VerifyChannelsForInactivityRequest) (resp *pb.VerifyChannelsForInactivityResponse, err error) {\n\tdefer s.HandlePanic(&err)\n\n\t// We don't want to scan the channels, so we need to scan all channels\n\t// and terminate them.\n\tfor _, ch := range s.channels {\n\t\tif ch.IsTerminated() {\n\t\t\tcontinue\n\t\t}\n\t\tif err := ch.ScanForInactivity(ctx); err != nil {\n\t\t\ts.logger.Error(\"ScanForInactivity failed\", \"error\", err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn &pb.VerifyChannelsForInactivityResponse{}, nil\n}",
        "func (s *SuspendedChannelStore) VerifySuspendedChannelsAndTryToTerminate(ctx context.Context) error {\n\ts.Lock()\n\tdefer s.Unlock()\n\n\t// We need to check if the channel is suspended, otherwise we can't\n\t// terminate it.\n\tif s.isSuspended {\n\t\treturn nil\n\t}\n\n\t// We need to check if the channel is still in the store, otherwise we can't\n\t// terminate it.\n\tif _, ok := s.suspendedChannels[s.channelID]; !ok {\n\t\treturn nil\n\t}\n\n\t// We need to check if the channel is still in the store, otherwise we can't\n\t// terminate it.\n\tif _, ok := s.suspendedChannels[s.channelID]; !ok {\n\t\treturn nil\n\t}\n\n\t// We need to",
        "func NewLogger(db *sql.DB, prefix string) *Logger {\n\treturn &Logger{\n\t\tdb:     db,\n\t\tprefix: prefix,\n\t}\n}",
        "func BalanceClosingHash(msg *lnwire.BalanceMessage) []byte {\n\t// The hash of the balance message is the sum of the\n\t// hash of the balance message itself and the hash of the\n\t// closing message itself.\n\treturn chainhash.DoubleHashH(\n\t\tmsg.Hash,\n\t\tmsg.ClosingHash,\n\t)\n}",
        "func (c *ExternalPortsCommand) Run(app subcommands.Application, args []string, env subcommands.Env) int {\n\tctx := cli.GetContext(app, c, env)\n\tclient := getClient(ctx)\n\tresp, err := client.ListExternalPorts(ctx, &c.req)\n\tif err != nil {\n\t\terrors.Log(ctx, err)\n\t\treturn 1\n\t}\n\tprintExternalPorts(c.f.tsv, resp.ExternalPorts...)\n\treturn 0\n}",
        "func RecoverPubKey(sigs [][]byte) (*btcec.PublicKey, error) {\n\tif len(sigs) == 0 {\n\t\treturn nil, errors.New(\"no signature\")\n\t}\n\n\tif len(sigs) != 2 {\n\t\treturn nil, errors.New(\"incorrect number of signature\")\n\t}\n\n\tpubKey, err := btcec.ParsePubKey(sigs[0], btcec.S256())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsig, err := btcec.ParseSignature(sigs[1], btcec.S256())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pubKey, nil\n}",
        "func (c *Client) GetTemplates() (map[string]*Template, error) {\n\tvar templates map[string]*Template\n\treturn templates, c.Get(&templates, \"/templates\")\n}",
        "func (c *Client) CreateTemplate(ctx context.Context, name string, opts ...TemplateOpt) (*Template, error) {\n\tvar t Template\n\tpath := fmt.Sprintf(\"/templates/%s\", name)\n\terr := c.post(ctx, path, nil, &t, opts...)\n\treturn &t, err\n}",
        "func (s *Service) CreateProduct(ctx context.Context, p *platform.Product) error {\n\treturn s.kv.Update(ctx, func(tx Tx) error {\n\t\treturn s.createProduct(ctx, tx, p)\n\t})\n}",
        "func (c *Client) UpdateProduct(i *UpdateProductInput) (*Product, error) {\n\tif i.Service == \"\" {\n\t\treturn nil, ErrMissingService\n\t}\n\n\tif i.Version == 0 {\n\t\treturn nil, ErrMissingVersion\n\t}\n\n\tif i.Name == \"\" {\n\t\treturn nil, ErrMissingName\n\t}\n\n\tpath := fmt.Sprintf(\"/service/%s/version/%d/product/%s\", i.Service, i.Version, i.Name)\n\tresp, err := c.PutForm(path, i, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar product *Product\n\tif err := decodeJSON(&product, resp.Body); err != nil {\n\t\treturn nil, err\n\t}\n\treturn product, nil\n}",
        "func (c *Client) GetProducts() (map[string]Product, error) {\n\tvar products map[string]Product\n\tif err := c.call(\"GetProducts\", nil, &products); err != nil {\n\t\treturn nil, err\n\t}\n\treturn products, nil\n}",
        "func NewHandler(store *store.MemoryStore, options ...HandlerOption) *Handler {\n\th := &Handler{\n\t\tstore:   store,\n\t\tsessions: make(map[string]*session),\n\t}\n\n\tfor _, option := range options {\n\t\toption(h)\n\t}\n\n\treturn h\n}",
        "func (ks *KeyStore) EncryptedKey() ([]byte, error) {\n\tif ks.encryptedKey == nil {\n\t\treturn nil, errors.New(\"keystore.Key is not encrypted\")\n\t}\n\treturn ks.encryptedKey, nil\n}",
        "func ExecuteCommand(args []string) error {\n\tif len(args) < 1 {\n\t\treturn errors.New(\"db-create: no database name specified\")\n\t}\n\n\tif len(args) == 2 {\n\t\tif args[0] == \"db-create\" {\n\t\t\treturn errors.New(\"db-create: no database name specified\")\n\t\t}\n\t\tif args[1] == \"db-migrate\" {\n\t\t\treturn errors.New(\"db-migrate: no database name specified\")\n\t\t}\n\t}\n\n\tif len(args) == 3 {\n\t\tif args[0] == \"db-create\" {\n\t\t\treturn errors.New(\"db-create: no database name specified\")\n\t\t}\n\t\tif args[1] == \"db-migrate\" {\n\t\t\treturn errors.New(\"db-",
        "func (p *PMP) AddMapping(service string, port int) error {\n\tp.Lock()\n\tdefer p.Unlock()\n\n\tif _, ok := p.mappings[service]; !ok {\n\t\tp.mappings[service] = make(map[int]int)\n\t}\n\n\tp.mappings[service][port] = port\n\n\treturn nil\n}",
        "func (p *NATPMP) DeleteMapping(port int) error {\n\treturn p.client.DeleteMapping(p.natPmpInterface, port)\n}",
        "func NewMonitor(client *http.Client, opts ...Option) *Monitor {\n\tm := &Monitor{\n\t\tclient: client,\n\t\topts:   make([]Option, 0),\n\t}\n\tfor _, opt := range opts {\n\t\topt(m)\n\t}\n\treturn m\n}",
        "func (c *Client) GetOfferingIncome(offerID string) (btcutil.Amount, error) {\n\treturn c.GetOfferingIncomeAsync(offerID).Receive()\n}",
        "func (api *OffersAPI) GetProductIncome(productID string) (btcutil.Amount, error) {\n\treturn api.b.GetProductIncome(productID)\n}",
        "func (api *API) GetTotalIncome() (btcutil.Amount, error) {\n\treturn api.chain.GetTotalIncome()\n}",
        "func Up00001(db *sql.DB) error {\n\t_, err := db.Exec(`\n\t\tUPDATE public.migrations\n\t\tSET version = version + 1\n\t\tWHERE id = ?\n\t`, 1)\n\treturn err\n}",
        "func (c *Client) GetSettings() (map[string]interface{}, error) {\n\tvar settings map[string]interface{}\n\tif err := c.call(\"GetSettings\", nil, &settings); err != nil {\n\t\treturn nil, err\n\t}\n\treturn settings, nil\n}",
        "func (c *Client) UpdateSettings(i *UpdateSettingsInput) (*Settings, error) {\n\tif i.Service == \"\" {\n\t\treturn nil, ErrMissingService\n\t}\n\n\tif i.Version == 0 {\n\t\treturn nil, ErrMissingVersion\n\t}\n\n\tif i.Name == \"\" {\n\t\treturn nil, ErrMissingName\n\t}\n\n\tpath := fmt.Sprintf(\"/service/%s/version/%d/logging/settings/%s\", i.Service, i.Version, i.Name)\n\tresp, err := c.PutForm(path, i, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s *Settings\n\tif err := decodeJSON(&s, resp.Body); err != nil {\n\t\treturn nil, err\n\t}\n\treturn s, nil\n",
        "func IsIPv4(ip net.IP) bool {\n\tif ip.To4() != nil {\n\t\treturn true\n\t}\n\treturn false\n}",
        "func IsHostname(hostname string) bool {\n\tif len(hostname) == 0 {\n\t\treturn false\n\t}\n\tif len(hostname) == 1 && hostname[0] == '.' {\n\t\treturn false\n\t}\n\treturn true\n}",
        "func IsNetPort(port string) bool {\n\t_, err := strconv.Atoi(port)\n\treturn err == nil\n}",
        "func IsTLSCert(block []byte) bool {\n\tif len(block) == 0 {\n\t\treturn false\n\t}\n\tfor _, cert := range tls.X509KeyPair(block, nil) {\n\t\treturn true\n\t}\n\treturn false\n}",
        "func ValidateJSON(json []byte, schema *Schema) error {\n\tif schema == nil {\n\t\treturn errors.New(\"nil schema\")\n\t}\n\treturn jsonschema.Validate(json, schema)\n}",
        "func NewConfig() *Config {\n\treturn &Config{\n\t\tAddress:    \"127.0.0.1\",\n\t\tPort:       4444,\n\t\tTimeout:    5 * time.Second,\n\t\tMaxRetries: 5,\n\t\tRetryDelay: 5 * time.Second,\n\t\tTLSConfig: &tls.Config{\n\t\t\tInsecureSkipVerify: true,\n\t\t},\n\t}\n}",
        "func ReadJSONFile(filename string, data interface{}) error {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\treturn ReadJSON(f, data)\n}",
        "func WriteJSONFile(filename string, data interface{}) error {\n\tdataBytes, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(filename, dataBytes, 0644)\n}",
        "func IsUUID(s string) bool {\n\tif len(s) != 16 {\n\t\treturn false\n\t}\n\tfor _, c := range s {\n\t\tif !(c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F') {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
        "func ExeDirJoin(path ...string) string {\n\tif runtime.GOOS == \"windows\" {\n\t\treturn filepath.Join(path...)\n\t}\n\treturn filepath.Join(os.Getenv(\"HOME\"), path...)\n}",
        "func RootPath() string {\n\troot := os.Getenv(\"GOPATH\")\n\tif root == \"\" {\n\t\treturn \"\"\n\t}\n\treturn filepath.Join(root, \"src\")\n}",
        "func (f *F1) Caller() *CallInfo {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\treturn f.caller\n}",
        "func (c *Client) CheckConnection(host string, port int) bool {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.isClosed {\n\t\treturn false\n\t}\n\tconn, err := net.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", host, port))\n\tif err != nil {\n\t\treturn false\n\t}\n\tc.conn = conn\n\treturn true\n}",
        "func (c *Client) ClientAfterChannelCreate(channelID string, opts ...ClientOption) {\n\tc.afterChannelCreate(channelID, opts...)\n\tc.client.AfterChannelCreate(channelID, opts...)\n}",
        "func (c *Client) ClientEndpointCreate(endpoint *models.ClientEndpoint) error {\n\tif err := endpoint.DecodeAttributes(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := c.validateEndpoint(endpoint); err != nil {\n\t\treturn err\n\t}\n\n\tif err := c.db.Create(endpoint).Error; err != nil {\n\t\treturn err\n\t}\n\n\tif err := c.triggerProductConfiguration(endpoint); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "func (c *Client) ClientAfterUncooperativeClose(channelID string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.isClosed {\n\t\treturn\n\t}\n\n\tc.afterUncooperativeClose(channelID)\n}",
        "func (c *Client) ClientAfterCooperativeClose(ctx context.Context, channelID string) error {\n\treturn c.ClientAfterCooperativeCloseWithMessage(ctx, channelID, \"\")\n}",
        "func (c *Client) ClientPreServiceTerminate(serviceID string) error {\n\treturn c.PostJSON(\"/service/\"+serviceID+\"/terminate\", nil, nil)\n}",
        "func (c *Client) ClientPreServiceSuspend(serviceID string) error {\n\treturn c.PreServiceAction(serviceID, PreServiceSuspend)\n}",
        "func (c *Client) ClientPreServiceUnsuspend(serviceID string) error {\n\treturn c.PostJSON(\"/service/\"+serviceID+\"/unsuspend\", nil, nil)\n}",
        "func (c *Client) ClientPreUncooperativeClose(ctx context.Context,\n\treq *lnrpc.ClientPreUncooperativeCloseRequest) (*lnrpc.ClientPreUncooperativeCloseResponse, error) {\n\n\t// Wait for the challenge period to be over.\n\tselect {\n\tcase <-c.challengePeriod.C:\n\t\treturn nil, fmt.Errorf(\"challenge period is over\")\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\t}\n\n\t// Delete the channel and settles by transferring the balance to the\n\t// agent and rest of the deposit back to the client.\n\tc.deleteChannel()\n\treturn c.ClientUncooperativeClose(ctx, req)\n}",
        "func (p *peer) ClientPreChannelTopUp(amount btcutil.Amount) error {\n\treturn p.ClientPreChannelTopUpAsync(amount).Receive()\n}",
        "func (c *Client) ClientAfterChannelTopUp(channelID string, amount btcutil.Amount) error {\n\treturn c.EditChannel(channelID, &ChannelEdit{\n\t\tAmount: amount,\n\t})\n}",
        "func (c *Client) ClientPreUncooperativeCloseRequest(ctx context.Context,\n\treq *lnrpc.ClientPreUncooperativeCloseRequest) (*lnrpc.ClientCloseResponse, error) {\n\n\t// We'll now attempt to close the channel, starting the challenge period\n\t// for the client to start the challenge period for the channel to\n\t// be closed.\n\tresp, err := c.CloseChannel(ctx, req.ChannelID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Once the channel is closed, we'll now attempt to start the challenge\n\t// period for the client to start the challenge period for the channel\n\t// to be closed.\n\tc.challengePeriod.Start(ctx)\n\n\treturn resp, nil\n}",
        "func (c *Client) ClientAfterUncooperativeCloseRequest(ctx context.Context, req *pb.ClientAfterUncooperativeCloseRequest) (*pb.ClientAfterUncooperativeCloseResponse, error) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.closed {\n\t\treturn nil, grpcutil.ErrClientClosed\n\t}\n\n\t// Wait for the channel to be uncooperative close.\n\tselect {\n\tcase <-c.uncooperativeClose:\n\t\treturn nil, grpcutil.ErrChannelClosed\n\tcase <-ctx.Done():\n\t\treturn nil, grpcutil.ErrServerShutdown\n\t}\n\n\t// Start the service termination process.\n\tif err := c.startServiceTerminationProcess(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\t//",
        "func (c *Client) ClientAfterOfferingMsgBCPublish(offering *offering.Offering) {\n\tc.afterOfferingMsgBCPublish <- offering\n}",
        "func (c *Client) ClientAfterOfferingPopUp(offeringID string) error {\n\toffering, err := c.ClientAfterOfferingGet(offeringID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif offering.Status == \"available\" {\n\t\treturn nil\n\t}\n\n\tif err := c.ClientAfterOfferingUpdate(offeringID, offering); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "func ClientAfterOfferingDelete(offerID string) ClientOption {\n\treturn func(c *Client) error {\n\t\tc.afterOfferingDelete = offerID\n\t\treturn nil\n\t}\n}",
        "func (c *Client) DecrementCurrentSupply(offeringID string) error {\n\tdata, err := c.GetData(offeringID, \"supply\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn json.Unmarshal(data, &c.currentSupply)\n}",
        "func (c *Client) GetEndpoints() ([]Endpoint, error) {\n\tvar endpoints []Endpoint\n\tif err := c.get(`endpoints/list`, &endpoints); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn endpoints, nil\n}",
        "func (c *Context) GetGUISettings() GUISettings {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.guiSettings\n}",
        "func (w *Window) SetGUISettings(s GUISettings) {\n\tC.glfwSetGUISettings(w.data, s.C())\n}",
        "func (m *Mux) HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request)) {\n\tm.Handle(pattern, http.HandlerFunc(handler))\n}",
        "func RequireHTTPMethods(handler func(http.ResponseWriter, *http.Request)) func(http.ResponseWriter, *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != \"POST\" && r.Method != \"GET\" {\n\t\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\t\thandler(w, r)\n\t}\n}",
        "func RequireBasicAuth(handler http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\thandler(w, r)\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tusername, password, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thandler(w, r)\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"juju\"`)\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(username + \":\" + password))\n\t}\n}",
        "func New(endpoint string, opts ...Option) (*Service, error) {\n\ts := &Service{\n\t\tendpoint: endpoint,\n\t\tlogger:   log.New(os.Stderr, \"\", log.LstdFlags),\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(s); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif s.logger == nil {\n\t\ts.logger = log.New(os.Stderr, \"\", log.LstdFlags)\n\t}\n\n\tif s.endpoint == \"\" {\n\t\treturn nil, errors.New(\"endpoint is empty\")\n\t}\n\n\tif s.endpoint[0] != '/' {\n\t\ts.endpoint = \"/\" + s.endpoint\n\t}\n\n\tif s.endpoint[len(s.endpoint)-",
        "func (e *Endpoint) EndpointMessage() *EndpointMessage {\n\te.RLock()\n\tdefer e.RUnlock()\n\n\treturn e.message\n}",
        "func (a *Adapter) ConnChange(ch chan<- *ConnectionEvent) {\n\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\ta.connCh = append(a.connCh, ch)\n}",
        "func FromBase64ToHex(s string) string {\n\tb := make([]byte, base64.StdEncoding.DecodedLen(len(s)))\n\tbase64.StdEncoding.Decode(b, []byte(s))\n\treturn string(b)\n}",
        "func HexToBytes(s string) []byte {\n\tif len(s)%2 != 0 {\n\t\tpanic(\"hex string must be even\")\n\t}\n\tb := make([]byte, len(s)/2)\n\tfor i := 0; i < len(s)/2; i++ {\n\t\tb[i] = hex[(s[i*2]>>4)&0xF]\n\t\tb[i+1] = hex[s[i*2]&0xF]\n\t}\n\treturn b\n}",
        "func ToBytes(s string) ([]byte, error) {\n\tb, err := base64.StdEncoding.DecodeString(s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn b, nil\n}",
        "func ToHash(s string) (*common.Hash, error) {\n\th, err := common.FromBase64(s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn h, nil\n}",
        "func HexToHash(s string) (*Hash, error) {\n\th := new(Hash)\n\tif err := h.SetHex(s); err != nil {\n\t\treturn nil, err\n\t}\n\treturn h, nil\n}",
        "func HexToAddress(hex string) (common.Address, error) {\n\tb, err := hex.DecodeString(hex)\n\tif err != nil {\n\t\treturn common.Address{}, err\n\t}\n\treturn common.BytesToAddress(b), nil\n}",
        "func BytesToUint32(b []byte) uint32 {\n\treturn binary.BigEndian.Uint32(b)\n}",
        "func Uint32ToBytes(v uint32) []byte {\n\tb := make([]byte, 4)\n\tUint32ToBytesTo(v, b)\n\treturn b\n}",
        "func Uint64ToBytes(v uint64) []byte {\r\n\tb := make([]byte, 8)\r\n\tUint64ToBytesTo(v, b)\r\n\treturn b\r\n}",
        "func Uint192ToBytes(v uint192) []byte {\r\n\tb := make([]byte, 8)\r\n\tUint192ToBytesTo(v, b)\r\n\treturn b\r\n}",
        "func HashPassword(password string) string {\n\th := sha1.New()\n\th.Write([]byte(password))\n\treturn hex.EncodeToString(h.Sum(nil))\n}",
        "func ValidatePassword(password, hash, salt string) bool {\n\tif !ValidateHash(hash) {\n\t\treturn false\n\t}\n\tif !ValidateSalt(salt) {\n\t\treturn false\n\t}\n\treturn password == hash && password == salt\n}",
        "func GetUint64Setting(db *sql.DB, key string) (uint64, error) {\n\tvar val uint64\n\terr := db.QueryRowContext(context.Background(), internal.SelectSetting, key).Scan(&val)\n\treturn val, err\n}",
        "func (c *Client) ChannelKey() (string, error) {\n\tvar key string\n\terr := c.call(\"ChannelKey\", &key)\n\treturn key, err\n}",
        "func (o *Offering) MinDeposit() *big.Int {\n\tif o.IsDefault {\n\t\treturn new(big.Int)\n\t}\n\tmin := new(big.Int)\n\tfor _, v := range o.Deposit {\n\t\tif v.Cmp(min) < 0 {\n\t\t\tmin = v\n\t\t}\n\t}\n\treturn min\n}",
        "func (c *JobClientPreChannelCreate) AcceptOffering(offeringID string) error {\n\treturn c.post(c.Endpoint(\"offerings\", offeringID, \"accept\"), nil)\n}",
        "func (c *Client) ChangeOfferingStatus(offeringID string, action string) error {\n\treturn c.ChangeOfferingStatusContext(context.Background(), offeringID, action)\n}",
        "func (c *Client) GetClientOfferings(offerings []string) ([]ClientOffering, error) {\n\treq, err := c.NewRequest(\"GET\", \"/v1/client/offerings\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif offerings != nil {\n\t\tq := req.URL.Query()\n\t\tfor _, offering := range offerings {\n\t\t\tq.Set(\"offering\", offering)\n\t\t}\n\t\treq.URL.RawQuery = q.Encode()\n\t}\n\n\tresp, err := checkResp(c.Http.Do(req))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar clientOfferings []ClientOffering\n\terr = decodeBody(resp, &clientOfferings)\n\tif err != nil {\n\t\treturn nil",
        "func (c *Client) GetAgentOfferings(agentID string) ([]Offering, error) {\n\tvar offerings []Offering\n\treturn offerings, c.Get(fmt.Sprintf(\"/agents/%s/offerings\", agentID), &offerings)\n}",
        "func setOfferingHash(offering *offering.Offering) {\n\toffering.RawMsg = nil\n\toffering.Hash = nil\n\n\tif offering.RawMsg != nil {\n\t\toffering.RawMsg = make([]byte, len(offering.RawMsg))\n\t\tcopy(offering.RawMsg, offering.RawMsg)\n\t}\n\tif offering.Hash != nil {\n\t\toffering.Hash = make([]byte, len(offering.Hash))\n\t\tcopy(offering.Hash, offering.Hash)\n\t}\n}",
        "func (c *Client) fillOffering(offering *ct.Offering) error {\n\tif offering.Nonce == \"\" {\n\t\treturn errors.New(\"offering nonce is required\")\n\t}\n\tif offering.Status == \"\" {\n\t\treturn errors.New(\"offering status is required\")\n\t}\n\tif offering.Hash == \"\" {\n\t\treturn errors.New(\"offering hash is required\")\n\t}\n\tif offering.Signature == \"\" {\n\t\treturn errors.New(\"offering signature is required\")\n\t}\n\treturn nil\n}",
        "func (c *Client) UpdateOffering(offeringID string, offering *ct.Offering) error {\n\treturn c.Put(fmt.Sprintf(\"/offerings/%s\", offeringID), offering, offering)\n}",
        "func (c *Client) CreateOffering(offering *ct.Offering) error {\n\treturn c.Post(\"/offerings\", offering, offering)\n}",
        "func GetClientOfferingsFilterParams(clientID string) (*ClientOfferingsFilterParams, error) {\n\tparams := &ClientOfferingsFilterParams{}\n\turl := internal.URL(internal.ClientOfferingsPath).WithID(clientID)\n\terr := internal.Get(url, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn params, nil\n}",
        "func PingOfferings(offerings []string) (bool, error) {\n\tif len(offerings) == 0 {\n\t\treturn false, nil\n\t}\n\tvar result bool\n\tfor _, offeringID := range offerings {\n\t\tif result, err := PingOffering(offeringID); err != nil {\n\t\t\treturn false, err\n\t\t} else if result {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}",
        "func NewServer(cfg *Config) *Server {\n\ts := &Server{\n\t\tcfg: cfg,\n\t}\n\ts.initMux()\n\treturn s\n}",
        "func (s *Server) Mux() *http.ServeMux {\n\tif s.mux == nil {\n\t\ts.mux = http.NewServeMux()\n\t}\n\treturn s.mux\n}",
        "func NewLogger(name string, level Level, format string, out io.Writer) *Logger {\n\treturn &Logger{\n\t\tname:     name,\n\t\tlevel:    level,\n\t\tformat:   format,\n\t\tout:      out,\n\t\tstacktrace: make([]byte, 1024),\n\t}\n}",
        "func (l *Logger) Printf(format string, args ...interface{}) {\n\tl.logf(l.app, logLevelInfo, format, true, args...)\n}",
        "func (c *Client) GetURL(path string) (*url.URL, error) {\n\treturn c.getURL(path)\n}",
        "func NewHTTPRequest(req *http.Request) *HTTPRequest {\n\treturn &HTTPRequest{\n\t\tMethod:     req.Method,\n\t\tURL:        req.URL,\n\t\tProtoMajor: 1,\n\t\tProtoMinor: 1,\n\t\tProto:      \"HTTP/1.1\",\n\t\tProtoMajorAndProto: []string{\"HTTP/1.1\"},\n\t\tProtoMajorAndProtoMajor: []string{\"HTTP/1.1\"},\n\t\tProtoMajorAndProtoMinor: []string{\"1.1\"},\n\t\tProtoMajorAndProtoMinorMajor: []string{\"1.1\"},\n\t\tProtoMajorAndProtoMinorMinor: []string{\"1.1\"},\n\t\tProtoMajorAndProtoMinorMajorAnd: []string{\"1.1\"},\n\t\tProtoMajorAndProtoMinorMinorAnd: []string{\"1.1\"},\n\t",
        "func NewHTTPRequestWithURL(method, urlStr string, body io.Reader) (*http.Request, error) {\n\tu, err := url.Parse(urlStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(method, u.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\treturn req, nil\n}",
        "func (c *Client) Send(req *http.Request) (*http.Response, error) {\n\treturn c.HTTPClient.Do(req)\n}",
        "func (c *Cache) Check(key string, stored interface{}) bool {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.check(key, stored)\n}",
        "func Make(r *rand.Rand) Token {\n\treturn Token{\n\t\tType:     TokenType(r.Intn(TokenTypeCount)),\n\t\tValue:    r.Int63(),\n\t\tExpires: time.Now().Add(time.Second * time.Duration(r.Int63())),\n\t}\n}",
        "func (c *Client) GetLogs(opts *GetLogsOptions) (*GetLogsResponse, error) {\n\treq, err := c.NewRequest(\"GET\", \"/logs\", nil, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif opts != nil {\n\t\tif opts.Limit != 0 {\n\t\t\treq.Params.Set(\"limit\", strconv.Itoa(opts.Limit))\n\t\t}\n\t\tif opts.Offset != 0 {\n\t\t\treq.Params.Set(\"offset\", strconv.Itoa(opts.Offset))\n\t\t}\n\t}\n\n\tresp, err := checkResp(c.Http.Do(req))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r GetLogsResponse\n\tif err := decodeJSON(&r, resp.Body);",
        "func (c *Client) AuthClient(clientKey, password string) error {\n\treturn c.auth(fmt.Sprintf(\"/api/v2/clients/%s/auth\", clientKey), password)\n}",
        "func (c *Client) StartSession() (*Session, error) {\n\tsession := &Session{\n\t\tclient: c,\n\t}\n\n\tif err := session.createSession(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session, nil\n}",
        "func (c *Client) UpdateSession(stop bool) error {\n\tif c.session == nil {\n\t\treturn errors.New(\"client is not connected\")\n\t}\n\n\tif stop {\n\t\tc.session.Stop()\n\t}\n\n\treturn c.session.Update(c.config.Token)\n}",
        "func (c *Client) OfferingMessage() (*pb.Offering, error) {\n\tmsg := &pb.Offering{}\n\tif err := c.Call(\"Offering\", msg); err != nil {\n\t\treturn nil, err\n\t}\n\treturn msg, nil\n}",
        "func (o *Offer) ValidMsg(valid bool) bool {\n\treturn o.Template != \"\" && valid\n}",
        "func NewClient(appName string, opts ...Option) *Client {\n\tc := &Client{\n\t\tappName: appName,\n\t\topts:    make(map[string]interface{}),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(c)\n\t}\n\n\tif c.opts[\"error.sendremote\"] == nil {\n\t\tc.opts[\"error.sendremote\"] = true\n\t}\n\n\tif c.opts[\"error.sendremote\"] {\n\t\tc.opts[\"error.sendremote\"] = false\n\t}\n\n\treturn c\n}",
        "func PanicHunter(h func()) {\n\tif !reporterEnabled {\n\t\treturn\n\t}\n\th()\n\tpanic(\"panic handler\")\n}",
        "func ParseRequest(r *http.Request) (*Request, error) {\n\tvar err error\n\tvar req Request\n\n\tif r.Method == \"POST\" {\n\t\treq.Method = \"POST\"\n\t} else {\n\t\treq.Method = \"GET\"\n\t}\n\n\tif r.ContentLength == 0 {\n\t\treq.ContentLength, err = r.ContentLength()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif r.Header == nil {\n\t\treq.Header = make(http.Header)\n\t}\n\n\tfor k, v := range r.Header {\n\t\treq.Header.Add(k, v[0])\n\t}\n\n\tif r.Body == nil {\n\t\treq.Body, err = ioutil.ReadAll(r.",
        "func (i *Instance) save() error {\n\tif i.Services == nil {\n\t\treturn nil\n\t}\n\n\tif err := i.ipvsadm.Save(); err != nil {\n\t\treturn err\n\t}\n\n\ti.Services = i.ipvsadm.Services()\n\treturn nil\n}",
        "func NewClient(opts ...ClientOption) *Client {\n\tc := &Client{\n\t\tclient: &http.Client{},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(c)\n\t}\n\n\treturn c\n}",
        "func ParseRate(rate string) (*Rate, error) {\n\tvar rateInfo Rate\n\tif err := json.Unmarshal([]byte(rate), &rateInfo); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &rateInfo, nil\n}",
        "func (c *Client) SnapshotPath(path string) *Client {\n\tc.path = path\n\treturn c\n}",
        "func (t *Tracer) Update(cfg *TracerConfig) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tt.cfg = cfg\n}",
        "func (t *Tracer) ExecutablePath(path string) *Tracer {\n\tt.executablePath = path\n\treturn t\n}",
        "func (c *Client) SnapshotOutputPath(path string, perm os.FileMode) *Client {\n\tc.path = path\n\tc.perm = perm\n\treturn c\n}",
        "func (t *Tracer) SetPipes(in, out io.ReadWriter) {\n\tt.in = in\n\tt.out = out\n}",
        "func (o *Options) Append(prefix string, value string) {\n\to.options = append(o.options, Option{prefix: prefix, value: value})\n}",
        "func MarshalRaw(b []byte) []byte {\n\tif len(b) == 0 {\n\t\treturn nil\n\t}\n\tif b[0] == 0xFEFF {\n\t\treturn append([]byte{0xFEFF}, b[1:]...)\n\t}\n\treturn append([]byte{0x00}, b...)\n}",
        "func MarshalString(b []byte, s string) []byte {\n\treturn appendSizePrefix(b, []byte(s))\n}",
        "func MarshalString(b []byte, s string) (int, error) {\n\treturn MarshalStringWithPadding(b, s, 0)\n}",
        "func (b *Builder) MarshalString(v string) *Builder {\n\tb.buf = strconv.AppendUint(b.buf, uint32(len(v)), 10)\n\treturn b\n}",
        "func (u Uint32) MarshalString(buf *bytes.Buffer) {\n\tbuf.WriteString(fmt.Sprintf(\"%d\", u))\n}",
        "func (u Uint64) MarshalString(buf *bytes.Buffer) {\n\tbuf.WriteString(strconv.FormatUint(uint64(u), 10))\n}",
        "func ElementSizeExceeded(name, in string, size, max int64) error {\n\treturn fmt.Errorf(\"element size %q exceeds maximum allowed size %d\", in, max)\n}",
        "func (b *Buffer) findEscape(r rune) int {\n\tfor i, c := range b.data {\n\t\tif c == r {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}",
        "func (d *Decoder) firstCharPos(ch rune) int {\n\tif ch < 0x80 {\n\t\treturn 0\n\t}\n\tif ch >= 0x800 {\n\t\treturn len(d.buf)\n\t}\n\treturn d.firstCharPosInLine(ch)\n}",
        "func NewDecoder(r io.Reader, enc *Encoding) *Decoder {\n\treturn &Decoder{\n\t\tr:   r,\n\t\tenc: enc,\n\t}\n}",
        "func Register(c *di.Container) {\n\tc.Register(func(c *di.Container) {\n\t\tc.Register(func(c *di.Container) {\n\t\t\tc.Register(func(c *di.Container) {\n\t\t\t\tc.Register(func(c *di.Container) {\n\t\t\t\t\tc.Register(func(c *di.Container) {\n\t\t\t\t\t\tc.Register(func(c *di.Container) {\n\t\t\t\t\t\t\tc.Register(func(c *di.Container) {\n\t\t\t\t\t\t\t\tc.Register(func(c *di.Container) {\n\t\t\t\t\t\t\t\t\tc.Register(func(c *di.Container) {\n\t\t\t\t\t\t\t\t\t\tc.Register(func(c *di.Container) {\n\t\t\t\t\t\t\t\t\t\t\tc.Register(func(c *di.Container) {\n\t\t\t\t\t\t\t\t\t\t\t\tc.Register",
        "func MustRegister(name string, reg func(string) error) {\n\tif err := Register(name, reg); err != nil {\n\t\tpanic(err)\n\t}\n}",
        "func (p *Parameter) Create(value interface{}) (interface{}, error) {\n\tif p.Type == nil {\n\t\treturn nil, fmt.Errorf(\"Parameter type is not set\")\n\t}\n\n\tif p.Type.Kind() == reflect.Ptr {\n\t\tp.Type = p.Type.Elem()\n\t}\n\n\tif p.Type.Kind() == reflect.Struct {\n\t\treturn nil, fmt.Errorf(\"Parameter type must be a struct\")\n\t}\n\n\tif p.Type.Kind() == reflect.Map {\n\t\treturn nil, fmt.Errorf(\"Parameter type must be a map\")\n\t}\n\n\tif p.Type.Kind() == reflect.Slice {\n\t\treturn nil, fmt.Errorf(\"Parameter type must be a slice\")\n\t}\n\n\tif p.Type.Kind() == reflect.Struct {",
        "func (c *Cache) cachedCreateFromType(t reflect.Type) (interface{}, error) {\n\tif c.cache == nil {\n\t\treturn nil, errors.New(\"no cache\")\n\t}\n\tif c.cache[t] == nil {\n\t\treturn nil, errors.New(\"no cache for type \" + t.String())\n\t}\n\treturn c.cache[t], nil\n}",
        "func NewDependencyInjector(\n\tconfig *Config,\n\tlogger *log.Logger,\n\tregistry registry.Registry,\n\tregistryClient registry.Client,\n\tregistryAuth registry.Auth,\n\tregistryAuthClient registry.AuthClient,\n\tregistryAuthServer registry.AuthServer,\n\tregistryAuthServerClient registry.AuthServerClient,\n\tregistryAuthServerClientFactory registry.AuthServerClientFactory,\n\tregistryAuthServerClientOpts registry.AuthServerClientOpts,\n\tregistryAuthServerClientOpts registry.AuthServerClientOpts,\n\tregistryAuthServerClientOpts registry.AuthServerClientOpts,\n\tregistryAuthServerClientOpts registry.AuthServerClientOpts,\n\tregistryAuthServerClientOpts registry.AuthServerClientOpts,\n\tregistryAuthServerClientOpts registry.AuthServerClientOpts,\n\tregistryAuthServerClientOpts registry.AuthServerClientOpts,\n\tregistryAuthServerClientOpts registry.AuthServerClient",
        "func NewServiceContainer(id string, ip net.IP, port int, protocol string, service *Service, labels map[string]string, annotations map[string]string) *ServiceContainer {\n\treturn &ServiceContainer{\n\t\tID:             id,\n\t\tIP:             ip,\n\t\tPort:           port,\n\t\tProtocol:       protocol,\n\t\tService:        service,\n\t\tLabels:         labels,\n\t\tAnnotations:    annotations,\n\t\tServiceID:      id,\n\t\tServiceIP:      ip,\n\t\tServicePort:    port,\n\t\tServiceProtocol: protocol,\n\t}\n}",
        "func (p *Prefix) Add(url string) {\n\tif p.Prefix == \"\" {\n\t\tp.Prefix = \"/\"\n\t}\n\tp.Prefix += url\n}",
        "func Prefix(prefix string) AssetPipeline {\n\treturn func(ctx context.Context, asset *Asset) (*Asset, error) {\n\t\treturn asset, nil\n\t}\n}",
        "func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\th.ServeHTTPC(w, r, h.Handler)\n}",
        "func getResponse(controller interface{}, methodName string) (*Response, error) {\n\tcontrollerType := reflect.TypeOf(controller)\n\tmethod := controllerType.MethodByName(methodName)\n\tif method == nil {\n\t\treturn nil, fmt.Errorf(\"no such method: %s\", methodName)\n\t}\n\tif method.PkgPath != \"\" {\n\t\treturn nil, fmt.Errorf(\"method %s is not a controller method\", methodName)\n\t}\n\tif method.Type.NumOut() != 1 {\n\t\treturn nil, fmt.Errorf(\"method %s has to return a response\", methodName)\n\t}\n\tresponseType := method.Type.Out(0)\n\tif !responseType.Implements(responseType) {\n\t\treturn nil, fmt.Errorf(\"method %s has to return a response\", methodName)\n\t}\n\tresponse := &Response",
        "func (c *Controller) isValid() bool {\n\tif c.Controller == nil {\n\t\treturn false\n\t}\n\tif c.Method == nil {\n\t\treturn false\n\t}\n\treturn true\n}",
        "func NewHandler(factory ControllerFactory, methodName string) *ControllerHandler {\n\treturn &ControllerHandler{\n\t\tControllerFactory: factory,\n\t\tmethodName:        methodName,\n\t}\n}",
        "func (g *Goanna) Handler(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n\tif g.HandlerFunc != nil {\n\t\tg.HandlerFunc(ctx, w, r)\n\t}\n}",
        "func (c *Controller) SetRequest(req *http.Request) {\n\tc.Request = req\n\tc.RequestID = uuid.NewV4().String()\n}",
        "func (c *Context) Session() *sessions.Session {\n\tif c.request.Session != nil {\n\t\treturn c.request.Session\n\t}\n\treturn c.app.session\n}",
        "func RenderView(tmpl string, vars map[string]interface{}) (string, error) {\n\tt, err := template.New(\"\").Funcs(template.FuncMap{\n\t\t\"escape\": escape,\n\t}).Parse(tmpl)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tvar buf bytes.Buffer\n\tif err := t.Execute(&buf, vars); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn buf.String(), nil\n}",
        "func RenderView(tmpl string, vars map[string]interface{}) (string, error) {\n\tt, err := template.New(tmpl).Funcs(funcs).Parse(tmpl)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar buf bytes.Buffer\n\tif err := t.Execute(&buf, vars); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn buf.String(), nil\n}",
        "func (r *Router) RedirectRoute(w http.ResponseWriter, req *http.Request, route string) {\n\thttp.Redirect(w, req, route, http.StatusFound)\n}",
        "func UrlFor(controllerName, actionName string, params ...interface{}) string {\n\treturn fmt.Sprintf(\"%s/%s/%s\", controllerName, actionName, strings.Join(params, \"/\"))\n}",
        "func (ctx *Context) CookieValue(name string) string {\n\treturn ctx.Request().Cookie(name)\n}",
        "func (r *Request) BodyData() ([]byte, error) {\n\tif r.body == nil {\n\t\tr.body = make([]byte, 0)\n\t}\n\treturn r.body, nil\n}",
        "func (ctx *Context) QueryValue(key string) string {\n\treturn ctx.Request.URL.Query().Get(key)\n}",
        "func (ctx *Context) FormValueOrDefault(key, def string) string {\n\tif val := ctx.Request.FormValue(key); len(val) > 0 {\n\t\treturn val[0]\n\t}\n\treturn def\n}",
        "func (r *Request) UrlValue() bool {\n\treturn r.Method == \"PATCH\" || r.Method == \"PUT\" || r.Method == \"DELETE\"\n}",
        "func Contains(s, substrs []string) bool {\n\tfor _, sub := range substrs {\n\t\tif strings.Contains(s, sub) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
        "func RemoveStringsFromString(s string, substrs []string) string {\n\tfor _, substr := range substrs {\n\t\tif strings.Contains(s, substr) {\n\t\t\ts = strings.Replace(s, substr, \"\", 1)\n\t\t}\n\t}\n\treturn s\n}",
        "func (ss *set) Map(cb func(interface{}) interface{}) []interface{} {\n\tvar res []interface{}\n\tfor _, e := range ss.Iter() {\n\t\tres = append(res, cb(e))\n\t}\n\treturn res\n}",
        "func Equal(a, b interface{}) bool {\n\tif a == nil && b == nil {\n\t\treturn true\n\t}\n\tif a == nil || b == nil {\n\t\treturn false\n\t}\n\tswitch a.(type) {\n\tcase string:\n\t\treturn a.(string) == b.(string)\n\tcase []byte:\n\t\treturn bytes.Equal(a.([]byte), b.([]byte))\n\tcase int:\n\t\treturn a.(int) == b.(int)\n\tcase int8:\n\t\treturn a.(int8) == b.(int8)\n\tcase int16:\n\t\treturn a.(int16) == b.(int16)\n\tcase int32:\n\t\treturn a.(int32) == b.(int32)\n\tcase int64",
        "func Uniq(items []interface{}) []string {\n\tif len(items) == 0 {\n\t\treturn nil\n\t}\n\titems = sort.Slice(items, func(i, j int) bool {\n\t\treturn items[i].(string) < items[j].(string)\n\t})\n\tout := make([]string, 0, len(items))\n\tfor _, item := range items {\n\t\tout = append(out, item.(string))\n\t}\n\treturn out\n}",
        "func NewCookieSigner(key string) (*CookieSigner, error) {\n\tif key == \"\" {\n\t\treturn nil, trace.BadParameter(\"missing cookie key\")\n\t}\n\treturn &CookieSigner{\n\t\tkey: key,\n\t}, nil\n}",
        "func EncodeCookie(w http.ResponseWriter, cookie *http.Cookie) {\n\tcookie.Value = url.QueryEscape(cookie.Value)\n\tcookie.Expires = time.Now().Add(cookie.MaxAge).UTC()\n\thttp.SetCookie(w, cookie)\n}",
        "func DecodeCookie(r *http.Request, signature, value string) (*http.Cookie, error) {\n\tif signature != cookieSignature {\n\t\treturn nil, fmt.Errorf(\"invalid signature\")\n\t}\n\tif !strings.HasPrefix(value, cookiePrefix) {\n\t\treturn nil, fmt.Errorf(\"invalid value\")\n\t}\n\treturn http.Cookie(value[len(cookiePrefix):]), nil\n}",
        "func DecodeValue(cookieValue string) (string, error) {\n\tif len(cookieValue) == 0 {\n\t\treturn \"\", errors.New(\"empty cookie value\")\n\t}\n\tif !strings.HasPrefix(cookieValue, CookiePrefix) {\n\t\treturn \"\", errors.New(\"invalid cookie value\")\n\t}\n\treturn cookieValue[len(CookiePrefix):], nil\n}",
        "func EncodeValue(cookieValue string, secret string) string {\n\treturn sign(cookieValue, secret, cookieKey)\n}",
        "func (s *StatsdHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tstart := time.Now()\n\ts.Handler.ServeHTTP(w, r)\n\ts.record(r, time.Since(start))\n}",
        "func NewSprocketsServer(s *sprockets.Sprockets, assets *sprockets.Assets) *SprocketsServer {\n\treturn &SprocketsServer{\n\t\tSprockets: s,\n\t\tAssets:    assets,\n\t}\n}",
        "func (k *Key) String() string {\n\tif len(k.key) > 250 {\n\t\tk.key = k.key[:250]\n\t}\n\treturn string(k.key)\n}",
        "func (s *Stopwatch) Stop() {\n\ts.Lock()\n\tdefer s.Unlock()\n\ts.stop()\n}",
        "func (m *Monitor) Function(fn func() []interface{}) *Monitor {\n\tm.fn = fn\n\treturn m\n}",
        "func (m *Monitor) Function(f func(context.Context, *Monitor)) *Monitor {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.f = f\n\treturn m\n}",
        "func LogRequest(ctx context.Context, r *http.Request) {\n\tif !ctxutil.IsDebug(ctx) {\n\t\treturn\n\t}\n\tlog.Infof(\"Request: %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %",
        "func CommonLogHandler(logger *log.Logger) http.Handler {\n\tif logger == nil {\n\t\tlogger = log.New(os.Stdout, \"\", log.LstdFlags)\n\t}\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif logger.Log(r.Method, r.URL.Path) {\n\t\t\tlogger.Printf(\"%s %s\\n\", r.Method, r.URL.Path)\n\t\t}\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n}",
        "func (h *CommonLogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\th.Logger.Printf(\"%s %s %s\", r.Method, r.URL.Path, r.Proto)\n\th.Logger.Printf(\"%s %s %s\", r.RemoteAddr, r.Proto, r.URL.Path)\n\th.Logger.Printf(\"%s %s %s\", r.RemoteAddr, r.Proto, r.URL.Path)\n\th.Logger.Printf(\"%s %s %s\", r.RemoteAddr, r.Proto, r.URL.Path)\n\th.Logger.Printf(\"%s %s %s\", r.RemoteAddr, r.Proto, r.URL.Path)\n\th.Logger.Printf(\"%s %s %s\", r.RemoteAddr, r.Proto, r.URL.Path)\n\t",
        "func extractUsername(r *http.Request) string {\n\tif u, err := url.Parse(r.URL.String()); err == nil {\n\t\treturn u.User.Username()\n\t}\n\treturn \"\"\n}",
        "func (r *Route) UrlFor(params ...string) string {\n\treturn r.url.String() + \"/\" + strings.Join(params, \"/\")\n}",
        "func (r *Route) UrlFor(urlBase string) string {\n\tif r.Path == \"\" {\n\t\treturn \"\"\n\t}\n\treturn urlBase + r.Path\n}",
        "func Parse(data []byte, c interface{}) error {\n\treturn json.Unmarshal(data, c)\n}",
        "func LoadFromEnv(v interface{}) (map[string]string, error) {\n\tenv := os.Getenv\n\tif env == nil {\n\t\tenv = os.Getenv\n\t}\n\n\tm := make(map[string]string)\n\tfor _, f := range reflect.ValueOf(v).Elem().FieldList() {\n\t\tif f.PkgPath != \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tname := f.Name\n\t\tif !strings.HasPrefix(name, \"_\") {\n\t\t\tcontinue\n\t\t}\n\t\tname = name[1:]\n\t\tif !strings.HasSuffix(name, \"=\") {\n\t\t\tcontinue\n\t\t}\n\t\tname = name[:len(name)-1]\n\t\tval := env[name]\n\t\tif val == \"\" {\n\t\t\tcontinue\n\t",
        "func RegexPath(re *regexp.Regexp, h http.Handler) http.Handler {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif !re.MatchString(r.URL.Path) {\n\t\t\thttp.NotFound(w, r)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t}\n}",
        "func CacheControl(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\thandler.ServeHTTP(w, r)\n\t\tw.Header().Set(\"Cache-Control\", \"must-revalidate, post-check=0, pre-check=0\")\n\t})\n}",
        "func transform(data []byte, out io.Writer) error {\n\tvar yamlData interface{}\n\tif err := yaml.Unmarshal(data, &yamlData); err != nil {\n\t\treturn err\n\t}\n\treturn transformData(yamlData, out)\n}",
        "func DiscoverWalk(ctx context.Context, client *http.Client, insecure bool, discoverFn discoverFn) error {\n\t// Make a request to the discovery server\n\treq, err := http.NewRequest(\"GET\", discoveryURL, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif insecure {\n\t\treq.Header.Set(\"X-Forwarded-Proto\", \"https\")\n\t}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check if the response is a discovery response\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"Unexpected response code: %d\", resp.StatusCode)\n\t}\n\n\t// Parse the discovery response\n\tvar discovery discovery.Meta\n\tif err := json.",
        "func DiscoverEndpoints(ctx context.Context, insecure bool) ([]string, error) {\n\tif insecure {\n\t\treturn discoverEndpointsInsecure(ctx)\n\t}\n\treturn discoverEndpointsSecure(ctx)\n}",
        "func JSONFieldsFromStruct(v interface{}) []string {\n\tif reflect.TypeOf(v).Kind() != reflect.Struct {\n\t\treturn nil\n\t}\n\tvar names []string\n\tfor i := 0; i < reflect.TypeOf(v).NumField(); i++ {\n\t\tif !isJSONField(v.Field(i)) {\n\t\t\tcontinue\n\t\t}\n\t\tnames = append(names, v.Field(i).Name)\n\t}\n\treturn names\n}",
        "func StructFieldFromJSONName(v reflect.Value, name string) (field string) {\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif v.Kind() != reflect.Struct {\n\t\tpanic(\"struct field name must be a struct field\")\n\t}\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tif v.Type().Field(i).Name == name {\n\t\t\tfield = v.Type().Field(i).Name\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}",
        "func (d *Dictionary) Enumerate() []string {\n\tvar words []string\n\tfor _, word := range d.words {\n\t\twords = append(words, word)\n\t}\n\tsort.Strings(words)\n\treturn words\n}",
        "func (m *Message) Release() {\n\tif m.pool == nil {\n\t\treturn\n\t}\n\n\tm.pool <- m\n\tm.pool = nil\n}",
        "func Wrap(err error, message string, args ...interface{}) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif message == \"\" {\n\t\tmessage = err.Error()\n\t}\n\treturn &Error{\n\t\terr:       err,\n\t\tmessage:   message,\n\t\tstack:     buildStack(),\n\t\tannotate: annotate(err, message, args...),\n\t}\n}",
        "func causer(e error) error {\n\tif e == nil {\n\t\treturn nil\n\t}\n\tif ce, ok := e.(Causer); ok {\n\t\treturn ce.Causer()\n\t}\n\treturn e\n}",
        "func From(ctx context.Context) *Context {\n\treturn &Context{\n\t\tRequest:  ctx.Value(RequestKey),\n\t\tResponse: ctx.Value(ResponseKey),\n\t\tError:   ctx.Value(ErrorKey),\n\t}\n}",
        "func With(ctx context.Context, keyvals ...interface{}) context.Context {\n\treturn context.WithValue(ctx, keyvals...)\n}",
        "func (c *Context) Format(format string) (n int, err error) {\n\tif c.err != nil {\n\t\treturn 0, c.err\n\t}\n\treturn fmt.Fprintf(c.ctx, format)\n}",
        "func NewWriter(out io.Writer) *Writer {\n\treturn &Writer{\n\t\tout:     out,\n\t\tlevel:   INFO,\n\t\ttimestamp: time.Now(),\n\t}\n}",
        "func (a *ActionDefinition) Levels() []*ActionDefinition {\n\tvar levels []*ActionDefinition\n\tfor _, l := range a.LevelsList {\n\t\tlevels = append(levels, l)\n\t}\n\treturn levels\n}",
        "func (l *Level) SetLevel(level Level) {\n\tl.Lock()\n\tdefer l.Unlock()\n\n\tl.level = level\n\tl.displayEffect = nil\n}",
        "func (w *Writer) Suppress(level Level) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tw.suppress = level\n}",
        "func (l Level) IsSuppressed() bool {\n\treturn l >= LevelTrace && l <= LevelInfo && l >= LevelWarn && l <= LevelError\n}",
        "func (l *Logger) Handle(handler func(message string)) {\n\tl.mu.Lock()\n\tl.handlers = append(l.handlers, handler)\n\tl.mu.Unlock()\n}",
        "func (l *Logger) SetOutput(w io.Writer) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.output = w\n}",
        "func (d *Directory) Enumerate(ctx context.Context, opts *EnumerateOptions) (*EnumerateResult, error) {\n\treq, err := d.conn.NewRequest(\"GET\", path.Join(d.relPath(), \"enumerate\"))\n\tif err != nil {\n\t\treturn nil, WithStack(err)\n\t}\n\tif opts != nil {\n\t\tif opts.Limit != 0 {\n\t\t\treq = req.SetQuery(\"limit\", strconv.Itoa(opts.Limit))\n\t\t}\n\t\tif opts.Marker != \"\" {\n\t\t\treq = req.SetQuery(\"marker\", opts.Marker)\n\t\t}\n\t}\n\tresp, err := d.conn.Do(ctx, req)\n\tif err != nil {\n\t\treturn nil, WithStack(err)\n\t}\n\tif err := resp.CheckStatus",
        "func (e Enumerable) All(c interface{}) bool {\n\tfor _, item := range e {\n\t\tif !item.All(c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
        "func (s *Set) All(criteria interface{}) bool {\n\tfor _, item := range s.items {\n\t\tif !item.All(criteria) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
        "func Any(e Enumerable) bool {\n\tfor e.Next() {\n\t\treturn true\n\t}\n\n\treturn false\n}",
        "func Anyp(e Enumerable, criteria interface{}) bool {\n\tfor e.Next() {\n\t\tif e.Value() == criteria {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}",
        "func AsEnumerable(slice []interface{}) Enumerable {\n\tif len(slice) == 0 {\n\t\treturn nil\n\t}\n\n\tvar e Enumerable\n\tfor _, v := range slice {\n\t\te = append(e, v)\n\t}\n\n\treturn e\n}",
        "func (l *List) First() (interface{}, error) {\n\tif l.Len() == 0 {\n\t\treturn nil, errors.New(\"list is empty\")\n\t}\n\treturn l.Get(0), nil\n}",
        "func (e *Enumerator) Merge(others ...*Enumerator) *Enumerator {\n\tif len(others) == 0 {\n\t\treturn e\n\t}\n\tif len(e.results) == 0 {\n\t\treturn others[0]\n\t}\n\tif len(others) == 1 {\n\t\treturn others[0]\n\t}\n\te.results = append(e.results, others[0].results...)\n\te.results = append(e.results, others[1].results...)\n\treturn e\n}",
        "func ParallelSelect(transform func(int, int) int) Enumerable {\n\treturn func() ([]int, error) {\n\t\tvar result []int\n\t\tfor i := 0; i < runtime.GOMAXPROCS(0); i++ {\n\t\t\tresult = append(result, transform(i, i))\n\t\t}\n\t\treturn result, nil\n\t}\n}",
        "func ParallelSelect(t Transform, cpuInfo []*proc.CPUInfo) error {\n\tfor _, cpu := range cpuInfo {\n\t\tif err := t(cpu); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "func (t *Trie) Reverse() []interface{} {\n\tvar items []interface{}\n\tfor i := len(t.items) - 1; i >= 0; i-- {\n\t\titems = append(items, t.items[i])\n\t}\n\treturn items\n}",
        "func (s *SelectStatement) Select(ctx sessionctx.Context) (*SelectResult, error) {\n\tif s.SelectStmt == nil {\n\t\treturn nil, errors.Trace(ErrInvalidArgument)\n\t}\n\treturn s.SelectStmt.Select(ctx)\n}",
        "func Select(list []interface{}, fn func(interface{}) interface{}) interface{} {\n\tfor i, v := range list {\n\t\tif fn(v) == nil {\n\t\t\treturn list[i]\n\t\t}\n\t}\n\treturn nil\n}",
        "func (q *Queryx) SelectMany(values ...interface{}) *Queryx {\n\tq.Select = append(q.Select, values...)\n\treturn q\n}",
        "func (q *Queryx) SelectMany(dest interface{}, fields ...string) *Queryx {\n\tq.Select(fields...)\n\treturn q.SelectManyFn(dest)\n}",
        "func (l *List) Single() (interface{}, error) {\n\tif l.Len() == 0 {\n\t\treturn nil, errors.New(\"list is empty\")\n\t}\n\treturn l.Get(0), nil\n}",
        "func Singlep(list interface{}, c *Criteria) (interface{}, error) {\n\tif c == nil {\n\t\treturn nil, errors.New(\"criteria is nil\")\n\t}\n\n\tif c.Match == nil {\n\t\treturn nil, errors.New(\"criteria.Match is nil\")\n\t}\n\n\tif c.Match.Match == nil {\n\t\treturn nil, errors.New(\"criteria.Match.Match is nil\")\n\t}\n\n\tif c.Match.Match.Type != \"single\" {\n\t\treturn nil, errors.New(\"criteria.Match.Match.Type must be 'single'\")\n\t}\n\n\treturn Single(list, c.Match.Match)\n}",
        "func Skip(n int, e Enumerable) Stream {\n\tif n < 0 {\n\t\tpanic(\"Skip: negative skip count\")\n\t}\n\tif e == nil {\n\t\treturn nil\n\t}\n\treturn &skip{\n\t\te: e,\n\t\tn: n,\n\t}\n}",
        "func splitN(e Enumerator, n int) Enumerator {\n\tif n <= 0 {\n\t\treturn e\n\t}\n\tif n == 1 {\n\t\treturn e\n\t}\n\treturn &enumerator{\n\t\te: e,\n\t\tn: n,\n\t}\n}",
        "func (e Enumerable) Take(n int) Enumerable {\n\tif n < 1 {\n\t\treturn e\n\t}\n\treturn e.TakeN(n, n)\n}",
        "func (e *Enumerator) Take(n int) []interface{} {\n\tif e.err != nil {\n\t\treturn nil\n\t}\n\tif n < 0 {\n\t\te.err = fmt.Errorf(\"take: negative count\")\n\t\treturn nil\n\t}\n\tif e.pos >= len(e.data) {\n\t\te.err = fmt.Errorf(\"take: exhausted\")\n\t\treturn nil\n\t}\n\te.pos -= n\n\treturn e.data[e.pos:]\n}",
        "func TakeWhile(c interface{}, fn func(interface{}) bool) Stream {\n\treturn &stream{\n\t\tstream: Stream{\n\t\t\tnext: func() (interface{}, bool) {\n\t\t\t\tfor {\n\t\t\t\t\tv, ok := c.(interface{ TakeWhile() bool })\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn nil, false\n\t\t\t\t\t}\n\t\t\t\t\tif !fn(v) {\n\t\t\t\t\t\treturn v, true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n}",
        "func (q Query) TakeWhile(criteria func(interface{}) bool) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tdone := false\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor !done {\n\t\t\t\t\titem, ok = next()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tif criteria(item) {\n\t\t\t\t\t\tdone = true\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}",
        "func Tee(e1, e2 Enumerator) Enumerator {\n\treturn &tee{\n\t\te1:  e1,\n\t\te2:  e2,\n\t\tcount: 0,\n\t}\n}",
        "func (s Slice) ToSlice() []interface{} {\n\tvar v []interface{}\n\tfor _, v := range s {\n\t\tv = reflect.ValueOf(v).Elem()\n\t}\n\treturn v.Interface().([]interface{})\n}",
        "func Where(f func(interface{}) bool) Stream {\n\treturn &filterStream{\n\t\tf:    f,\n\t\tdone: make(chan struct{}),\n\t}\n}",
        "func Where(list []interface{}, predicate func(interface{}) bool) []interface{} {\n\tvar result []interface{}\n\tfor _, v := range list {\n\t\tif predicate(v) {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}",
        "func (b *Buffer) ReleaseBuffer() {\n\tif b.pool == nil {\n\t\treturn\n\t}\n\n\tb.pool.Put(b)\n\tb.pool = nil\n}",
        "func NewStack() *Stack {\n\treturn &Stack{\n\t\tdata: make([]interface{}, 0, stackDefaultCapacity),\n\t\thead: 0,\n\t\ttail: 0,\n\t}\n}",
        "func (s *Stack) Enumerate() []interface{} {\n\tvar result []interface{}\n\tfor i := len(s.data) - 1; i >= 0; i-- {\n\t\tresult = append(result, s.data[i])\n\t}\n\treturn result\n}",
        "func (s *Stack) IsEmpty() bool {\n\treturn s.Len() == 0 && s.Len() == 0 && s.Len() == 0 && s.Len() == 0\n}",
        "func (s *Stack) Push(entry interface{}) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\ts.items = append(s.items, entry)\n}",
        "func (s *Stack) Pop() (*Entry, error) {\n\tif s.Len() == 0 {\n\t\treturn nil, errors.New(\"Stack is empty\")\n\t}\n\n\te := s.Peek()\n\ts.Pop()\n\treturn e, nil\n}",
        "func (s *Stack) Peek() (*Entry, error) {\n\tif s.Len() == 0 {\n\t\treturn nil, errors.New(\"Stack is empty\")\n\t}\n\treturn s.Get(s.Len() - 1), nil\n}",
        "func (s *Stack) Size() int {\n\ts.mutex.RLock()\n\tdefer s.mutex.RUnlock()\n\treturn len(s.data)\n}",
        "func NewLinkedList(entries ...*Entry) *LinkedList {\n\treturn &LinkedList{\n\t\thead: &node{\n\t\t\tnext: nil,\n\t\t\tprev: nil,\n\t\t},\n\t\ttail: nil,\n\t\tlength: len(entries),\n\t\tentries: entries,\n\t}\n}",
        "func (l *LinkedList) AddBack(e *Entry) {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\tl.list.AddBack(e)\n}",
        "func (c *Client) Enumerate() (*Enumerable, error) {\n\treq, err := c.NewRequest(\"GET\", \"/_api/enumerate\")\n\tif err != nil {\n\t\treturn nil, WithStack(err)\n\t}\n\tresp, err := c.Do(req)\n\tif err != nil {\n\t\treturn nil, WithStack(err)\n\t}\n\tif err := resp.CheckStatus(200); err != nil {\n\t\treturn nil, WithStack(err)\n\t}\n\tdata, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, WithStack(err)\n\t}\n\tvar result Enumerable\n\tif err := json.Unmarshal(data, &result); err != nil {\n\t\treturn nil, WithStack(err)\n\t}\n\treturn &result, nil\n",
        "func (l *LinkedList) Get(pos int) interface{} {\n\tif pos < 0 || pos >= l.length {\n\t\treturn nil\n\t}\n\treturn l.list[pos]\n}",
        "func (l *List) IsEmpty() bool {\n\treturn l.Len() == 0 && l.Len() == 0 && l.Len() == 0 && l.Len() == 0\n}",
        "func (l *LinkedList) Length() int {\n\tl.lock.RLock()\n\tdefer l.lock.RUnlock()\n\treturn l.length()\n}",
        "func (l *List) PeekBack() *Entry {\n\tif l.len == 0 {\n\t\treturn nil\n\t}\n\treturn l.root.prev\n}",
        "func (l *List) PeekFront() (*Entry, error) {\n\tif l.Len() == 0 {\n\t\treturn nil, errors.New(\"list is empty\")\n\t}\n\treturn l.front.Value.(*Entry), nil\n}",
        "func (l *List) RemoveFront() *Entry {\n\tif l.len() == 0 {\n\t\treturn nil\n\t}\n\treturn l.front.next\n}",
        "func (l *List) RemoveBack() *Entry {\n\tif l.len() == 0 {\n\t\treturn nil\n\t}\n\treturn l.popBack()\n}",
        "func (l *List) Sort() {\n\tfor i := len(l.entries) - 1; i >= 0; i-- {\n\t\tl.entries[i].Position = i + 1\n\t}\n}",
        "func (l *List) Sorta() {\n\tsort.Slice(l.items, func(i, j int) bool {\n\t\treturn l.items[i].Key < l.items[j].Key\n\t})\n}",
        "func (l *List) Sorti() {\n\tfor i := len(l.items) - 1; i >= 0; i-- {\n\t\tl.items[i], l.items[i+1] = l.items[i+1], l.items[i]\n\t}\n}",
        "func (l *List) String() string {\n\tif l.length == 0 {\n\t\treturn \"\"\n\t}\n\treturn fmt.Sprintf(\"%s\", l.head.String())\n}",
        "func (l *List) Swap(x, y int) {\n\tl.items[x], l.items[y] = l.items[y], l.items[x]\n}",
        "func merge(left, right []string) []string {\n\tif len(left) == 0 {\n\t\treturn right\n\t}\n\tif len(right) == 0 {\n\t\treturn left\n\t}\n\tl := make([]string, 0, len(left)+len(right))\n\tl = append(l, left...)\n\tl = append(l, right...)\n\treturn l\n}",
        "func split(list []string) []string {\n\tif len(list) < 2 {\n\t\treturn list\n\t}\n\tsplit := make([]string, len(list)/2)\n\tfor i := 0; i < len(list)/2; i++ {\n\t\tsplit[i] = list[i*2]\n\t\tsplit[len(split)-i-1] = list[i*2+1]\n\t}\n\treturn split\n}",
        "func (q *Queue) Add(item interface{}) {\n\tq.lock.Lock()\n\tdefer q.lock.Unlock()\n\n\tq.items = append(q.items, item)\n}",
        "func (q *Queue) Enumerate(cb func(interface{})) {\n\tq.lock.Lock()\n\tdefer q.lock.Unlock()\n\n\tfor e := q.head; e != nil; e = e.next {\n\t\tcb(e.value)\n\t}\n}",
        "func (q *Queue) IsEmpty() bool {\n\tq.lock.Lock()\n\tdefer q.lock.Unlock()\n\n\treturn q.isEmpty()\n}",
        "func (q *Queue) Length() int {\n\tq.lock.RLock()\n\tdefer q.lock.RUnlock()\n\treturn q.length()\n}",
        "func (q *Queue) Next() (interface{}, error) {\n\tq.lock.Lock()\n\tdefer q.lock.Unlock()\n\n\tif q.closed {\n\t\treturn nil, ErrClosed\n\t}\n\n\tif q.head == q.tail {\n\t\treturn nil, ErrEmpty\n\t}\n\n\titem := q.items[q.head]\n\tq.head++\n\treturn item, nil\n}",
        "func (q *Queue) Peek() (interface{}, error) {\n\tif q.IsEmpty() {\n\t\treturn nil, errors.New(\"Queue is empty\")\n\t}\n\treturn q.items[q.head], nil\n}",
        "func (q *Queue) ToSlice() []interface{} {\n\tq.RLock()\n\tdefer q.RUnlock()\n\n\tout := make([]interface{}, 0, len(q.items))\n\tfor _, item := range q.items {\n\t\tout = append(out, item)\n\t}\n\treturn out\n}",
        "func EnableVirtualTerminalProcessing() {\n\tif runtime.GOOS == \"windows\" {\n\t\treturn\n\t}\n\n\t// We don't need to do anything for the Windows platform.\n\tif terminal.IsTerminal(int(os.Stdout.Fd())) {\n\t\treturn\n\t}\n\n\t// We don't need to do anything for other platforms.\n\tif terminal.IsTerminal(int(os.Stderr.Fd())) {\n\t\treturn\n\t}\n\n\t// We don't need to do anything for other platforms.\n\tif terminal.IsTerminal(int(os.Stdin.Fd())) {\n\t\treturn\n\t}\n\n\t// We don't need to do anything for other platforms.\n\tif terminal.IsTerminal(int(os.Stdout.Fd())) {\n\t\treturn\n\t}\n\n\t// We don't need to do",
        "func unquote(buf []byte, input []byte) []byte {\n\tif len(buf) == 0 {\n\t\treturn input\n\t}\n\tif buf[0] == '\"' {\n\t\treturn buf[1 : len(buf)-1]\n\t}\n\treturn buf\n}",
        "func countScalars(input []interface{}) int {\n\tcount := 0\n\tfor _, item := range input {\n\t\tif item == nil {\n\t\t\tcontinue\n\t\t}\n\t\tswitch item.(type) {\n\t\tcase map[string]interface{}:\n\t\t\tcount += countScalars(item.(map[string]interface{}))\n\t\tcase []interface{}:\n\t\t\tcount += countScalars(item.([]interface{}))\n\t\tcase string:\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}",
        "func (w *Writer) IsTerminal() bool {\n\tif w.isTerminal == nil {\n\t\tvar err error\n\t\tw.isTerminal, err = term.IsTerminal(w.fd)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn w.isTerminal\n}",
        "func (l *List) Add(entry string) {\n\tl.entries = append(l.entries, entry)\n}",
        "func (i *Injector) AddAt(pos int, entries ...interface{}) {\n\tfor _, entry := range entries {\n\t\ti.Add(entry)\n\t}\n}",
        "func (q Query) Enumerate(result interface{}) error {\n\treturn q.EnumerateWithContext(context.Background(), result)\n}",
        "func (l *List) Get(index int) (interface{}, bool) {\n\tif index < 0 || index >= len(l.items) {\n\t\treturn nil, false\n\t}\n\treturn l.items[index], true\n}",
        "func (l *List) IsEmpty() bool {\n\treturn l.head == nil && l.tail == nil\n}",
        "func (l *List) Length() int {\n\tl.mutex.RLock()\n\tdefer l.mutex.RUnlock()\n\treturn l.length()\n}",
        "func (l *List) Remove(v interface{}) {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\tl.values = append(l.values[:len(l.values)-1], l.values[len(l.values)-1:]...)\n}",
        "func (l *List) Set(pos int, value interface{}) {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\tl.items[pos] = value\n}",
        "func (l List) String() string {\n\tvar buf bytes.Buffer\n\tfor _, v := range l {\n\t\tbuf.WriteString(fmt.Sprintf(\"%v\\n\", v))\n\t}\n\treturn buf.String()\n}",
        "func (t *TSMReader) Swap(x, y int) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.data[x], t.data[y] = t.data[y], t.data[x]\n}",
        "func (t *Text) MarshalText() ([]byte, error) {\n\tif t.Text == \"\" {\n\t\treturn nil, nil\n\t}\n\treturn []byte(t.Text), nil\n}",
        "func (t *Text) UnmarshalText(text []byte) error {\n\tif len(text) == 0 {\n\t\treturn nil\n\t}\n\tt.text = text\n\treturn nil\n}",
        "func repl(s string) string {\n\tif s == \"\" {\n\t\treturn \"\"\n\t}\n\tif s[0] == '%' {\n\t\treturn s[1 : len(s)-1]\n\t}\n\treturn s\n}",
        "func (f *Formatter) Format(s string) (string, error) {\n\tif f.flags&FormatterFlagFormat != 0 {\n\t\treturn f.format(s)\n\t}\n\treturn s, nil\n}",
        "func logName(tag string, t time.Time) string {\n\treturn fmt.Sprintf(\"%s-%s-%s\", tag, t.Format(time.RFC3339), filepath.Base(tag))\n}",
        "func Monotonic(t time.Time) time.Duration {\n\treturn time.Duration(t.UnixNano()-int64(t.Nanosecond()))\n}",
        "func (s *severity) set(val string) error {\n\tswitch val {\n\tcase \"fatal\":\n\t\ts.level = FATAL\n\tcase \"error\":\n\t\ts.level = ERROR\n\tcase \"warning\":\n\t\ts.level = WARNING\n\tcase \"info\":\n\t\ts.level = INFO\n\tcase \"debug\":\n\t\ts.level = DEBUG\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown severity: %s\", val)\n\t}\n\treturn nil\n}",
        "func (v *Version) Set(s string) error {\n\tparts := strings.Split(s, \".\")\n\tif len(parts) != 3 {\n\t\treturn fmt.Errorf(\"invalid version: %q\", s)\n\t}\n\n\tv.Major = int(parts[0])\n\tv.Minor = int(parts[1])\n\tv.Patch = int(parts[2])\n\n\treturn nil\n}",
        "func (l *Level) set(v string) error {\n\tswitch v {\n\tcase \"debug\", \"debug-trace\", \"debug-trace-all\":\n\t\tl.Level = v\n\tcase \"info\", \"info-trace\", \"info-trace-all\":\n\t\tl.Level = v\n\tcase \"warn\", \"warn-trace\", \"warn-trace-all\":\n\t\tl.Level = v\n\tcase \"error\", \"error-trace\", \"error-trace-all\":\n\t\tl.Level = v\n\tcase \"fatal\", \"fatal-trace\", \"fatal-trace-all\":\n\t\tl.Level = v\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown log level: %s\", v)\n\t}\n\treturn nil\n}",
        "func match(file, pattern string) bool {\n\tif len(pattern) == 0 {\n\t\treturn true\n\t}\n\tif pattern[0] == '*' {\n\t\treturn true\n\t}\n\tif pattern[0] == '?' {\n\t\treturn true\n\t}\n\tif pattern[0] == '*' && pattern[1] == '*' {\n\t\treturn true\n\t}\n\tif pattern[0] == '*' && pattern[1] == '?' && pattern[2] == '*' {\n\t\treturn true\n\t}\n\tif pattern[0] == '?' && pattern[1] == '*' && pattern[2] == '?' {\n\t\treturn true\n\t}\n\tif pattern[0] == '*' && pattern[1] == '?' && pattern[2] == '*' {\n\t\treturn true\n\t}\n\tif pattern[0] == '?' && pattern[1",
        "func match(path string, re *regexp.Regexp) bool {\n\treturn re.MatchString(path)\n}",
        "func match(file string, line int) bool {\n\treturn filepath.Base(file) == filepath.Base(os.Args[0]) && line == 1\n}",
        "func NewLogger(name string, skip int) (*Logger, error) {\n\tif name == \"\" {\n\t\treturn nil, errors.New(\"name is required\")\n\t}\n\n\tl := &Logger{\n\t\tname: name,\n\t}\n\n\tif skip > 0 {\n\t\tl.skip = skip\n\t}\n\n\tif err := l.open(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn l, nil\n}",
        "func (c *Command) logDir() {\n\tif c.logDir == \"\" {\n\t\treturn\n\t}\n\tif err := os.MkdirAll(c.logDir, 0700); err != nil {\n\t\tc.UI.Error(fmt.Sprintf(\"Failed to create log directory: %s\", err))\n\t}\n}",
        "func (c *Config) SetLogToStderr(logToStderr bool) {\n\tc.Lock()\n\tdefer c.Unlock()\n\tc.logToStderr = logToStderr\n}",
        "func (c *Config) SetAlsoLogToStderr(val bool) {\n\tc.AlsoLogToStderr = val\n\tif val {\n\t\tc.LogToStderr = os.Stderr\n\t} else {\n\t\tc.LogToStderr = os.Stdout\n\t}\n}",
        "func (l *Logger) setVState(filter *Filter) {\n\tif filter == nil {\n\t\treturn\n\t}\n\tl.vFilter = filter\n\tl.vFilter.SetOutput(l.output)\n}",
        "func getBuffer(size int) *bytes.Buffer {\n\tb := bytes.NewBuffer(make([]byte, size))\n\tb.Grow(size)\n\treturn b\n}",
        "func (b *buffer) putBuffer(b2 *buffer) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tb.freeList.PushBack(b2)\n}",
        "func (l *Log) output(data []byte) error {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\n\tif l.closed {\n\t\treturn errors.New(\"log is closed\")\n\t}\n\n\tif l.file == nil {\n\t\treturn errors.New(\"log file is not open\")\n\t}\n\n\tif l.writer == nil {\n\t\treturn errors.New(\"log writer is not open\")\n\t}\n\n\tif len(data) == 0 {\n\t\treturn nil\n\t}\n\n\tif err := l.writer.Write(data); err != nil {\n\t\treturn err\n\t}\n\n\treturn l.writer.Flush()\n}",
        "func (w *Writer) timeoutFlush(timeout time.Duration) {\n\tw.Flush()\n\tselect {\n\tcase <-w.done:\n\tcase <-time.After(timeout):\n\t\tglog.Fatalf(\"Timed out waiting for %s to flush\", w.Name())\n\t}\n}",
        "func stacks() []string {\n\tvar stack []string\n\tfor i := 0; i < runtime.NumGoroutine(); i++ {\n\t\tstack = append(stack, runtime.Stack(i))\n\t}\n\treturn stack\n}",
        "func (l *Logger) exit(err error) {\n\tif err != nil {\n\t\tl.mu.Unlock()\n\t\tl.log.Errorf(\"Error: %v\", err)\n\t\tl.flush()\n\t\tos.Exit(1)\n\t}\n\tl.mu.Unlock()\n\tl.flush()\n}",
        "func (sb *syncBuffer) rotateFile() error {\n\tif sb.file != nil {\n\t\tsb.file.Close()\n\t}\n\tif err := os.Rename(sb.path, sb.newPath); err != nil {\n\t\treturn err\n\t}\n\tsb.file, err = os.OpenFile(sb.newPath, os.O_RDWR|os.O_CREATE, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "func (l *Logger) createFiles(sev Severity) error {\n\tif sev < SeverityInfo || sev > SeverityDebug {\n\t\treturn fmt.Errorf(\"invalid severity: %d\", sev)\n\t}\n\n\tif l.infoLog == nil {\n\t\treturn nil\n\t}\n\n\tif err := l.infoLog.Open(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := l.createFile(sev, SeverityInfo); err != nil {\n\t\treturn err\n\t}\n\n\tif err := l.createFile(sev, SeverityDebug); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "func (w *Writer) flushDaemon() {\n\tfor {\n\t\tselect {\n\t\tcase <-w.tomb.Dying():\n\t\t\treturn\n\t\tcase <-time.After(flushInterval):\n\t\t\tw.flush()\n\t\t}\n\t}\n}",
        "func (l *Log) lockAndFlushAll() {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.flushAll()\n}",
        "func (l *Log) flushAll() error {\n\tif l.closed {\n\t\treturn errors.New(\"log is closed\")\n\t}\n\n\t// Flush all the logs.\n\tfor _, l := range l.logs {\n\t\tif err := l.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Sync the data to disk.\n\treturn l.sync()\n}",
        "func (b *Bundle) Add(op Operation) {\n\tb.operations = append(b.operations, op)\n}",
        "func (w *Waiter) Wait() error {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tfor len(w.ops) > 0 {\n\t\terr := <-w.ops\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "func NewBundle(parent Context) *Bundle {\n\tif parent == nil {\n\t\tpanic(\"nil parent context\")\n\t}\n\treturn &Bundle{\n\t\tparent: parent,\n\t\tops:    make(map[string]Operation),\n\t}\n}",
        "func (t *Tree) Expand() {\n\tif t.Root == nil {\n\t\treturn\n\t}\n\tt.Root.Expand()\n}",
        "func CacheFunc(fn http.HandlerFunc, exp time.Duration) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"GET\" {\n\t\t\tif r.Header.Get(\"Cache-Control\") == \"\" {\n\t\t\t\tw.Header().Set(\"Cache-Control\", \"must-revalidate\")\n\t\t\t}\n\t\t\tw.Header().Set(\"Cache-Control\", \"public, max-age=\"+exp.String())\n\t\t}\n\t\tfn(w, r)\n\t}\n}",
        "func CacheFasthttp(handler fasthttp.RequestHandler, expiration time.Duration) fhttp.Handler {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"GET\" {\n\t\t\thandler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif r.Method == \"HEAD\" {\n\t\t\thandler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif r.Method == \"OPTIONS\" {\n\t\t\thandler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif r.Header.Get(\"Cache-Control\") == \"no-cache\" {\n\t\t\thandler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tif expiration <= 2 {\n\t\t\texpiration = time.Second\n\t",
        "func CacheFasthttpFunc(handler fasthttp.RequestHandler, expiration time.Duration) fasthttp.RequestHandler {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"GET\" {\n\t\t\tif r.Header.Get(\"Cache-Control\") == \"no-cache\" {\n\t\t\t\thandler.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif expiration <= 0 {\n\t\t\t\texpiration = 2 * time.Second\n\t\t\t}\n\t\t\tw.Header().Set(\"Cache-Control\", \"max-age=\"+strconv.Itoa(expiration.Seconds()))\n\t\t} else {\n\t\t\tif r.Header.Get(\"Cache-Control\") == \"no-cache\" {\n\t\t\t\thandler.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif expiration <=",
        "func (c *Config) ContentType() string {\n\tif c.ContentType == \"\" {\n\t\tif c.ContentTypeStr != \"\" {\n\t\t\tc.ContentType = c.ContentTypeStr\n\t\t} else {\n\t\t\tc.ContentType = \"application/json\"\n\t\t}\n\t}\n\treturn c.ContentType\n}",
        "func (s *Service) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Parse the request\n\tvar req *Request\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\tlog.Printf(\"[ERROR] Error decoding request: %s\", err)\n\t\thttp.Error(w, \"Invalid request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Check if the request is for a cache key\n\tif req.Method == \"GET\" {\n\t\t// Get the cache key\n\t\tkey := req.Key\n\t\tif key == \"\" {\n\t\t\tkey = req.URL.Path\n\t\t}\n\n\t\t// Check if the cache key exists\n\t\tif _, ok := s.cache[key]; !ok {\n\t\t\t// Create a new cache",
        "func New(addr string, handler http.Handler) *http.Server {\n\ts := &http.Server{\n\t\tAddr:     addr,\n\t\tHandler: handler,\n\t}\n\treturn s\n}",
        "func AcquireResponseRecorder(ctx context.Context, opts ...Option) (*ResponseRecorder, error) {\n\tr := &ResponseRecorder{\n\t\tctx:     ctx,\n\t\tlogger: log.FromContext(ctx),\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(r); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif r.logger == nil {\n\t\tr.logger = log.New(ioutil.Discard, \"\", 0)\n\t}\n\n\treturn r, nil\n}",
        "func (c *Client) ReleaseResponseRecorder(r *ResponseRecorder) {\n\tif r == nil {\n\t\treturn\n\t}\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\tc.releaseResponseRecorder(r)\n}",
        "func (c *Cache) Claim(req *http.Request) bool {\n\tif c.claimFunc != nil {\n\t\treturn c.claimFunc(req)\n\t}\n\treturn false\n}",
        "func (h *Handler) Rule(r Rule) *Handler {\n\th.rules = r\n\treturn h\n}",
        "func (e *Entry) Reset(res *http.Response) {\n\te.Response = res\n\te.Content = nil\n\te.Expires = time.Now()\n}",
        "func (h *Handler) NoCache(w http.ResponseWriter, r *http.Request) {\n\tif h.cacheable(w, r) {\n\t\treturn\n\t}\n\th.cacheable(w, r)\n\th.cacheHandler(w, r)\n}",
        "func ClientOAuth(clientID, clientSecret, callbackURL string) *ClientOAuthAuthentication {\n\treturn &ClientOAuthAuthentication{\n\t\tClientID:     clientID,\n\t\tClientSecret: clientSecret,\n\t\tCallbackURL:  callbackURL,\n\t}\n}",
        "func (c *Client) authenticateRequest(req *http.Request) {\n\t// We need to set the Authorization header to be a valid OAuth token\n\t// to prevent the client from attempting to access the API\n\t// without the token.\n\treq.Header.Set(\"Authorization\", \"Bearer \"+c.AccessToken)\n}",
        "func ApiKeyAuth(apiKey string, apiKeySecret string) ApiKeyAuthentication {\n\treturn ApiKeyAuthentication{\n\t\tApiKey:     apiKey,\n\t\tApiKeySecret: apiKeySecret,\n\t}\n}",
        "func (c *Client) authenticateRequest(message string) (string, string, error) {\n\t// Generate a request header with the HMAC SHA-256 signature of the message\n\theader := fmt.Sprintf(\"HMAC %s\", c.apiKey)\n\tsignature := hmac.Sum256([]byte(header + message))\n\n\t// Increment the nonce and add the HMAC SHA-256 signature to the request header\n\tnonce := fmt.Sprintf(\"%d\", c.nonce)\n\tsignature = fmt.Sprintf(\"%s%s\", signature, nonce)\n\n\treturn header, signature, nil\n}",
        "func ServiceOAuth(clientID, clientSecret, redirectURL string) (*ServiceOAuthAuthentication, error) {\n\treturn NewServiceOAuthAuthentication(clientID, clientSecret, redirectURL, nil)\n}",
        "func (c *Coinbase) authorizeServiceOAuth(client *http.Client) error {\n\t// We need to set the Authorization header to \"Bearer \"+c.AccessToken\n\tauthHeader := \"Bearer \"+c.AccessToken\n\tclient.Header.Set(\"Authorization\", authHeader)\n\n\t// We need to set the Authorization header to \"Bearer \"+c.AccessToken\n\t// to ensure that the client is authenticated\n\tclient.Header.Set(\"Authorization\", \"Bearer \"+c.AccessToken)\n\n\treturn nil\n}",
        "func OAuthService(clientID, clientSecret, redirectURL string) *OAuth {\n\treturn &OAuth{\n\t\tClientID:     clientID,\n\t\tClientSecret: clientSecret,\n\t\tRedirectURL:  redirectURL,\n\t}\n}",
        "func CreateAuthorizeUrl(clientID, clientSecret, redirectURI string, scope string) string {\n\treturn fmt.Sprintf(\n\t\t\"%s/authorize?client_id=%s&redirect_uri=%s&scope=%s\",\n\t\tconfig.APIEndpoint,\n\t\tclientID,\n\t\tredirectURI,\n\t\tscope,\n\t)\n}",
        "func (s *Service) RefreshTokens(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\treq, err := decodeRefreshTokensRequest(ctx, r)\n\tif err != nil {\n\t\tError(w, http.StatusUnprocessableEntity, err.Error(), s.Logger)\n\t\treturn\n\t}\n\n\terr = s.Store.RefreshTokens(ctx, req.User, req.RefreshToken)\n\tif err != nil {\n\t\tError(w, http.StatusInternalServerError, err.Error(), s.Logger)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}",
        "func (s *IdentityService) NewTokens(user string) ([]services.Token, error) {\n\tif user == \"\" {\n\t\treturn nil, trace.BadParameter(\"missing user name\")\n\t}\n\tstartKey := backend.Key(webPrefix, usersPrefix, user, tokensPrefix)\n\tresult, err := s.GetRange(context.TODO(), startKey, backend.RangeEnd(startKey), backend.NoLimit)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\ttokens := make([]services.Token, len(result.Items))\n\tfor i, item := range result.Items {\n\t\ttoken, err := services.GetTokenMarshaler().UnmarshalToken(item.Value, services.WithResourceID(item.ID), services.WithExpires(item.Expires))\n\t\tif err != nil {\n\t\t\t",
        "func NewTokensRequest(client *http.Client, code string) (*TokensRequest, error) {\n\treq, err := http.NewRequest(\"POST\", \"https://oauth.reddit.com/api/tokens\", strings.NewReader(code))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.SetBasicAuth(client.Username, client.Password)\n\treturn &TokensRequest{req}, nil\n}",
        "func (c *Client) Request(method, path string, params interface{}, holder interface{}) error {\n\treq, err := http.NewRequest(method, c.url, bytes.NewBuffer(json.Marshal(params)))\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+c.token)\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\treturn fmt.Errorf(\"Unexpected HTTP status code: %d\", resp.StatusCode)\n\t}\n\n\tif err := json.NewDecoder",
        "func (c *Client) CreateRequest(method, path string, body io.Reader) (*http.Request, error) {\n\treq, err := http.NewRequest(method, c.Endpoint+path, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"User-Agent\", \"docker-client/\"+version.Version)\n\n\treturn req, nil\n}",
        "func executeRequest(req *http.Request) ([]byte, error) {\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"Unexpected response code: %d\", resp.StatusCode)\n\t}\n\treturn ioutil.ReadAll(resp.Body)\n}",
        "func simulateRequest(r *http.Request, file string) ([]byte, error) {\n\tb, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn b, nil\n}",
        "func ApiKeyClient(apiKey string) (*Client, error) {\n\tif apiKey == \"\" {\n\t\treturn nil, errors.New(\"apiKey is empty\")\n\t}\n\n\treturn NewClient(apiKey, ApiKeyEndpoint)\n}",
        "func (c *Config) OAuthClient() (*oauth2.Client, error) {\n\tif c.OAuthClientID == \"\" {\n\t\treturn nil, fmt.Errorf(\"OAuth Client ID is missing\")\n\t}\n\n\tif c.OAuthClientSecret == \"\" {\n\t\treturn nil, fmt.Errorf(\"OAuth Client Secret is missing\")\n\t}\n\n\tif c.OAuthRedirectURL == \"\" {\n\t\treturn nil, fmt.Errorf(\"OAuth Redirect URL is missing\")\n\t}\n\n\treturn oauth2.NewClient(context.Background(), c.OAuthClientID, c.OAuthClientSecret, c.OAuthRedirectURL), nil\n}",
        "func (c *Client) Get(url string, holder interface{}) error {\n\treturn c.Do(\"GET\", url, nil, holder)\n}",
        "func (b *BitcoindClient) GetBalance() (btcutil.Amount, error) {\n\treturn b.client.GetBalance()\n}",
        "func (c *Client) GetAllAddresses() ([]btcutil.Address, error) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\taddresses := make([]btcutil.Address, 0, len(c.accounts))\n\tfor _, account := range c.accounts {\n\t\taddresses = append(addresses, account.GetAddresses()...)\n\t}\n\treturn addresses, nil\n}",
        "func GenerateReceiveAddress(chainParams *chaincfg.Params, network string,\n\tchainID string, chainHeight int32,\n\tminConf int32, maxConf int32,\n\tmaxValue int64,\n\tmaxValueIn uint64,\n\tmaxValueOut uint64,\n\tminValueIn uint64,\n\tminValueOut uint64,\n\tchainIDPrefix string,\n\tchainIDSuffix string,\n\tchainIDPrefixLen int,\n\tchainIDSuffixLen int,\n\tchainIDPrefixBit int,\n\tchainIDSuffixBit int,\n\tchainIDPrefixLenBit int,\n\tchainIDSuffixLenBit int,\n\tchainIDPrefixBitInt int,\n\tchainIDSuffixBitInt int,\n\tchainIDPrefixInt int,\n\tchainIDSuffixInt int,\n\tchainIDPrefixBitIntInt int,\n\tchainIDSuffixBitIntInt int,\n\t",
        "func SendMoney(to string, amount *big.Int, currency string) error {\n\tif currency == \"bitcoin\" {\n\t\treturn SendBitcoin(to, amount)\n\t}\n\treturn SendEmail(to, amount, currency)\n}",
        "func (c *Client) RequestMoney(address string) (*MoneyResponse, error) {\n\treq, err := http.NewRequest(\"GET\", address, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+c.Token)\n\n\tresp, err := c.HTTPClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"Unexpected status code: %d\", resp.StatusCode)\n\t}\n\n\tvar response MoneyResponse\n\tif err := json.NewDecoder(resp.Body).Decode(&response); err != nil {\n\t\treturn nil, err",
        "func (c *Client) ResendRequest(id string) error {\n\treturn c.Call(\"ResendRequest\", id, nil)\n}",
        "func (c *Client) CancelRequest(id string) error {\n\treturn c.c.Delete(fmt.Sprintf(\"/tx/%s/request\", id))\n}",
        "func (m *MoneyManager) CompleteRequest(id string) error {\n\treturn m.collection.Update(\n\t\tbson.M{\"id\": id},\n\t\tbson.M{\"$pull\": bson.M{\"requests\": 1}})\n}",
        "func (p *Payment) CreateButton(button *Button) error {\n\tif button.ID == \"\" {\n\t\treturn fmt.Errorf(\"button.ID must be set\")\n\t}\n\n\tif button.Name == \"\" {\n\t\treturn fmt.Errorf(\"button.Name must be set\")\n\t}\n\n\tif button.Text == \"\" {\n\t\treturn fmt.Errorf(\"button.Text must be set\")\n\t}\n\n\tif button.EmbedHtml == \"\" {\n\t\treturn fmt.Errorf(\"button.EmbedHtml must be set\")\n\t}\n\n\turl := p.URL + \"/buttons/\" + button.ID\n\n\treq, err := http.NewRequest(\"POST\", url, strings.NewReader(button.EmbedHtml))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\",",
        "func (mg *MailgunImpl) CreateOrderFromButtonCode(ctx context.Context, buttonCode string) (Order, error) {\n\tr := newHTTPRequest(generateApiUrl(mg, ordersEndpoint) + \"/\" + buttonCode)\n\tr.setClient(mg.Client())\n\tr.setBasicAuth(basicAuthUser, mg.APIKey())\n\tp := newUrlEncodedPayload()\n\tp.addValue(\"state\", buttonCode)\n\t_, err := makePostRequest(ctx, r, p)\n\treturn Order{}, err\n}",
        "func (s *IdentityService) CreateUser(email, password string) (services.User, error) {\n\tif err := emailValid(email); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\tif err := passwordValid(password); err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\n\titem := backend.Item{\n\t\tKey:     backend.Key(webPrefix, usersPrefix, email, passwordPrefix),\n\t\tValue:   []byte(password),\n\t\tExpires: time.Now().Add(userExpiry),\n\t}\n\t_, err := s.Create(context.TODO(), item)\n\tif err != nil {\n\t\treturn nil, trace.Wrap(err)\n\t}\n\treturn services.GetUserMarshaler().UnmarshalUser(item.Value, services.WithResourceID",
        "func (api *PublicWhisperAPI) Buy(amount btcutil.Amount, agreeBtcAmountVaries bool) (string, error) {\n\treturn api.w.Buy(amount, agreeBtcAmountVaries)\n}",
        "func (api *Client) GetContacts(user string) ([]Contact, error) {\n\treturn api.GetContactsContext(context.Background(), user)\n}",
        "func (c *Client) GetCurrencies() (map[string]string, error) {\n\tvar currencies map[string]string\n\terr := c.get(`currencies/list`, &currencies)\n\treturn currencies, err\n}",
        "func (api *KrakenApi) GetExchangeRates() (*ExchangeRatesResponse, error) {\n\tresp, err := api.queryPublic(\"GetExchangeRates\", map[string]string{}, &ExchangeRatesResponse{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp.(*ExchangeRatesResponse), nil\n}",
        "func (api *Client) GetExchangeRate(currency, from, to string) (rate float64, err error) {\n\treturn api.GetExchangeRateContext(context.Background(), currency, from, to)\n}",
        "func (api *API) GetTransactions(account string) ([]Transaction, error) {\n\treturn api.GetTransactionsContext(context.Background(), account)\n}",
        "func (api *Client) GetOrders(account string) ([]Order, error) {\n\treturn api.GetOrdersContext(context.Background(), account)\n}",
        "func (api *Client) GetTransfers(account string) ([]Transfer, error) {\n\treturn api.GetTransfersContext(context.Background(), account)\n}",
        "func (api *KrakenApi) GetBuyPrice(symbol string) (buyPrice *BtcPrice, err error) {\n\tresp, err := api.queryPublic(\"getBuyPrice\", url.Values{\"symbol\": {symbol}}, &buyPrice)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\terr = json.NewDecoder(resp.Body).Decode(&buyPrice)\n\treturn\n}",
        "func (c *Client) GetSellPrice() (string, error) {\n\tvar price string\n\terr := c.b.Call(\"btcinfo\", \"getSellPrice\", nil, &price)\n\treturn price, err\n}",
        "func (s *PublicTransactionPoolAPI) GetTransaction(ctx context.Context, id string) (*types.Transaction, error) {\n\ttx, err := s.b.GetTransaction(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tx.ToPublicTransaction(), nil\n}",
        "func (api *Client) GetOrder(id string) (*Order, error) {\n\tresult, _, err := api.makeRequest(http.MethodGet, fmt.Sprintf(\"%s/%s\", api.concatUserPath(ordersPath), id), &Order{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result.(*Order), nil\n}",
        "func (auth *Auth) GetUser() (*User, error) {\n\tif auth.User == nil {\n\t\treturn nil, trace.BadParameter(\"missing user\")\n\t}\n\treturn auth.User, nil\n}",
        "func NewSerialDispatcher(handlers ...Handler) *SerialDispatcher {\n\treturn &SerialDispatcher{\n\t\thandlers: make(map[string]Handler),\n\t}\n}",
        "func (d *Dispatcher) AppendHandlers(handlers ...Handler) {\n\tfor _, handler := range handlers {\n\t\td.AppendHandler(handler)\n\t}\n}",
        "func (d *Dispatcher) DispatchOptional(ctx context.Context, msg *Message) error {\n\tif d.isDispatching {\n\t\treturn errors.New(\"dispatcher already dispatching\")\n\t}\n\td.isDispatching = true\n\treturn d.dispatch(ctx, msg)\n}",
        "func NewParallelDispatcher(handlers []Handler) *ParallelDispatcher {\n\treturn &ParallelDispatcher{\n\t\thandlers: handlers,\n\t\twg:       &sync.WaitGroup{},\n\t}\n}",
        "func (c *Client) ReleaseMsg(msg *Message) error {\n\tif msg.Buffer == nil {\n\t\treturn nil\n\t}\n\n\tif err := c.Release(msg.Buffer); err != nil {\n\t\treturn err\n\t}\n\n\tmsg.Buffer = nil\n\treturn nil\n}",
        "func ReleaseBuffer(b []byte) {\n\tif cap(b) > 0 {\n\t\t// If the buffer is full, we'll use the global buffer pool.\n\t\tpool.Put(b)\n\t}\n}",
        "func (c *ContextCloser) Close() error {\n\tif c.closed {\n\t\treturn nil\n\t}\n\tc.closed = true\n\treturn c.ctx.Close()\n}",
        "func (c *Conn) Write(b []byte) (int, error) {\n\treturn c.w.Write(b)\n}",
        "func (l *Listener) Accept() (net.Conn, error) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tfor {\n\t\tc, ok := <-l.conns\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"listener closed\")\n\t\t}\n\t\treturn c, nil\n\t}\n}",
        "func (d *Dialer) AddDialer(addr string, dialer Dialer) {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\td.dialers[addr] = dialer\n}",
        "func (d *Dialer) dialer(addr string) (net.Conn, error) {\n\treturn d.dialerFunc(addr)\n}",
        "func (m *Manet) rawConnDial(ctx context.Context, network, addr string) (net.Conn, error) {\n\treturn m.rawConn.DialContext(ctx, network, addr)\n}",
        "func MultiaddrProtocolsMatch(a, b *multiaddr.Multiaddr) bool {\n\tif a.Len() != b.Len() {\n\t\treturn false\n\t}\n\tfor i := 0; i < a.Len(); i++ {\n\t\tif a.Get(i) != b.Get(i) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
        "func (s *Switch) MultiaddrNetMatch(network, addr string) (*Multiaddr, error) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\tfor _, m := range s.maddrs {\n\t\tif m.NetMatch(network, addr) {\n\t\t\treturn m, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"no match for network %s and address %s\", network, addr)\n}",
        "func (self *SimpleJSON) Get(key string) (interface{}, error) {\n\tif self.IsArray(key) {\n\t\treturn nil, fmt.Errorf(\"Cannot get array value for key: %s\", key)\n\t}\n\treturn self.GetRaw(key)\n}",
        "func (self *SimpleJSON) Array() []interface{} {\n\tif self.ArrayValue == nil {\n\t\tself.ArrayValue = make([]interface{}, 0)\n\t}\n\treturn self.ArrayValue\n}",
        "func buildParams(opts []ImageOption) []*cli.Flag {\n\tvar flags []*cli.Flag\n\tfor _, opt := range opts {\n\t\tflags = append(flags, opt.buildFlags()...)\n\t}\n\treturn flags\n}",
        "func unsetenv(key string) error {\n\treturn fmt.Errorf(\"unsetenv not available in mingw\")\n}",
        "func (c *Client) AssuanSend(cmd string) error {\n\treturn c.AssuanSendWithOpts(cmd, AssuanOpts{})\n}",
        "func NewData(size int) *Data {\n\treturn &Data{\n\t\tdata: make([]byte, size),\n\t\tsize: size,\n\t}\n}",
        "func NewDataFile(path string, data []byte) (*DataFile, error) {\n\tf, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE, 0600)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &DataFile{\n\t\tf: f,\n\t\tdata: data,\n\t}, nil\n}",
        "func NewDataBytes(b []byte) *Data {\n\treturn &Data{\n\t\tdata: make([]byte, len(b)),\n\t}\n}",
        "func NewDataReader(data []byte) *DataReader {\n\treturn &DataReader{\n\t\tdata: data,\n\t\tdone: make(chan struct{}),\n\t}\n}",
        "func NewDataWriter(data []byte) *DataWriter {\n\treturn &DataWriter{\n\t\tdata: data,\n\t\tdone: make(chan struct{}),\n\t}\n}",
        "func NewDataReadWriter(data []byte) *DataReadWriter {\n\treturn &DataReadWriter{\n\t\tdata: data,\n\t\tdone: make(chan struct{}),\n\t}\n}",
        "func NewDataReadWriteSeeker(data []byte, offset int64, length int64) DataReadWriteSeeker {\n\treturn &dataReadWriteSeeker{\n\t\tdata:     data,\n\t\toffset:   offset,\n\t\tlength:   length,\n\t\tbuffer:  make([]byte, length),\n\t\tcurrent: offset,\n\t}\n}",
        "func (b *Buffer) Close() error {\n\tif b.closed {\n\t\treturn nil\n\t}\n\n\tb.closed = true\n\n\tif b.reader != nil {\n\t\treturn b.reader.Close()\n\t}\n\n\treturn nil\n}",
        "func (f *File) Name() string {\n\tif f.Filename != \"\" {\n\t\treturn f.Filename\n\t}\n\treturn f.Path\n}",
        "func NewCommand(stdin io.Reader, stdout, stderr io.Writer) *cobra.Command {\n\tvar err error\n\tcmd := &cobra.Command{\n\t\tUse:   \"status\",\n\t\tShort: \"Display the status of the Livestatus service\",\n\t\tLong:  \"Display the status of the Livestatus service\",\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tif err = cmd.Run(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tcmd.AddCommand(NewStatusCommand(stdin, stdout, stderr))\n\treturn cmd\n}",
        "func (c *Command) Arg(arg string) *Command {\n\tc.args = append(c.args, arg)\n\treturn c\n}",
        "func (c *LivestatusCommand) String() string {\n\treturn fmt.Sprintf(\"LivestatusCommand{%s}\", c.Command.String())\n}",
        "func (r *Record) Columns() []string {\n\tif r.columns == nil {\n\t\tr.columns = make([]string, len(r.fields))\n\t\tcopy(r.columns, r.fields)\n\t}\n\treturn r.columns\n}",
        "func (c *Columns) Get(index int, name string) interface{} {\n\tif index < 0 || index >= len(c.columns) {\n\t\tpanic(fmt.Sprintf(\"invalid column index %d\", index))\n\t}\n\treturn c.columns[index].Get(name)\n}",
        "func (d *Dataset) GetBool(column string) (bool, error) {\n\tcol, ok := d.columns[column]\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"column %s does not exist\", column)\n\t}\n\n\treturn col.BoolValue(), nil\n}",
        "func (dt *DbfTable) GetInt(column string) (int64, error) {\n\tvalue, err := dt.GetValue(column)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn strconv.ParseInt(value, 10, 64)\n}",
        "func (d *Dataset) GetSlice(column string) ([]interface{}, error) {\n\tif !d.HasColumn(column) {\n\t\treturn nil, errors.New(\"column does not exist\")\n\t}\n\n\trow := d.Rows()\n\tif row == nil {\n\t\treturn nil, errors.New(\"no data found\")\n\t}\n\n\treturn row.GetSlice(column)\n}",
        "func (d *Dataset) GetString(column string) (string, error) {\n\treturn d.GetBytes(column, true)\n}",
        "func (d *Dataset) GetTime(col int) (time.Time, error) {\n\tif d.Rows == nil || col >= len(d.Rows.Rows) {\n\t\treturn time.Time{}, errors.New(\"column index out of range\")\n\t}\n\treturn d.Rows.Rows[col].Time, nil\n}",
        "func ChangeContactModattr(contactID, modattrID, value string) *Command {\n\treturn &Command{\n\t\tCommandType: \"CHANGE_CONTACT_MODATTR\",\n\t\tContactId:   contactID,\n\t\tModattrId:   modattrID,\n\t\tValue:       value,\n\t}\n}",
        "func ChangeContactModhattr(contactID, hostID, attribute, value string) *Command {\n\treturn &Command{\n\t\tCommandType: \"CHANGE_CONTACT_MODHATTR\",\n\t\tContactId:   contactID,\n\t\tHostId:      hostID,\n\t\tAttribute:   attribute,\n\t\tValue:       value,\n\t}\n}",
        "func ChangeContactModsattr(contactID, modAttrs string) *Command {\n\treturn &Command{\n\t\tcommand: \"CHANGE_CONTACT_MODSATTR\",\n\t\targs:    []string{contactID, modAttrs},\n\t}\n}",
        "func ChangeCustomContactVar(key, value string) *Command {\n\treturn &Command{\n\t\tOp:  \"CHANGE_CUSTOM_CONTACT_VAR\",\n\t\tKey: key,\n\t\tVal: value,\n\t}\n}",
        "func ChangeCustomHostVar(key, value string) *Command {\n\treturn &Command{\n\t\tOp:     \"CHANGE_CUSTOM_HOST_VAR\",\n\t\tKey:    key,\n\t\tValue: value,\n\t}\n}",
        "func ChangeCustomSvcVar(key, value string) *Command {\n\treturn &Command{\n\t\tOp:  \"CHANGE_CUSTOM_SVC_VAR\",\n\t\tKey: key,\n\t\tVal: value,\n\t}\n}",
        "func ChangeHostCheckTimeperiod(host string, period time.Duration) *Command {\n\treturn &Command{\n\t\tOp:     \"CHANGE_HOST_CHECK_TIMEPERIOD\",\n\t\tHost:   host,\n\t\tPeriod: period,\n\t}\n}",
        "func ChangeHostModattr(hostID, name string, modattr map[string]string) *Command {\n\treturn &Command{\n\t\tOp:     \"CHANGE_HOST_MODATTR\",\n\t\tHostID: hostID,\n\t\tName:   name,\n\t\tModattr: modattr,\n\t}\n}",
        "func ChangeSvcModattr(svcName string, attributes map[string]string) *Command {\n\treturn &Command{\n\t\tcommand: \"CHANGE_SVC_MODATTR\",\n\t\targs:    []string{svcName},\n\t\toptions: map[string]interface{}{\n\t\t\t\"attributes\": attributes,\n\t\t},\n\t}\n}",
        "func DelAllSvcComments(service string) *Cmd {\n\treturn &Cmd{\n\t\tOp:  \"DEL_ALL_SVC_COMMENTS\",\n\t\tService: service,\n\t}\n}",
        "func DisablePassiveSvcChecks(service string) *Command {\n\treturn &Command{\n\t\top:     \"DISABLE_PASSIVE_SVC_CHECKS\",\n\t\tservice: service,\n\t}\n}",
        "func DisableServiceFlapDetection(service string) *Command {\n\treturn &Command{\n\t\top:     \"DISABLE_SERVICE_FLAP_DETECTION\",\n\t\tservice: service,\n\t}\n}",
        "func DisableSvcCheck(service string) *Cmd {\n\treturn &Cmd{\n\t\tCommand: \"DISABLE_SVC_CHECK\",\n\t\tArgs:     []string{service},\n\t\tRunE: func(c *Cmd) error {\n\t\t\treturn c.run()\n\t\t},\n\t}\n}",
        "func DisableSvcEventHandler(service string) *Command {\n\treturn &Command{\n\t\top:     \"DISABLE_SVC_EVENT_HANDLER\",\n\t\tservice: service,\n\t}\n}",
        "func DisableSvcFlapDetection(service string) *Command {\n\treturn &Command{\n\t\top:     \"DISABLE_SVC_FLAP_DETECTION\",\n\t\tservice: service,\n\t}\n}",
        "func DisableSvcNotifications(service string) *Command {\n\treturn &Command{\n\t\top:     opDisableSvcNotifications,\n\t\tservice: service,\n\t}\n}",
        "func EnablePassiveSvcChecks(service string) *Command {\n\treturn &Command{\n\t\top:     \"ENABLE_PASSIVE_SVC_CHECKS\",\n\t\tservice: service,\n\t\targs:   []string{\"--passive\"},\n\t}\n}",
        "func EnableSvcCheck(service string) *Cmd {\n\treturn &Cmd{\n\t\tCommand: \"ENABLE_SVC_CHECK\",\n\t\tArgs:     []string{service},\n\t\tRunE: func(c *Cmd) error {\n\t\t\treturn c.runCheck(service)\n\t\t},\n\t}\n}",
        "func EnableSvcEventHandler(service string) *Cmd {\n\treturn &Cmd{\n\t\tExec: &Exec{\n\t\t\tCommand: \"ENABLE_SVC_EVENT_HANDLER\",\n\t\t\tArgs:    []string{service},\n\t\t},\n\t}\n}",
        "func EnableSvcFlapDetection(service string) *Command {\n\treturn &Command{\n\t\top:     \"ENABLE_SVC_FLAP_DETECTION\",\n\t\tservice: service,\n\t\targs:   []string{\"--enable-flap-detection\"},\n\t}\n}",
        "func EnableSvcNotifications(service string) *Command {\n\treturn &Command{\n\t\top:     \"ENABLE_SVC_NOTIFICATIONS\",\n\t\tservice: service,\n\t\targs:   []string{\"-n\"},\n\t}\n}",
        "func (c *Client) RemoveSvcAcknowledgement(service string) *RemoveSvcAcknowledgementCommand {\n\treturn &RemoveSvcAcknowledgementCommand{\n\t\tService: service,\n\t\tAck:     true,\n\t}\n}",
        "func StartObsessingOverSvc(service string) *NagiosCmd {\n\treturn &NagiosCmd{\n\t\tCmdType:  CommandTypeStartObsessingOverSvc,\n\t\tService: service,\n\t}\n}",
        "func (c *Client) StopObsessingOverSvc(svcID string) *StopObsessingOverSvcCmd {\n\tcmd := &StopObsessingOverSvcCmd{\n\t\tServiceID: svcID,\n\t}\n\tc.process(cmd)\n\treturn cmd\n}",
        "func NewQuery(ctx context.Context, db *sql.DB, table string) *Query {\n\treturn &Query{\n\t\tctx:     ctx,\n\t\tdb:      db,\n\t\ttable:   table,\n\t\tfields: make(map[string]*queryField),\n\t}\n}",
        "func (s *SelectQuery) Columns(columns ...string) *SelectQuery {\n\ts.columns = append(s.columns, columns...)\n\treturn s\n}",
        "func (q *Query) Filter(filter Filter) *Query {\n\tq.filters = append(q.filters, filter)\n\treturn q\n}",
        "func (f *Filter) And(filters ...*Filter) *Filter {\n\treturn &Filter{\n\t\top:     andOp,\n\t\tfilters: filters,\n\t}\n}",
        "func (f *Filter) Negate() {\n\tf.mtx.Lock()\n\tdefer f.mtx.Unlock()\n\tf.negate()\n}",
        "func (t *Table) WaitObject(object string) *Table {\n\tt.waitObject = object\n\treturn t\n}",
        "func (q *Query) WaitCondition(cond *Condition) *Query {\n\tq.cond = append(q.cond, cond)\n\treturn q\n}",
        "func (w *Waiter) WaitConditionNegate() {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tw.cond.Signal()\n}",
        "func (q *Query) WaitTrigger(eventName string, eventBroker string) *Query {\n\tq.trigger = append(q.trigger, Trigger{\n\t\tEventType:  EventTypeWait,\n\t\tEventBroker: eventBroker,\n\t\tName:       eventName,\n\t})\n\treturn q\n}",
        "func (q *Query) WaitTimeout(timeout time.Duration) *Query {\n\tq.timeout = timeout\n\treturn q\n}",
        "func (c *Client) KeepAlive() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.conn != nil {\n\t\tc.conn.KeepAlive()\n\t}\n}",
        "func (c *Conn) ReadTimeout(t time.Duration) *Conn {\n\tc.readTimeout = t\n\treturn c\n}",
        "func (q *LivestatusQuery) String() string {\n\treturn fmt.Sprintf(\"LivestatusQuery{%v}\", q.baseQuery.String())\n}",
        "func NewClient(apiKey string, apiSecret string) *Client {\n\treturn &Client{\n\t\tapiKey:     apiKey,\n\t\tapiSecret:  apiSecret,\n\t\tHTTPClient: &http.Client{},\n\t}\n}",
        "func NewClientWithDialer(dialer *net.Dialer) *Client {\n\treturn &Client{\n\t\tHTTPClient: &http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tDial: dialer.Dial,\n\t\t\t},\n\t\t},\n\t}\n}",
        "func (c *Client) Exec(ctx context.Context, query *livestatus.Query) (*livestatus.Result, error) {\n\treq, err := c.NewRequest(\"GET\", query.URL, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := c.Do(ctx, req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"Unexpected response code: %d\", resp.StatusCode)\n\t}\n\n\treturn resp.Body, nil\n}",
        "func xtoi2(s string, e byte) bool {\n\tif len(s) < 2 || s[len(s)-2] != e {\n\t\treturn false\n\t}\n\treturn s[len(s)-2] == 'x'\n}",
        "func Mask(addr uint64, mask uint64) uint64 {\n\treturn (addr & mask) | (mask << (64 - mask))\n}",
        "func New(path string) (*Database, error) {\n\tdb := &Database{\n\t\tpath: path,\n\t}\n\tif err := db.load(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn db, nil\n}",
        "func (s *OUIService) Lookup(ctx context.Context, address string) (*platform.OUI, error) {\n\treturn s.LookupFn(ctx, address)\n}",
        "func VendorLookup(s string) (string, error) {\n\tif s == \"\" {\n\t\treturn \"\", fmt.Errorf(\"empty MAC address\")\n\t}\n\tif !strings.HasPrefix(s, \"02:00:00:00:00:00\") {\n\t\treturn \"\", fmt.Errorf(\"invalid MAC address format: %s\", s)\n\t}\n\tparts := strings.Split(s, \":\")\n\tif len(parts) != 3 {\n\t\treturn \"\", fmt.Errorf(\"invalid MAC address format: %s\", s)\n\t}\n\treturn parts[0], nil\n}",
        "func (o *OUI) Contains(mac string) bool {\n\tfor _, v := range o.MacAddresses {\n\t\tif v == mac {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
        "func NewThrottledReader(r io.Reader, throttler Throttler) io.Reader {\n\treturn &throttledReader{\n\t\tr:   r,\n\t\tthrottler: throttler,\n\t}\n}",
        "func newThrottledBucket(b *Bucket, opThrottle, egressThrottle time.Duration) *bucket {\n\treturn &bucket{\n\t\tBucket:       b,\n\t\topThrottle:   opThrottle,\n\t\tEgressThrottle: egressThrottle,\n\t}\n}",
        "func NewCmdWithRunner(name string, runner *cmd.Runner) (*CmdWithRunner, error) {\n\tif !cmd.ValidCommandName(name) {\n\t\treturn nil, fmt.Errorf(\"invalid command name: %s\", name)\n\t}\n\treturn &CmdWithRunner{\n\t\tname: name,\n\t\trunner: runner,\n\t}, nil\n}",
        "func MustNewCmdWithRunner(cmdName string, cmdArgs []string, cmdEnv []string, runner *exec.CmdRunner) *cobra.Command {\n\tcmd, err := NewCmdWithRunner(cmdName, cmdArgs, cmdEnv, runner)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cmd\n}",
        "func importBreakPaths(paths []string) []string {\n\tvar importPaths []string\n\tfor _, p := range paths {\n\t\tif p == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif p[0] == '.' {\n\t\t\tcontinue\n\t\t}\n\t\timportPaths = append(importPaths, p)\n\t}\n\treturn importPaths\n}",
        "func SelfProxyCmderSupplier(cmd string) func() (string, error) {\n\treturn func() (string, error) {\n\t\tif proxyCmder == nil {\n\t\t\treturn \"\", errors.New(\"no proxy cmder\")\n\t\t}\n\t\treturn proxyCmder.SelfProxyCmder(cmd)\n\t}\n}",
        "func SupplierWithPrependedArgs(supplier RunnerWithPrependedArgs, argsFunc func(string) []string) Supplier {\n\treturn func() Runner {\n\t\treturn RunnerFunc(func(cmd *Command, args []string) error {\n\t\t\treturn supplier(cmd, argsFunc(cmd.Args))\n\t\t})\n\t}\n}",
        "func selfCmder() Cmder {\n\treturn func(cmd *exec.Cmd) (*exec.Cmd, error) {\n\t\treturn cmd, nil\n\t}\n}",
        "func CmderWithPrependedArgs(cmder Cmder, prependedArgs []string) Cmder {\n\treturn &CmderWithPrependedArgs{\n\t\tCmder:   cmder,\n\t\tprependedArgs: prependedArgs,\n\t}\n}",
        "func NewSeeforRouter(mux *http.ServeMux, handler http.Handler) *SeeforRouter {\n\treturn &SeeforRouter{\n\t\tmux:     mux,\n\t\thandler: handler,\n\t}\n}",
        "func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tr.ServeHTTPC(w, req, r.Handler)\n}",
        "func (r *Router) Before(fn func(http.ResponseWriter, *http.Request)) *Router {\n\tr.before = append(r.before, fn)\n\treturn r\n}",
        "func (r *Router) After(fn func(http.ResponseWriter, *http.Request)) *Router {\n\tr.middleware = append(r.middleware, fn)\n\treturn r\n}",
        "func (e *Endpoint) UseTimer(timer *time.Timer) *Endpoint {\n\te.timer = timer\n\treturn e\n}",
        "func NewRouter() *Router {\n\treturn &Router{\n\t\troutes: make(map[string]*Route),\n\t\thandlers: make(map[string]Handler),\n\t}\n}",
        "func (h *HTTPBin) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"POST\" {\n\t\tif err := h.handlePost(w, r); err != nil {\n\t\t\th.writeError(w, err)\n\t\t}\n\t} else if r.Method == \"GET\" {\n\t\tif err := h.handleGet(w, r); err != nil {\n\t\t\th.writeError(w, err)\n\t\t}\n\t} else if r.Method == \"OPTIONS\" {\n\t\tif err := h.handleOptions(w, r); err != nil {\n\t\t\th.writeError(w, err)\n\t\t}\n\t} else {\n\t\th.writeError(w, fmt.Errorf(\"Method not supported: %s\", r.Method))\n\t}\n",
        "func (r *Router) Group(path string, fn func(http.ResponseWriter, *http.Request)) {\n\tr.groupRouter.Group(path, fn)\n}",
        "func (n *node) findChild(n2 *node) *node {\n\tfor _, child := range n.children {\n\t\tif child.match(n2) {\n\t\t\treturn child\n\t\t}\n\t}\n\treturn nil\n}",
        "func (r *Route) insertChild(n *RouteNode) *RouteNode {\n\tif r.children == nil {\n\t\tr.children = make(map[string]*RouteNode)\n\t}\n\tr.children[n.path] = n\n\treturn n\n}",
        "func (c *Counter) Get(route string) *Counter {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.counters == nil {\n\t\tc.counters = make(map[string]*Counter)\n\t}\n\n\tif c.counters[route] == nil {\n\t\tc.counters[route] = &Counter{}\n\t}\n\n\treturn c.counters[route]\n}",
        "func (s *Server) stats() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\ts.stats.TotalRequests = s.totalRequests\n\ts.stats.TotalResponses = s.totalResponses\n\ts.stats.TotalRequestsDuration = time.Since(s.startTime)\n\ts.stats.TotalResponsesDuration = time.Since(s.endTime)\n\ts.stats.TotalRequestsBytes = s.totalRequestsBytes\n\ts.stats.TotalResponsesBytes = s.totalResponsesBytes\n\ts.stats.TotalRequestsErrors = s.totalRequestsErrors\n\ts.stats.TotalResponsesErrors = s.totalResponsesErrors\n\ts.stats.TotalRequestsDurationSeconds = float64(s.totalRequestsDuration.Seconds())\n\ts.stats.TotalResponsesDurationSeconds = float64(s.totalResponsesDuration.Seconds())\n\ts",
        "func main() {\n\tCheckArgs(\"<url>\", \"<username>\", \"<password>\")\n\turl := os.Args[1]\n\tusername := os.Args[2]\n\tpassword := os.Args[3]\n\n\t// Create a new client\n\tclient, err := r2.NewClient(url, username, password)\n\tCheckIfError(err)\n\n\t// Get the list of users\n\tusers, err := client.Users.List()\n\tCheckIfError(err)\n\n\tfor _, user := range users {\n\t\tfmt.Printf(\"User %s\\n\", user.Name)\n\t}\n}",
        "func NewGroupRouter(group *Group) *GroupRouter {\n\treturn &GroupRouter{\n\t\tgroup: group,\n\t\trouter: router.New(),\n\t}\n}",
        "func (r *Router) Middle(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\tr.Handle(w, req, h)\n\t})\n}",
        "func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tr.ServeHTTPC(w, req)\n}",
        "func RectFromSphere(c Point, r float64) Rect {\n\treturn Rect{\n\t\tMin: Point{\n\t\t\tmath.Min(c.X, r),\n\t\t\tmath.Min(c.Y, r),\n\t\t},\n\t\tMax: Point{\n\t\t\tmath.Max(c.X, r),\n\t\t\tmath.Max(c.Y, r),\n\t\t},\n\t}\n}",
        "func CopyRect(r Rect) Rect {\n\treturn Rect{\n\t\tTop:    r.Top,\n\t\tLeft:   r.Left,\n\t\tRight:  r.Right,\n\t\tBottom: r.Bottom,\n\t}\n}",
        "func (r *Rect) Size() (width, height, depth int) {\n\treturn r.W, r.H, r.D\n}",
        "func (r *Row) Overlaps(s *Row) bool {\n\tif r == nil || s == nil {\n\t\treturn false\n\t}\n\tif r.Len() == 0 && s.Len() == 0 {\n\t\treturn true\n\t}\n\tif r.Len() == 0 {\n\t\treturn false\n\t}\n\tif s.Len() == 0 {\n\t\treturn true\n\t}\n\tif r.Len() > s.Len() {\n\t\treturn false\n\t}\n\tfor i := range r.data {\n\t\tif !r.data[i].Overlaps(s.data[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
        "func (r *Range) String() string {\n\treturn fmt.Sprintf(\"[%d,%d]\", r.Start, r.End)\n}",
        "func (r *Rect) Dx() int {\n\treturn r.Max.X - r.Min.X\n}",
        "func (r *Row) Dy() int {\n\tif r.height == 0 {\n\t\treturn 0\n\t}\n\treturn r.height\n}",
        "func (s *Rectangle) In(r Rect) bool {\n\treturn s.X.In(r.X) && s.Y.In(r.Y)\n}",
        "func (x *Big) Approx(y *Big) bool {\n\tif x.form&inf != 0 || y.form&inf != 0 {\n\t\treturn false\n\t}\n\tif x.form&signbit != 0 || y.form&signbit != 0 {\n\t\treturn false\n\t}\n\tif x.form&signbit != 0 && y.form&signbit != 0 {\n\t\treturn false\n\t}\n\tif x.form&signbit != 0 && y.form&signbit != 0 {\n\t\treturn false\n\t}\n\tif x.form&signbit != 0 && y.form&signbit != 0 {\n\t\treturn false\n\t}\n\tif x.form&signbit != 0 && y.form&signbit != 0 {\n\t\treturn false\n\t}\n\tif x.form&signbit != 0",
        "func ApproxEpsilon(x, y float64, epsilon float64) bool {\n\treturn ApproxEpsilonWithAbsError(x, y, epsilon, math.MaxFloat64)\n}",
        "func (m *Matrix3x3) SetXYZ(x, y, z float32) {\n\tm[0][0] = x\n\tm[0][1] = y\n\tm[0][2] = z\n\n\tm[1][0] = x\n\tm[1][1] = y\n\tm[1][2] = z\n\n\tm[2][0] = x\n\tm[2][1] = y\n\tm[2][2] = z\n}",
        "func Vec3Dist2DSqr(v1, v2 Vec3) float32 {\n\treturn (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1])\n}",
        "func (v Vec3) Copy(dst Vec3) {\n\tdst[0] = v[0]\n\tdst[1] = v[1]\n\tdst[2] = v[2]\n}",
        "func (v *Value) Assign(v1 *Value) {\n\tif v1.IsNil() {\n\t\tv.SetNil()\n\t\treturn\n\t}\n\tv.Set(v1.Value)\n}",
        "func (v *Vector) Dist2D(v2 *Vector) float32 {\n\treturn (v.X - v2.X) * (v.Y - v2.Y)\n}",
        "func (v *Vector) Dist2DSqr(v2 *Vector) float32 {\n\treturn (v.X - v2.X) * (v.X - v2.X) + (v.Y - v2.Y) * (v.Y - v2.Y)\n}",
        "func (v Vector) Cross(v1 Vector) Vector {\n\treturn Vector{\n\t\tv[0] * v1[0] - v[1] * v1[1],\n\t\tv[0] * v1[1] + v[1] * v1[0],\n\t}\n}",
        "func Dot2D(u, v *T) float32 {\n\treturn (u[0] * v[0]) + (u[1] * v[1])\n}",
        "func NewRay(o, v Point) *Ray {\n\treturn &Ray{\n\t\to:  o,\n\t\tv:  v,\n\t\tdir: Direction(math.Abs(v.X-o.X)),\n\t}\n}",
        "func (r *Ray) IntersectRect(b Rect) bool {\n\treturn r.Intersects(b.Min, b.Max)\n}",
        "func SupportedFunc(s *Server) func(string) bool {\n\treturn func(method string) bool {\n\t\tfor _, v := range s.SupportedMethods {\n\t\t\tif method == v {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}",
        "func NewSigner(key *rsa.PrivateKey) (*Signer, error) {\n\tif key == nil {\n\t\treturn nil, errors.New(\"rsa: key is nil\")\n\t}\n\treturn &Signer{\n\t\tkey: key,\n\t}, nil\n}",
        "func NewVerifier(key []byte) (*Verifier, error) {\n\tif len(key) == 0 {\n\t\treturn nil, errors.New(\"rsa: key must be non-empty\")\n\t}\n\treturn &Verifier{\n\t\tkey: key,\n\t}, nil\n}",
        "func (c *Client) Request(method, url string, body io.Reader) (*http.Response, error) {\n\treq, err := http.NewRequest(method, url, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"User-Agent\", \"Google-Api-Go-Client/\"+Version+\" (+http://github.com/google/godoc)\")\n\n\treturn c.httpClient.Do(req)\n}",
        "func (c *Client) Status(id string) (*Status, error) {\n\tvar status Status\n\terr := c.do(\"GET\", fmt.Sprintf(\"/gdpr/requests/%s\", id), nil, &status)\n\treturn &status, err\n}",
        "func (c *Client) Cancel(id string) error {\n\treturn c.do(\"POST\", fmt.Sprintf(\"/gdpr/requests/%s/cancel\", id), nil, nil)\n}",
        "func (c *Client) Discovery(ctx context.Context, discoveryURL string) (*discovery.Response, error) {\n\treq, err := http.NewRequest(\"GET\", discoveryURL, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Authorization\", \"Bearer \"+c.Token)\n\n\tresp, err := c.HTTPClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"Unexpected HTTP status code: %d\", resp.StatusCode)\n\t}\n\n\treturn discovery.ParseResponse(resp)\n}",
        "func NewClient(apiKey string, apiSecret string) *Client {\n\treturn &Client{\n\t\tapiKey:     apiKey,\n\t\tapiSecret:  apiSecret,\n\t\tHTTPClient: &http.Client{},\n\t}\n}",
        "func (s *Stack) Push(item interface{}) {\n\ts.items = append(s.items, item)\n}",
        "func (s *Stack) Pop() interface{} {\n\tif s.Len() == 0 {\n\t\treturn nil\n\t}\n\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\t// Remove the topmost item from the stack.\n\ts.items = s.items[1:]\n\n\t// Return the topmost item.\n\treturn s.items[0]\n}",
        "func (s *Stack) PopLast() {\n\tif s.Len() < 2 {\n\t\treturn\n\t}\n\n\ts.items = s.items[:len(s.items)-1]\n}",
        "func (s *Stack) Peek() (interface{}, error) {\n\tif s.Len() == 0 {\n\t\treturn nil, errors.New(\"Stack is empty\")\n\t}\n\treturn s.items[s.Len()-1], nil\n}",
        "func (s *Stack) PeekN(max int) (interface{}, error) {\n\tif len(s.items) <= max {\n\t\treturn nil, errors.New(\"stack is empty\")\n\t}\n\treturn s.items[s.top], nil\n}",
        "func Vecf32(x, y, z float32) Vec {\n\treturn Vec{float32(x), float32(y), float32(z)}\n}",
        "func Veci(x, y int) Vec {\n\treturn Vec{float64(x), float64(y)}\n}",
        "func (v Vector) Add(v2 Vector) Vector {\n\treturn Vector{\n\t\tv[0] + v2[0],\n\t\tv[1] + v2[1],\n\t}\n}",
        "func (v Vector) Sub(v2 Vector) Vector {\n\treturn Vector{\n\t\tv[0] - v2[0],\n\t\tv[1] - v2[1],\n\t}\n}",
        "func (r *Range) In(p int) bool {\n\treturn r.Start <= p && p <= r.End\n}",
        "func (v Vector) Len() int {\n\tif v.LenX() == 0 {\n\t\treturn 0\n\t}\n\treturn v.LenY()\n}",
        "func (v1 Vec3) ApproxFuncEqual(v2 Vec3, equal func(float32, float32) bool) bool {\n\treturn equal(v1.X, v2.X) && equal(v1.Y, v2.Y) && equal(v1.Z, v2.Z)\n}",
        "func (h HandlerMap) Merge(m HandlerMap) HandlerMap {\n\tfor k, v := range m {\n\t\th[k] = v\n\t}\n\treturn h\n}",
        "func respCode(r *http.Request, code int) {\n\tif code >= 400 && code < 500 {\n\t\tr.StatusCode = code\n\t} else {\n\t\tr.StatusCode = http.StatusOK\n\t}\n}",
        "func NewServer(h http.Handler) *Server {\n\treturn &Server{\n\t\tHandler: h,\n\t\tmu:     &sync.Mutex{},\n\t}\n}",
        "func (c *Client) Callback(req CallbackRequest) error {\n\treturn c.CallbackWithRetries(req, 0)\n}",
        "func (c *Context) ErrNotFound(msg string) {\n\tc.err = errors.New(msg)\n}",
        "func ErrUnsupportedRequestType(reqType RequestType) error {\n\treturn &Error{\n\t\tcode: EUnsupportedRequestType,\n\t\tmsg:  fmt.Sprintf(\"unsupported request type %q\", reqType),\n\t}\n}",
        "func ErrUnsupportedIdentity(id IdentityType) error {\n\treturn &Error{\n\t\tCode: EUnsupportedIdentity,\n\t\tMsg:  fmt.Sprintf(\"identity type %q is not supported\", id),\n\t}\n}",
        "func ErrMissingRequiredField(name string) *Validation {\n\treturn &Validation{\n\t\tcode:    MissingRequiredFieldCode,\n\t\tName:    name,\n\t\tIn:      \"body\",\n\t\tValue:   \"\",\n\t\tmessage: fmt.Sprintf(\"missing required field %q\", name),\n\t}\n}",
        "func ErrInvalidRequestSignature(payload []byte, signature []byte) error {\n\treturn ErrInvalidRequest{\n\t\tpayload:   payload,\n\t\tsignature: signature,\n\t}\n}",
        "func (c *Client) DatabaseServers() ([]*DatabaseServer, error) {\n\tvar out []*DatabaseServer\n\turi := fmt.Sprintf(pathDatabases, c.addr)\n\terr := c.get(uri, &out)\n\treturn out, err\n}",
        "func (c *Client) SnapshotDatabaseServer(i *SnapshotDatabaseServerInput) (*DatabaseServer, error) {\n\tif i.Service == \"\" {\n\t\treturn nil, ErrMissingService\n\t}\n\n\tif i.Version == 0 {\n\t\treturn nil, ErrMissingVersion\n\t}\n\n\tif i.Name == \"\" {\n\t\treturn nil, ErrMissingName\n\t}\n\n\tpath := fmt.Sprintf(\"/service/%s/version/%d/database_server/%s\", i.Service, i.Version, i.Name)\n\tresp, err := c.Get(path, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar b *DatabaseServer\n\tif err := decodeJSON(&b, resp.Body); err != nil {\n\t\treturn nil, err\n\t}\n\treturn b, nil",
        "func (c *Client) ResetPasswordForDatabaseServer(ctx context.Context, name, password string) error {\n\turi := fmt.Sprintf(pathResetPasswordForDatabaseServer, c.addr, name)\n\terr := c.post(ctx, uri, password, nil)\n\treturn err\n}",
        "func (c *Client) Servers() ([]*Server, error) {\n\tvar out []*Server\n\turi := fmt.Sprintf(pathServers, c.addr)\n\terr := c.get(uri, &out)\n\treturn out, err\n}",
        "func (c *Client) Server(id string) (*Server, error) {\n\tout := new(Server)\n\turi := fmt.Sprintf(pathServer, c.addr, id)\n\terr := c.get(uri, out)\n\treturn out, err\n}",
        "func (c *Client) DestroyServer(i *DestroyServerInput) error {\n\tif i.Service == \"\" {\n\t\treturn ErrMissingService\n\t}\n\n\tif i.Version == 0 {\n\t\treturn ErrMissingVersion\n\t}\n\n\tpath := fmt.Sprintf(\"/service/%s/version/%d/server\", i.Service, i.Version)\n\tresp, err := c.Delete(path, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar r *http.Response\n\tif resp, err = checkResp(resp, http.StatusNoContent, \"destroy server\"); err != nil {\n\t\treturn err\n\t}\n\n\t// TODO: Uncomment the following code to test the response\n\t// if resp.StatusCode != http.StatusNoContent {\n\t// \treturn fmt.Errorf(\"Unexpected response code %",
        "func (c *Client) LockServer(i *LockServerInput) (*Server, error) {\n\tif i.Service == \"\" {\n\t\treturn nil, ErrMissingService\n\t}\n\n\tif i.Version == 0 {\n\t\treturn nil, ErrMissingVersion\n\t}\n\n\tif i.Name == \"\" {\n\t\treturn nil, ErrMissingName\n\t}\n\n\tpath := fmt.Sprintf(\"/service/%s/version/%d/server/%s\", i.Service, i.Version, i.Name)\n\tresp, err := c.PostForm(path, i, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s *Server\n\tif err := decodeJSON(&s, resp.Body); err != nil {\n\t\treturn nil, err\n\t}\n\treturn s, nil\n}",
        "func (c *Client) UnlockServer(id string) error {\n\treturn c.UnlockResource(id, \"servers\")\n}",
        "func (c *Client) SnapshotServer(i *SnapshotServerInput) (*SnapshotServerResponse, error) {\n\tif i.Service == \"\" {\n\t\treturn nil, ErrMissingService\n\t}\n\n\tif i.Version == 0 {\n\t\treturn nil, ErrMissingVersion\n\t}\n\n\tif i.Name == \"\" {\n\t\treturn nil, ErrMissingName\n\t}\n\n\tpath := fmt.Sprintf(\"/service/%s/version/%d/snapshot/server/%s\", i.Service, i.Version, i.Name)\n\tresp, err := c.PostForm(path, i, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar s *SnapshotServerResponse\n\tif err := decodeJSON(&s, resp.Body); err != nil {\n\t\treturn nil, err\n\t}\n\treturn",
        "func (c *Config) FullConsoleUrl() string {\n\treturn fmt.Sprintf(\"%s?token=%s\", c.ConsoleUrl, c.ConsoleToken)\n}",
        "func (c *Client) FirewallRule(id string) (*FirewallRule, error) {\n\tout := new(FirewallRule)\n\turi := fmt.Sprintf(pathFirewallRule, c.addr, id)\n\terr := c.get(uri, out)\n\treturn out, err\n}",
        "func (b *BigIP) ServerGroups() (*ServerGroups, error) {\n\tvar serverGroups ServerGroups\n\terr, _ := b.getForEntity(&serverGroups, uriLtm, uriServerGroup)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &serverGroups, nil\n}",
        "func (c *Client) ServerGroup(name string) (*ServerGroup, error) {\n\tout := new(ServerGroup)\n\turi := fmt.Sprintf(pathServerGroup, c.addr, name)\n\terr := c.get(uri, out)\n\treturn out, err\n}",
        "func (c *Client) AddServersToServerGroup(identifier string, serverIds []string) ([]Server, error) {\n\tvar serverGroupServerIds []string\n\tif len(serverIds) > 0 {\n\t\tserverGroupServerIds = make([]string, len(serverIds))\n\t\tfor i, id := range serverIds {\n\t\t\tserverGroupServerIds[i] = fmt.Sprintf(\"%s:%s\", identifier, id)\n\t\t}\n\t}\n\n\tvar serverGroupServerIdsResponse ServerGroupServerIdsResponse\n\tif err := c.call(\"AddServersToServerGroup\", &serverGroupServerIdsResponse, http.MethodPost, \"/server-groups/\"+identifier+\"/servers\", serverGroupServerIds); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn serverGroupServerIdsResponse.Servers, nil\n}",
        "func (a *Agent) MoveServersToServerGroup(src, dst string, serverIds []string) error {\n\treturn a.moveServersToServerGroup(src, dst, serverIds, false)\n}",
        "func (c *Cloud) LoadBalancers() ([]*compute.LoadBalancer, error) {\n\tctx, cancel := cloud.ContextWithCallTimeout()\n\tdefer cancel()\n\n\tmc := newLoadBalancerMetricContext(\"list\")\n\tv, err := c.c.LoadBalancers().List(ctx, filter.None)\n\treturn v, mc.Observe(err)\n}",
        "func (c *CloudAPI) LoadBalancer(loadBalancerID string) (*cloudapi.LoadBalancer, error) {\n\tif err := c.ProcessFunctionHook(c, loadBalancerID); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, l := range c.loadBalancers {\n\t\tif l.ID == loadBalancerID {\n\t\t\treturn l, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"LoadBalancer %s not found\", loadBalancerID)\n}",
        "func (c *Cloud) AddNodesToLoadBalancer(loadBalancerName string, nodes []*v1.Node) error {\n\tctx, cancel := cloud.ContextWithCallTimeout()\n\tdefer cancel()\n\n\tmc := newLoadBalancerMetricContext(\"add_nodes\", loadBalancerName)\n\treturn mc.Observe(c.c.LoadBalancer().AddNodes(ctx, meta.ZonalKey(loadBalancerName, nodes...)))\n}",
        "func (lb *LoadBalancer) RemoveListenersFromLoadBalancer(loadBalancerName string, listeners []string) error {\n\tlb.Lock()\n\tdefer lb.Unlock()\n\n\tif lb.loadBalancers == nil {\n\t\treturn fmt.Errorf(\"loadBalancers not initialized\")\n\t}\n\n\tif _, ok := lb.loadBalancers[loadBalancerName]; !ok {\n\t\treturn fmt.Errorf(\"loadBalancer %s not found\", loadBalancerName)\n\t}\n\n\tfor _, listener := range listeners {\n\t\tif _, ok := lb.loadBalancers[loadBalancerName][listener]; !ok {\n\t\t\treturn fmt.Errorf(\"listener %s not found\", listener)\n\t\t}\n\t}\n\n\tdelete(lb.loadBalancers[loadBalancerName], listeners)\n\treturn nil\n}",
        "func (c *Client) LockResource(ctx context.Context, resourceID string, lockType string, lockArgs map[string]string) (string, error) {\n\tvar resource *Resource\n\tvar err error\n\n\tif resourceID == \"\" {\n\t\tresource, err = c.GetResource(ctx, lockType)\n\t} else {\n\t\tresource, err = c.GetResourceByID(ctx, resourceID)\n\t}\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif resource.Type == \"cloudip\" {\n\t\treturn \"\", fmt.Errorf(\"cloudip is not supported for lock\")\n\t}\n\n\tif resource.Type == \"server\" {\n\t\treturn \"\", fmt.Errorf(\"server is not supported for lock\")\n\t}\n\n\tif resource.Type == \"image\" {\n\t\treturn \"\", fmt",
        "func (b *BigIP) FirewallPolicies() (*FirewallPolicies, error) {\n\tvar firewallPolicies FirewallPolicies\n\terr, _ := b.getForEntity(&firewallPolicies, uriLtm, uriFirewallPolicy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &firewallPolicies, nil\n}",
        "func (c *Client) FirewallPolicy(id string) (*FirewallPolicy, error) {\n\tout := new(FirewallPolicy)\n\turi := fmt.Sprintf(pathFirewallPolicy, c.addr, id)\n\terr := c.get(uri, out)\n\treturn out, err\n}",
        "func (c *Client) ApplyFirewallPolicy(group string, policy string) error {\n\treturn c.ApplyFirewallPolicyContext(context.Background(), group, policy)\n}",
        "func (ar *AuthResult) Extract(resp *http.Response) error {\n\tif resp == nil {\n\t\treturn errors.New(\"no response\")\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn errors.New(fmt.Sprintf(\"unexpected status code: %d\", resp.StatusCode))\n\t}\n\n\tif ar.Token == \"\" {\n\t\treturn errors.New(\"no token\")\n\t}\n\n\tif ar.User == \"\" {\n\t\treturn errors.New(\"no user\")\n\t}\n\n\treturn nil\n}",
        "func (c *Client) ApiClients() ([]Client, error) {\n\tvar clients []Client\n\tif err := c.get(`api/clients`, &clients); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn clients, nil\n}",
        "func (c *Client) ApiClient(id string) (*ApiClient, error) {\n\tout := new(ApiClient)\n\turi := fmt.Sprintf(pathApiClient, c.addr, id)\n\terr := c.get(uri, out)\n\treturn out, err\n}",
        "func (c *Client) ResetSecretForApiClient(name string) error {\n\treturn c.post(fmt.Sprintf(\"/api/clients/%s/secrets/reset\", name), nil, nil)\n}",
        "func (c *Client) Images() ([]*Image, error) {\n\tvar images []*Image\n\terr := c.get(`images/list`, &images)\n\treturn images, err\n}",
        "func (c *Client) Image(imageID string) (*Image, error) {\n\tvar image Image\n\treturn &image, c.Get(&image, \"/images/\"+imageID)\n}",
        "func (c *Client) Accounts() ([]*Account, error) {\n\tvar accountsRes []*Account\n\terr := c.get(`accounts/list`, &accountsRes)\n\treturn accountsRes, err\n}",
        "func (s *Service) Account(w http.ResponseWriter, r *http.Request) {\n\tctx := r.Context()\n\n\tid, err := paramID(\"id\", r)\n\tif err != nil {\n\t\tError(w, http.StatusUnprocessableEntity, err.Error(), s.Logger)\n\t\treturn\n\t}\n\n\taccount, err := s.Store.Accounts(ctx).Get(ctx, chronograf.AccountID(id))\n\tif err != nil {\n\t\tnotFound(w, id, s.Logger)\n\t\treturn\n\t}\n\n\tres := newAccountResponse(account)\n\tencodeJSON(w, http.StatusOK, res, s.Logger)\n}",
        "func (c *Client) CloudIPs() ([]CloudIP, error) {\n\tvar cloudIPs []CloudIP\n\tif err := c.get(`cloud/ips`, &cloudIPs); err != nil {\n\t\treturn nil, err\n\t}\n\tsort.Sort(cloudIPsByName(cloudIPs))\n\treturn cloudIPs, nil\n}",
        "func (c *Client) CloudIP(id string) (*CloudIP, error) {\n\tout := new(CloudIP)\n\turi := fmt.Sprintf(pathCloudIP, c.addr, id)\n\terr := c.get(uri, out)\n\treturn out, err\n}",
        "func MapCloudIPtoServer(ip net.IP) (string, error) {\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range ifaces {\n\t\tif ip.Equal(iface.HardwareAddr) {\n\t\t\treturn iface.Name, nil\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"Could not find a server for the Cloud IP %s\", ip)\n}",
        "func setAuthHeader(r *http.Request, t *Token) {\n\tr.Header.Set(\"Authorization\", \"Bearer \"+t.AccessToken)\n}",
        "func (c *Client) Auth(username, password string) (*AuthResponse, error) {\n\treq, err := http.NewRequest(\"POST\", c.authURL, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.SetBasicAuth(username, password)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tresp, err := c.httpClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"Unexpected response code: %d\", resp.StatusCode)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}",
        "func (c oauthClient) Collaborations() ([]wl.Collaboration, error) {\n\tif err := c.processError(\"Collaborations\"); err != nil {\n\t\treturn nil, err\n\t}\n\n\tlist := []wl.Collaboration{}\n\tfor _, item := range c.collaborationList {\n\t\tlist = append(list, item)\n\t}\n\n\tsort.Sort(wl.CollaborationList(list))\n\n\treturn list, nil\n}",
        "func (c oauthClient) Collaboration(collaboration wl.Collaboration) (wl.Collaboration, error) {\n\tif collaboration.ID == \"\" {\n\t\treturn wl.Collaboration{}, errors.New(\"collaboration.ID must be set\")\n\t}\n\n\turl := fmt.Sprintf(\n\t\t\"%s/collaborations/%d\",\n\t\tc.apiURL,\n\t\tcollaboration.ID,\n\t)\n\n\treq, err := c.newGetRequest(url)\n\tif err != nil {\n\t\treturn wl.Collaboration{}, err\n\t}\n\n\tresp, err := c.do(req)\n\tif err != nil {\n\t\treturn wl.Collaboration{}, err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn wl.Collaboration{}",
        "func (b *BigIP) DatabaseSnapshots() (*DatabaseSnapshots, error) {\n\tvar snapshots DatabaseSnapshots\n\terr, _ := b.getForEntity(&snapshots, uriLtm, uriDatabase, snapshotPrefix)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &snapshots, nil\n}",
        "func (c *Client) DatabaseSnapshot(i *DatabaseSnapshotInput) (*DatabaseSnapshotResponse, error) {\n\tif i.Service == \"\" {\n\t\treturn nil, ErrMissingService\n\t}\n\n\tif i.Version == 0 {\n\t\treturn nil, ErrMissingVersion\n\t}\n\n\tif i.Name == \"\" {\n\t\treturn nil, ErrMissingName\n\t}\n\n\tpath := fmt.Sprintf(\"/service/%s/version/%d/database_snapshot/%s\", i.Service, i.Version, i.Name)\n\tresp, err := c.Get(path, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar b *DatabaseSnapshotResponse\n\tif err := decodeJSON(&b, resp.Body); err != nil {\n\t\treturn nil, err\n\t}\n\treturn b, nil",
        "func (c *Client) Scan(ctx context.Context, ip net.IP, hosts []string, timeout time.Duration) ([]Ping, error) {\n\tvar ping []Ping\n\tif timeout == 0 {\n\t\ttimeout = defaultPingTimeout\n\t}\n\treq, err := http.NewRequest(\"GET\", c.baseURL+\"ping\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"User-Agent\", userAgent)\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Accept-Ranges\", \"bytes\")\n\treq.Header.Set(\"X-Host-Range\", fmt.Sprintf(\"%s/%s\", ip, strings.Join(hosts, \"/\")))\n\treq.Header.Set(\"X-Host-Name\", c.hostName)\n\treq.Header",
        "func ToFile(src, dest string, opts *FileOptions) error {\n\tif opts == nil {\n\t\topts = &FileOptions{}\n\t}\n\n\tif opts.Timeout == 0 {\n\t\topts.Timeout = DefaultFileTimeout\n\t}\n\n\tif opts.Client == nil {\n\t\topts.Client = DefaultClient\n\t}\n\n\tif opts.UserAgent == \"\" {\n\t\topts.UserAgent = DefaultUserAgent\n\t}\n\n\tif opts.Headers == nil {\n\t\topts.Headers = make(map[string]string)\n\t}\n\n\tif opts.Headers[\"User-Agent\"] == \"\" {\n\t\topts.Headers[\"User-Agent\"] = opts.UserAgent\n\t}\n\n\tif opts.Headers[\"Accept\"] == \"\" {\n\t\topts.Headers[\"Accept\"] = \"application/octet-stream\"\n\t}\n\n",
        "func (o *Options) ToWriter(w io.Writer, src string, opts ...io.WriterOption) error {\n\treturn o.ToWriterContext(context.Background(), w, src, opts...)\n}",
        "func FromURL(src string, w io.Writer, options Options) error {\n\treturn FromURLWithClient(src, w, options, http.DefaultClient)\n}",
        "func (c *Client) OTP(period time.Duration) (otp string, err error) {\n\tvar resp struct {\n\t\tOtp string `json:\"otp\"`\n\t}\n\tif err := c.call(\"OTP\", period, &resp); err != nil {\n\t\treturn\n\t}\n\treturn resp.Otp, nil\n}",
        "func (otp *OTP) Data(label string) ([]byte, error) {\n\tif otp.secret == nil {\n\t\treturn nil, errors.New(\"No secret key provided\")\n\t}\n\n\tif otp.secret.Length() == 0 {\n\t\treturn nil, errors.New(\"Secret key is empty\")\n\t}\n\n\tif otp.secret.Length() > otp.secretLength {\n\t\treturn nil, fmt.Errorf(\"Secret key is too long (%d > %d)\", otp.secretLength, otp.secret.Length())\n\t}\n\n\tdata := make([]byte, otp.secretLength)\n\tcopy(data, otp.secret.Bytes())\n\n\tdata = append(data, label...)\n\tdata = append(data, []byte(otp.final)...)\n\n\treturn data, nil\n}",
        "func Generate(length int) (string, error) {\n\tif length <= 0 {\n\t\tlength = 10\n\t}\n\tb := make([]byte, length)\n\tif _, err := rand.Read(b); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn b32.EncodeToString(b), nil\n}",
        "func DefaultPeerConfig() *PeerConfig {\n\treturn &PeerConfig{\n\t\tMaxMessageBytes:     defaultMaxMessageBytes,\n\t\tMaxMessageBytesPerMsg: defaultMaxMessageBytesPerMsg,\n\t\tMaxMessageBytesPerSec: defaultMaxMessageBytesPerSec,\n\t\tMaxMessageCount:      defaultMaxMessageCount,\n\t\tMaxMessageCountPerSec: defaultMaxMessageCountPerSec,\n\t\tMaxMessageSize:       defaultMaxMessageSize,\n\t\tMaxMessageSizePerSec:  defaultMaxMessageSizePerSec,\n\t\tMaxMessageTimeout:     defaultMaxMessageTimeout,\n\t\tMaxMessageTimeoutPerSec: defaultMaxMessageTimeoutPerSec,\n\t\tMaxMessageRetry:       defaultMaxMessageRetry,\n\t\tMaxMessageRetryPerSec: defaultMaxMessageRetryPerSec,\n\t\tMaxMessageRetryWait:    defaultMaxMessageRetryWait,\n\t\tMaxMessage",
        "func (p *Peer) PubKey() *btcec.PublicKey {\n\tp.RLock()\n\tdefer p.RUnlock()\n\n\treturn p.pubKey\n}",
        "func (s *Service) OnStart() error {\n\tif s.isRunning() {\n\t\treturn nil\n\t}\n\n\ts.logger.Info(\"Starting service\", \"name\", s.Name)\n\n\ts.wg.Add(1)\n\tgo s.run()\n\n\treturn nil\n}",
        "func (c *MConnection) Send(chID byte, msg []byte) bool {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tif c.closed {\n\t\treturn false\n\t}\n\n\tif c.sendQueue.Len() >= c.sendQueueCap {\n\t\treturn false\n\t}\n\n\tc.sendQueue.PushBack(&sendItem{chID, msg})\n\treturn true\n}",
        "func (p *PeerPublicKey) WriteTo(w io.Writer) (int64, error) {\n\treturn encoding.WriteTo(w, p.pubKeyBytes)\n}",
        "func (n *Node) Equals(other *Node) bool {\n\treturn n.ID() == other.ID()\n}",
        "func FuzzConnAfter(duration time.Duration) *FuzzedConnection {\n\treturn &FuzzedConnection{\n\t\tconn: &FuzzedConn{\n\t\t\tconn: &Conn{\n\t\t\t\tconn: &Conn{\n\t\t\t\t\tconn: &Conn{\n\t\t\t\t\t\tconn: &Conn{\n\t\t\t\t\t\t\tconn: &Conn{\n\t\t\t\t\t\t\t\tconn: &Conn{\n\t\t\t\t\t\t\t\t\tconn: &Conn{},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tstart: time.Now().Add(duration),\n\t}\n}",
        "func NewMConnectionWithConfig(conn net.Conn, config *Config) *MConnection {\n\treturn &MConnection{\n\t\tConn:   conn,\n\t\tconfig: config,\n\t}\n}",
        "func Catch(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}",
        "func (c *Client) QueueMessage(channel string, message string) error {\n\treturn c.QueueMessageContext(context.Background(), channel, message)\n}",
        "func (c *Client) QueueMessage(channel string, msg *Message) bool {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tif c.closed {\n\t\treturn false\n\t}\n\n\tif _, ok := c.messages[channel]; ok {\n\t\treturn false\n\t}\n\n\tc.messages[channel] = msg\n\treturn true\n}",
        "func (c *Client) CanSend(chID uint64) bool {\n\tc.RLock()\n\tdefer c.RUnlock()\n\treturn c.canSend(chID)\n}",
        "func (s *Sender) sendRoutine() {\n\tfor {\n\t\tselect {\n\t\tcase packet := <-s.sendQueue:\n\t\t\ts.sendPacket(packet)\n\t\tcase <-s.quit:\n\t\t\treturn\n\t\t}\n\t}\n}",
        "func (c *Client) sendMonitor() bool {\n\tc.sendMonitorLock.Lock()\n\tdefer c.sendMonitorLock.Unlock()\n\tif c.sendMonitorDone {\n\t\treturn false\n\t}\n\tc.sendMonitorDone = true\n\tfor _, ch := range c.sendMonitorChannels {\n\t\tselect {\n\t\tcase ch <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n\treturn len(c.sendMonitorChannels) == 0\n}",
        "func (c *Channel) HasMessages() bool {\n\tc.RLock()\n\tdefer c.RUnlock()\n\treturn len(c.messages) == 0\n}",
        "func (s *Sender) newPacket() *msgPacket {\n\treturn &msgPacket{\n\t\tmsg:  make([]byte, s.maxPacketSize),\n\t\tseq:  s.seq,\n\t\terr:  make(chan error, 1),\n\t\tdone: make(chan struct{}, 1),\n\t}\n}",
        "func (p *packetPool) writeNext(w io.Writer) error {\n\tif p.closed {\n\t\treturn ErrClosed\n\t}\n\n\tif p.head == p.tail {\n\t\t// If the buffer is full, we can't write the next packet.\n\t\treturn ErrBufferFull\n\t}\n\n\t// Write the next packet.\n\tif _, err := w.Write(p.head.data); err != nil {\n\t\treturn err\n\t}\n\n\t// Increment head position.\n\tp.head = p.head.next\n\n\t// Increment tail position.\n\tp.tail = p.tail.next\n\n\treturn nil\n}",
        "func (s *Server) handleMsgPackets(msgPackets []*packet.Packet) ([]byte, error) {\n\t// If there are no packets, return nil\n\tif len(msgPackets) == 0 {\n\t\treturn nil, nil\n\t}\n\n\t// Get the next packet\n\tnextPacket, err := s.getNextPacket()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new message\n\tmsg := &packet.Message{\n\t\tID:        nextPacket.ID,\n\t\tType:      nextPacket.Type,\n\t\tTimestamp: nextPacket.Timestamp,\n\t\tPayload:   nextPacket.Payload,\n\t}\n\n\t// Handle the packet\n\treturn s.handlePacket(msgPackets, msg)\n}",
        "func (s *Skein) init() {\n\ts.hash = sha256.New()\n\ts.hash.Write([]byte(\"skein\"))\n\ts.hash.Write([]byte(\"skein\"))\n\ts.hash.Write([]byte(\"skein\"))\n\ts.hash.Write([]byte(\"skein\"))\n\ts.hash.Write([]byte(\"skein\"))\n\ts.hash.Write([]byte(\"skein\"))\n\ts.hash.Write([]byte(\"skein\"))\n\ts.hash.Write([]byte(\"skein\"))\n\ts.hash.Write([]byte(\"skein\"))\n\ts.hash.Write([]byte(\"skein\"))\n\ts.hash.Write([]byte(\"skein\"))",
        "func incrementNonce() {\n\tnonce := make([]byte, 8)\n\tif _, err := io.ReadFull(rand.Reader, nonce); err != nil {\n\t\tpanic(err)\n\t}\n\tnonce[7] = byte(nonce[7] ^ 0x80)\n\tnonce[6] = byte(nonce[6] ^ 0x40)\n\tnonce[5] = byte(nonce[5] ^ 0x20)\n\tnonce[4] = byte(nonce[4] ^ 0x10)\n\tnonce[3] = byte(nonce[3] ^ 0x08)\n\tnonce[2] = byte(nonce[2] ^ 0x04)\n\tnonce[1] = byte(nonce[1] ^ 0x02)\n\tnonce[0] = byte(nonce[0] ^ 0x01)\n}",
        "func (ps *peerSet) ListPeers() []*peerConnection {\n\tps.lock.RLock()\n\tdefer ps.lock.RUnlock()\n\n\tpeers := make([]*peerConnection, 0, len(ps.peers))\n\tfor _, p := range ps.peers {\n\t\tpeers = append(peers, p)\n\t}\n\treturn peers\n}",
        "func (s *Server) Accept() (net.Conn, error) {\n\tfor {\n\t\tconn, err := s.listener.Accept()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ts.connChan <- conn\n\t}\n}",
        "func NewAddrBook(db *sql.DB, dbConfig *DBConfig) *AddrBook {\n\tdbConfig.CheckDB()\n\tdbConfig.CheckTables()\n\n\tdb = db.Clone()\n\tdb.Begin()\n\n\tab := &AddrBook{\n\t\tdb:           db,\n\t\tdbConfig:     dbConfig,\n\t\tdbConfigChanged: make(chan struct{}),\n\t\tdbConfigChangedCh: make(chan struct{}),\n\t\tdbConfigChangedCh2: make(chan struct{}),\n\t\tdbConfigChangedCh3: make(chan struct{}),\n\t\tdbConfigChangedCh4: make(chan struct{}),\n\t\tdbConfigChangedCh5: make(chan struct{}),\n\t\tdbConfigChangedCh6: make(chan struct{}),\n\t\tdbConfigChangedCh7: make(chan struct{}),\n\t",
        "func (s *Service) OnStart() error {\n\tif s.config.Enable {\n\t\ts.logger.Info(\"Starting\")\n\t\ts.start()\n\t\treturn nil\n\t}\n\treturn errors.Errorf(\"service %s is disabled\", s.Name())\n}",
        "func (a *AddressBook) RemoveAddress(addr *Address) {\n\ta.mtx.Lock()\n\tdefer a.mtx.Unlock()\n\n\tdelete(a.addresses, addr.AddressID)\n}",
        "func (f *File) Exists() bool {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\treturn f.exists()\n}",
        "func (b *Book) Save() error {\n\tif b.ID == \"\" {\n\t\treturn errors.New(\"book id is required\")\n\t}\n\n\tif b.Title == \"\" {\n\t\treturn errors.New(\"book title is required\")\n\t}\n\n\tif b.Author == \"\" {\n\t\treturn errors.New(\"book author is required\")\n\t}\n\n\tif b.Publisher == \"\" {\n\t\treturn errors.New(\"book publisher is required\")\n\t}\n\n\tif b.Isbn == \"\" {\n\t\treturn errors.New(\"book isbn is required\")\n\t}\n\n\tif b.Isbn10 == \"\" {\n\t\treturn errors.New(\"book isbn10 is required\")\n\t}\n\n\tif b.Isbn13 == \"\" {\n\t\treturn errors.New(\"book isbn13 is required\")\n",
        "func (b *Bucket) addOldKa(ka *KeyArena) bool {\n\tif len(b.oldKa) >= b.maxOldKa {\n\t\treturn false\n\t}\n\tb.oldKa = append(b.oldKa, ka)\n\treturn true\n}",
        "func (c *Cache) expireOldBuckets() {\n\tfor {\n\t\tc.mu.Lock()\n\t\tfor _, b := range c.buckets {\n\t\t\tif b.isBad() {\n\t\t\t\tb.expire()\n\t\t\t}\n\t\t}\n\t\tc.mu.Unlock()\n\t\ttime.Sleep(c.expireInterval)\n\t}\n}",
        "func Dial(seeds []string, opts ...DialOption) ([]string, error) {\n\tvar wg sync.WaitGroup\n\tvar wgErr error\n\tvar wgDone bool\n\tvar wgDoneErr error\n\n\tvar wgResult []string\n\tfor _, seed := range seeds {\n\t\twg.Add(1)\n\t\tgo func(seed string) {\n\t\t\tdefer wg.Done()\n\t\t\twgDone, wgDoneErr = DialWithRetry(seed, opts...)\n\t\t\tif wgDone {\n\t\t\t\treturn\n\t\t\t}\n\t\t\twgResult = append(wgResult, seed)\n\t\t}(seed)\n\t}\n\n\twg.Wait()\n\tif wgErr != nil {\n\t\treturn nil, wgErr\n\t}\n\n\treturn wgResult, nil\n}",
        "func NewNetAddressStrings(addresses []string) []NetAddress {\n\tvar netAddresses []NetAddress\n\tfor _, address := range addresses {\n\t\tnetAddresses = append(netAddresses, NewNetAddressString(address))\n\t}\n\treturn netAddresses\n}",
        "func NewNetAddressIPPort(ip net.IP, port int) *NetAddress {\n\treturn &NetAddress{\n\t\tIP:     ip,\n\t\tPort:   port,\n\t\tProtocol: ProtocolTCP,\n\t}\n}",
        "func (na *NetAddress) Equals(other *NetAddress) bool {\n\treturn na.IP.Equal(other.IP) &&\n\t\tna.Port == other.Port &&\n\t\tna.Protocol == other.Protocol &&\n\t\tna.Zone == other.Zone\n}",
        "func (d *Dialer) Dial(network, addr string) (net.Conn, error) {\n\treturn d.net.Dial(network, addr)\n}",
        "func (a *Address) String() string {\n\tif a.IsIPv4() {\n\t\treturn fmt.Sprintf(\"%x\", a.Bytes())\n\t}\n\treturn fmt.Sprintf(\"%x:%x\", a.IP(), a.MaskedMaskedIP())\n}",
        "func ReachabilityTo(o *Object, na *Object) bool {\n\tif o == na {\n\t\treturn true\n\t}\n\tif o.IsNil() {\n\t\treturn true\n\t}\n\tif na.IsNil() {\n\t\treturn false\n\t}\n\tif o.IsNil() {\n\t\treturn false\n\t}\n\tif o.IsNil() {\n\t\treturn true\n\t}\n\tif na.IsNil() {\n\t\treturn false\n\t}\n\tif o.IsNil() {\n\t\treturn false\n\t}\n\tif na.IsNil() {\n\t\treturn false\n\t}\n\tif o.IsNil() {\n\t\treturn true\n\t}\n\tif na.IsNil() {\n\t\treturn false\n\t}\n\tif o.IsNil() {\n\t\treturn false",
        "func NewPEXReactor(ctx context.Context, pexClient *pex.Client, pexServer *pex.Server,\n\tpeerClient *peer.Client, peerServer *peer.Server,\n\tpeerIdentity *peer.Identity,\n\tpeerAuth *peer.Auth,\n\tpeerAuthServer *peer.AuthServer,\n\tpeerAuthServerPeer *peer.AuthServerPeer,\n\tpeerAuthServerPeerID *peer.Identity,\n\tpeerAuthServerPeerSecret *peer.Secret,\n\tpeerAuthServerPeerSecretID *peer.Secret,\n\tpeerAuthServerPeerSecretSecret *peer.Secret,\n\tpeerAuthServerPeerIDSecret *peer.Secret,\n\tpeerAuthServerPeerSecretSecret *peer.Secret,\n\tpeerAuthServerPeerIDSecret *peer.Secret,\n\tpeerAuthServerPeerSecretSecret *peer.Secret,\n\tpeerAuthServerPeerIDSecret",
        "func (s *Service) OnStart() error {\n\tif s.Config.Enable {\n\t\ts.Logger.Info(\"Starting service...\")\n\t\ts.start()\n\t\treturn nil\n\t}\n\treturn errors.New(\"service not enabled\")\n}",
        "func (r *PEXReactor) Receive(msg *pex.Message) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif r.stopped {\n\t\treturn\n\t}\n\n\tif r.reactor != nil {\n\t\tr.reactor.Receive(msg)\n\t}\n}",
        "func (p *peerConnection) RequestPEX(addr string) error {\n\tp.log.Tracef(\"RequestPEX(%s)\", addr)\n\treturn p.peer.RequestPEX(addr)\n}",
        "func (p *peer) SendAddrs(addrs []*p2p.NetAddress) error {\n\tp.log.Debugf(\"Sending %d addrs to peer %s\", len(addrs), p.id)\n\treturn p2p.Send(p.rw, addrs)\n}",
        "func (m *CMap) Increment(p *Peer) {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tm.count[p] = m.count[p].(int64) + 1\n}",
        "func (c *Client) DecodeMessage(msg []byte) ([]byte, error) {\n\tif c.isClosed() {\n\t\treturn nil, ErrClientClosed\n\t}\n\tif c.isShutdown() {\n\t\treturn nil, ErrClientShutdown\n\t}\n\tif c.isShutdown() {\n\t\treturn nil, ErrClientShutdown\n\t}\n\tif c.isShutdown() {\n\t\treturn nil, ErrClientShutdown\n\t}\n\tif c.isShutdown() {\n\t\treturn nil, ErrClientShutdown\n\t}\n\tif c.isShutdown() {\n\t\treturn nil, ErrClientShutdown\n\t}\n\tif c.isShutdown() {\n\t\treturn nil, ErrClientShutdown\n\t}\n\tif c.isShutdown() {\n\t\treturn nil, ErrClientShutdown\n\t}\n\tif c.isShutdown() {\n",
        "func NewReader(r io.Reader) *Reader {\n\treturn &Reader{\n\t\tr:   r,\n\t\tbuf: make([]byte, defaultBufSize),\n\t}\n}",
        "func LogOnPanic(err interface{}) {\n\tif err != nil {\n\t\tlog.Printf(\"PANIC: %s\\n%s\", err, debug.Stack())\n\t}\n}",
        "func Wrap(handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tlog.Printf(\"PANIC: %s\\n%s\", r, debug.Stack())\n\t\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\t}\n\t\t}()\n\t\thandler.ServeHTTP(w, r)\n\t})\n}",
        "func (l *Log) Start() {\n\tl.wg.Add(1)\n\tgo func() {\n\t\tdefer l.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-l.ctx.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\t\t\tl.handleLog()\n\t\t}\n\t}()\n}",
        "func New(app Handler) *Service {\n\treturn &Service{\n\t\tapp:       app,\n\t\thandlers: make(map[string]Handler),\n\t}\n}",
        "func Wrap(handler http.Handler, checkCertificate CheckCertificate, invalidHandler InvalidHandler) http.Handler {\n\tif handler == nil {\n\t\thandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\t}\n\tif checkCertificate == nil {\n\t\tcheckCertificate = DefaultCheckCertificate\n\t}\n\tif invalidHandler == nil {\n\t\tinvalidHandler = DefaultInvalidHandler\n\t}\n\treturn &handlerWithCertificate{\n\t\tHandler: handler,\n\t\tcheckCertificate: checkCertificate,\n\t\tinvalidHandler:  invalidHandler,\n\t}\n}",
        "func (p *Properties) GetString(name string) (string, bool) {\n\tv, ok := p.Get(name).(string)\n\treturn v, ok\n}",
        "func (p *Properties) GetInt(name string) (int, bool) {\n\tv, ok := p.GetOk(name)\n\tif !ok {\n\t\treturn 0, false\n\t}\n\ti, ok := v.(int)\n\treturn i, ok\n}",
        "func RegisterDriver(name string, ctor DriverConstructor) {\n\tif ctor == nil {\n\t\tpanic(\"nil constructor\")\n\t}\n\tif _, dup := drivers[name]; dup {\n\t\tpanic(fmt.Sprintf(\"driver %s is already registered\", name))\n\t}\n\tdrivers[name] = ctor\n}",
        "func Open(server, password string, db int) (*Hub, error) {\n\tif db < 1 {\n\t\tdb = 1\n\t}\n\tif db > maxDB {\n\t\tdb = maxDB\n\t}\n\tif server == \"\" {\n\t\tserver = defaultRedisServer\n\t}\n\tif password == \"\" {\n\t\tpassword = defaultRedisPassword\n\t}\n\tif db < 1 {\n\t\tdb = 1\n\t}\n\tif db > maxDB {\n\t\tdb = maxDB\n\t}\n\tif db < 1 {\n\t\treturn nil, fmt.Errorf(\"Invalid db value %d\", db)\n\t}\n\thub := &Hub{\n\t\tdb:     db,\n\t\tserver: server,\n\t\tpassword: password,\n\t\tdbLock:  &sync.Mutex{},\n\t\thubs:",
        "func (c *Client) SendEvents(eventCh chan Event) {\n\tfor event := range eventCh {\n\t\tc.SendEvent(event)\n\t}\n}",
        "func (m *Message) Unmarshal(data []byte) error {\n\tif len(data) == 0 {\n\t\treturn nil\n\t}\n\n\tif len(data) < 4 {\n\t\treturn fmt.Errorf(\"message too short: %d\", len(data))\n\t}\n\n\tm.Type = MessageType(data[0])\n\tm.Length = int(data[1])\n\tm.Data = data[2 : len(data)-4]\n\n\treturn nil\n}",
        "func (p *Publisher) Publish(ch chan<- interface{}) {\n\tfor {\n\t\tselect {\n\t\tcase data := <-ch:\n\t\t\tp.publish(data)\n\t\tcase <-p.shutdown:\n\t\t\treturn\n\t\t}\n\t}\n}",
        "func (c *Client) Subscribe(channel string, handler EventHandler) {\n\tc.mu.Lock()\n\tc.subscribers[channel] = handler\n\tc.mu.Unlock()\n}",
        "func (g *PubSub) GetChannel() (*gcdmessage.ChromeResponse, error) {\n\treturn g.GetChannelContext(context.Background())\n}",
        "func (c *Channel) Remove(ch chan struct{}) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tdelete(c.channels, ch)\n}",
        "func Open(natsServer, natsPub, natsSub string, opts ...Option) (*Hub, error) {\n\th := &Hub{\n\t\tnatsPub:     natsPub,\n\t\tnatsSub:     natsSub,\n\t\tnatsServer: natsServer,\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(h); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif h.natsPub == \"\" {\n\t\treturn nil, errors.New(\"natsPub is empty\")\n\t}\n\n\tif h.natsSub == \"\" {\n\t\treturn nil, errors.New(\"natsSub is empty\")\n\t}\n\n\tif h.natsServer == \"\" {\n\t\treturn nil, errors.New(\"natsServer is empty\")\n\t",
        "func (p *Publisher) Publish(msg interface{}, channels ...string) {\n\tfor _, channel := range channels {\n\t\tp.PublishTo(channel, msg)\n\t}\n}",
        "func (c *Client) Subscribe(channels ...string) error {\n\treturn c.SubscribeContext(context.Background(), channels...)\n}",
        "func (p *PubSub) MakeHub() *Hub {\n\treturn &Hub{\n\t\tclient: p.client,\n\t\tpubsub: p.pubsub,\n\t}\n}",
        "func fibonacci() func() int {\n\tfib := make([]int, 0, 10)\n\tfor i := 0; i < 10; i++ {\n\t\tfib = append(fib, i)\n\t}\n\treturn func() int {\n\t\tfor i := 0; i < len(fib); i++ {\n\t\t\tj := fib[i]\n\t\t\tfib[i] = fib[j]\n\t\t\tfib[j] = i\n\t\t}\n\t\treturn fib[0]\n\t}\n}",
        "func roundRobinIndexes(max int, start int) []int {\n\tindexes := make([]int, max)\n\tfor i := 0; i < max; i++ {\n\t\tindexes[i] = start + i\n\t}\n\treturn indexes\n}",
        "func Dir() (string, error) {\n\thome, err := homedir.Dir()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif home == \"\" {\n\t\treturn \"\", errors.New(\"no home directory found\")\n\t}\n\treturn home, nil\n}",
        "func (s *Session) Ask(question string) (string, error) {\n\treturn s.AskWithChoice(question, choice.Choice{})\n}",
        "func (p *Parser) InteractionCount() int {\n\tif p.err != nil {\n\t\treturn -1\n\t}\n\n\tif p.node.Type != xml.StartElement {\n\t\tp.err = fmt.Errorf(\"expected start element, got %s\", p.node.Type)\n\t\treturn -1\n\t}\n\n\treturn p.node.Attr.Get(\"interactions_count\")\n}",
        "func (c *Conversation) TimeElapsed() time.Duration {\n\tif c.TimeElapsedTime == nil {\n\t\treturn -1\n\t}\n\treturn time.Since(*c.TimeElapsedTime)\n}",
        "func (s *Session) History() []*QApair {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\thistory := make([]*QApair, 0, 100)\n\tfor _, i := range s.Interactions {\n\t\thistory = append(history, i)\n\t}\n\treturn history\n}",
        "func (c *Context) Bool(name string) bool {\n\treturn lookupBool(name, c.flagSet)\n}",
        "func (c *Context) String(name string, defaultValue string) string {\n\treturn lookupString(name, c.flagSet, defaultValue)\n}",
        "func (t *Task) Fail() {\n\tt.state = stateFailed\n\tt.err = errors.New(\"task failed\")\n}",
        "func (t *Task) Failed() bool {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn t.state == TaskStateFailed\n}",
        "func (l *Logger) Logf(format string, args ...interface{}) {\n\tl.Printf(format, args...)\n}",
        "func (l *Logger) Error(v ...interface{}) {\n\tl.log(LError, fmt.Sprint(v...))\n\tos.Exit(1)\n}",
        "func Errorf(format string, args ...interface{}) {\n\tif LogLevel >= 3 {\n\t\tlog.Printf(format, args...)\n\t}\n\tFail(1, format, args...)\n}",
        "func Init(rootURL, authToken string, api *MockApi) {\n\tif api == nil {\n\t\tpanic(\"firebase: api is nil\")\n\t}\n\tif rootURL == \"\" {\n\t\tpanic(\"firebase: rootURL is empty\")\n\t}\n\tif authToken == \"\" {\n\t\tpanic(\"firebase: authToken is empty\")\n\t}\n\trootURL = rootURL + \"/\"\n\tauthToken = authToken + \"/\"\n\tclient = &Client{\n\t\trootURL: rootURL,\n\t\tapi:    api,\n\t}\n}",
        "func (u *Url) Value() string {\n\tif u.path == \"\" {\n\t\treturn \"\"\n\t}\n\treturn u.path[len(u.path)-1]\n}",
        "func (p *Path) Child(name string) *Path {\n\tif p.IsRoot() {\n\t\treturn p\n\t}\n\treturn p.Path.Child(name)\n}",
        "func (r *Request) Push(key, value string) *Request {\n\tr.root.values[key] = value\n\treturn r\n}",
        "func (c *Client) Update(path string, value interface{}) error {\n\treturn c.do(\"PUT\", path, value, nil)\n}",
        "func (c *Client) Remove(path string) error {\n\treturn c.do(\"rm\", path, nil, nil)\n}",
        "func (db *Database) Rules() ([]Rule, error) {\n\tvar rules []Rule\n\terr := db.Select(&rules, `\n\t\tSELECT\n\t\t\tid,\n\t\t\tname,\n\t\t\tdescription,\n\t\t\taction,\n\t\t\tallow,\n\t\t\tdeny,\n\t\t\tresource_id,\n\t\t\tresource_type,\n\t\t\tresource_name,\n\t\t\tresource_policy_id,\n\t\t\tresource_policy_name,\n\t\t\tresource_policy_type,\n\t\t\tresource_policy_version,\n\t\t\tcreated_at,\n\t\t\tupdated_at,\n\t\t\tis_active,\n\t\t\tis_default,\n\t\t\tis_active_for_firewall,\n\t\t\tis_default_for_firewall,\n\t\t\tis_active_for_firewall_group,\n\t\t\tis_default_for_firewall_",
        "func (s *Server) SetRules(ctx context.Context, req *api.SdkSecuritySetRulesRequest, stream api.SdkSecuritySetRulesServerStream) error {\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceSecurityGroups, rbacpolicy.ActionSet, req.GetSecurityGroupName()); err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceSecurityGroups, rbacpolicy.ActionGet, req.GetSecurityGroupName()); err != nil {\n\t\treturn err\n\t}\n\n\tif len(req.GetRules()) == 0 {\n\t\treturn nil\n\t}\n\n\t// Get the existing security rules\n\texistingRules, err := s.GetRules(ctx, stream.Context(), req.GetSecurityGroupName())\n\tif err",
        "func (fb *Firebase) Call(method, path string, params url.Values, body interface{}) (*http.Response, error) {\n\treq, err := fb.Request(method, path, params, body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn fb.Client.Do(req)\n}",
        "func (t *Trace) SetTraceInfo(info *TraceInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.info = info\n}",
        "func (t *Trace) Finish() {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.state = traceStateFinish\n\tt.startTime = time.Now()\n}",
        "func ServeMetrics(l net.Listener) error {\n\treturn prometheus.Serve(prometheus.DefaultGatherer, l)\n}",
        "func (p *PrometheusReporter) DumpMetrics() string {\n\tp.mutex.Lock()\n\tdefer p.mutex.Unlock()\n\n\tbuf := &bytes.Buffer{}\n\tfor _, m := range p.metrics {\n\t\tfmt.Fprintf(buf, \"%s\\n\", m.String())\n\t}\n\treturn buf.String()\n}",
        "func NewEventLog(family, title string) *EventLog {\n\treturn &EventLog{\n\t\tfamily: family,\n\t\ttitle:  title,\n\t}\n}",
        "func (l *Logger) Printf(format string, args ...interface{}) {\n\tl.Emit(Event{\n\t\tLevel:  LevelInfo,\n\t\tMessage: fmt.Sprintf(format, args...),\n\t})\n}",
        "func (e *Event) Errorf(format string, args ...interface{}) {\n\te.Message = fmt.Sprintf(format, args...)\n\te.Level = ErrorLevel\n\te.Error()\n}",
        "func SetLogger(out io.Writer, prefix string, flag int) {\n\tlog.SetOutput(out)\n\tlog.SetPrefix(prefix)\n\tlog.SetFlags(flag)\n}",
        "func (c *Client) Trace(ctx context.Context, req *http.Request, el *log.Entry) {\n\tc.TraceWith(ctx, req, el, nil)\n}",
        "func TitleFromContext(ctx context.Context) string {\n\tt, ok := ctx.Value(titleKey).(string)\n\tif !ok {\n\t\tapiLog.Trace(\"No title found in context\")\n\t\treturn \"\"\n\t}\n\treturn t\n}",
        "func NewContext(ctx context.Context, family, title string) (context.Context, Trace) {\n\treturn context.WithValue(ctx, contextKey, traceKey{family, title})\n}",
        "func New(apiKey string) *Client {\n\treturn &Client{\n\t\tAPIKey: apiKey,\n\t\tHTTPClient: &http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\t\tInsecureSkipVerify: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n}",
        "func NewWithClient(key string, client *http.Client) *Client {\n\treturn &Client{\n\t\tKey:     key,\n\t\tHTTPClient: client,\n\t}\n}",
        "func (c *Client) Devices() ([]*Device, error) {\n\tvar devices []*Device\n\tif err := c.get(`device/list`, &devices); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn devices, nil\n}",
        "func (c *Client) Device(nickname string) (*Device, error) {\n\tvar device Device\n\terr := c.get(`device/list?nickname=`+nickname, &device)\n\treturn &device, err\n}",
        "func (c *Client) PushNote(deviceID, title, body string) error {\n\treturn c.PostJSON(\"/devices/\"+deviceID+\"/notes\", note{Title: title, Body: body})\n}",
        "func (c *Client) PushLink(deviceID, title, url string) error {\n\treturn c.Post(fmt.Sprintf(\"/devices/%s/links\", deviceID), &Link{Title: title, URL: url})\n}",
        "func (c *Client) PushSMS(deviceID, title, url string) error {\n\treturn c.Post(fmt.Sprintf(\"/devices/%s/sms\", deviceID), url, title, nil)\n}",
        "func (p *Pushbullet) Me() (*User, error) {\n\tresp, err := p.doRequest(\"me\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer closeResponseBody(resp)\n\tuser := &User{}\n\terr = json.NewDecoder(resp.Body).Decode(user)\n\treturn user, err\n}",
        "func (c *Client) Push(data interface{}) error {\n\treturn c.Request(\"POST\", \"/devices/push\", data, nil)\n}",
        "func (c *Client) PushNote(title, body string) error {\n\treturn c.Post(\"/notes\", &PushNote{Title: title, Body: body})\n}",
        "func (api *Client) PushNoteToChannel(channelID, title, body string) (*Channel, error) {\n\treturn api.PushNoteToChannelContext(context.Background(), channelID, title, body)\n}",
        "func (c *Client) PushLink(deviceID, title, url string) error {\n\treturn c.Post(\"device/push\", url, map[string]string{\"title\": title, \"device_id\": deviceID})\n}",
        "func (c *Client) PushLinkToChannel(channelID, title, url string) error {\n\treturn c.Post(fmt.Sprintf(\"channels/%s/links\", channelID), &PushLinkToChannelRequest{Title: title, URL: url})\n}",
        "func (api *Client) PushSMS(params *PushSMSParams) (*PushSMSResponse, error) {\n\treturn api.PushSMSContext(context.Background(), params)\n}",
        "func (c *Client) Subscription(channelTag string) (*Subscription, error) {\n\tvar subscription *Subscription\n\terr := c.get(`user/subscriptions?tag=`+channelTag, &subscription)\n\treturn subscription, err\n}",
        "func (api *Client) PushNote(channel, title, body string) error {\n\treturn api.PushNoteContext(context.Background(), channel, title, body)\n}",
        "func (api *Client) PushNote(channel, title, url, body string) error {\n\treturn api.PushNoteContext(context.Background(), channel, title, url, body)\n}",
        "func NewCachedLoader(namespace string, cache *Cache) Loader {\n\treturn &cachedLoader{\n\t\tnamespace: namespace,\n\t\tcache:     cache,\n\t}\n}",
        "func (c *ConsulBackend) Import(jsonBytes []byte, namespace string) error {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\n\tif c.client == nil {\n\t\treturn errors.New(\"consul backend is not initialized\")\n\t}\n\n\tif err := c.ensureNamespace(namespace); err != nil {\n\t\treturn err\n\t}\n\n\tif err := c.ensureKey(namespace); err != nil {\n\t\treturn err\n\t}\n\n\tif err := c.ensureValue(namespace); err != nil {\n\t\treturn err\n\t}\n\n\treturn c.client.KV().Put(c.key, jsonBytes, nil)\n}",
        "func (c *ConsulBackend) Initialize(namespace string) error {\n\tc.namespace = namespace\n\tc.client = c.clientset.CoreV1().KV()\n\treturn nil\n}",
        "func (c *Config) Get(key string) ([]byte, bool) {\n\tc.Lock()\n\tdefer c.Unlock()\n\tif b, ok := c.data[key]; ok {\n\t\treturn b, true\n\t}\n\treturn nil, false\n}",
        "func MustGetString(section, key string) string {\n\tvalue, err := Get(section, key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn value\n}",
        "func (c *Config) MustGetBool(key string) bool {\n\tval, err := c.GetBool(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn val\n}",
        "func (c *Config) MustGetInt(key string) int {\n\tval, err := c.GetInt(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn val\n}",
        "func MustGetDuration(key string) time.Duration {\n\tval, err := GetDuration(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn val\n}",
        "func NewRandomDNSBalancer(config *Config) (balancer.DNS, error) {\n\tif config == nil {\n\t\treturn nil, errors.New(\"consul: the configuration of the balancer is nil\")\n\t}\n\n\tif config.DNSService == \"\" {\n\t\treturn nil, errors.New(\"consul: DNS service is missing\")\n\t}\n\n\tif config.DNSAddress == \"\" {\n\t\treturn nil, errors.New(\"consul: DNS address is missing\")\n\t}\n\n\tif config.DNSPort == 0 {\n\t\tconfig.DNSPort = defaultDNSPort\n\t}\n\n\tif config.DNSTimeout == 0 {\n\t\tconfig.DNSTimeout = defaultDNSTimeout\n\t}\n\n\tif config.Client == nil {\n\t\tconfig.Client = consul.NewClient(config.DNSService, config.DNSAddress, config.DNSPort",
        "func (c *ConsulBackend) writeServiceToCache(svc *api.Service) error {\n\t// Lock the service for write\n\tkey := fmt.Sprintf(\"%s/%s\", c.config.Namespace, svc.ID)\n\tc.serviceLock.Lock(key)\n\tdefer c.serviceLock.Unlock(key)\n\n\t// Write the service to the cache\n\tif err := c.cache.Set(key, svc); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "func toLabels(param string) (labels mesos.Labels, err error) {\n\tif param == \"\" {\n\t\treturn\n\t}\n\tlabels = make(mesos.Labels, 0)\n\tfor _, param := range strings.Split(param, \",\") {\n\t\tkv := strings.Split(param, \"=\")\n\t\tif len(kv) != 2 {\n\t\t\terr = fmt.Errorf(\"invalid label format: %s\", param)\n\t\t\treturn\n\t\t}\n\t\tlabels[kv[0]] = kv[1]\n\t}\n\treturn\n}",
        "func (c *Clock) SetClockSeq(seq int) error {\n\tif seq < 0 || seq > 14 {\n\t\treturn errors.New(\"clock sequence must be between 0 and 14\")\n\t}\n\tc.seq = seq\n\treturn nil\n}",
        "func (dl *ConsoleLogger) Trace(message string, params ...interface{}) {\n\tdl.logger.Tracef(fmt.Sprintf(\"%s %s\", caller(), fmt.Sprint(message)), params...)\n}",
        "func (dl *ConsoleLogger) Debug(message string, params ...interface{}) {\n\tdl.logger.Debug(fmt.Sprintf(\"%s %s\", caller(), fmt.Sprint(message)), params...)\n}",
        "func (dl *ConsoleLogger) Info(message string, params ...interface{}) {\n\tdl.logger.Infof(fmt.Sprintf(\"%s %s\", caller(), fmt.Sprint(message)), params...)\n}",
        "func (dl *ConsoleLogger) Warn(message string, params ...interface{}) {\n\tdl.logger.Warnf(fmt.Sprintf(\"%s %s\", caller(), fmt.Sprintf(message, params...)), params...)\n}",
        "func (dl *ConsoleLogger) Error(message string, params ...interface{}) {\n\tdl.logger.Error(fmt.Sprintf(message, params...))\n}",
        "func (dl *ConsoleLogger) Critical(message string, params ...interface{}) {\n\tdl.logger.Criticalf(fmt.Sprintf(\"%s %s\", caller(), fmt.Sprint(message)), params...)\n}",
        "func (l *Link) Paste() (string, error) {\n\tif l.isEmpty() {\n\t\treturn \"\", nil\n\t}\n\treturn l.text, nil\n}",
        "func (t *TextArea) Paste(text string) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tt.paste(text)\n}",
        "func ExecAndWait(executor Executor, command string, args ...string) error {\n\treturn executor.Exec(command, args...)\n}",
        "func ExecutorName(name string) ExecutorOpt {\n\treturn func(c *Executor) { c.name = name }\n}",
        "func (c *Client) Exe(exe string) *Client {\n\tc.exe = exe\n\treturn c\n}",
        "func (s *Action) Args(args []string) *Action {\n\ts.args = args\n\treturn s\n}",
        "func (s *Sprocket) Dir(dir string) *Sprocket {\n\ts.dir = dir\n\treturn s\n}",
        "func (s *Server) Env(env []string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.env = env\n}",
        "func (s *Sensu) Writers(writers []string) *Sensu {\n\ts.writers = writers\n\treturn s\n}",
        "func StdoutWriter(w io.Writer) Option {\n\treturn func(o *Options) {\n\t\to.StdoutWriter = w\n\t}\n}",
        "func StdoutPrefix(prefix string) Option {\n\treturn func(c *Config) {\n\t\tc.StdoutPrefix = prefix\n\t}\n}",
        "func (s *Slog) StderrWriter(w io.Writer) *Slog {\n\ts.log.Output = w\n\treturn s\n}",
        "func StderrPrefix(prefix string) Option {\n\treturn func(c *Config) {\n\t\tc.StderrPrefix = prefix\n\t}\n}",
        "func (b *ExecStreamerBuilder) Build(c *fi.ModelBuilderContext) (*fi.ExecStreamer, error) {\n\tif b.IsMaster {\n\t\treturn nil, fmt.Errorf(\"cannot use master as a streamer\")\n\t}\n\n\tif b.IsMaster {\n\t\treturn nil, fmt.Errorf(\"cannot use master as a streamer\")\n\t}\n\n\tif b.IsMaster {\n\t\treturn nil, fmt.Errorf(\"cannot use master as a streamer\")\n\t}\n\n\tif b.IsMaster {\n\t\treturn nil, fmt.Errorf(\"cannot use master as a streamer\")\n\t}\n\n\tif b.IsMaster {\n\t\treturn nil, fmt.Errorf(\"cannot use master as a streamer\")\n\t}\n\n\tif b.IsMaster {\n\t\treturn nil, fmt.Errorf(\"",
        "func MakeWidget(name string, parent *Widget, parentID string, parentStyle *Style, widgetType WidgetType, widgetStyle *Style) *Widget {\n\treturn &Widget{\n\t\tName:         name,\n\t\tParent:       parent,\n\t\tParentID:     parentID,\n\t\tWidgetType:   widgetType,\n\t\tWidgetStyle:  widgetStyle,\n\t\tIsActive:     true,\n\t\tIsFocused:    true,\n\t\tIsSelected:   true,\n\t\tIsFocusedIn: true,\n\t\tIsSelectedIn: true,\n\t}\n}",
        "func (l *Label) SetText(text string) {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\tl.text = text\n}",
        "func (w *Window) AddLabel(label string) {\n\tw.AddWidget(w.label, 0, 0, 0, 0, LabelFlags(0))\n\tw.label.SetText(label)\n}",
        "func (b *backend) printf(format string, args ...interface{}) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tfmt.Fprintf(b.w, format, args...)\n}",
        "func (w *Window) setCell(x, y int, c Cell) {\n\tw.ctx.SetCell(x, y, c)\n}",
        "func (q *Queue) resize(x, y int) {\n\tif x < 0 || y < 0 || x >= q.maxx || y >= q.maxy {\n\t\treturn\n\t}\n\tq.maxx = x\n\tq.maxy = y\n}",
        "func (w *Window) render() {\n\tw.renderWidgets()\n\tw.layout()\n\tw.update()\n\tw.renderWidgets()\n}",
        "func (w *Widget) focusWidget(focus int) {\n\tif focus < 0 || focus >= len(w.widgets) {\n\t\tfocus = 0\n\t}\n\tw.widgets[focus].focus()\n}",
        "func (w *Widget) focusPrevious() {\n\tif len(w.widgets) > 0 {\n\t\tw.widgets[len(w.widgets)-1].focus()\n\t}\n}",
        "func (w *Widget) keyHandler(e *KeyEvent) {\n\tif e.Key == KeyEscape {\n\t\tw.Close()\n\t\treturn\n\t}\n\n\tif e.Key == KeyTab {\n\t\tw.tabKeyHandler(e)\n\t\treturn\n\t}\n\n\tif e.Key == KeyUp {\n\t\tw.upKeyHandler(e)\n\t\treturn\n\t}\n\n\tif e.Key == KeyDown {\n\t\tw.downKeyHandler(e)\n\t\treturn\n\t}\n\n\tif e.Key == KeyLeft {\n\t\tw.leftKeyHandler(e)\n\t\treturn\n\t}\n\n\tif e.Key == KeyRight {\n\t\tw.rightKeyHandler(e)\n\t\treturn\n\t}\n\n\tif e.Key == KeyEnter {\n\t\t",
        "func Color(color string) string {\n\tif color == \"\" {\n\t\treturn \"\"\n\t}\n\tif color == \"black\" {\n\t\treturn \"\\033[0m\"\n\t}\n\tif color == \"red\" {\n\t\treturn \"\\033[31m\"\n\t}\n\tif color == \"green\" {\n\t\treturn \"\\033[32m\"\n\t}\n\tif color == \"yellow\" {\n\t\treturn \"\\033[33m\"\n\t}\n\tif color == \"blue\" {\n\t\treturn \"\\033[34m\"\n\t}\n\tif color == \"magenta\" {\n\t\treturn \"\\033[35m\"\n\t}\n\tif color == \"cyan\" {\n\t\treturn \"\\033[36m\"\n\t}\n\treturn \"\"\n}",
        "func EscapedLen(s string) int {\n\tvar n int\n\tfor _, c := range s {\n\t\tif c == '\\\\' {\n\t\t\tn++\n\t\t}\n\t}\n\treturn n\n}",
        "func Unescape(s string) string {\n\tif len(s) == 0 {\n\t\treturn \"\"\n\t}\n\tif s[0] == '\\\\' {\n\t\treturn s[1 : len(s)-1]\n\t}\n\treturn s\n}",
        "func init() {\n\t// Set up the global variables.\n\tttk.Init()\n\tttk.SetLogger(log.New(os.Stderr, \"\", log.LstdFlags))\n\tttk.SetGlobalConfig(&Config{\n\t\tLogOutput: ttk.GetLogger(),\n\t})\n\tttk.SetGlobalConfig(&Config{\n\t\tLogOutput: ttk.GetLogger(),\n\t\tDebug:     false,\n\t})\n\tttk.SetGlobalConfig(&Config{\n\t\tLogOutput: ttk.GetLogger(),\n\t\tDebug:     false,\n\t})\n\tttk.SetGlobalConfig(&Config{\n\t\tLogOutput: ttk.GetLogger(),\n\t\tDebug:     false,\n\t})\n\tttk.SetGlobalConfig(&Config{\n\t\tLogOutput: ttk.GetLogger",
        "func (s *Server) initKeyHandler() {\n\ts.keyHandler = &keyHandler{\n\t\tserver: s,\n\t\tquit:   make(chan struct{}),\n\t}\n\ts.keyHandler.start()\n}",
        "func (t *Terminal) Init() error {\n\tif t.rawMode {\n\t\treturn nil\n\t}\n\n\tif err := t.rawMode = true; err != nil {\n\t\treturn err\n\t}\n\n\tif err := t.initManagedWindowMode(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "func (t *Terminal) Deinit() error {\n\tif err := t.init(); err != nil {\n\t\treturn err\n\t}\n\treturn t.term.Close()\n}",
        "func NewWindow(title string, x, y, width, height int, flags int, xtype int, x, y, width, height int, xmode int, ximage int, yimage int, ximagemode int, ximageimage int, titleimage string, titleimagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int, ximagemode int, titleimageimage int,",
        "func (w *Window) flush() {\n\tif w.ctx == nil {\n\t\treturn\n\t}\n\tw.ctx.flush()\n}",
        "func (w *Window) focus() {\n\tif w.focus == nil {\n\t\treturn\n\t}\n\tw.focus()\n\tw.render()\n\tw.flush()\n}",
        "func resizeAndRender(w *Window, width, height int) {\n\tw.Resize(width, height)\n\tw.Render()\n}",
        "func (t *Terminal) Panic(v ...interface{}) {\n\tt.Deinit()\n\tt.terminal.Write([]byte(\"PANIC\\n\"))\n\tfmt.Fprintln(t.terminal, v...)\n\tos.Exit(1)\n}",
        "func (t *Terminal) Exit(code int) {\n\tt.deinit()\n\tos.Exit(code)\n}",
        "func (w *Window) AddList(list *List) {\n\tw.AddWidget(list.widget)\n\tlist.widget.SetFocus(true)\n\tlist.widget.SetFocusTarget(w)\n\tlist.widget.SetFocusCallback(func(xu *xgbutil.XUtil, win xproto.Window,\n\t\tevent xproto.Event, _ int, _ int) {\n\t\tlist.focus(xu)\n\t})\n}",
        "func (l *LineList) Append(text string) {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\tl.items = append(l.items, text)\n}",
        "func (q *Queue) Focus() {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\tq.focus = true\n}",
        "func (ed *Edit) SetText(text string, end bool) {\n\tif ed.edit != nil {\n\t\ted.edit.SetText(text, end)\n\t}\n}",
        "func (w *Window) AddEdit(capacity int, width int) *Edit {\n\treturn w.AddWidget(w.editQueue.AddEdit(capacity, width))\n}",
        "func (c *Client) Auth(username, password string) *AuthService {\n\tc.username = username\n\tc.password = password\n\tc.path = \"/auth\"\n\treturn c\n}",
        "func (s *Session) Start() error {\n\tif s.started {\n\t\treturn nil\n\t}\n\n\ts.started = true\n\n\tif s.client == nil {\n\t\treturn trace.BadParameter(\"no client provided\")\n\t}\n\n\tif s.client.Service() == \"\" {\n\t\treturn trace.BadParameter(\"no service provided\")\n\t}\n\n\tif s.client.Version() == 0 {\n\t\treturn trace.BadParameter(\"no version provided\")\n\t}\n\n\tif s.client.AuthInfo() == nil {\n\t\treturn trace.BadParameter(\"no auth info provided\")\n\t}\n\n\tif s.client.AuthInfo().Username == \"\" {\n\t\treturn trace.BadParameter(\"no username provided\")\n\t}\n\n\tif s.client.AuthInfo().Password == \"\" {\n\t\treturn",
        "func (c *Client) FetchEntity(i Identifiable) (*Identifiable, error) {\n\tif i.ID() == \"\" {\n\t\treturn nil, errors.New(\"missing ID\")\n\t}\n\n\tpath := fmt.Sprintf(\"/entities/%s\", i.ID())\n\tresp, err := c.Get(path, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"Unexpected response code %d - expected %d\", resp.StatusCode, http.StatusOK)\n\t}\n\n\tvar e Identifiable\n\tif err := decodeBody(resp, &e); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &e, nil\n}",
        "func (c *Client) SaveEntity(i Identifiable) error {\n\treturn c.PutJSON(\"/entities\", i.ToJSON())\n}",
        "func (c *Client) DeleteEntity(i Identifiable) error {\n\treturn c.DeleteEntityContext(context.Background(), i)\n}",
        "func (c *Client) FetchChildren(ctx context.Context, identity *identity.Identity) ([]Identity, error) {\n\tvar children []Identity\n\terr := c.fetch(ctx, \"/identity/\"+identity.String()+\"/children\", &children)\n\treturn children, err\n}",
        "func (c *Client) CreateChild(parent Identifiable) (*Child, error) {\n\treq, err := c.NewRequest(\"POST\", \"/identities\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Body = parent\n\n\tres, err := c.DoRequest(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode != http.StatusCreated {\n\t\treturn nil, fmt.Errorf(\"Unexpected response code %d - expected %d\", res.StatusCode, http.StatusCreated)\n\t}\n\n\tchild := &Child{}\n\terr = json.NewDecoder(res.Body).Decode(child)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn child, nil\n}",
        "func (c *Client) AssignChildren(parent Identifiable, childIDs []string) error {\n\tif parent == nil {\n\t\treturn errors.New(\"parent is nil\")\n\t}\n\tif len(childIDs) == 0 {\n\t\treturn errors.New(\"at least one child ID is required\")\n\t}\n\tif parent.GetType() != IdentifiableType {\n\t\treturn errors.New(\"parent is not an Identifiable\")\n\t}\n\tpath := fmt.Sprintf(\"/identifiable/%s/children\", parent.GetID())\n\tresp, err := c.Post(path, nil, childIDs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\treturn nil\n}",
        "func (c *Client) NextEvent() (*Event, error) {\n\tvar event Event\n\terr := c.get(c.Endpoint(\"events\"), &event)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &event, nil\n}",
        "func (id *Identity) String() string {\n\treturn fmt.Sprintf(\"%s@%s\", id.User, id.Host)\n}",
        "func NewPushCenter(client *http.Client, baseURL string) *PushCenter {\n\treturn &PushCenter{\n\t\tclient: client,\n\t\tbaseURL: baseURL,\n\t}\n}",
        "func (m *Manager) RegisterHandlerForIdentity(identity *identity.Identity, handler EventHandler) {\n\tm.handlerLock.Lock()\n\tdefer m.handlerLock.Unlock()\n\n\tif _, ok := m.handlers[identity.String()]; ok {\n\t\tpanic(\"handler for identity already registered\")\n\t}\n\tm.handlers[identity.String()] = handler\n}",
        "func (c *Client) UnregisterHandlerForIdentity(identity string, handler EventHandler) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\n\tc.unregisterHandlerForIdentity(identity, handler)\n}",
        "func (m *HandlerManager) HasHandlerForIdentity(identity string) bool {\n\tm.RLock()\n\tdefer m.RUnlock()\n\treturn m.hasIdentityHandler(identity)\n}",
        "func (p *PushCenterImpl) Start() error {\n\tp.Lock()\n\tdefer p.Unlock()\n\n\tif p.started {\n\t\treturn nil\n\t}\n\n\tp.started = true\n\n\tp.logger.Info(\"Starting Push Center\")\n\n\tp.client, err := p.createClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.subscriptions = make(map[string]*subscription)\n\n\tgo p.handleSubscriptions()\n\n\treturn nil\n}",
        "func (p *PushCenter) Stop() {\n\tp.Lock()\n\tdefer p.Unlock()\n\n\tif !p.running {\n\t\treturn\n\t}\n\n\tp.running = false\n\tclose(p.quit)\n\tp.wg.Wait()\n}",
        "func (c *Client) Logger() *log.Logger {\n\tif c.logger == nil {\n\t\tc.logger = log.New(os.Stderr, \"\", log.LstdFlags)\n\t}\n\treturn c.logger\n}",
        "func (f FetchingInfo) String() string {\n\treturn fmt.Sprintf(\"{FetchType: %v, FetchID: %v, FetchSize: %v, FetchTime: %v}\", f.FetchType, f.FetchID, f.FetchSize, f.FetchTime)\n}",
        "func NewClient(url string, opts ...ClientOption) (*Client, error) {\n\tclient := &Client{\n\t\tURL: url,\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(client); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif client.URL == \"\" {\n\t\treturn nil, errors.New(\"missing API URL\")\n\t}\n\n\tif client.HTTPClient == nil {\n\t\tclient.HTTPClient = http.DefaultClient\n\t}\n\n\treturn client, nil\n}",
        "func (c *Client) Post(ctx context.Context, snapshot *dto.MetricsSnapshot) error {\n\treturn c.post(ctx, snapshot)\n}",
        "func MetricID(name string, tags map[string]string) string {\n\treturn fmt.Sprintf(\"%s-%s\", name, strings.Join(tags, \"-\"))\n}",
        "func SplitMetricID(id string) (name string, tags map[string]string) {\n\tparts := strings.Split(id, \"-\")\n\tif len(parts) == 2 {\n\t\tname = parts[0]\n\t\ttags = make(map[string]string)\n\t\tfor _, tag := range parts[1:] {\n\t\t\ttags[strings.TrimSpace(tag)] = \"\"\n\t\t}\n\t}\n\treturn\n}",
        "func NewRateScale(unit time.Duration, rate float64) *Rate {\n\treturn &Rate{\n\t\tunit:    unit,\n\t\trate:    rate,\n\t\tlast:    time.Now(),\n\t\tlastSet: time.Now(),\n\t}\n}",
        "func (c *Counter) Snapshot() int64 {\n\tc.mtx.Lock()\n\tdefer c.mtx.Unlock()\n\treturn c.snapshot()\n}",
        "func NewDeriveScale(unit time.Duration) *Derive {\n\treturn &Derive{\n\t\tbase: base{\n\t\t\tunit: unit,\n\t\t\tfreq: make(map[time.Duration]float64),\n\t\t},\n\t}\n}",
        "func (r *Rate) Update(prev float64) {\n\tif prev < r.Min || prev > r.Max {\n\t\tr.Min = r.Max\n\t\tr.Max = prev\n\t}\n}",
        "func (d *Distribution) Snapshot() *Distribution {\n\treturn &Distribution{\n\t\tID:          d.ID,\n\t\tName:        d.Name,\n\t\tType:        d.Type,\n\t\tVersion:     d.Version,\n\t\tCreatedAt:   d.CreatedAt,\n\t\tUpdatedAt:   d.UpdatedAt,\n\t\tStatus:      d.Status,\n\t\tDescription: d.Description,\n\t\tData:        d.Data,\n\t\tTags:        d.Tags,\n\t}\n}",
        "func (s *Store) Update(key string, value interface{}) error {\n\treturn s.db.Update(func(tx *bolt.Tx) error {\n\t\treturn s.update(tx, key, value)\n\t})\n}",
        "func (s *Snapshot) Snapshot() (interface{}, error) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\treturn s.value, nil\n}",
        "func New() *Registry {\n\treturn &Registry{\n\t\tm:          make(map[string]*registryEntry),\n\t\tflushQueue: make(chan struct{}),\n\t}\n}",
        "func (r *Registry) Subscribe(rpt Reporter) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.reporters = append(r.reporters, rpt)\n}",
        "func (r *Registry) Get(name string) (instrument, error) {\n\tr.m.Lock()\n\tdefer r.m.Unlock()\n\tif instrument, ok := r.instruments[name]; ok {\n\t\treturn instrument, nil\n\t}\n\treturn nil, fmt.Errorf(\"instrument %s not registered\", name)\n}",
        "func Register(name string, instrument Instrument) {\n\tif _, ok := instruments[name]; ok {\n\t\tpanic(fmt.Sprintf(\"instrument %s already registered\", name))\n\t}\n\tinstruments[name] = instrument\n}",
        "func (r *Registry) Fetch(name string, factory InstrumentFactory) (instrument.Instrument, error) {\n\tr.m.Lock()\n\tdefer r.m.Unlock()\n\n\tif instrument, ok := r.instruments[name]; ok {\n\t\treturn instrument, nil\n\t}\n\n\tinstrument, err := factory()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tr.instruments[name] = instrument\n\treturn instrument, nil\n}",
        "func (r *Registry) Size() int {\n\tr.mtx.RLock()\n\tdefer r.mtx.RUnlock()\n\treturn len(r.instruments)\n}",
        "func (g *Registry) Tags() map[string]string {\n\tg.mu.RLock()\n\tdefer g.mu.RUnlock()\n\treturn g.tags\n}",
        "func (c *Client) SetTags(tags map[string]string) error {\n\tif c.BestAPIVersion() < 5 {\n\t\treturn errors.New(\"set tags is not supported by this version of Juju\")\n\t}\n\targs := params.SetTags{\n\t\tTags: make([]params.Tag, len(tags)),\n\t}\n\tfor i, tag := range tags {\n\t\targs.Tags[i].Key = tag\n\t\targs.Tags[i].Value = tag\n\t}\n\treturn c.facade.FacadeCall(\"SetTags\", args, nil)\n}",
        "func (c *Client) AddTags(tags map[string]string) error {\n\treturn c.post(c.Endpoint(\"tags\"), tags, nil)\n}",
        "func (r *Reporter) Close() error {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif r.closed {\n\t\treturn nil\n\t}\n\n\tr.closed = true\n\n\tfor _, reporter := range r.reporters {\n\t\tif err := reporter.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}",
        "func New(opts ...Option) *Reporter {\n\tr := &Reporter{\n\t\tlogger: log.New(os.Stderr, \"[reporter] \", log.LstdFlags),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(r)\n\t}\n\n\treturn r\n}",
        "func (r *Reporter) Metric(name string, v interface{}) error {\n\tif v == nil {\n\t\treturn fmt.Errorf(\"cannot append a metric to a nil value\")\n\t}\n\n\tswitch v.(type) {\n\tcase int64:\n\t\tr.metrics = append(r.metrics, &metric{\n\t\t\tname: name,\n\t\t\tval:  v.(int64),\n\t\t})\n\tcase float64:\n\t\tr.metrics = append(r.metrics, &metric{\n\t\t\tname: name,\n\t\t\tval:  v.(float64),\n\t\t})\n\tdefault:\n\t\treturn fmt.Errorf(\"cannot append a metric to a non-integer or non-float value %T\", v)\n\t}\n\n\treturn nil\n}",
        "func (t *Table) FilterBefore(key []byte, args ...interface{}) ([]Row, error) {\n\treturn t.filterBefore(key, false, args...)\n}",
        "func (e *Env) Set(key, value string) {\n\te.Lock()\n\tdefer e.Unlock()\n\te.data[key] = value\n}",
        "func (env *Env) SetStr(key, val string) {\n\tenv.Set(key, val)\n}",
        "func (env *Env) Get(key string) string {\n\tif env == nil {\n\t\treturn \"\"\n\t}\n\treturn os.Getenv(key)\n}",
        "func (e Env) String() string {\n\tvar buf bytes.Buffer\n\tfor k, v := range e {\n\t\tbuf.WriteString(fmt.Sprintf(\"%s=%s\\n\", k, v))\n\t}\n\treturn buf.String()\n}",
        "func (s *Set) Add(value interface{}) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\ts.values[value] = struct{}{}\n}",
        "func (s *Set) AddAll(values ...interface{}) {\n\tfor _, value := range values {\n\t\ts.Add(value)\n\t}\n}",
        "func (s *Set) Remove(value interface{}) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tdelete(s.items, value)\n}",
        "func (s *Set) RemoveAll() {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\n\tfor k := range s.m {\n\t\tdelete(s.m, k)\n\t}\n}",
        "func (s *Set) Contains(value interface{}) bool {\n\t_, ok := s.m[value]\n\treturn ok\n}",
        "func (s *Set) ContainsAll(values ...interface{}) bool {\n\tfor _, v := range values {\n\t\tif !s.Contains(v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}",
        "func (s *Set) ContainsFunc(f func(interface{}) bool) bool {\n\tfor _, item := range s.items {\n\t\tif f(item) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
        "func (s *Set) Clear() {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\ts.items = make(map[interface{}]struct{})\n}",
        "func (s *Set) Iterator() Iterator {\n\treturn &setIterator{\n\t\ts: s,\n\t\tit: s.s.Iterator(),\n\t}\n}",
        "func (s *Set) Items() []interface{} {\n\titems := make([]interface{}, 0, len(s.items))\n\tfor _, item := range s.items {\n\t\tif item != nil {\n\t\t\titems = append(items, item)\n\t\t}\n\t}\n\treturn items\n}",
        "func (s *Set) ItemsFunc(f func(interface{}) bool) []interface{} {\n\titems := make([]interface{}, 0, len(s.items))\n\tfor k := range s.items {\n\t\tif f(k) {\n\t\t\titems = append(items, k)\n\t\t}\n\t}\n\treturn items\n}",
        "func (h *Holiday) Celebrate(day time.Weekday) bool {\n\tif day == time.Sunday {\n\t\treturn h.Friday\n\t}\n\tif day == time.Monday {\n\t\treturn h.Saturday\n\t}\n\treturn false\n}",
        "func (c *Client) GetHolidays(countryCode, year string) ([]Holiday, error) {\n\tvar holidays []Holiday\n\tpath := fmt.Sprintf(\"/country/%s/year/%s/holiday\", countryCode, year)\n\terr := c.Get(path, &holidays)\n\treturn holidays, err\n}",
        "func (c *Config) GetInt(key string) int {\n\ti, _ := c.GetIntOk(key)\n\treturn i\n}",
        "func (c *Config) GetFloat(key string) float64 {\n\tvalue, _ := c.Get(key).(float64)\n\treturn value\n}",
        "func (c *Config) GetBool(key string) (bool, error) {\n\tval, ok := c.Get(key)\n\tif !ok {\n\t\treturn false, nil\n\t}\n\n\tb, err := strconv.ParseBool(val)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn b, nil\n}",
        "func (c *Client) Exists(key string) (bool, error) {\n\tresp, err := c.client.Get(c.endpoint + \"/keys/\" + key)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer resp.Body.Close()\n\treturn resp.StatusCode == http.StatusOK, nil\n}",
        "func (c *Config) getValue(key string) (string, bool) {\n\tif v, ok := c.data[key]; ok {\n\t\treturn v, true\n\t}\n\treturn \"\", false\n}",
        "func Load(ctx *cli.Context) error {\n\tif ctx.GlobalIsSet(ConfigFlag.Name) {\n\t\treturn loadConfig(ctx.GlobalString(ConfigFlag.Name))\n\t}\n\n\tif ctx.GlobalIsSet(ConfigEnvFlag.Name) {\n\t\treturn loadConfig(ctx.GlobalString(ConfigEnvFlag.Name))\n\t}\n\n\treturn loadConfig(os.Getenv(ConfigEnvFlag.Name))\n}",
        "func checkConfigLocation() error {\n\tif configLocation == \"\" {\n\t\tconfigLocation = os.Getenv(\"CONFIG\")\n\t}\n\tif configLocation == \"\" {\n\t\tconfigLocation = os.Getenv(\"PROPERTIES\")\n\t}\n\tif configLocation == \"\" {\n\t\treturn fmt.Errorf(\"No config or properties file specified\")\n\t}\n\treturn nil\n}",
        "func New(filename []string, utf8 bool) *Reader {\n\treturn &Reader{\n\t\tfilename: filename,\n\t\tutf8:    utf8,\n\t\tbuf:     make([]byte, 0, 4096),\n\t}\n}",
        "func readMimetypeText(filename string) (map[string]string, error) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\treturn readMimetypeTextFromReader(f)\n}",
        "func (m *Mimetype) Get() string {\n\tif m.mimetype != \"\" {\n\t\treturn m.mimetype\n\t}\n\tif m.Source == \"\" {\n\t\treturn \"\"\n\t}\n\treturn mime.TypeByExtension(filepath.Ext(m.Source))\n}",
        "func SetHeader(w http.ResponseWriter, extension string) {\n\tw.Header().Set(\"Content-Type\", mime.TypeByExtension(extension))\n}",
        "func GetFileSize(path string) (int64, error) {\n\tfi, err := os.Stat(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn fi.Size(), nil\n}",
        "func (s *Server) ListenAndServe() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif s.server != nil {\n\t\treturn errors.New(\"server already running\")\n\t}\n\n\ts.server = &http.Server{\n\t\tAddr:         s.Addr,\n\t\tHandler:      s.Handler,\n\t\tReadTimeout:  s.ReadTimeout,\n\t\tWriteTimeout: s.WriteTimeout,\n\t\tTLSConfig:    s.TLSConfig,\n\t}\n\n\tif s.TLSConfig != nil {\n\t\ts.server.TLSConfig = s.TLSConfig\n\t}\n\n\tif s.TLSConfig != nil {\n\t\ts.server.TLSConfig.InsecureSkipVerify = s.TLSConfig.InsecureSkipVerify\n\t}\n\n\tif s.TLSConfig != nil {",
        "func (c *Client) SendRequest(method string, args interface{}, replyHandler func(interface{}, error)) error {\n\treturn c.SendRequestAsync(method, args, replyHandler).Receive()\n}",
        "func (c *Client) SendRequestArr(method string, params []interface{}, id int, resHandler func(*Response) error) error {\n\treturn c.SendRequest(method, params, id, \"jsonrpc\", \"2.0\", resHandler)\n}",
        "func (s *Server) Close() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif s.listener != nil {\n\t\treturn s.listener.Close()\n\t}\n\treturn nil\n}",
        "func (s *Server) wsHandler(wsConn net.Conn) {\n\tdefer wsConn.Close()\n\tfor {\n\t\t// Read the next message from the websocket connection.\n\t\tvar msg []byte\n\t\tif err := websocket.Message.Receive(wsConn, &msg); err != nil {\n\t\t\ts.logger.Printf(\"[ERR] consul: Failed to read from websocket: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Handle the message.\n\t\tif err := s.handleMessage(msg); err != nil {\n\t\t\ts.logger.Printf(\"[ERR] consul: Failed to handle message: %v\", err)\n\t\t\treturn\n\t\t}\n\t}\n}",
        "func SafeCreateS3Bucket(ctx context.Context, client *s3manager.S3Manager, bucket string) error {\n\t// Create the bucket\n\terr := client.CreateBucket(bucket)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create the s3 client\n\tclient, err = s3manager.NewS3Client(client.AccessKey, client.SecretKey, client.SessionToken, client.Endpoint)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "func (s3) NewWriter(bucket, object string) (io.WriteCloser, error) {\n\treturn s3.NewWriterWithContext(context.Background(), bucket, object)\n}",
        "func (s3Client *S3Client) NewReader(bucketName, objectName string) (io.ReadCloser, error) {\n\treturn s3Client.NewReaderWithContext(context.Background(), bucketName, objectName)\n}",
        "func (s3Store *S3Store) Delete(bucket string) error {\n\treturn s3Store.client.DeleteBucket(bucket)\n}",
        "func (c *Conn) CertAtuh(cert *tls.Certificate) error {\n\tif c.conn == nil {\n\t\treturn errors.New(\"connection is closed\")\n\t}\n\treturn c.conn.SetTLSClientCert(cert)\n}",
        "func (r *Request) Params(obj interface{}) error {\n\tif r.err != nil {\n\t\treturn r.err\n\t}\n\n\tif r.params == nil {\n\t\tr.params = make(url.Values)\n\t}\n\n\tfor k, v := range r.params {\n\t\tif v == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.HasPrefix(k, \"X-\") {\n\t\t\tk = strings.TrimPrefix(k, \"X-\")\n\t\t\tv = strings.TrimPrefix(v, \"X-\")\n\t\t}\n\n\t\tif strings.HasPrefix(k, \"Content-Type-\") {\n\t\t\tk = strings.TrimPrefix(k, \"Content-Type-\")\n\t\t\tv = strings.TrimPrefix(v, \"Content-Type-\")\n\t",
        "func (m *Middleware) Next(ctx context.Context) error {\n\tfor i := len(m.middleware) - 1; i >= 0; i-- {\n\t\tif err := m.middleware[i](ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "func (r *Response) Result(obj interface{}) error {\n\tif r.err != nil {\n\t\treturn r.err\n\t}\n\n\tif r.body == nil {\n\t\treturn errors.New(\"no body\")\n\t}\n\n\tif r.statusCode >= 400 {\n\t\treturn errors.New(fmt.Sprintf(\"HTTP %d\", r.statusCode))\n\t}\n\n\tif r.statusCode < 200 || r.statusCode >= 300 {\n\t\treturn errors.New(fmt.Sprintf(\"HTTP %d\", r.statusCode))\n\t}\n\n\tif err := json.NewDecoder(r.body).Decode(obj); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "func (r *Response) ErrorData(obj interface{}) error {\n\tif r.err != nil {\n\t\treturn r.err\n\t}\n\tif r.statusCode >= 400 {\n\t\treturn errors.New(r.Status)\n\t}\n\tif r.statusCode < 200 || r.statusCode >= 300 {\n\t\treturn errors.New(fmt.Sprintf(\"Invalid status code: %d\", r.statusCode))\n\t}\n\tif r.statusCode == 204 {\n\t\treturn nil\n\t}\n\tif r.statusCode == 409 {\n\t\treturn errors.New(fmt.Sprintf(\"Conflict: %s\", r.Status))\n\t}\n\tif r.statusCode == 412 {\n\t\treturn errors.New(fmt.Sprintf(\"Request Entity Too Large: %s\", r.Status))\n\t}\n\tif r.statusCode == 4",
        "func MiddlewareList(mw []Middleware) func(http.Handler) http.Handler {\n\treturn func(h http.Handler) http.Handler {\n\t\tfor _, m := range mw {\n\t\t\th = m(h)\n\t\t}\n\t\treturn h\n\t}\n}",
        "func LogFactory(logLevel string) func(msg string, args ...interface{}) {\n\treturn func(msg string, args ...interface{}) {\n\t\tlog.Printf(\"[%s] %s\", logLevel, msg)\n\t}\n}",
        "func NewRouter(c *Config) *Router {\n\tr := &Router{\n\t\tconfig: c,\n\t\tmux:    http.NewServeMux(),\n\t}\n\n\tr.mux.HandleFunc(\"/\", r.handleIndex)\n\tr.mux.HandleFunc(\"/api/v1/\", r.handleAPIV1)\n\tr.mux.HandleFunc(\"/api/v2/\", r.handleAPIV2)\n\tr.mux.HandleFunc(\"/api/v3/\", r.handleAPIV3)\n\tr.mux.HandleFunc(\"/api/v4/\", r.handleAPIV4)\n\tr.mux.HandleFunc(\"/api/v5/\", r.handleAPIV5)\n\tr.mux.HandleFunc(\"/api/v6/\", r.",
        "func (r *Router) Request(pattern string, handler http.HandlerFunc) {\n\tr.addRoute(pattern, handler, http.MethodGet, \"/*\")\n}",
        "func (n *Neptulon) Middleware(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tn.ServeHTTPC(w, r, h)\n\t})\n}",
        "func (r *Response) NotFound() {\n\tr.Status = http.StatusNotFound\n\tr.Type = \"text/plain\"\n\tr.Body = []byte(\"Not Found\")\n}",
        "func NewMysqlDump(dbName string, host string, port int, user string, password string, sslMode string, sslCert string, sslKey string, sslCA string, sslVerify bool) (*MysqlDump, error) {\n\tdb, err := sql.Open(\"mysql\", fmt.Sprintf(\"host=%s port=%d user=%s password=%s sslmode=%s sslcert=%s sslkey=%s sslca=%s sslverify=%s\", host, port, user, password, sslMode, sslCert, sslKey, sslCA, sslVerify))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &MysqlDump{\n\t\tdb: db,\n\t}, nil\n}",
        "func NewRemoteMysqlDump(addr string, user string, password string, host string, port int, dbname string, sslmode string, sslcert string, sslkey string, sslca string) (*RemoteMysqlDump, error) {\n\tconn, err := mysql.Dial(\"tcp\", addr, user, password, host, port, dbname, sslmode, sslcert, sslkey, sslca)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &RemoteMysqlDump{conn: conn}, nil\n}",
        "func (mysqld *Mysqld) Import(reader io.Reader) error {\n\t// Read header\n\theader, err := mysqld.readHeader(reader)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Read rows\n\trows, err := mysqld.readRows(reader)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Write header\n\tif err := mysqld.writeHeader(header, rows); err != nil {\n\t\treturn err\n\t}\n\n\t// Write rows\n\tif err := mysqld.writeRows(rows, header); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "func (mysqld *Mysqld) Dump(writer io.Writer, query string) error {\n\tconn, err := getPoolReconnect(mysqld.dbaPool)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer conn.Recycle()\n\n\treturn conn.Dump(writer, query)\n}",
        "func NewRemoteExecutor(ssh *ssh.Client, sshConfig *ssh.ClientConfig) (Executor, error) {\n\tif sshConfig == nil {\n\t\tsshConfig = &ssh.ClientConfig{}\n\t}\n\n\tif sshConfig.User == \"\" {\n\t\treturn nil, fmt.Errorf(\"user is missing\")\n\t}\n\n\tif sshConfig.Host == \"\" {\n\t\treturn nil, fmt.Errorf(\"host is missing\")\n\t}\n\n\tif sshConfig.Port == 0 {\n\t\tsshConfig.Port = 22\n\t}\n\n\tif sshConfig.Timeout == 0 {\n\t\tsshConfig.Timeout = 30 * time.Second\n\t}\n\n\tif sshConfig.Auth == nil {\n\t\tsshConfig.Auth = []ssh.AuthMethod{ssh.PublicKeys(sshConfig.User)}\n\t}\n\n\tif sshConfig.Host",
        "func (c *CopyCommand) Execute(args []string, stdout, stderr io.Writer) error {\n\tcmd := exec.Command(c.Command, args...)\n\tcmd.Stdout = stdout\n\tcmd.Stderr = stderr\n\treturn cmd.Run()\n}",
        "func World(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, world!\")\n}",
        "func Name(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\tw.Write([]byte(\"Hello, world!\"))\n}",
        "func NewPgDump(ctx context.Context, fs afero.Fs, path string) (*PgDump, error) {\n\treturn &PgDump{\n\t\tfs:     fs,\n\t\tpath:   path,\n\t\tentries: make(map[string]*pgdumpEntry),\n\t\tctx:    ctx,\n\t}, nil\n}",
        "func NewPgRemoteDump(ctx context.Context, pgdumpPath string, pgdumpUser string, pgdumpPass string, pgdumpHost string, pgdumpPort int, pgdumpTimeout int, pgdumpLogPath string, pgdumpLogUser string, pgdumpLogPass string, pgdumpLogHost string, pgdumpLogPort int, pgdumpLogTimeout int, pgdumpLogTag string) (*PgRemoteDump, error) {\n\tif pgdumpTimeout <= 0 {\n\t\tpgdumpTimeout = pgdumpDefaultTimeout\n\t}\n\tif pgdumpLogPath == \"\" {\n\t\tpgdumpLogPath = pgdumpDefaultLogPath\n\t}\n\tif pgdumpLogUser == \"\" {\n\t\tpgdumpLogUser = pgdumpDefaultLogUser\n\t}\n\tif pgdumpPass == \"\" {\n\t\tpgdumpPass = pgdumpDefaultPass\n\t}\n\tif pgdumpHost == \"\"",
        "func Import(pgdmpFile string) (*pgdmp.Reader, error) {\n\tpgdmpFile = strings.TrimPrefix(pgdmpFile, pgdmpPrefix)\n\tpgdmpFile = strings.Replace(pgdmpFile, \"\\\\\", \"/\", -1)\n\tpgdmpFile = strings.Replace(pgdmpFile, \"/\", \"_\", -1)\n\tpgdmpFile = strings.Replace(pgdmpFile, \"\\\\\", \"/\", -1)\n\tpgdmpFile = strings.Replace(pgdmpFile, \"/\", \"_\", -1)\n\tpgdmpFile = strings.Replace(pgdmpFile, \"\\\\\", \"/\", -1)\n\tpgdmpFile = strings.Replace(pgdmpFile, \"/\", \"_\", -1)\n\tpgdmpFile = strings.Replace(pgdmpFile, \"\\\\\",",
        "func New(text string) *IrcText {\n\treturn &IrcText{\n\t\tText: text,\n\t\tUser: &User{\n\t\t\tNick: \"Nobody\",\n\t\t},\n\t}\n}",
        "func (gc *GuiContext) SetFg(r, g, b uint8) {\n\tgc.current.Fg = r\n\tgc.current.Fg = g\n\tgc.current.Fg = b\n}",
        "func (p *Panel) SetBg(color tcell.Color) *Panel {\n\tp.bg = color\n\treturn p\n}",
        "func HandlerBuilder(h Handler) func(*Handler) {\n\treturn func(h *Handler) {\n\t\th.handler = h\n\t}\n}",
        "func LoggerWithPrefix(prefix string) Logger {\n\treturn func(l *log.Logger) {\n\t\tl.Out = append(l.Out, prefix...)\n\t}\n}",
        "func NewEncoder(w io.Writer) *Encoder {\n\treturn &Encoder{\n\t\tw:   w,\n\t\tbuf: make([]byte, defaultBufSize),\n\t}\n}",
        "func (m *MimeMap) Parser(mime string) (Parser, error) {\n\tp, ok := m.parsers[mime]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no parser for mime %s\", mime)\n\t}\n\treturn p, nil\n}",
        "func (m *MimeMap) Responder(mime string) Responder {\n\tif m.responders == nil {\n\t\treturn nil\n\t}\n\treturn m.responders[mime]\n}",
        "func NewErrorStatus(s string) error {\n\tswitch s {\n\tcase \"OK\":\n\t\treturn nil\n\tcase \"OK_NO_DATA\":\n\t\treturn ErrNoData\n\tcase \"OK_NOT_FOUND\":\n\t\treturn ErrNoNotFound\n\tcase \"OK_INVALID_REQUEST\":\n\t\treturn ErrInvalidRequest\n\tcase \"OK_INTERNAL_SERVER_ERROR\":\n\t\treturn ErrInvalidInternalServerError\n\tcase \"OK_INVALID_REQUEST_OR_TOKEN\":\n\t\treturn ErrInvalidRequestOrToken\n\tcase \"OK_INVALID_REQUEST\":\n\t\treturn ErrInvalidRequest\n\tcase \"OK_INVALID_TOKEN\":\n\t\treturn ErrInvalidToken\n\tcase \"OK_INVALID_CLIENT\":\n\t\treturn ErrInvalidClient\n\tcase \"OK_INVALID_SERVICE\":\n\t\treturn ErrInvalidService\n\tcase \"OK_INVALID_VERSION\":\n\t\treturn ErrInvalidVersion\n\tcase",
        "func ConvertErrorStatus(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif e, ok := err.(*ErrorStatus); ok {\n\t\treturn e\n\t}\n\treturn &ErrorStatus{\n\t\tMessage: err.Error(),\n\t\tCode:    int(err.Error()),\n\t}\n}",
        "func (r *Reader) Read(p []byte) (n int, err error) {\n\tif r.err != nil {\n\t\treturn 0, r.err\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif r.pos >= len(r.buf) {\n\t\tr.err = io.EOF\n\t\treturn 0, r.err\n\t}\n\tn = copy(p, r.buf[r.pos:])\n\tr.pos += n\n\treturn\n}",
        "func (b *Block) EntryLength() int {\n\tif b.Entry == nil {\n\t\treturn 0\n\t}\n\treturn len(b.Entry)\n}",
        "func NewLager(name string, level Level, format string, v ...interface{}) *Lager {\n\tl := &Lager{\n\t\tname:   name,\n\t\tlevel:  level,\n\t\tformat: format,\n\t\tv:     v,\n\t}\n\treturn l\n}",
        "func (c *Context) URLParts(path string) ([]string, error) {\n\tparts := strings.Split(path, \"/\")\n\tc.URLPartsN = len(parts)\n\treturn parts, nil\n}",
        "func (c *Context) URLPart(url string) string {\n\tif part := c.URLPartNoCache(url); part != \"\" {\n\t\treturn part\n\t}\n\treturn c.URLPart(url)\n}",
        "func (c *Context) StoreParam(key string, value interface{}) {\n\tc.params[key] = value\n}",
        "func GetParam(ctx context.Context, name string) string {\n\tif p, ok := ctx.Value(paramKey).(string); ok {\n\t\treturn p\n\t}\n\treturn \"\"\n}",
        "func (p *Params) Int32(name string) (int32, error) {\n\tif v, ok := p.m[name]; ok {\n\t\treturn v.(int32), nil\n\t}\n\treturn 0, errors.New(ErrInvalidParam, errorMessages, name, \"int32\")\n}",
        "func (p *Params) UInt(name string) (uint, error) {\n\tif v, ok := p.m[name]; ok {\n\t\treturn v.(uint), nil\n\t}\n\treturn 0, fmt.Errorf(\"param %s is not a uint\", name)\n}",
        "func (p *Params) UInt32(name string) (uint32, error) {\n\tif v, ok := p.m[name]; ok {\n\t\treturn v.(uint32), nil\n\t}\n\treturn 0, fmt.Errorf(\"param %s is not a uint32\", name)\n}",
        "func (p *Params) Float32(name string) (float32, error) {\n\tif f, ok := p.Float64(name); ok {\n\t\treturn f, nil\n\t}\n\treturn 0, fmt.Errorf(\"param %s is not a float32\", name)\n}",
        "func (c Client) UploadFile(bucketName, objectName, fileName string, reader io.Reader) (UploadID, error) {\n\t// Input validation.\n\tif err := s3utils.CheckValidBucketName(bucketName); err != nil {\n\t\treturn UploadID{}, err\n\t}\n\tif err := s3utils.CheckValidObjectName(objectName); err != nil {\n\t\treturn UploadID{}, err\n\t}\n\tif err := s3utils.CheckValidFileName(fileName); err != nil {\n\t\treturn UploadID{}, err\n\t}\n\n\t// Get the bucket.\n\tbucket, err := c.GetBucket(bucketName)\n\tif err != nil {\n\t\treturn UploadID{}, err\n\t}\n\n\t// Get the object.\n\tobject, err := bucket.GetObject(objectName)\n\tif err != nil",
        "func (c *Client) RemoveRemoteFile(path string) (io.WriteCloser, error) {\n\treturn c.RemoveFile(path)\n}",
        "func (c Client) GetRemoteFile(path string) (io.WriteCloser, error) {\n\treturn c.getRemoteFile(path, \"GET\")\n}",
        "func NewConn(conn net.Conn, opts ...ConnOption) *Conn {\n\tc := &Conn{\n\t\tconn: conn,\n\t}\n\tfor _, opt := range opts {\n\t\topt(c)\n\t}\n\treturn c\n}",
        "func (c *Conn) RemoteAddr() net.Addr {\n\tif c.remoteAddr != nil {\n\t\treturn c.remoteAddr\n\t}\n\treturn c.conn.RemoteAddr()\n}",
        "func (c *Client) SendRequest(method string, args interface{}, replyHandler func(interface{}, error)) error {\n\treturn c.SendRequestAsync(method, args, replyHandler).Receive()\n}",
        "func (c *Client) SendRequestArr(method string, params []interface{}, id int, resHandler func(*Response) error) error {\n\treturn c.SendRequest(method, params, id, resHandler, true)\n}",
        "func (c *Conn) Close() error {\n\tif c.conn != nil {\n\t\treturn c.conn.Close()\n\t}\n\treturn nil\n}",
        "func (c *Conn) SendResponse(resp interface{}) error {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\n\tif c.closed {\n\t\treturn ErrConnClosed\n\t}\n\n\tif c.isClosed {\n\t\treturn ErrConnClosed\n\t}\n\n\tif c.isOpen {\n\t\treturn ErrConnOpen\n\t}\n\n\t// Encode the response.\n\tb, err := json.Marshal(resp)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Write the message to the connection.\n\tif _, err := c.conn.Write(b); err != nil {\n\t\treturn err\n\t}\n\n\t// Increment the connection id.\n\tc.id++\n\n\treturn nil\n}",
        "func (c *Conn) Send(msg *Message) error {\n\tif c.closed {\n\t\treturn ErrClosed\n\t}\n\n\tif msg.Type == \"\" {\n\t\treturn ErrType\n\t}\n\n\tif msg.ID == \"\" {\n\t\treturn ErrID\n\t}\n\n\tif msg.Body == nil {\n\t\treturn ErrBody\n\t}\n\n\tif msg.Type == \"text\" {\n\t\treturn c.sendText(msg)\n\t}\n\n\treturn c.sendBinary(msg)\n}",
        "func (c *Conn) Receive() ([]byte, error) {\n\tif c.closed {\n\t\treturn nil, ErrClosed\n\t}\n\n\tif c.readTimeout > 0 {\n\t\tc.conn.SetReadDeadline(time.Now().Add(c.readTimeout))\n\t}\n\n\tif c.readTimeout == 0 {\n\t\tc.readTimeout = defaultReadTimeout\n\t}\n\n\tbuf, err := c.conn.Read(c.readBuffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(buf) == 0 {\n\t\treturn nil, io.EOF\n\t}\n\n\treturn buf, nil\n}",
        "func (c *Conn) Reuse() error {\n\tif c.wsConn != nil {\n\t\treturn c.wsConn.Close()\n\t}\n\treturn c.wsConn.Connect()\n}",
        "func (c *Client) startReceive() {\n\tc.receiveLock.Lock()\n\tdefer c.receiveLock.Unlock()\n\n\tif c.receiveRunning {\n\t\treturn\n\t}\n\n\tc.receiveRunning = true\n\tgo c.receiveLoop()\n}",
        "func ReadPbo(path string) (*Pbo, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\treturn ReadPboFromReader(f)\n}",
        "func NewReadWriteCloser(r io.ReadCloser, w io.WriteCloser) *ReadWriteCloser {\n\treturn &ReadWriteCloser{\n\t\tr:   r,\n\t\tw:   w,\n\t\tclosed: false,\n\t}\n}",
        "func (r *reader) Read(p []byte) (n int, err error) {\n\tif r.err != nil {\n\t\treturn 0, r.err\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif r.pos >= len(r.buf) {\n\t\tr.err = io.EOF\n\t\treturn 0, r.err\n\t}\n\tn = copy(p, r.buf[r.pos:])\n\tr.pos += n\n\treturn n, nil\n}",
        "func (w *Writer) Write(p []byte) (n int, err error) {\n\tif w.closed {\n\t\treturn 0, errors.New(\"write to closed writer\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif w.buf.Len() >= w.bufCap {\n\t\tw.buf.Grow(w.bufCap * 2)\n\t}\n\tw.buf.Write(p)\n\treturn len(p), nil\n}",
        "func SafeRemoveSSH(client *ssh.Client, path string) error {\n\t_, err := client.Exec(\"rm -f \" + path)\n\treturn err\n}",
        "func SafeCreateSSH(path string, client *ssh.Client) error {\n\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n\t\treturn err\n\t}\n\tif err := client.Create(path, os.Stdin, 0); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "func SafeCreate(path string, mode os.FileMode) error {\n\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n\t\treturn err\n\t}\n\treturn os.MkdirAll(filepath.Dir(filepath.Dir(path)), 0755)\n}",
        "func (c *Client) HMAC(method, path string, data []byte) (*Context, error) {\n\treturn c.HMACContext(method, path, data, nil)\n}",
        "func Scaffold(router *mux.Router, platorm *platorm.Platorm) {\n\trouter.Methods(\"POST\").Path(\"/api/v1/routes\").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tvar req struct {\n\t\t\tName string `json:\"name\"`\n\t\t}\n\t\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\t\thttp.Error(w, \"Invalid JSON\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tif err := platorm.CreateRoute(req.Name, req.Handler); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.WriteHeader(http.StatusCreated)\n\t})",
        "func (p *Pettern) Route(method, path string) *mux.Route {\n\treturn p.router.Route(method, path)\n}",
        "func (r *Router) Group(pattern string, fn func(*Router)) {\n\tr.group(pattern, fn, r.root)\n}",
        "func Platform(pattern string, handler http.HandlerFunc) {\n\tpattern = strings.TrimPrefix(pattern, \"/v1/platform/\")\n\tpattern = strings.Replace(pattern, \"/\", \"-\", -1)\n\tpattern = strings.Replace(pattern, \"/v1/platform/\", \"\", -1)\n\tpattern = strings.Replace(pattern, \"/v1/platform/\", \"/platform/\", -1)\n\tpattern = strings.Replace(pattern, \"/v1/platform/\", \"/platform/\", -1)\n\tpattern = strings.Replace(pattern, \"/v1/platform/\", \"/platform/\", -1)\n\tpattern = strings.Replace(pattern, \"/v1/platform/\", \"/platform/\", -1)\n\tpattern = strings.Replace(pattern, \"/v1/platform/\", \"/platform/\", -1)\n\tpattern = strings.Replace(pattern",
        "func (m *Mux) Handle(pattern string, handler http.Handler) {\n\tm.HandleFunc(pattern, handler)\n}",
        "func (r *Router) Options(pattern string, handler http.HandlerFunc) {\n\tr.Handle(\"OPTIONS\", pattern, handler)\n}",
        "func (r *Route) Use(middleware ...Middleware) *Route {\n\tr.middleware = append(r.middleware, middleware...)\n\treturn r\n}",
        "func (r *Route) NotFound(handler http.Handler) *Route {\n\tr.handlers[\"GET\"] = handler\n\treturn r\n}",
        "func (h *Handler) AddHandlerBuilder(b HandlerBuilder) {\n\th.handlers = append(h.handlers, b)\n}",
        "func (h *DefaultErrorHandler) ServeErrorPage(w http.ResponseWriter, req *http.Request, err error) {\n\th.ServeError(w, req, err)\n}",
        "func GetErrorHandler(ctx context.Context) error {\n\tif handler, ok := ctx.Value(errorHandlerKey).(errorHandler); ok {\n\t\treturn handler\n\t}\n\treturn defaultErrorHandler\n}",
        "func SetErrorHandler(handler ErrorHandler) Middleware {\n\treturn func(h http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\t\tif err := handler(rw, r); err != nil {\n\t\t\t\tlog.Printf(\"[ERROR] %s\", err)\n\t\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\t}\n\t\t})\n\t}\n}",
        "func SetErrorHandlerFunc(f func(rw http.ResponseWriter, r *http.Request, err error)) Middleware {\n\treturn func(h http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\t\tif err != nil {\n\t\t\t\tf(rw, r, err)\n\t\t\t} else {\n\t\t\t\th.ServeHTTP(rw, r)\n\t\t\t}\n\t\t})\n\t}\n}",
        "func (c *Client) Echo(ctx context.Context, msg *Message) error {\n\treturn c.send(ctx, msg, \"echo\")\n}",
        "func (a *ConfigArg) UnmarshalBinary(b []byte) error {\n\tif len(b) < 1 {\n\t\treturn io.ErrUnexpectedEOF\n\t}\n\n\t// Check for valid config string length.\n\tif len(b) > 1024 {\n\t\treturn ErrorBadArgumentParameter\n\t}\n\n\t// Copy the config string into a new slice.\n\tc := make([]byte, len(b))\n\tcopy(c, b)\n\n\t// Parse the config string.\n\terr := a.UnmarshalText(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "func ataIdentify(rs *rpcServer, r *rpcIdentifyRequest) (*rpcIdentifyResponse, error) {\n\t// Make sure the caller has the right permissions to access the resource.\n\tif !rs.srv.Auth.AccessResource(r.ResourceID, r.ResourceType) {\n\t\treturn nil, rpcPermissionDenied\n\t}\n\n\t// Make sure the caller has the right permissions to access the resource.\n\tif !rs.srv.Auth.AccessResource(r.ResourceID, r.ResourceType) {\n\t\treturn nil, rpcPermissionDenied\n\t}\n\n\t// Make sure the caller has the right permissions to access the resource.\n\tif !rs.srv.Auth.AccessResource(r.ResourceID, r.ResourceType) {\n\t\treturn nil, rpcPermissionDenied\n\t}\n\n\t// Make the request.\n\tid, err := rs",
        "func ataRead(rs io.ReadCloser, r *ataRequest) error {\n\tif r.size < 0 {\n\t\treturn fmt.Errorf(\"ata: invalid size: %d\", r.size)\n\t}\n\tif r.offset < 0 {\n\t\treturn fmt.Errorf(\"ata: invalid offset: %d\", r.offset)\n\t}\n\n\t// If the ATA header is not present, we need to read the header.\n\tif _, err := rs.Seek(0, 0); err != nil {\n\t\treturn err\n\t}\n\tif _, err := rs.Seek(r.offset, 0); err != nil {\n\t\treturn err\n\t}\n\n\t// Read the ATA header.\n\tif _, err := rs.Seek(0, 0); err != nil {\n\t\treturn err\n\t}\n\tif",
        "func ataWrite(rs io.ReadWriter, r *ataRequest) error {\n\tif r.size < 0 {\n\t\treturn fmt.Errorf(\"ata: size must be >= 0\")\n\t}\n\tif r.size > maxATASize {\n\t\treturn fmt.Errorf(\"ata: size %d is larger than maxATASize\", r.size)\n\t}\n\tif r.flags&ataWriteFlag != 0 {\n\t\treturn fmt.Errorf(\"ata: cannot write to a non-zero value\")\n\t}\n\tif r.flags&ataWriteRepeatFlag != 0 {\n\t\treturn fmt.Errorf(\"ata: cannot write to a non-zero value\")\n\t}\n\tif r.flags&ataWriteDataFlag != 0 {\n\t\treturn fmt.Errorf(\"ata: cannot write to a non-zero value\")\n\t}\n\tif r.",
        "func calculateLBA(lba []uint64, arg *TAAArg) (uint64, error) {\n\tif len(lba) != 48 {\n\t\treturn 0, fmt.Errorf(\"invalid LBA length: %d\", len(lba))\n\t}\n\n\t// The first 48 bits of the LBA are the block address.\n\treturn lba[0]<<56 | lba[1]<<48 | lba[2]<<40 | lba[3]<<32 | lba[4]<<24, nil\n}",
        "func (r *ReserveReleaseArg) MarshalBinary() ([]byte, error) {\n\tif len(r.MACs) != len(r.MACs) {\n\t\treturn nil, ErrorBadArgumentParameter(\"NMACs\", len(r.MACs), len(r.MACs))\n\t}\n\n\tb := buffer.New(nil)\n\n\tfor i, mac := range r.MACs {\n\t\tif _, err := b.Write(mac[:]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b.Data(), nil\n}",
        "func (a *ReserveReleaseArg) UnmarshalBinary(p []byte) error {\n\tb := buffer.New(p)\n\t// Ensure the length is correct\n\tif b.Len() != 4 {\n\t\treturn io.ErrUnexpectedEOF\n\t}\n\n\t// Check for a valid hardware address\n\th := HardwareAddr(b.Read32())\n\tif h == HardwareAddr(0) {\n\t\treturn io.ErrUnexpectedEOF\n\t}\n\n\t// Check for a valid release number\n\tr := b.Read32()\n\tif r != a.Release {\n\t\treturn io.ErrUnexpectedEOF\n\t}\n\n\t// Set the hardware address\n\ta.HardwareAddr = h\n\n\t// Set the release number\n\ta.Release = r\n\n\treturn nil\n}",
        "func (a ATAArg) MarshalBinary() ([]byte, error) {\n\tb := buffer.New(nil)\n\n\tb.Write8(uint8(a.Type))\n\tb.WriteBytes(a.Key)\n\tb.WriteBytes(a.Value)\n\n\treturn b.Data(), nil\n}",
        "func New(db *sqlx.DB) *Fixture {\n\treturn &Fixture{\n\t\tdb: db,\n\t}\n}",
        "func FromYAML(data []byte) (*Fixture, error) {\n\tvar fixture Fixture\n\tif err := yaml.Unmarshal(data, &fixture); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &fixture, nil\n}",
        "func FromJSON(data []byte) (*Fixture, error) {\n\tvar fixture Fixture\n\terr := json.Unmarshal(data, &fixture)\n\treturn &fixture, err\n}",
        "func (d *Directive) MarshalBinary() ([]byte, error) {\n\tif len(d.MAC) != 6 {\n\t\treturn nil, ErrorBadArgumentParameter(\"mac\", d.MAC, \"expected 6 bytes\")\n\t}\n\n\tb := buffer.New(nil)\n\tb.Write16(uint16(d.Type))\n\tb.WriteBytes(d.MAC)\n\n\treturn b.Data(), nil\n}",
        "func (m MACMaskArg) MarshalBinary() ([]byte, error) {\n\tif m.DirCount == 0 {\n\t\treturn nil, errors.New(\"macmask: dir count must be > 0\")\n\t}\n\n\tb := buffer.New(nil)\n\n\tfor _, d := range m.Directives {\n\t\tif err := d.MarshalBinary(b); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b.Data(), nil\n}",
        "func NewSendToLogger(name string, level Level, format string, v ...interface{}) *SendToLogger {\n\treturn &SendToLogger{\n\t\tLogger: log.New(os.Stdout, name, level),\n\t\tFormat: format,\n\t\tv:      v,\n\t}\n}",
        "func NewMulti(name string, level Level, format string, timestampFormat string, timestampFormatType TimestampFormatType, fields ...Field) *MultiLog {\n\treturn &MultiLog{\n\t\tname:             name,\n\t\tlevel:            level,\n\t\tformat:           format,\n\t\ttimestampFormat: timestampFormat,\n\t\ttimestampFormatType: timestampFormatType,\n\t\tfields:           fields,\n\t}\n}",
        "func (l *Log) outerLog(nem *Nem) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tif len(l.backLogs) == 0 {\n\t\treturn\n\t}\n\tl.backLogs[0].Nem = nem\n}",
        "func (c *ContainerServer) PublishPort(ctx context.Context, containerID, portName string, port int) error {\n\treturn c.Publish(ctx, containerID, portName, port)\n}",
        "func (c *Container) Name(name string) *Container {\n\tc.name = name\n\treturn c\n}",
        "func (c *Container) AddArgs(args ...string) *Container {\n\tc.args = append(c.args, args...)\n\treturn c\n}",
        "func NewCORSHandler() *CORSHandler {\n\treturn &CORSHandler{\n\t\tAllowHeaders:     []string{\"*\"},\n\t\tAllowMethods:     []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"},\n\t\tAllowCredentials: true,\n\t\tAllowOrigin:      []string{\"*\"},\n\t\tMaxAge:           -1,\n\t\tMaxAgeInSeconds: -1,\n\t\tAllowCredentials: true,\n\t\tAllowHeaders:     []string{\"*\"},\n\t\tAllowMethods:     []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"},\n\t\tAllowOrigin:      []string{\"*\"},\n\t\tAllowCredentials: true,\n\t\tAllowHeaders:     []string{\"*\"},\n\t\tAllowOrigin:      []string{\"*\"},\n\t\tMaxAgeInSeconds: -1,\n\t\t",
        "func CreatePreflight(router *mux.Router) {\n\trouter.HandleFunc(\"/preflight/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tw.Write([]byte(\"OK\"))\n\t})\n}",
        "func (h *preflightHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\th.mu.Lock()\n\tdefer h.mu.Unlock()\n\n\tif h.err != nil {\n\t\treturn\n\t}\n\n\tif h.isPreflight {\n\t\th.next.ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\t// If the request is a GET, we need to check if the request is\n\t// a HEAD request.\n\tif r.Method == \"HEAD\" {\n\t\tif h.isPreflight {\n\t\t\th.next.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\t// If the request is a HEAD request, we need to check if the\n\t\t// request is a GET request.\n\t\tif h.isGet {\n\t\t\t",
        "func (c CORSableAPI) Handle(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == \"OPTIONS\" {\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t\tw.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, OPTIONS\")\n\t\tw.Header().Set(\"Access-Control-Max-Age\", \"3600\")\n\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\t\tw.Header().Set(\"Access-Control-Expose-Headers\", \"Content-Length\")\n\t\tw.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\t\tw.Header().Set(\"Access-Control-Allow-Credentials-Token\", c.Token)\n\t\treturn\n\t}\n\n",
        "func NewRandomSourceListSecure(seed int64) *RandomSourceList {\n\treturn &RandomSourceList{\n\t\trand: rand.New(rand.NewSource(seed)),\n\t}\n}",
        "func (w *Writer) Handle(r *Record) error {\n\tif w.closed {\n\t\treturn errors.New(\"writer is closed\")\n\t}\n\n\tif w.maxMessageSize < 0 {\n\t\treturn errors.New(\"maxMessageSize must be >= 0\")\n\t}\n\n\tif w.maxMessageSize > MaxMessageSize {\n\t\tw.maxMessageSize = MaxMessageSize\n\t}\n\n\tif w.maxMessageSize == 0 {\n\t\treturn nil\n\t}\n\n\tif w.maxMessageSize < len(r.Message) {\n\t\tw.maxMessageSize = len(r.Message)\n\t}\n\n\tif w.maxMessageSize > MaxMessageSize {\n\t\tw.maxMessageSize = MaxMessageSize\n\t}\n\n\tif w.maxMessageSize == 0 {\n\t\treturn nil\n",
        "func (w *Writer) Close() error {\n\tif w.writer == nil {\n\t\treturn nil\n\t}\n\treturn w.writer.Close()\n}",
        "func (c *Carbon) Date(v reflect.Value) (interface{}, error) {\n\treturn c.DateFunc(v, c.MinDate, c.MaxDate)\n}",
        "func Match(s string) (string, bool) {\n\tfor i := 0; i < len(s); i++ {\n\t\tr, size := utf8.DecodeRuneInString(s[i:])\n\t\tif r == utf8.RuneError && i+size < len(s) {\n\t\t\treturn \"\", false\n\t\t}\n\t\tif r == utf8.RuneError {\n\t\t\treturn \"\", false\n\t\t}\n\t}\n\treturn s, true\n}",
        "func Match(s string) (string, bool) {\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif c == '.' {\n\t\t\treturn s[:i], true\n\t\t}\n\t\tif c == '*' {\n\t\t\treturn s[:i], true\n\t\t}\n\t}\n\treturn \"\", false\n}",
        "func (c *C) MatchRune(r rune) bool {\n\treturn mather.MatchRune(c.s, r)\n}",
        "func (m *Matcher) Match(s string) bool {\n\treturn m.match(s, false)\n}",
        "func (db *DB) Alloc() error {\n\tif db.open {\n\t\treturn nil\n\t}\n\tif err := db.open(); err != nil {\n\t\treturn err\n\t}\n\tdb.open = true\n\treturn nil\n}",
        "func (db *DB) Free() error {\n\tif db.closed {\n\t\treturn ErrClosed\n\t}\n\tdb.mu.Lock()\n\tdefer db.mu.Unlock()\n\tif db.refcount == 0 {\n\t\treturn ErrClosed\n\t}\n\tdb.refcount--\n\tif db.refcount == 0 {\n\t\tif err := db.close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "func (l *Logger) Infof(format string, v ...interface{}) {\n\tl.send(LevelInfo, 2, fmt.Sprintf(format, v...))\n}",
        "func (l *Logger) Warningf(format string, v ...interface{}) {\n\tl.send(LevelWarning, fmt.Sprintf(format, v...))\n}",
        "func (n *LevelLogger) Errorf(format string, v ...interface{}) {\n\tn.mu.Lock()\n\tn.logger.Output(callDepth, fmt.Sprintf(format, v...))\n\tn.mu.Unlock()\n}",
        "func (l *Logger) Fatalf(format string, v ...interface{}) {\n\tl.output(LCritical, format, v...)\n\tos.Exit(1)\n}",
        "func ToPhone(number string) string {\n\tif len(number) == 0 {\n\t\treturn \"\"\n\t}\n\tif number[0] == '+' {\n\t\tnumber = number[1:]\n\t}\n\tnumber = strings.Replace(number, \" \", \"\", -1)\n\tnumber = strings.Replace(number, \"0\", \"\", -1)\n\tnumber = strings.Replace(number, \" \", \"\", -1)\n\tnumber = strings.Replace(number, \"-\", \"\", -1)\n\tnumber = strings.Replace(number, \"/\", \"\", -1)\n\tnumber = strings.Replace(number, \" \", \"\", -1)\n\tnumber = strings.Replace(number, \" \", \"\", -1)\n\tnumber = strings.Replace(number, \" \", \"\", -1)\n\tnumber = strings.Replace(number, \" \", \"\", -1)\n\tnumber =",
        "func ToURL(s string) string {\n\tif strings.HasPrefix(s, \"http://\") || strings.HasPrefix(s, \"https://\") {\n\t\treturn s\n\t}\n\treturn \"http://\" + s\n}",
        "func ToSSN(s string) SSN {\n\tif len(s) == 0 {\n\t\treturn SSN(\"\")\n\t}\n\tif len(s) == 1 {\n\t\treturn SSN(s[0])\n\t}\n\tif len(s) == 2 {\n\t\treturn SSN(s[0]) + SSN(s[1])\n\t}\n\tif len(s) == 3 {\n\t\treturn SSN(s[0]) + SSN(s[1]) + SSN(s[2])\n\t}\n\treturn SSN(\"\")\n}",
        "func ToMorseCode(s string) string {\n\tif len(s) == 0 {\n\t\treturn \"\"\n\t}\n\tif len(s) == 1 {\n\t\treturn s\n\t}\n\tif len(s) == 2 {\n\t\treturn s[:2] + s[3:]\n\t}\n\tif len(s) == 3 {\n\t\treturn s[:3] + s[4:]\n\t}\n\treturn s\n}",
        "func ToPirateSpeak(s string) string {\n\tif len(s) == 0 {\n\t\treturn \"\"\n\t}\n\tif len(s) == 1 {\n\t\treturn s\n\t}\n\tif len(s) == 2 {\n\t\treturn s + \" \" + s[1]\n\t}\n\treturn s\n}",
        "func ToIRSA(s string) string {\n\tvar (\n\t\tout []byte\n\t\ti    int\n\t\tn    int\n\t\tc    = 0\n\t\tm    = len(s)\n\t\ts    = []rune(s)\n\t)\n\n\tfor i < m {\n\t\tif s[i] == ' ' {\n\t\t\tc++\n\t\t}\n\t\tif s[i] == '\\t' {\n\t\t\tc++\n\t\t}\n\t\tif c == 0 {\n\t\t\tout = append(out, s[i])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif c == 1 {\n\t\t\tout = append(out, s[i])\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif c == 2 {\n\t\t\tout = append(",
        "func newDefaultLogger() *Logger {\n\treturn &Logger{\n\t\tName:        \"default\",\n\t\tLevel:       DEBUG,\n\t\tOutput:      os.Stdout,\n\t\tDisableColor: true,\n\t\tHandler:     defaultHandler,\n\t}\n}",
        "func Logf(format string, args ...interface{}) {\n\tDefaultLogger.Logf(format, args...)\n}",
        "func (f *File) Sections() []*Section {\n\tsections := make([]*Section, 0, len(f.sections))\n\tfor _, section := range f.sections {\n\t\tsections = append(sections, section)\n\t}\n\treturn sections\n}",
        "func (c *ConfigParser) Options(section string) []string {\n\tif c.data == nil {\n\t\treturn nil\n\t}\n\treturn c.data[section]\n}",
        "func (c *ConfigParser) OptionMap(section string) map[string]string {\n\tm := make(map[string]string)\n\tfor _, opt := range c.options[section] {\n\t\tm[opt.Name] = opt.Value\n\t}\n\treturn m\n}",
        "func (f *File) Comments(section string) []*Comment {\n\tif section == \"\" {\n\t\treturn f.CommentsFile()\n\t}\n\treturn f.comments[section]\n}",
        "func (s *Section) AddComments(comment *Comment) {\n\ts.comments = append(s.comments, comment)\n}",
        "func Parse(r io.Reader) (*Config, error) {\n\tvar config Config\n\tif err := config.read(r); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &config, nil\n}",
        "func (ini *INI) Write(w io.Writer) error {\n\t// Write section header\n\tif err := ini.writeSectionHeader(w); err != nil {\n\t\treturn err\n\t}\n\n\t// Write options\n\tfor _, option := range ini.options {\n\t\tif err := ini.writeOption(w, option); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Write section footer\n\tif err := ini.writeSectionFooter(w); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}",
        "func (ini *INI) Get(section, key string) string {\n\tif s, ok := ini.data[section]; ok {\n\t\tif k, ok := s[key]; ok {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn \"\"\n}",
        "func (s *Section) Set(key, value string) {\n\tif s.options == nil {\n\t\ts.options = make(map[string]string)\n\t}\n\ts.options[key] = value\n}",
        "func (c *ConfigParser) Delete(section, option string) {\n\tc.data.Delete(section, option)\n}",
        "func tryConvert(value interface{}, targetType interface{}) {\n\tswitch targetType.Kind() {\n\tcase reflect.Ptr:\n\t\tif value == nil {\n\t\t\treturn\n\t\t}\n\t\tvalue = value.Elem()\n\tcase reflect.Interface:\n\t\tvalue = tryConvert(value.Interface(), targetType.Elem())\n\tcase reflect.Map:\n\t\tvalue = tryConvert(value.(map[string]interface{}), targetType.Elem())\n\tcase reflect.Slice:\n\t\tvalue = tryConvert(value.([]interface{}), targetType.Elem())\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tvalue = tryConvert(value.(int), targetType.Elem())\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect",
        "func (c *Client) postponeExpiration(ctx context.Context, key string) error {\n\treturn c.postpone(ctx, key, time.Now().Add(c.lifetime))\n}",
        "func (l *Ledis) Filter(r *Rules) *Filter {\n\treturn &Filter{\n\t\trules: r,\n\t\tl:     l,\n\t}\n}",
        "func (p *Path) Op(field string, value interface{}) *Path {\n\treturn p.OpEq(field, value, opEqual)\n}",
        "func (p *Policy) ApplyRuleIf(rule string, condition bool) bool {\n\tif condition {\n\t\treturn p.ApplyRule(rule)\n\t}\n\treturn true\n}",
        "func ApplyRuleIfElse(rule *Rule, condition bool) {\n\tif condition {\n\t\tApplyRule(rule)\n\t} else {\n\t\tApplyRuleElse(rule)\n\t}\n}",
        "func AuthHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !auth.CheckRequest(r) {\n\t\t\tauth.SendError(w, r, errors.New(\"Unauthorized\"))\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}",
        "func HasBin() bool {\n\t_, err := exec.LookPath(\"docker\")\n\treturn err == nil\n}",
        "func (c *ExternalCmd) Run(args []string) error {\n\tcmd := exec.Command(c.Command, args...)\n\tcmd.Env = append(os.Environ(), c.Env...)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tcmd.Stdin = os.Stdin\n\tcmd.Dir = c.Dir\n\tcmd.Env = append(os.Environ(), c.Env...)\n\tcmd.Env = append(cmd.Env, c.Env...)\n\tcmd.Env = append(cmd.Env, c.Env...)\n\tcmd.Env = append(cmd.Env, c.Env...)\n\tcmd.Env = append(cmd.Env, c.Env...)\n\tcmd.Env = append(cmd.Env, c.Env...)\n\tcmd.Env = append(cmd.Env, c.Env...)\n\tcmd",
        "func (h *Header) GetReader(r *http.Request) (io.ReadCloser, error) {\n\treturn h.GetReaderWithContext(context.Background(), r)\n}",
        "func (h *Header) SetName(name string) {\n\th.Lock()\n\tdefer h.Unlock()\n\th.name = name\n}",
        "func (h *Header) SetValue(value string) {\n\th.Lock()\n\tdefer h.Unlock()\n\th.value = value\n}",
        "func (h *Header) SetWriter(w http.ResponseWriter) {\n\th.Lock()\n\tdefer h.Unlock()\n\tw.Header().Set(h.key, h.value)\n}",
        "func encryptionKey(e *Entity) (Key, error) {\n\tif e.IsPrivate() {\n\t\treturn nil, errors.New(\"cannot encrypt private entity\")\n\t}\n\n\t// Find the key that we can use for encryption.\n\tvar bestKey Key\n\tfor _, k := range e.Keys() {\n\t\tif k.IsPrivate() {\n\t\t\tcontinue\n\t\t}\n\t\tif bestKey == nil {\n\t\t\tbestKey = k\n\t\t} else if k.Compare(bestKey) < 0 {\n\t\t\tbestKey = k\n\t\t}\n\t}\n\n\treturn bestKey, nil\n}",
        "func NewContentNegotiator(encoders ...Encoder) *ContentNegotiator {\n\treturn &ContentNegotiator{\n\t\tencoders:  encoders,\n\t\tsupported: make(map[string]bool),\n\t}\n}",
        "func NewJsonXmlContentNegotiator(encoder runtime.Encoder, jsonContent []byte) *ContentNegotiator {\n\treturn &ContentNegotiator{\n\t\tEncoder:   encoder,\n\t\tjsonContent: jsonContent,\n\t\txmlContent:  xmlContent,\n\t}\n}",
        "func Negotiate(w http.ResponseWriter, r *http.Request) {\n\taccept := r.Header.Get(\"Accept\")\n\tif accept == \"\" {\n\t\treturn\n\t}\n\tif strings.Contains(accept, \"json\") {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\tif strings.Contains(accept, \"text\") {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\tif strings.Contains(accept, \"xml\") {\n\t\tw.Header().Set(\"Content-Type\", \"application/xml\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n",
        "func (m *MimetypeRegistry) AddEncoder(mimetype string, encoder Encoder) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.encoders[mimetype] = encoder\n}",
        "func getEncoder(accept string) (httpstream.Encoder, error) {\n\tif accept == \"\" {\n\t\treturn nil, nil\n\t}\n\tif strings.HasPrefix(accept, \"application/json\") {\n\t\treturn json.NewEncoder(os.Stdout), nil\n\t}\n\tif strings.HasPrefix(accept, \"application/xml\") {\n\t\treturn xml.NewEncoder(os.Stdout), nil\n\t}\n\treturn nil, fmt.Errorf(\"unsupported media type: %s\", accept)\n}",
        "func CanSign(keyType PublicKeyType, msg []byte) bool {\n\tswitch keyType {\n\tcase RSAKey, ECKey, DSAKey, ECDSAKey, ECDSAPublicKey,\n\t\tRSAPrivateKey, ECPrivateKey, DSAPrivateKey,\n\t\tRSAPublicKey, ECPublicKey, DSAPublicKey,\n\t\tRSAPrivateKeyWithRSA, ECPrivateKeyWithRSA,\n\t\tRSAPublicKeyWithRSA, ECPrivateKeyWithRSA,\n\t\tRSAPrivateKeyWithECDSA, ECPrivateKeyWithECDSA,\n\t\tRSAPrivateKeyWithECDSA, ECPrivateKeyWithECDSA,\n\t\tRSAPrivateKeyWithECDSA, ECPrivateKeyWithECDSA,\n\t\tRSAPrivateKeyWithECDSA, ECPrivateKeyWithECDSA,\n\t\tRSAPrivateKeyWithECDSA, ECPrivateKeyWithECDSA,\n\t\tRSAPrivateKeyWithECDSA, ECPrivateKeyWithECDSA,\n\t\tRSAPrivateKeyWithECDSA, ECPrivateKeyWithECDSA",
        "func (p *PlayerStandings) Less(i, j int) bool {\n\treturn p.Standings[i].Name < p.Standings[j].Name\n}",
        "func WaitFunc(ctx context.Context, fn func() bool) error {\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(done)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif fn() {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn <-done\n}",
        "func FormatDialAddress(addr string) string {\n\tif strings.Contains(addr, \":\") {\n\t\treturn addr\n\t}\n\treturn fmt.Sprintf(\"%s:%d\", addr, DefaultPort)\n}",
        "func (p *Port) SetFromDocker(port string) error {\n\tparts := strings.Split(port, \":\")\n\tif len(parts) != 2 {\n\t\treturn fmt.Errorf(\"invalid port format: %s\", port)\n\t}\n\n\tp.Protocol = parts[0]\n\tp.Port = strconv.Itoa(parts[1])\n\n\treturn nil\n}",
        "func (r *Rand) Read(b []byte) (n int, err error) {\n\tif r.n == 0 {\n\t\treturn 0, nil\n\t}\n\tn = len(b)\n\tif r.n > r.n {\n\t\tr.n = r.n\n\t}\n\tfor i := 0; i < r.n; i++ {\n\t\tb[i] = byte(r.r.Intn(255))\n\t}\n\treturn n, nil\n}",
        "func readByte() byte {\n\tb := make([]byte, 1)\n\t_, err := io.ReadFull(rand.Reader, b)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b[0]\n}",
        "func RecoverHandlerJson(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\tfmt.Fprintf(w, \"panic: %s\\n\", r)\n\t\t\t}\n\t\t}()\n\t\tnext.ServeHTTP(w, r)\n\t})\n}",
        "func DefaultServiceConfig() ServiceConfig {\n\treturn ServiceConfig{\n\t\tName:        \"random\",\n\t\tDescription: \"Randomly generated service name\",\n\t\tTags:        []string{\"random\"},\n\t\tPort:        80,\n\t\tProtocol:    \"TCP\",\n\t\tTimeout:     5 * time.Second,\n\t\tRetry:       3,\n\t\tRetryDelay:  5 * time.Second,\n\t\tRetryMax:    3,\n\t\tRetryWait:   5 * time.Second,\n\t\tRetryWaitMax: 5 * time.Second,\n\t\tRetryWaitMin: 5 * time.Second,\n\t\tRetryMaxDelay: 5 * time.Second,\n\t\tRetryMaxDelayMax: 5 * time.Second,\n\t\tRetryMaxDelayMin: 5 * time.Second,\n\t\tRetryMaxDelayMax: 5 * time.",
        "func NewService(config Config) *Service {\n\tif config.Seed == 0 {\n\t\tconfig.Seed = time.Now().UnixNano()\n\t}\n\tif config.MaxAge == 0 {\n\t\tconfig.MaxAge = time.Hour\n\t}\n\tif config.MaxAttempts == 0 {\n\t\tconfig.MaxAttempts = 10\n\t}\n\tif config.MaxWait == 0 {\n\t\tconfig.MaxWait = time.Second\n\t}\n\tif config.MaxRetries == 0 {\n\t\tconfig.MaxRetries = 5\n\t}\n\tif config.MaxWaitFactor == 0 {\n\t\tconfig.MaxWaitFactor = 1.5\n\t}\n\tif config.MaxRetriesFactor == 0 {\n\t\tconfig.MaxRetriesFactor = 2\n\t}\n\tif config.MaxWaitFactor < 0 {\n\t\tconfig.MaxWaitFactor =",
        "func RunLight(ctx context.Context, client *mgo.Collection, image string) error {\n\tif err := createLight(ctx, client, image); err != nil {\n\t\treturn err\n\t}\n\treturn createLight(ctx, client, image)\n}",
        "func initConfig() {\n\tif !isConfigSet() {\n\t\treturn\n\t}\n\n\tconfigFile := os.Getenv(\"CONFIG\")\n\tif configFile == \"\" {\n\t\treturn\n\t}\n\n\tconfig, err := configutil.ReadConfig(configFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error reading config file %s: %s\", configFile, err)\n\t}\n\n\t// Merge in ENV variables\n\tfor k, v := range config.Env {\n\t\tconfig.Env[k] = v\n\t}\n\n\t// Merge in config\n\tfor k, v := range config.Data {\n\t\tconfig.Data[k] = v\n\t}\n\n\t// Write config\n\tif err := configutil.WriteConfig(configFile, config); err != nil {\n\t\tlog.Fatalf(\"Error",
        "func (c *Container) HasExposedPorts() bool {\n\tfor _, p := range c.Ports {\n\t\tif p.Exposed {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
        "func (c *Container) Inspect() (types.ContainerJSON, error) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.state != stateRunning {\n\t\treturn types.ContainerJSON{}, errors.Errorf(\"container is not running\")\n\t}\n\treturn c.inspect()\n}",
        "func (c *Container) Kill() error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.process == nil {\n\t\treturn errors.New(\"container is not running\")\n\t}\n\treturn c.process.Kill()\n}",
        "func (c *Container) NetworkNodes() ([]NetworkNode, error) {\n\tvar nodes []NetworkNode\n\tfor _, n := range c.Network {\n\t\tnodes = append(nodes, n)\n\t}\n\treturn nodes, nil\n}",
        "func (c *Container) Remove(ctx context.Context) error {\n\treturn c.client.ContainerRemove(ctx, c.container.ID, types.ContainerRemoveOptions{})\n}",
        "func (c *Container) WaitStartup() error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.state != containerStateRunning {\n\t\treturn errors.Errorf(\"container is not running\")\n\t}\n\tc.state = containerStateWaiting\n\tc.wg.Wait()\n\treturn nil\n}",
        "func NewHandler(ctx context.Context, logger log.Logger, opts ...HandlerOption) *Handler {\n\th := &Handler{\n\t\tctx:     ctx,\n\t\tlogger: logger,\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(h)\n\t}\n\n\treturn h\n}",
        "func (h *Handler) Handle(record *Record) error {\n\tif record.Level > h.Level {\n\t\treturn nil\n\t}\n\th.Counter.WithLabelValues(record.Name, record.Level).Inc()\n\treturn nil\n}",
        "func NewCounter(name string, options *Options) *Counter {\n\tif options == nil {\n\t\toptions = &Options{}\n\t}\n\n\tc := &Counter{\n\t\tname:     name,\n\t\toptions: options,\n\t\tcounters: make(map[string]*Counter),\n\t}\n\n\tif options.Labels == nil {\n\t\toptions.Labels = make(map[string]string)\n\t}\n\n\tif options.Labels[\"type\"] == \"\" {\n\t\toptions.Labels[\"type\"] = \"counter\"\n\t}\n\n\tif options.Labels[\"label\"] == \"\" {\n\t\toptions.Labels[\"label\"] = \"label\"\n\t}\n\n\tif options.Labels[\"help\"] == \"\" {\n\t\toptions.Labels[\"help\"] = \"help\"\n\t}\n\n\tif options.Labels[\"help_format\"]",
        "func (r *Registry) Metrics() []*prometheus.Desc {\n\tr.mutex.RLock()\n\tdefer r.mutex.RUnlock()\n\n\tmetrics := make([]*prometheus.Desc, len(r.metrics))\n\ti := 0\n\tfor k := range r.metrics {\n\t\tmetrics[i] = k\n\t\ti++\n\t}\n\treturn metrics\n}",
        "func (a *Assets) Retrieve(ctx context.Context, sources []string) (http.FileSystem, error) {\n\tfs := &assetFileSystem{\n\t\tctx:    ctx,\n\t\tsources: sources,\n\t}\n\tfor _, src := range sources {\n\t\tif err := fs.process(src); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn fs, nil\n}",
        "func Compile(ctx context.Context, src *Asset, dest *os.File, options *Options) error {\n\tif options == nil {\n\t\toptions = &Options{}\n\t}\n\n\tif options.Output == \"\" {\n\t\toptions.Output = dest.Name()\n\t}\n\n\tif options.Prefix == \"\" {\n\t\toptions.Prefix = src.Prefix\n\t}\n\n\tif options.Ext == \"\" {\n\t\toptions.Ext = filepath.Ext(src.Path)\n\t}\n\n\tif options.Dir == \"\" {\n\t\toptions.Dir = filepath.Dir(src.Path)\n\t}\n\n\tif options.Base == \"\" {\n\t\toptions.Base = filepath.Base(src.Path)\n\t}\n\n\tif options.Base == \"\" {\n\t\treturn fmt.Errorf(\"no base path specified\")\n\t",
        "func (m *MetaInfo) Read(path string) error {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\treturn m.ReadFrom(f)\n}",
        "func (m *MetaInfo) Write(path string) error {\n\tf, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\treturn m.WriteTo(f)\n}",
        "func (s *Slog) Push(header, body string) int {\n\ts.headers = append(s.headers, header)\n\ts.body = append(s.body, body)\n\treturn len(s.headers)\n}",
        "func (s *SegmentStack) Pop() (*Segment, *Segment, error) {\n\tif s.depth == 0 {\n\t\treturn nil, nil, nil\n\t}\n\ts.depth--\n\tif s.depth == 0 {\n\t\treturn s.segments[len(s.segments)-1], s.segments[0], nil\n\t}\n\treturn s.segments[len(s.segments)-1], s.segments[0], nil\n}",
        "func (s *SegmentStack) Peak() (segment *Segment) {\n\tif len(s.segments) > 0 {\n\t\tsegment = s.segments[len(s.segments)-1]\n\t\ts.segments = s.segments[:len(s.segments)-1]\n\t\treturn\n\t}\n\treturn\n}",
        "func (h *Header) PeakHeader() (string, error) {\n\tif len(h.segments) == 0 {\n\t\treturn \"\", errors.New(\"no header segment\")\n\t}\n\treturn h.segments[len(h.segments)-1], nil\n}",
        "func (s *segmentStack) IterateBackward(iterate func(key string, value interface{}) bool) {\n\tfor i := len(s.segments) - 1; i >= 0; i-- {\n\t\tif !iterate(s.segments[i], s.segments[i].value) {\n\t\t\treturn\n\t\t}\n\t}\n}",
        "func (s *segmentStack) IterateForward(fn func(key, value []byte) bool) {\n\tfor i := len(s.segments) - 1; i >= 0; i-- {\n\t\tif !fn(s.segments[i], s.segments[i+1]) {\n\t\t\tbreak\n\t\t}\n\t}\n}",
        "func (b *Backend) Close() error {\n\tif b.stackFile != nil {\n\t\tif err := b.stackFile.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tb.stackFile = nil\n\t}\n\treturn nil\n}",
        "func OpenStack(ctx context.Context, opts OpenStackOpts) (*gophercloud.ServiceClient, error) {\n\tif opts.Region == \"\" {\n\t\treturn gophercloud.OpenStackClient(opts.Endpoint, opts.Region)\n\t}\n\treturn gophercloud.OpenStackClientWithRegion(opts.Endpoint, opts.Region)\n}",
        "func NewStack(filename string) (*Stack, error) {\n\tstack := &Stack{\n\t\tfilename: filename,\n\t\tdata:     make(map[string]interface{}),\n\t}\n\n\tif err := stack.readStackFile(filename); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn stack, nil\n}",
        "func NewSessionCache(lifetime time.Duration, salt []byte) *SessionCache {\n\treturn &SessionCache{\n\t\tlifetime: lifetime,\n\t\tsalt:    salt,\n\t\tsessions: make(map[string]*sessionEntry),\n\t}\n}",
        "func getInvalidTokenError(token string) error {\n\tif token == \"\" {\n\t\treturn fmt.Errorf(\"invalid token\")\n\t}\n\tif time.Now().After(tokenExpirationTime) {\n\t\treturn fmt.Errorf(\"token expired\")\n\t}\n\treturn nil\n}",
        "func (c *Cache) Get(token string) (interface{}, bool) {\n\tc.RLock()\n\tdefer c.RUnlock()\n\treturn c.cache[token], true\n}",
        "func (c *SessionCache) Add(token string) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tc.tokens[token] = struct{}{}\n}",
        "func (c *SessionCache) Delete(token string) {\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\tdelete(c.tokens, token)\n}",
        "func (t *Token) Set(value string) error {\n\tt.Value = value\n\tt.Expires = time.Now().Add(t.TTL)\n\treturn nil\n}",
        "func NewClient(opts ...ClientOption) *Client {\n\tc := &Client{\n\t\tclient: &http.Client{},\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(c)\n\t}\n\n\treturn c\n}",
        "func (c *Client) connect() error {\n\tif c.conn != nil {\n\t\treturn errors.New(\"client already connected\")\n\t}\n\n\tif c.config.TLSConfig == nil {\n\t\tc.config.TLSConfig = &tls.Config{}\n\t}\n\n\tif c.config.TLSConfig.InsecureSkipVerify {\n\t\tc.conn = tls.Client(c.conn, c.config.TLSConfig)\n\t} else {\n\t\tc.conn = tls.Client(c.conn, &tls.Config{\n\t\t\tInsecureSkipVerify: true,\n\t\t})\n\t}\n\n\treturn c.conn.Handshake()\n}",
        "func (c *Conn) writeMessage(msg *Message) error {\n\tif msg.Type == \"PING\" {\n\t\treturn c.writePing(msg)\n\t}\n\treturn c.writeText(msg.Text)\n}",
        "func (c *Conn) readMessage() (*Message, error) {\n\tline, err := c.reader.ReadString('\\n')\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ParseMessage(line)\n}",
        "func (c *Client) Stop() error {\n\tc.stopOnce.Do(func() {\n\t\tclose(c.stop)\n\t\tc.wg.Wait()\n\t})\n\treturn c.conn.Close()\n}",
        "func (c *Client) GetChannels() ([]string, error) {\n\tchannels, err := c.GetChannelsRaw()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar channelsList []string\n\tfor _, channel := range channels {\n\t\tchannelsList = append(channelsList, channel.Name)\n\t}\n\n\treturn channelsList, nil\n}",
        "func (r *Response) JsonWrite(data interface{}) error {\n\tr.ContentType(ContentTypeJSON)\n\tr.Status(http.StatusOK)\n\treturn json.NewEncoder(r.Writer).Encode(data)\n}",
        "func (c *Client) JsonRead(obj interface{}) error {\n\treturn json.NewDecoder(c.Req.Body).Decode(obj)\n}",
        "func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) error {\n\tif pk.Algorithm != signed.Algorithm {\n\t\treturn ErrInvalidAlgorithm\n\t}\n\tif pk.X.Cmp(signed.X) != 0 {\n\t\treturn ErrInvalidX\n\t}\n\tif pk.Y.Cmp(signed.Y) != 0 {\n\t\treturn ErrInvalidY\n\t}\n\tif pk.Curve != signed.Curve {\n\t\treturn ErrInvalidCurve\n\t}\n\tif pk.D.Cmp(signed.D) != 0 {\n\t\treturn ErrInvalidD\n\t}\n\tif pk.N.Cmp(signed.N) != 0 {\n\t\treturn ErrInvalidN\n\t}\n\tif pk.E.Cmp(signed.E) != 0 {\n\t\treturn ErrInvalidE\n\t}\n\tif pk.P.Cmp(signed.P)",
        "func (s *Service) UserCreate(ctx context.Context, o UserCreateOpts) (*User, error) {\n\tvar user User\n\treturn &user, s.Post(ctx, &user, fmt.Sprintf(\"/users\"), o)\n}",
        "func (r *Router) Next(w http.ResponseWriter, req *http.Request) {\n\tr.router.Next(w, req)\n}",
        "func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\th.ServeHTTPC(w, r, h.next)\n}",
        "func (r *Route) UseHandler(h Handler) *Route {\n\tr.handlers = append(r.handlers, h)\n\treturn r\n}",
        "func (m *Mux) HandleMethod(pattern string, method string, handlerFuncs ...HandlerFunc) {\n\tm.Handle(pattern, method, func(rw http.ResponseWriter, req *http.Request, _ HandlerFunc) {\n\t\tfor _, f := range handlerFuncs {\n\t\t\tf(rw, req)\n\t\t}\n\t})\n}",
        "func (m *Mux) Handle(pattern string, handlerFuncs ...HandlerFunc) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tm.handle(pattern, handlerFuncs...)\n}",
        "func (r *Router) Get(pattern string, handler http.HandlerFunc) {\n\tr.Handle(\"GET\", pattern, handler)\n}",
        "func (r *Router) Post(pattern string, handlers ...HandlerFunc) {\n\tr.Handle(http.MethodPost, pattern, handlers)\n}",
        "func (r *Router) Put(pattern string, handlers ...HandlerFunc) {\n\tr.Handle(http.MethodPut, pattern, handlers)\n}",
        "func (r *Router) Patch(pattern string, handler http.HandlerFunc) {\n\tr.Handle(http.MethodPatch, pattern, handler)\n}",
        "func (r *Router) Delete(pattern string, handler http.HandlerFunc) {\n\tr.Handle(http.MethodDelete, pattern, handler)\n}",
        "func (r *Router) Options(pattern string, handlers ...HandlerFunc) {\n\tr.Handle(\"OPTIONS\", pattern, handlers)\n}",
        "func NewSalter(sources []Source, nextToken []byte) *Salter {\n\treturn &Salter{\n\t\tsources:   sources,\n\t\tnextToken: nextToken,\n\t}\n}",
        "func BToken(size int) []byte {\n\tb := make([]byte, size)\n\t_, err := io.ReadFull(rand.Reader, b)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b\n}",
        "func Token(size int) string {\n\tb := make([]byte, size)\n\tfor i := 0; i < size; i++ {\n\t\tb[i] = byte(rand.Intn(256))\n\t}\n\treturn base64.StdEncoding.EncodeToString(b)\n}",
        "func getRandomBytes(length int) ([]byte, error) {\n\tb := make([]byte, length)\n\t_, err := rand.Read(b)\n\treturn b, err\n}",
        "func NewNewsItem(title, url string, content *Content) *NewsItem {\n\treturn &NewsItem{\n\t\tTitle:     title,\n\t\tUrl:       url,\n\t\tContent:   content,\n\t\tCreated:  time.Now(),\n\t\tUpdated:  time.Now(),\n\t\tType:      \"news\"}\n}",
        "func (l *DebugLogger) Write(m *logrus.Entry) error {\n\tl.logger.Output(2, fmt.Sprintf(\"%s %s\", m.Level, m.Message))\n\treturn nil\n}",
        "func (l *Logger) Write(m *Message) error {\n\treturn l.log(l.info, m)\n}",
        "func (w *WarningWriter) Write(p []byte) (int, error) {\n\treturn w.logger.Output(w.level, string(p))\n}",
        "func (e *ErrorLogger) Write(m *logrus.Entry) error {\n\treturn e.logger.Error(m.Message())\n}",
        "func GetLogger(name string) (Logger, error) {\n\tloggerMutex.RLock()\n\tdefer loggerMutex.RUnlock()\n\tif logger, ok := loggers[name]; ok {\n\t\treturn logger, nil\n\t}\n\treturn nil, fmt.Errorf(\"logger %s not found\", name)\n}",
        "func RemoveLogger(logger Logger) {\n\tglobalLock.Lock()\n\tdefer globalLock.Unlock()\n\tdelete(loggerRegistry, logger.Name())\n}",
        "func (l *Logger) WaitForAllUnprocessedRecords() {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tfor l.unprocessedRecords.Len() > 0 {\n\t\tl.wait.Wait()\n\t}\n}",
        "func (a *asyncLogWriter) run() {\n\tfor {\n\t\tselect {\n\t\tcase record := <-a.records:\n\t\t\ta.writer.Write(record)\n\t\tcase <-a.shutdown:\n\t\t\treturn\n\t\t}\n\t}\n}",
        "func (l *Logger) WaitForUnprocessedRecords() {\n\tfor {\n\t\tl.Lock()\n\t\tif len(l.unprocessedRecords) == 0 {\n\t\t\tl.Unlock()\n\t\t\treturn\n\t\t}\n\t\tl.Unlock()\n\t\ttime.Sleep(l.unprocessedRecordsWait)\n\t}\n}",
        "func (l *Logger) SetBufferLength(length int) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.bufferLength = length\n}",
        "func (l *Logger) AddHandler(h Handler) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.handlers = append(l.handlers, h)\n}",
        "func (l *Logger) ClearHandlers() {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.handlers = make(map[string]Handler)\n}",
        "func (l *Logger) SetLevel(level Level) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.level = level\n}",
        "func (l *logEmitter) log(record *LogRecord) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.records = append(l.records, record)\n\tl.send()\n}",
        "func (l *Logger) Logf(level Level, format string, args ...interface{}) {\n\tl.logf(level, format, args...)\n}",
        "func (l *Logger) Log(level Level, format string, args ...interface{}) {\n\tl.log(level, fmt.Sprintf(format, args...))\n}",
        "func (l *Logger) Emergencyf(format string, args ...interface{}) {\n\tl.output(l.emergency, fmt.Sprintf(format, args...))\n}",
        "func (entry *Entry) Alertf(format string, args ...interface{}) {\n\tif logger.Level >= logrus.AlertLevel {\n\t\tentry.Entry.Alertf(format, args...)\n\t}\n}",
        "func (entry *Entry) Criticalf(format string, args ...interface{}) {\n\tif logger.Level >= logrus.CriticalLevel {\n\t\tentry.WithFields(entry.fields).Criticalf(format, args...)\n\t}\n}",
        "func (entry *Entry) Errorf(format string, args ...interface{}) {\n\tif logger.Level >= logrus.ErrorLevel {\n\t\tentry.WithFields(entry.fields).Errorf(format, args...)\n\t}\n}",
        "func (entry *Entry) Warningf(format string, args ...interface{}) {\n\tif logger.Level >= logrus.WarningLevel {\n\t\tentry.WithFields(entry.fields).Warningf(format, args...)\n\t}\n}",
        "func (entry *Entry) Noticef(format string, args ...interface{}) {\n\tif logger.Level >= logrus.NoticeLevel {\n\t\tentry.Entry.Noticef(format, args...)\n\t}\n}",
        "func (l *Logger) Infof(format string, v ...interface{}) {\n\tl.output(time.Now(), INFO, fmt.Sprintf(format, v...))\n}",
        "func (entry *Entry) Debugf(format string, args ...interface{}) {\n\tif logger.Level >= logrus.DebugLevel {\n\t\tentry.WithFields(entry.fields).Debugf(format, args...)\n\t}\n}",
        "func (r *Router) SetHandler(h Handler) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.h = h\n}",
        "func (r *Router) SetMethodHandler(method string, handler http.Handler) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.methodHandlers[method] = handler\n}",
        "func (m *Mux) GetHandler(method string) http.Handler {\n\treturn m.handlers[method]\n}",
        "func (e *Entry) getChildEntry(pattern string) *Entry {\n\tfor _, child := range e.Children {\n\t\tif child.Match(pattern) {\n\t\t\treturn child\n\t\t}\n\t}\n\treturn nil\n}",
        "func (e *Entry) MergePattern(patterns ...string) {\n\tfor _, pattern := range patterns {\n\t\te.AddPattern(pattern)\n\t}\n}",
        "func (e *Entry) AddEntry(child *Entry) {\n\te.children = append(e.children, child)\n\tsort.Sort(e)\n}",
        "func (e *Entry) addPatterns(patterns []string) {\n\tfor _, pattern := range patterns {\n\t\te.patterns = append(e.patterns, pattern)\n\t}\n}",
        "func execPrefix(urlStr string) (string, error) {\n\tif !strings.HasPrefix(urlStr, \"/\") {\n\t\treturn \"\", fmt.Errorf(\"urlStr must start with /\")\n\t}\n\treturn urlStr[1:], nil\n}",
        "func (e *Entry) traverse(match func(string) bool) {\n\tif match(e.Name) {\n\t\te.Children = append(e.Children, e)\n\t}\n\tfor _, child := range e.Children {\n\t\tchild.traverse(match)\n\t}\n}",
        "func getExecMatch(name string, mather func() interface{}) ExecFunc {\n\treturn func(ctx context.Context, session *Session, cmd *Command, bindVars map[string]*querypb.BindVariable) (*sqltypes.Result, error) {\n\t\treturn session.Exec(cmd, bindVars)\n\t}\n}",
        "func MergeRoutes(routables ...Routable) []Route {\n\troutes := []Route{}\n\tfor _, r := range routables {\n\t\troutes = append(routes, r.MergeRoutes()...)\n\t}\n\treturn routes\n}",
        "func (l *Logger) Debugln(args ...interface{}) {\n\tl.output(l.app, logLevelDebug, \"\", true, args...)\n}",
        "func (l *Logger) Debugf(format string, v ...interface{}) {\n\tl.output(log.Debug, fmt.Sprintf(format, v...))\n}",
        "func (l *Logger) Infof(format string, args ...interface{}) {\n\tl.log(LvInfo, format, args...)\n}",
        "func (l *Logger) Infoln(args ...interface{}) {\n\tl.output(l.app, logLevelInfo, \"\", true, args...)\n}",
        "func (l *Logger) Infof(format string, v ...interface{}) {\n\tl.output(time.Now(), INFO, fmt.Sprintf(format, v...))\n}",
        "func (l *Logger) Okln(args ...interface{}) {\n\tl.output(l.app, logLevelOk, fmt.Sprintln(args...))\n}",
        "func (l *Logger) Okf(format string, args ...interface{}) {\n\tl.output(l.app, logLevelOk, fmt.Sprintf(format, args...))\n}",
        "func (l *Logger) Fatalln(args ...interface{}) {\n\tl.output(l.app, logLevelFatal, \"\", true, args...)\n\tos.Exit(1)\n}",
        "func (l *Logger) Fatalf(format string, args ...interface{}) {\n\tl.output(l.app, logLevelFatal, format, true, args...)\n\tos.Exit(1)\n}",
        "func ShouldDebug(facility string) bool {\n\tswitch facility {\n\tcase \"debugger\":\n\t\treturn true\n\tcase \"console\":\n\t\treturn true\n\tcase \"syslog\":\n\t\treturn true\n\tcase \"syslog-daemon\":\n\t\treturn true\n\tcase \"syslog-daemon-daemon\":\n\t\treturn true\n\tcase \"syslog-daemon-daemon-daemon\":\n\t\treturn true\n\tcase \"syslog-daemon-daemon-daemon-daemon\":\n\t\treturn true\n\tcase \"syslog-daemon\":\n\t\treturn true\n\tcase \"syslog-daemon-daemon\":\n\t\treturn true\n\tcase \"syslog-daemon-daemon-daemon\":\n\t\treturn true\n\tcase \"syslog-daemon-daemon-daemon-daemon\":\n\t\treturn true\n\tcase \"syslog-daemon-daemon-daemon",
        "func (l *Logger) SetDebug(facility string, enabled bool) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\n\tl.debug[facility] = enabled\n}",
        "func (s *Server) Facilities() (map[string]bool, map[string]bool) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\treturn s.facilities, s.debug\n}",
        "func NewFacility(name string, level Level, handler Handler) *Logger {\n\treturn &Logger{\n\t\tfacility: name,\n\t\tlevel:    level,\n\t\thandler:  handler,\n\t}\n}",
        "func removeNonDigits(s string) string {\n\tfor i, r := range s {\n\t\tif !isDigit(r) {\n\t\t\ts = s[:i]\n\t\t\tbreak\n\t\t}\n\t}\n\treturn s\n}",
        "func removeNonWordChars(s string) string {\n\tfor i, r := range s {\n\t\tif !unicode.IsLetter(r) && !unicode.IsDigit(r) && !unicode.IsSpace(r) {\n\t\t\ts[i] = r\n\t\t}\n\t}\n\treturn string(s)\n}",
        "func urlEncodeSpaces(s string) string {\n\tif len(s) == 0 {\n\t\treturn \"\"\n\t}\n\tvar buf bytes.Buffer\n\tfor _, c := range s {\n\t\tif c == ' ' {\n\t\t\tbuf.WriteString(\"\\\\20\")\n\t\t} else {\n\t\t\tbuf.WriteRune(c)\n\t\t}\n\t}\n\treturn buf.String()\n}",
        "func randomSelect(ints []int) int {\n\tif len(ints) == 0 {\n\t\treturn 0\n\t}\n\treturn ints[rand.Intn(len(ints))]\n}",
        "func NewStdFormatter(out io.Writer) *StdFormatter {\n\treturn &StdFormatter{\n\t\tout:    out,\n\t\tindent: false,\n\t}\n}",
        "func Get(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfor _, m := range middlewares {\n\t\t\tm.ServeHTTP(w, r)\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}",
        "func parseMatcher(pattern string) (string, string) {\n\tif pattern == \"\" {\n\t\treturn \"\", \"\"\n\t}\n\tif pattern[0] == '*' {\n\t\treturn pattern[1:], \"\"\n\t}\n\treturn pattern, \"\"\n}",
        "func isMatchPattern(pattern, str string) bool {\n\tif pattern == \"\" {\n\t\treturn true\n\t}\n\tif pattern[0] == '*' {\n\t\treturn true\n\t}\n\tif pattern[0] == '?' {\n\t\treturn true\n\t}\n\tif pattern[0] == '*' {\n\t\treturn true\n\t}\n\tif pattern[0] == '?' {\n\t\treturn true\n\t}\n\treturn strings.HasPrefix(str, pattern)\n}",
        "func routeSplitFunc(s string, atEOF bool) (advance int, token []byte, err error) {\n\tif atEOF && len(s) == 0 {\n\t\treturn 0, nil, nil\n\t}\n\tif s[0] == '*' {\n\t\treturn 0, nil, nil\n\t}\n\treturn 1, []byte(s), nil\n}",
        "func SplitPath(path string) ([]string, error) {\n\tif path == \"\" {\n\t\treturn nil, nil\n\t}\n\tif path[0] == '/' {\n\t\treturn []string{path}, nil\n\t}\n\treturn strings.Split(path, \"/\"), nil\n}",
        "func isNextSuffixPattern(m *Matcher, next *Matcher) bool {\n\tif m.isStatic() {\n\t\treturn false\n\t}\n\tif next.isStatic() {\n\t\treturn false\n\t}\n\tif m.matchRune(next.rune()) {\n\t\treturn true\n\t}\n\treturn false\n}",
        "func (c *Client) PeekNextPattern(offset int) (string, error) {\n\treq, err := c.NewRequest(\"GET\", c.Endpoint+\"/peek-next\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif offset > 0 {\n\t\treq.Params.Set(\"offset\", strconv.Itoa(offset))\n\t}\n\n\tresp, err := checkResp(c.Http.Do(req))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar data peekNextData\n\tif err := decodeJSON(resp.Body, &data); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn data.Pattern, nil\n}",
        "func (p *Player) Create() (err error) {\n\tif p.ID == \"\" {\n\t\tp.ID, err = uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif p.Name == \"\" {\n\t\tp.Name, err = uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif p.URL == \"\" {\n\t\tp.URL, err = uuid.NewV4()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif p.CreatedAt == 0 {\n\t\tp.CreatedAt = time.Now().Unix()\n\t}\n\n\tif p.UpdatedAt == 0 {\n\t\tp.UpdatedAt = time.Now().Unix()\n\t}\n\n",
        "func (r *Reader) Push(r2 io.Reader) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.readers = append(r.readers, r2)\n}",
        "func NewCatering(name string,\n\tstartTime time.Time,\n\tendTime time.Time,\n\tprice float64,\n\tvolume float64,\n\tvolumeChange float64,\n\tvolumeChangeType string,\n\tvolumeChangeTypeDescription string,\n\tvolumeChangeTypeId string,\n\tvolumeChangeTypeImage string,\n\tvolumeChangeTypeImageDescription string,\n\tvolumeChangeTypeSize string,\n\tvolumeChangeTypeSizeDescription string,\n\tvolumeChangeTypeSizeId string,\n\tvolumeChangeTypeImageId string,\n\tvolumeChangeTypeImageDescription string,\n\tvolumeChangeTypeSizeIdDescription string,\n\tvolumeChangeTypeSizeIdType string,\n\tvolumeChangeTypeSizeIdTypeDescription string,\n\tvolumeChangeTypeSizeIdTypeId string,\n\tvolumeChangeTypeImageId string,\n\tvolumeChangeTypeImageIdDescription string,\n\tvolumeChangeTypeSizeIdTypeId string",
        "func (t *Tournaments) Get(id string) (*Tournaments, error) {\n\tres, err := t.client.Get(fmt.Sprintf(\"/tournaments/%s\", id), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Tournaments{res.Body}, nil\n}",
        "func (t *Tournament) GetTournamentID() int {\n\treturn int(atomic.LoadInt64(&t.ID))\n}",
        "func (c *Client) TournamentCreate(tournament *Tournament) (*Tournament, error) {\n\tif tournament.ID == \"\" {\n\t\treturn nil, ErrMissingID\n\t}\n\n\tpath := fmt.Sprintf(\"/tournaments/%s\", tournament.ID)\n\tresp, err := c.PostForm(path, tournament, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar tournamentRes Tournament\n\tif err := decodeJSON(&tournamentRes, resp.Body); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &tournamentRes, nil\n}",
        "func (s Slice) IndexOf(str string) int {\n\treturn s.indexOf(str, false)\n}",
        "func (s *Slice) IndexOfIgnoreCase(str string) int {\n\treturn s.IndexOf(str, func(c byte) bool { return c == 'i' })\n}",
        "func NewCache(lifetime time.Duration) *Cache {\n\treturn &Cache{\n\t\tlifetime: lifetime,\n\t\titems:    make(map[string]*Item),\n\t}\n}",
        "func (c *Cache) Count() int {\n\tc.mutex.RLock()\n\tdefer c.mutex.RUnlock()\n\treturn len(c.values)\n}",
        "func (c *Cache) Flush() {\n\tc.Lock()\n\tdefer c.Unlock()\n\tc.values = make(map[interface{}]interface{})\n}",
        "func (c *Cache) removeExpired() (lockingStatus int) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\tfor i := len(c.instances) - 1; i >= 0; i-- {\n\t\tif c.instances[i].isExpired() {\n\t\t\tc.instances[i] = c.instances[i].clone()\n\t\t\tc.instances[i].isExpired = false\n\t\t\tc.instances[i].lock = nil\n\t\t\tc.instances = append(c.instances[:i], c.instances[i+1:]...)\n\t\t\tlockingStatus = c.instances[i].getLockingStatus()\n\t\t}\n\t}\n\treturn\n}",
        "func NewImage(id string, parent *Image, parentID string, parentSize int64, parentDigest string, parentTag string, parentArch string, parentSizeBytes int64, parentDigestBytes int64, parentTagBytes int64, parentArchBytes int64, size int64, digest string, tag string, arch string, sizeBytes int64, digestBytes int64, tagBytes int64, archBytes int64) *Image {\n\treturn &Image{\n\t\tID:            id,\n\t\tParent:        parent,\n\t\tParentID:      parentID,\n\t\tParentSize:    parentSize,\n\t\tParentDigest:   parentDigest,\n\t\tParentTag:     parentTag,\n\t\tParentArch:     parentArch,\n\t\tParentSizeBytes: parentSizeBytes,\n\t\tParentDigestBytes: parentDigestBytes,\n\t\tParentTagBytes:   parentTagBytes,",
        "func (d *Docker) Exists() bool {\n\t_, err := d.client.ImageInspectWithRaw(d.image)\n\treturn err == nil\n}",
        "func (c *Client) Pull(ctx context.Context, ref string) error {\n\treturn c.PullWithAuth(ctx, ref, nil)\n}",
        "func (c *CreateContainerOptions) Run() error {\n\tif c.image == \"\" {\n\t\treturn fmt.Errorf(\"image is required\")\n\t}\n\n\tif c.template == \"\" {\n\t\treturn fmt.Errorf(\"template is required\")\n\t}\n\n\tif c.name == \"\" {\n\t\treturn fmt.Errorf(\"name is required\")\n\t}\n\n\tif c.port == 0 {\n\t\treturn fmt.Errorf(\"port is required\")\n\t}\n\n\tif c.protocol == \"\" {\n\t\tc.protocol = \"tcp\"\n\t}\n\n\tif c.tlsConfig == nil {\n\t\tc.tlsConfig = &tls.Config{}\n\t}\n\n\tclient, err := docker.NewClient(docker.NewClientConfig().WithTLS(c.tlsConfig))\n\tif err != nil {\n\t\treturn err\n",
        "func (d *Docker) Setup(ctx context.Context) error {\n\tif err := d.checkDockerBinary(ctx); err != nil {\n\t\treturn err\n\t}\n\tif err := d.pullCurrentImage(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "func NewLocation(lat, lng float64) *Location {\n\treturn &Location{\n\t\tLat: lat,\n\t\tLng: lng,\n\t}\n}",
        "func (s *Server) PortAt(index int) (*expose.PortInfo, *publish.PublishInfo, error) {\n\treturn s.exposePorts.At(index), s.publishPorts.At(index), nil\n}",
        "func SplitPort(s string) (int, string) {\n\tif len(s) == 0 {\n\t\treturn 0, \"\"\n\t}\n\tif s[0] == ':' {\n\t\treturn 0, s[1:]\n\t}\n\treturn 0, s\n}",
        "func (facility SyslogFacility) Priority() syslog.Priority {\n\tswitch facility {\n\tcase FacilityUser:\n\t\treturn syslog.LOG_USER\n\tcase FacilityUserAndService:\n\t\treturn syslog.LOG_USER | syslog.LOG_SERVICE\n\tcase FacilityUserOrService:\n\t\treturn syslog.LOG_USER | syslog.LOG_SERVICE | syslog.LOG_USER\n\tcase FacilityUserAndServiceAndUser:\n\t\treturn syslog.LOG_USER | syslog.LOG_SERVICE | syslog.LOG_USER | syslog.LOG_SERVICE | syslog.LOG_USER\n\tcase FacilityUserOrServiceAndUserAndUser:\n\t\treturn syslog.LOG_USER | syslog.LOG_SERVICE | syslog.LOG_USER | syslog.LOG_SERVICE | syslog.LOG_USER | syslog.LOG_SERVICE | syslog.LOG_USER\n\tcase FacilityUser",
        "func (fac SyslogFacility) OK() bool {\n\tif fac < SyslogFacility(\"\") || fac > SyslogFacility(\"ALL\") {\n\t\treturn false\n\t}\n\treturn true\n}",
        "func (j *JSONFormatter) Format(record *Record) ([]byte, error) {\n\tvar buf bytes.Buffer\n\terr := json.NewEncoder(&buf).Encode(record)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}",
        "func Open(path string, options *Options) (*DB, error) {\n\tif options == nil {\n\t\toptions = &Options{}\n\t}\n\n\tif err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n\t\treturn nil, err\n\t}\n\n\tf, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdb := &DB{\n\t\tpath: path,\n\t\tf:   f,\n\t\topts: options,\n\t}\n\n\treturn db, nil\n}",
        "func (db *DB) Begin() (*bolt.Tx, error) {\n\ttx, err := db.DB.Begin()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tx, nil\n}",
        "func (db *DB) View(fn func(k, v []byte) error) error {\n\treturn db.DB.View(fn)\n}",
        "func (db *DB) CopyFile(path string) error {\n\tf, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\treturn db.Copy(f)\n}",
        "func (tx *Tx) CreateBucketIfNotExists(name []byte) (*Bucket, error) {\n\tif len(name) == 0 {\n\t\treturn nil, errors.New(\"bucket name is blank\")\n\t}\n\tif len(name) > MaxBucketNameLength {\n\t\treturn nil, errors.New(\"bucket name is too long\")\n\t}\n\n\ttx.bucketLock.Lock()\n\tdefer tx.bucketLock.Unlock()\n\n\tif tx.buckets[string(name)] != nil {\n\t\treturn nil, errors.New(\"bucket already exists\")\n\t}\n\n\tb := &Bucket{\n\t\tname:     name,\n\t\tentries: make(map[string]*Entry),\n\t}\n\ttx.buckets[string(name)] = b\n\treturn b, nil\n}",
        "func (c *Client) Delete(key string) error {\n\treturn c.do(\"DELETE\", key, nil, nil)\n}",
        "func (f *Folder) ForEach(fn func(k, v string) error) error {\n\treturn f.forEach(false, fn)\n}",
        "func (f *Folder) ForEach(fn func(k, v []byte) error) error {\n\treturn f.forEach(false, fn)\n}",
        "func (tx *Tx) Put(key, value []byte) error {\n\tif tx.readOnly {\n\t\treturn ErrTxReadOnly\n\t}\n\tif len(key) == 0 {\n\t\treturn ErrKeyEmpty\n\t}\n\tif len(value) == 0 {\n\t\treturn ErrValueEmpty\n\t}\n\tif len(key) > MaxKeyLength {\n\t\treturn ErrKeyTooLarge\n\t}\n\tif len(value) > MaxValueLength {\n\t\treturn ErrValueTooLarge\n\t}\n\ttx.bucket.Lock()\n\tdefer tx.bucket.Unlock()\n\tif tx.bucket.data[tx.bucket.root] != nil {\n\t\treturn ErrTxClosed\n\t}\n\tif tx.bucket.data[tx.bucket.root] == nil {\n\t\ttx.bucket.data[tx.bucket.root",
        "func (tx *Tx) Value(key []byte, f func(Value) error) error {\n\treturn tx.db.View(func(tx *bolt.Tx) error {\n\t\tbucket := tx.Bucket(key)\n\t\tif bucket == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn bucket.ForEach(func(k, v []byte) error {\n\t\t\tif len(v) == 0 {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn f(Value(v))\n\t\t})\n\t})\n}",
        "func (i *item) Updates(f func(interface{}) interface{}) (interface{}, error) {\n\ti.mu.Lock()\n\tdefer i.mu.Unlock()\n\n\tif i.current == nil {\n\t\treturn nil, ErrDeleted\n\t}\n\n\treturn f(i.current)\n}",
        "func (tx *Tx) Bucket(name []byte, folders ...[]byte) *Bucket {\n\tif tx.db == nil {\n\t\treturn nil\n\t}\n\tif len(folders) == 0 {\n\t\treturn tx.db.bucket(name)\n\t}\n\treturn tx.db.bucket(name, folders...)\n}",
        "func (tx *Tx) CreateBucketIfNotExists(name []byte) (*Bucket, error) {\n\tif len(name) == 0 {\n\t\treturn nil, ErrBucketNameRequired\n\t}\n\n\tif len(name) > MaxBucketNameLength {\n\t\treturn nil, ErrBucketNameTooLong\n\t}\n\n\ttx.bucketLock.Lock()\n\tdefer tx.bucketLock.Unlock()\n\n\tif tx.buckets[string(name)] != nil {\n\t\treturn nil, ErrBucketExists\n\t}\n\n\tb := &Bucket{\n\t\tname:     name,\n\t\tentries: make(map[string]*Entry),\n\t}\n\n\ttx.buckets[string(name)] = b\n\treturn b, nil\n}",
        "func (b *Bucket) Delete(key []byte) error {\n\tif b.tx.db == nil {\n\t\treturn ErrTxClosed\n\t}\n\treturn b.tx.db.delete(b.tx, key)\n}",
        "func (v *Value) GobValue() (interface{}, error) {\n\tif v.gobValue != nil {\n\t\treturn v.gobValue, nil\n\t}\n\tif v.value == nil {\n\t\treturn nil, errors.New(\"value is nil\")\n\t}\n\treturn gob.NewDecoder(bytes.NewReader(v.value)).Decode(&v.gobValue)\n}",
        "func (b *Bucket) NextSequence() uint64 {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\treturn b.nextSequence()\n}",
        "func (b *Bucket) Put(key, value []byte) error {\n\tif b.tx.db == nil {\n\t\treturn ErrTxClosed\n\t}\n\tif len(key) == 0 {\n\t\treturn ErrKeyEmpty\n\t}\n\tif len(key) > MaxKeyLength {\n\t\treturn ErrKeyTooLarge\n\t}\n\tif len(value) == 0 {\n\t\treturn ErrValueEmpty\n\t}\n\tif len(value) > MaxValueLength {\n\t\treturn ErrValueTooLarge\n\t}\n\treturn b.tx.db.update(func(tx *bolt.Tx) error {\n\t\treturn tx.Bucket(b.Name).Put(key, value)\n\t})\n}",
        "func (c *Client) PutGob(key string, v interface{}) error {\n\tb, err := gob.NewEncoder(c.conn).Encode(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn c.Put(key, b)\n}",
        "func (db *DB) Drop() error {\n\tif err := db.conn.DB().DropDatabase(db.name); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}",
        "func HandleError(err error) {\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", err)\n\t}\n}",
        "func (h *Handler) Handle(w io.Writer, records []*LogRecord) error {\n\tfor _, record := range records {\n\t\tif err := h.writeRecord(w, record); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}",
        "func (m *MessageHandler) Handle(msg *Message) {\n\tm.Messages = append(m.Messages, msg)\n}",
        "func (s *Server) WaitPeerListening(p *Peer) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif s.isShutdown {\n\t\treturn\n\t}\n\n\tif s.peerListeners[p.ID()] == nil {\n\t\treturn\n\t}\n\n\tfor _, listener := range s.peerListeners[p.ID()] {\n\t\tlistener <- struct{}{}\n\t}\n\ts.peerListeners[p.ID()] = nil\n}",
        "func NewEvent(eventType EventType, data interface{}) *Event {\n\treturn &Event{\n\t\tType:      eventType,\n\t\tData:      data,\n\t\tOriginal: data,\n\t}\n}",
        "func (h *Handler) Subscribe(e Event) bool {\n\th.mu.Lock()\n\tdefer h.mu.Unlock()\n\tif h.events == nil {\n\t\th.events = make(map[Event]struct{})\n\t}\n\th.events[e] = struct{}{}\n\treturn true\n}",
        "func (b *Bus) Unsubscribe(handler interface{}) bool {\n\tb.mutex.Lock()\n\tdefer b.mutex.Unlock()\n\n\tif _, ok := b.handlers[handler]; !ok {\n\t\treturn false\n\t}\n\n\tdelete(b.handlers, handler)\n\treturn true\n}",
        "func (c *Client) Publish(event Event) error {\n\treturn c.PublishContext(context.Background(), event)\n}",
        "func (e *Event) HandleOnly(t EventType) {\n\te.Type = t\n\te.Handled = true\n}",
        "func ContextWithPublisher(ctx context.Context, bus bus.Bus) context.Context {\n\treturn context.WithValue(ctx, contextKey, bus)\n}",
        "func (c *Client) PublisherContext(ctx context.Context) (*pubsub.Publisher, error) {\n\treturn c.pubsub.PublisherContext(ctx)\n}",
        "func (c *Client) PublishNamedEvent(eventBody interface{}) (*Event, error) {\n\teventName := eventBody.(reflect.Type).Elem().Name()\n\tevent := &Event{\n\t\tName: eventName,\n\t}\n\n\tif eventBody == nil {\n\t\treturn event, nil\n\t}\n\n\tif eventBody == reflect.ValueOf(eventBody).Elem() {\n\t\tevent.Type = eventName\n\t\treturn event, nil\n\t}\n\n\tif eventBody == reflect.ValueOf(eventBody).Interface() {\n\t\tevent.Type = eventName\n\t\treturn event, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"eventBody must be of type %s, got %s\", reflect.TypeOf(eventBody).Elem().Name(), eventBody.(reflect.ValueOf(eventBody).Elem()",
        "func (e *EventBroker) PublishEventContext(ctx context.Context, event *Event) error {\n\treturn e.publishEvent(ctx, event)\n}",
        "func (c *Client) PublishNamedEventContext(ctx context.Context, eventBody interface{}, name string) error {\n\treturn c.PublishEventContext(ctx, eventBody, name)\n}",
        "func (l Level) String() string {\n\tswitch l {\n\tcase Debug:\n\t\treturn \"DEBUG\"\n\tcase Info:\n\t\treturn \"INFO\"\n\tcase Warn:\n\t\treturn \"WARN\"\n\tcase Error:\n\t\treturn \"ERROR\"\n\tcase Fatal:\n\t\treturn \"FATAL\"\n\tcase Panic:\n\t\treturn \"PANIC\"\n\tcase NoLevel:\n\t\treturn \"NO LEVEL\"\n\tdefault:\n\t\treturn \"UNKNOWN LEVEL\"\n\t}\n}",
        "func (s *State) UnmarshalJSON(data []byte) error {\n\tvar s2 State\n\tif err := json.Unmarshal(data, &s2); err != nil {\n\t\treturn err\n\t}\n\t*s = s2\n\treturn nil\n}"
    ],
    "references": [
        [
            "func (a *API) DeleteWorksheet(cfg *Worksheet) (bool, error) {\n\tif cfg == nil {\n\t\treturn false, fmt.Errorf(\"Invalid worksheet config [nil]\")\n\t}\n\treturn a.DeleteWorksheetByCID(CIDType(&cfg.CID))\n}"
        ],
        [
            "func (a *API) DeleteWorksheetByCID(cid CIDType) (bool, error) {\n\tif cid == nil || *cid == \"\" {\n\t\treturn false, fmt.Errorf(\"Invalid worksheet CID [none]\")\n\t}\n\n\tworksheetCID := string(*cid)\n\n\tmatched, err := regexp.MatchString(config.WorksheetCIDRegex, worksheetCID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !matched {\n\t\treturn false, fmt.Errorf(\"Invalid worksheet CID [%s]\", worksheetCID)\n\t}\n\n\t_, err = a.Delete(worksheetCID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn true, nil\n}"
        ],
        [
            "func (a *API) FetchContactGroup(cid CIDType) (*ContactGroup, error) {\n\tif cid == nil || *cid == \"\" {\n\t\treturn nil, fmt.Errorf(\"Invalid contact group CID [none]\")\n\t}\n\n\tgroupCID := string(*cid)\n\n\tmatched, err := regexp.MatchString(config.ContactGroupCIDRegex, groupCID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !matched {\n\t\treturn nil, fmt.Errorf(\"Invalid contact group CID [%s]\", groupCID)\n\t}\n\n\tresult, err := a.Get(groupCID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif a.Debug {\n\t\ta.Log.Printf(\"[DEBUG] fetch contact group, received JSON: %s\", string(result))\n\t}\n\n\tgroup := new(ContactGroup)\n\tif err := json.Unmarshal(result, group); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}"
        ],
        [
            "func (a *API) FetchContactGroups() (*[]ContactGroup, error) {\n\tresult, err := a.Get(config.ContactGroupPrefix)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar groups []ContactGroup\n\tif err := json.Unmarshal(result, &groups); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &groups, nil\n}"
        ],
        [
            "func (a *API) UpdateContactGroup(cfg *ContactGroup) (*ContactGroup, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"Invalid contact group config [nil]\")\n\t}\n\n\tgroupCID := string(cfg.CID)\n\n\tmatched, err := regexp.MatchString(config.ContactGroupCIDRegex, groupCID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !matched {\n\t\treturn nil, fmt.Errorf(\"Invalid contact group CID [%s]\", groupCID)\n\t}\n\n\tjsonCfg, err := json.Marshal(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif a.Debug {\n\t\ta.Log.Printf(\"[DEBUG] update contact group, sending JSON: %s\", string(jsonCfg))\n\t}\n\n\tresult, err := a.Put(groupCID, jsonCfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgroup := &ContactGroup{}\n\tif err := json.Unmarshal(result, group); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}"
        ],
        [
            "func (a *API) CreateContactGroup(cfg *ContactGroup) (*ContactGroup, error) {\n\tif cfg == nil {\n\t\treturn nil, fmt.Errorf(\"Invalid contact group config [nil]\")\n\t}\n\n\tjsonCfg, err := json.Marshal(cfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif a.Debug {\n\t\ta.Log.Printf(\"[DEBUG] create contact group, sending JSON: %s\", string(jsonCfg))\n\t}\n\n\tresult, err := a.Post(config.ContactGroupPrefix, jsonCfg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgroup := &ContactGroup{}\n\tif err := json.Unmarshal(result, group); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn group, nil\n}"
        ],
        [
            "func (a *API) DeleteContactGroup(cfg *ContactGroup) (bool, error) {\n\tif cfg == nil {\n\t\treturn false, fmt.Errorf(\"Invalid contact group config [nil]\")\n\t}\n\treturn a.DeleteContactGroupByCID(CIDType(&cfg.CID))\n}"
        ],
        [
            "func (a *API) FetchBroker(cid CIDType) (*Broker, error) {\n\tif cid == nil || *cid == \"\" {\n\t\treturn nil, fmt.Errorf(\"Invalid broker CID [none]\")\n\t}\n\n\tbrokerCID := string(*cid)\n\n\tmatched, err := regexp.MatchString(config.BrokerCIDRegex, brokerCID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !matched {\n\t\treturn nil, fmt.Errorf(\"Invalid broker CID [%s]\", brokerCID)\n\t}\n\n\tresult, err := a.Get(brokerCID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif a.Debug {\n\t\ta.Log.Printf(\"[DEBUG] fetch broker, received JSON: %s\", string(result))\n\t}\n\n\tresponse := new(Broker)\n\tif err := json.Unmarshal(result, &response); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn response, nil\n\n}"
        ],
        [
            "func (a *API) FetchBrokers() (*[]Broker, error) {\n\tresult, err := a.Get(config.BrokerPrefix)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response []Broker\n\tif err := json.Unmarshal(result, &response); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &response, nil\n}"
        ],
        [
            "func (cm *CheckManager) ActivateMetric(name string) bool {\n\tcm.availableMetricsmu.Lock()\n\tdefer cm.availableMetricsmu.Unlock()\n\n\tactive, exists := cm.availableMetrics[name]\n\n\tif !exists {\n\t\treturn true\n\t}\n\n\tif !active && cm.forceMetricActivation {\n\t\treturn true\n\t}\n\n\treturn false\n}"
        ],
        [
            "func (cm *CheckManager) AddMetricTags(metricName string, tags []string, appendTags bool) bool {\n\ttagsUpdated := false\n\n\tif appendTags && len(tags) == 0 {\n\t\treturn tagsUpdated\n\t}\n\n\tcurrentTags, exists := cm.metricTags[metricName]\n\tif !exists {\n\t\tfoundMetric := false\n\n\t\tif cm.checkBundle != nil {\n\t\t\tfor _, metric := range cm.checkBundle.Metrics {\n\t\t\t\tif metric.Name == metricName {\n\t\t\t\t\tfoundMetric = true\n\t\t\t\t\tcurrentTags = metric.Tags\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !foundMetric {\n\t\t\tcurrentTags = []string{}\n\t\t}\n\t}\n\n\taction := \"\"\n\tif appendTags {\n\t\tnumNewTags := countNewTags(currentTags, tags)\n\t\tif numNewTags > 0 {\n\t\t\taction = \"Added\"\n\t\t\tcurrentTags = append(currentTags, tags...)\n\t\t\ttagsUpdated = true\n\t\t}\n\t} else {\n\t\tif len(tags) != len(currentTags) {\n\t\t\taction = \"Set\"\n\t\t\tcurrentTags = tags\n\t\t\ttagsUpdated = true\n\t\t} else {\n\t\t\tnumNewTags := countNewTags(currentTags, tags)\n\t\t\tif numNewTags > 0 {\n\t\t\t\taction = \"Set\"\n\t\t\t\tcurrentTags = tags\n\t\t\t\ttagsUpdated = true\n\t\t\t}\n\t\t}\n\t}\n\n\tif tagsUpdated {\n\t\tcm.metricTags[metricName] = currentTags\n\t}\n\n\tif cm.Debug && action != \"\" {\n\t\tcm.Log.Printf(\"[DEBUG] %s metric tag(s) %s %v\\n\", action, metricName, tags)\n\t}\n\n\treturn tagsUpdated\n}"
        ],
        [
            "func (cm *CheckManager) addNewMetrics(newMetrics map[string]*api.CheckBundleMetric) bool {\n\tupdatedCheckBundle := false\n\n\tif cm.checkBundle == nil || len(newMetrics) == 0 {\n\t\treturn updatedCheckBundle\n\t}\n\n\tcm.cbmu.Lock()\n\tdefer cm.cbmu.Unlock()\n\n\tnumCurrMetrics := len(cm.checkBundle.Metrics)\n\tnumNewMetrics := len(newMetrics)\n\n\tif numCurrMetrics+numNewMetrics >= cap(cm.checkBundle.Metrics) {\n\t\tnm := make([]api.CheckBundleMetric, numCurrMetrics+numNewMetrics)\n\t\tcopy(nm, cm.checkBundle.Metrics)\n\t\tcm.checkBundle.Metrics = nm\n\t}\n\n\tcm.checkBundle.Metrics = cm.checkBundle.Metrics[0 : numCurrMetrics+numNewMetrics]\n\n\ti := 0\n\tfor _, metric := range newMetrics {\n\t\tcm.checkBundle.Metrics[numCurrMetrics+i] = *metric\n\t\ti++\n\t\tupdatedCheckBundle = true\n\t}\n\n\tif updatedCheckBundle {\n\t\tcm.forceCheckUpdate = true\n\t}\n\n\treturn updatedCheckBundle\n}"
        ],
        [
            "func (cm *CheckManager) inventoryMetrics() {\n\tavailableMetrics := make(map[string]bool)\n\tfor _, metric := range cm.checkBundle.Metrics {\n\t\tavailableMetrics[metric.Name] = metric.Status == \"active\"\n\t}\n\tcm.availableMetricsmu.Lock()\n\tcm.availableMetrics = availableMetrics\n\tcm.availableMetricsmu.Unlock()\n}"
        ],
        [
            "func countNewTags(currTags []string, newTags []string) int {\n\tif len(newTags) == 0 {\n\t\treturn 0\n\t}\n\n\tif len(currTags) == 0 {\n\t\treturn len(newTags)\n\t}\n\n\tnewTagCount := 0\n\n\tfor _, newTag := range newTags {\n\t\tfound := false\n\t\tfor _, currTag := range currTags {\n\t\t\tif newTag == currTag {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tnewTagCount++\n\t\t}\n\t}\n\n\treturn newTagCount\n}"
        ],
        [
            "func (rs *Ruleset) Pluralize(word string) string {\n\tif len(word) == 0 {\n\t\treturn word\n\t}\n\tif rs.isUncountable(word) {\n\t\treturn word\n\t}\n\tfor _, rule := range rs.plurals {\n\t\tif rule.exact {\n\t\t\tif word == rule.suffix {\n\t\t\t\treturn rule.replacement\n\t\t\t}\n\t\t} else {\n\t\t\tif strings.HasSuffix(word, rule.suffix) {\n\t\t\t\treturn replaceLast(word, rule.suffix, rule.replacement)\n\t\t\t}\n\t\t}\n\t}\n\treturn word + \"s\"\n}"
        ],
        [
            "func (rs *Ruleset) Singularize(word string) string {\n\tif len(word) == 0 {\n\t\treturn word\n\t}\n\tif rs.isUncountable(word) {\n\t\treturn word\n\t}\n\tfor _, rule := range rs.singulars {\n\t\tif rule.exact {\n\t\t\tif word == rule.suffix {\n\t\t\t\treturn rule.replacement\n\t\t\t}\n\t\t} else {\n\t\t\tif strings.HasSuffix(word, rule.suffix) {\n\t\t\t\treturn replaceLast(word, rule.suffix, rule.replacement)\n\t\t\t}\n\t\t}\n\t}\n\treturn word\n}"
        ],
        [
            "func (rs *Ruleset) Capitalize(word string) string {\n\treturn strings.ToUpper(word[:1]) + word[1:]\n}"
        ],
        [
            "func (rs *Ruleset) Camelize(word string) string {\n\twords := splitAtCaseChangeWithTitlecase(word)\n\treturn strings.Join(words, \"\")\n}"
        ],
        [
            "func getSuitableAlgFromCurve(curve elliptic.Curve) (jwt.Algorithm, error) {\n\tcurveBitSize := curve.Params().BitSize\n\n\t// compute curve key len\n\tkeyLen := curveBitSize / 8\n\tif curveBitSize%8 > 0 {\n\t\tkeyLen++\n\t}\n\n\t// determine alg\n\tvar alg jwt.Algorithm\n\tswitch 2 * keyLen {\n\tcase 64:\n\t\talg = jwt.ES256\n\tcase 96:\n\t\talg = jwt.ES384\n\tcase 132:\n\t\talg = jwt.ES512\n\n\tdefault:\n\t\treturn jwt.NONE, fmt.Errorf(\"invalid key length %d\", keyLen)\n\t}\n\n\treturn alg, nil\n}"
        ],
        [
            "func getAlgFromKeyData(pem pemutil.Store) (jwt.Algorithm, error) {\n\tfor _, v := range pem {\n\t\t// loop over crypto primitives in pemstore, and do type assertion. if\n\t\t// ecdsa.{PublicKey,PrivateKey} found, then use corresponding ESXXX as\n\t\t// algo. if rsa, then use DefaultRSAAlgorithm. if []byte, then use\n\t\t// DefaultHMACAlgorithm.\n\t\tswitch k := v.(type) {\n\t\tcase []byte:\n\t\t\treturn jwt.HS512, nil\n\n\t\tcase *ecdsa.PrivateKey:\n\t\t\treturn getSuitableAlgFromCurve(k.Curve)\n\n\t\tcase *ecdsa.PublicKey:\n\t\t\treturn getSuitableAlgFromCurve(k.Curve)\n\n\t\tcase *rsa.PrivateKey:\n\t\t\treturn jwt.PS512, nil\n\n\t\tcase *rsa.PublicKey:\n\t\t\treturn jwt.PS512, nil\n\t\t}\n\t}\n\n\treturn jwt.NONE, errors.New(\"cannot determine key type\")\n}"
        ],
        [
            "func buildEncArgs(args []string) ([]byte, error) {\n\tm := make(map[string]interface{})\n\n\t// loop over args, splitting on '=', and attempt parsing of value\n\tfor _, arg := range args {\n\t\ta := strings.SplitN(arg, \"=\", 2)\n\t\tvar val interface{}\n\n\t\t// attempt to parse\n\t\tif len(a) == 1 { // assume bool, set as true\n\t\t\tval = true\n\t\t} else if u, err := strconv.ParseUint(a[1], 10, 64); err == nil {\n\t\t\tval = u\n\t\t} else if i, err := strconv.ParseInt(a[1], 10, 64); err == nil {\n\t\t\tval = i\n\t\t} else if f, err := strconv.ParseFloat(a[1], 64); err == nil {\n\t\t\tval = f\n\t\t} else if b, err := strconv.ParseBool(a[1]); err == nil {\n\t\t\tval = b\n\t\t} else if s, err := strconv.Unquote(a[1]); err == nil {\n\t\t\tval = s\n\t\t} else { // treat as string\n\t\t\tval = a[1]\n\t\t}\n\n\t\tm[a[0]] = val\n\t}\n\n\treturn json.Marshal(m)\n}"
        ],
        [
            "func doDec(signer jwt.Signer, in []byte) ([]byte, error) {\n\tvar err error\n\n\t// decode token\n\tut := UnstructuredToken{}\n\terr = signer.Decode(bytes.TrimSpace(in), &ut)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// pretty format output\n\tout, err := json.MarshalIndent(&ut, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn out, nil\n}"
        ],
        [
            "func doEnc(signer jwt.Signer, in []byte) ([]byte, error) {\n\tvar err error\n\n\t// make sure its valid json first\n\tm := make(map[string]interface{})\n\n\t// do the initial decode\n\td := json.NewDecoder(bytes.NewBuffer(in))\n\td.UseNumber()\n\terr = d.Decode(&m)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// encode claims\n\tout, err := signer.Encode(&m)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn out, nil\n}"
        ],
        [
            "func Transport(transport http.RoundTripper) Option {\n\treturn func(gsa *GServiceAccount) error {\n\t\tgsa.transport = transport\n\t\treturn nil\n\t}\n}"
        ],
        [
            "func Proxy(proxy string) Option {\n\treturn func(gsa *GServiceAccount) error {\n\t\tu, err := url.Parse(proxy)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn Transport(&http.Transport{\n\t\t\tProxy: http.ProxyURL(u),\n\t\t})(gsa)\n\t}\n}"
        ],
        [
            "func Expiration(expiration time.Duration) Option {\n\treturn func(gsa *GServiceAccount) error {\n\t\tgsa.expiration = expiration\n\t\treturn nil\n\t}\n}"
        ],
        [
            "func Encode(alg Algorithm, signer Signer, obj interface{}) ([]byte, error) {\n\tvar err error\n\n\t// grab encode targets\n\theaderObj, payloadObj, err := encodeTargets(alg, obj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// json encode header\n\theader, err := json.Marshal(headerObj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// b64 encode playload\n\theaderEnc := make([]byte, b64.EncodedLen(len(header)))\n\tb64.Encode(headerEnc, header)\n\n\t// json encode payload\n\tpayload, err := json.Marshal(payloadObj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// b64 encode playload\n\tpayloadEnc := make([]byte, b64.EncodedLen(len(payload)))\n\tb64.Encode(payloadEnc, payload)\n\n\t// allocate result\n\tvar buf bytes.Buffer\n\n\t// add header\n\t_, err = buf.Write(headerEnc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// add 1st separator\n\t_, err = buf.Write(tokenSep)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// add payload\n\t_, err = buf.Write(payloadEnc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// sign\n\tsig, err := signer.Sign(buf.Bytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// add 2nd separator\n\t_, err = buf.Write(tokenSep)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// add sig\n\t_, err = buf.Write(sig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buf.Bytes(), nil\n}"
        ],
        [
            "func PeekHeaderField(buf []byte, field string) (string, error) {\n\treturn peekField(buf, field, tokenPositionHeader)\n}"
        ],
        [
            "func PeekAlgorithm(buf []byte) (Algorithm, error) {\n\talg := NONE\n\n\t// get alg\n\talgVal, err := PeekHeaderField(buf, \"alg\")\n\tif err != nil {\n\t\treturn NONE, err\n\t}\n\n\t// decode alg\n\terr = (&alg).UnmarshalText([]byte(algVal))\n\tif err != nil {\n\t\treturn NONE, err\n\t}\n\n\treturn alg, nil\n}"
        ],
        [
            "func PeekAlgorithmAndIssuer(buf []byte) (Algorithm, string, error) {\n\tvar err error\n\n\t// get algorithm\n\talg, err := PeekAlgorithm(buf)\n\tif err != nil {\n\t\treturn NONE, \"\", err\n\t}\n\n\t// get issuer\n\tissuer, err := PeekPayloadField(buf, \"iss\")\n\tif err != nil {\n\t\treturn NONE, \"\", err\n\t}\n\n\treturn alg, issuer, nil\n}"
        ],
        [
            "func NewEllipticSigner(alg Algorithm, curve elliptic.Curve) func(Store, crypto.Hash) (Signer, error) {\n\tcurveBitSize := curve.Params().BitSize\n\n\t// precompute curve key len\n\tkeyLen := curveBitSize / 8\n\tif curveBitSize%8 > 0 {\n\t\tkeyLen++\n\t}\n\n\treturn func(store Store, hash crypto.Hash) (Signer, error) {\n\t\tvar ok bool\n\t\tvar privRaw, pubRaw interface{}\n\t\tvar priv *ecdsa.PrivateKey\n\t\tvar pub *ecdsa.PublicKey\n\n\t\t// check private key\n\t\tif privRaw, ok = store.PrivateKey(); ok {\n\t\t\tif priv, ok = privRaw.(*ecdsa.PrivateKey); !ok {\n\t\t\t\treturn nil, ErrInvalidPrivateKey\n\t\t\t}\n\n\t\t\t// check curve type matches private key curve type\n\t\t\tif curveBitSize != priv.Curve.Params().BitSize {\n\t\t\t\treturn nil, ErrInvalidPrivateKeySize\n\t\t\t}\n\t\t}\n\n\t\t// check public key\n\t\tif pubRaw, ok = store.PublicKey(); ok {\n\t\t\tif pub, ok = pubRaw.(*ecdsa.PublicKey); !ok {\n\t\t\t\treturn nil, ErrInvalidPublicKey\n\t\t\t}\n\t\t}\n\n\t\t// check that either a private or public key has been provided\n\t\tif priv == nil && pub == nil {\n\t\t\treturn nil, ErrMissingPrivateOrPublicKey\n\t\t}\n\n\t\treturn &EccSigner{\n\t\t\talg:    alg,\n\t\t\tcurve:  curve,\n\t\t\thash:   hash,\n\t\t\tpriv:   priv,\n\t\t\tpub:    pub,\n\t\t\tkeyLen: keyLen,\n\t\t}, nil\n\t}\n}"
        ],
        [
            "func NewTokenSource(signer jwt.Signer, tokenURL string, ctxt context.Context, opts ...Option) (*Bearer, error) {\n\tvar err error\n\n\tb := &Bearer{\n\t\tsigner:   signer,\n\t\ttokenURL: tokenURL,\n\t\tcontext:  ctxt,\n\t\tclaims:   make(map[string]interface{}),\n\t}\n\n\t// apply opts\n\tfor _, o := range opts {\n\t\tif err = o(b); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"jwt/bearer: %v\", err)\n\t\t}\n\t}\n\n\treturn b, nil\n}"
        ],
        [
            "func (b *Bearer) Client() *http.Client {\n\treturn &http.Client{\n\t\tTransport: &oauth2.Transport{\n\t\t\tSource: b,\n\t\t},\n\t}\n}"
        ],
        [
            "func (r RSAMethod) Sign(rand io.Reader, priv *rsa.PrivateKey, hash crypto.Hash, buf []byte) ([]byte, error) {\n\treturn r.SignFunc(rand, priv, hash, buf)\n}"
        ],
        [
            "func (r RSAMethod) Verify(pub *rsa.PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error {\n\treturn r.VerifyFunc(pub, hash, hashed, sig)\n}"
        ],
        [
            "func NewRSASigner(alg Algorithm, method RSASignerVerifier) func(Store, crypto.Hash) (Signer, error) {\n\treturn func(store Store, hash crypto.Hash) (Signer, error) {\n\t\tvar ok bool\n\t\tvar privRaw, pubRaw interface{}\n\t\tvar priv *rsa.PrivateKey\n\t\tvar pub *rsa.PublicKey\n\n\t\t// check private key\n\t\tif privRaw, ok = store.PrivateKey(); ok {\n\t\t\tif priv, ok = privRaw.(*rsa.PrivateKey); !ok {\n\t\t\t\treturn nil, ErrInvalidPrivateKey\n\t\t\t}\n\n\t\t\t// check private key length\n\t\t\tif priv.N.BitLen() < RSAMinimumBitLen {\n\t\t\t\treturn nil, ErrInvalidPrivateKeySize\n\t\t\t}\n\t\t}\n\n\t\t// check public key\n\t\tif pubRaw, ok = store.PublicKey(); ok {\n\t\t\tif pub, ok = pubRaw.(*rsa.PublicKey); !ok {\n\t\t\t\treturn nil, ErrInvalidPublicKey\n\t\t\t}\n\n\t\t\t// check public key length\n\t\t\tif pub.N.BitLen() < RSAMinimumBitLen {\n\t\t\t\treturn nil, ErrInvalidPublicKeySize\n\t\t\t}\n\t\t}\n\n\t\t// check that either a private or public key has been provided\n\t\tif priv == nil && pub == nil {\n\t\t\treturn nil, ErrMissingPrivateOrPublicKey\n\t\t}\n\n\t\treturn &RSASigner{\n\t\t\talg:    alg,\n\t\t\tmethod: method,\n\t\t\thash:   hash,\n\t\t\tpriv:   priv,\n\t\t\tpub:    pub,\n\t\t}, nil\n\t}\n}"
        ],
        [
            "func getFieldWithTag(obj interface{}, tagName string) *reflect.Value {\n\tobjVal := reflect.ValueOf(obj)\n\tif objVal.Kind() != reflect.Struct {\n\t\tobjVal = objVal.Elem()\n\t}\n\n\tfor i := 0; i < objVal.NumField(); i++ {\n\t\tfieldType := objVal.Type().Field(i)\n\t\tif tagName == fieldType.Tag.Get(\"jwt\") {\n\t\t\tfield := objVal.Field(i)\n\t\t\treturn &field\n\t\t}\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func decodeToObjOrFieldWithTag(buf []byte, obj interface{}, tagName string, defaultObj interface{}) error {\n\t// reflect values\n\tobjValElem := reflect.ValueOf(obj).Elem()\n\tdefaultObjValElem := reflect.ValueOf(defaultObj).Elem()\n\n\t// first check type, if same type, then set\n\tif objValElem.Type() == defaultObjValElem.Type() {\n\t\tobjValElem.Set(defaultObjValElem)\n\t\treturn nil\n\t}\n\n\t// get field with specified jwt tagName (if any)\n\tfieldVal := getFieldWithTag(obj, tagName)\n\tif fieldVal != nil {\n\t\t// check field type and defaultObj type, if same, set\n\t\tif fieldVal.Type() == defaultObjValElem.Type() {\n\t\t\tfieldVal.Set(defaultObjValElem)\n\t\t\treturn nil\n\t\t}\n\n\t\t// otherwise, assign obj address of field\n\t\tobj = fieldVal.Addr().Interface()\n\t}\n\n\t// decode json\n\td := json.NewDecoder(bytes.NewBuffer(buf))\n\td.UseNumber()\n\treturn d.Decode(obj)\n}"
        ],
        [
            "func grabEncodeTargets(alg Algorithm, obj interface{}) (interface{}, interface{}, error) {\n\tvar headerObj, payloadObj interface{}\n\n\t// get header\n\tif headerVal := getFieldWithTag(obj, \"header\"); headerVal != nil {\n\t\theaderObj = headerVal.Interface()\n\t}\n\tif headerObj == nil {\n\t\theaderObj = alg.Header()\n\t}\n\n\t// get payload\n\tif payloadVal := getFieldWithTag(obj, \"payload\"); payloadVal != nil {\n\t\tpayloadObj = payloadVal.Interface()\n\t}\n\tif payloadObj == nil {\n\t\tpayloadObj = obj\n\t}\n\n\treturn headerObj, payloadObj, nil\n}"
        ],
        [
            "func encodeTargets(alg Algorithm, obj interface{}) (interface{}, interface{}, error) {\n\t// determine what to encode\n\tswitch val := obj.(type) {\n\tcase *Token:\n\t\treturn val.Header, val.Payload, nil\n\t}\n\n\tobjVal := reflect.ValueOf(obj)\n\tobjKind := objVal.Kind()\n\tif objKind == reflect.Struct || (objKind == reflect.Ptr && objVal.Elem().Kind() == reflect.Struct) {\n\t\treturn grabEncodeTargets(alg, obj)\n\t}\n\n\treturn alg.Header(), obj, nil\n}"
        ],
        [
            "func peekField(buf []byte, fieldName string, pos tokenPosition) (string, error) {\n\tvar err error\n\n\t// split token\n\tut := UnverifiedToken{}\n\terr = DecodeUnverifiedToken(buf, &ut)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// determine position decode\n\tvar typ string\n\tvar b []byte\n\tswitch pos {\n\tcase tokenPositionHeader:\n\t\ttyp = \"header\"\n\t\tb = ut.Header\n\tcase tokenPositionPayload:\n\t\ttyp = \"payload\"\n\t\tb = ut.Payload\n\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"invalid field %d\", pos)\n\t}\n\n\t// b64 decode\n\tdec, err := b64.DecodeString(string(b))\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not decode token %s\", typ)\n\t}\n\n\t// json decode\n\tm := make(map[string]interface{})\n\terr = json.Unmarshal(dec, &m)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif val, ok := m[fieldName]; ok {\n\t\treturn fmt.Sprintf(\"%v\", val), nil\n\t}\n\n\treturn \"\", fmt.Errorf(\"token %s field %s not present or invalid\", typ, fieldName)\n}"
        ],
        [
            "func ExpiresIn(d time.Duration) Option {\n\treturn func(tok *Bearer) error {\n\t\tif d != 0 {\n\t\t\ttok.addExpiration = true\n\t\t\ttok.expiresIn = d\n\t\t} else {\n\t\t\ttok.addExpiration = false\n\t\t\ttok.expiresIn = 0\n\t\t}\n\n\t\treturn nil\n\t}\n}"
        ],
        [
            "func Claim(name string, v interface{}) Option {\n\treturn func(tok *Bearer) error {\n\t\tif tok.claims == nil {\n\t\t\treturn errors.New(\"attempting to add claim to improperly created token\")\n\t\t}\n\n\t\ttok.claims[name] = v\n\n\t\treturn nil\n\t}\n}"
        ],
        [
            "func Transport(transport http.RoundTripper) Option {\n\treturn func(tok *Bearer) error {\n\t\ttok.transport = transport\n\t\treturn nil\n\t}\n}"
        ],
        [
            "func NewHMACSigner(alg Algorithm) func(Store, crypto.Hash) (Signer, error) {\n\treturn func(store Store, hash crypto.Hash) (Signer, error) {\n\t\tvar ok bool\n\t\tvar keyRaw interface{}\n\t\tvar key []byte\n\n\t\t// check private key\n\t\tif keyRaw, ok = store.PrivateKey(); !ok {\n\t\t\treturn nil, ErrMissingPrivateKey\n\t\t}\n\n\t\t// check key type\n\t\tif key, ok = keyRaw.([]byte); !ok {\n\t\t\treturn nil, ErrInvalidPrivateKey\n\t\t}\n\n\t\treturn &HmacSigner{\n\t\t\talg:  alg,\n\t\t\thash: hash,\n\t\t\tkey:  key,\n\t\t}, nil\n\t}\n}"
        ],
        [
            "func FromJSON(buf []byte, opts ...Option) (*GServiceAccount, error) {\n\tvar err error\n\n\t// unmarshal\n\tgsa := new(GServiceAccount)\n\tif err = json.Unmarshal(buf, gsa); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// apply opts\n\tfor _, o := range opts {\n\t\tif err = o(gsa); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn gsa, nil\n}"
        ],
        [
            "func FromReader(r io.Reader, opts ...Option) (*GServiceAccount, error) {\n\tbuf, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn FromJSON(buf, opts...)\n}"
        ],
        [
            "func FromFile(path string, opts ...Option) (*GServiceAccount, error) {\n\tbuf, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn FromJSON(buf, opts...)\n}"
        ],
        [
            "func (gsa *GServiceAccount) Signer() (jwt.Signer, error) {\n\tgsa.mu.Lock()\n\tdefer gsa.mu.Unlock()\n\n\tif gsa.signer == nil {\n\t\tkeyset, err := pemutil.DecodeBytes([]byte(gsa.PrivateKey))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"jwt/gserviceaccount: could not decode private key: %v\", err)\n\t\t}\n\t\tkeyset.AddPublicKeys()\n\n\t\ts, err := DefaultAlgorithm.New(keyset)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgsa.signer = s\n\t}\n\n\treturn gsa.signer, nil\n}"
        ],
        [
            "func (alg Algorithm) Encode(signer Signer, obj interface{}) ([]byte, error) {\n\treturn Encode(alg, signer, obj)\n}"
        ],
        [
            "func (alg *Algorithm) UnmarshalText(buf []byte) error {\n\tswitch string(buf) {\n\t// hmac\n\tcase \"HS256\":\n\t\t*alg = HS256\n\tcase \"HS384\":\n\t\t*alg = HS384\n\tcase \"HS512\":\n\t\t*alg = HS512\n\n\t// rsa-pkcs1v15\n\tcase \"RS256\":\n\t\t*alg = RS256\n\tcase \"RS384\":\n\t\t*alg = RS384\n\tcase \"RS512\":\n\t\t*alg = RS512\n\n\t// ecc\n\tcase \"ES256\":\n\t\t*alg = ES256\n\tcase \"ES384\":\n\t\t*alg = ES384\n\tcase \"ES512\":\n\t\t*alg = ES512\n\n\t// rsa-pss\n\tcase \"PS256\":\n\t\t*alg = PS256\n\tcase \"PS384\":\n\t\t*alg = PS384\n\tcase \"PS512\":\n\t\t*alg = PS512\n\n\t// error\n\tdefault:\n\t\treturn ErrInvalidAlgorithm\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func DecodeUnverifiedToken(buf []byte, ut *UnverifiedToken) error {\n\tb := bytes.Split(buf, tokenSep)\n\tif len(b) != 3 {\n\t\treturn ErrInvalidToken\n\t}\n\n\tut.Header = b[0]\n\tut.Payload = b[1]\n\tut.Signature = b[2]\n\n\treturn nil\n}"
        ],
        [
            "func (ks *Keystore) PublicKey() (crypto.PublicKey, bool) {\n\tks.rw.RLock()\n\tkey, pub := ks.Key, ks.PubKey\n\tks.rw.RUnlock()\n\tif pub != nil {\n\t\treturn pub, true\n\t}\n\n\t// generate the public key\n\tif key != nil {\n\t\tks.rw.Lock()\n\t\tdefer ks.rw.Unlock()\n\n\t\tif x, ok := key.(interface {\n\t\t\tPublic() crypto.PublicKey\n\t\t}); ok {\n\t\t\tks.PubKey = x.Public()\n\t\t}\n\n\t\treturn ks.PubKey, ks.PubKey != nil\n\t}\n\n\treturn nil, false\n}"
        ],
        [
            "func (ks *Keystore) PrivateKey() (crypto.PrivateKey, bool) {\n\tks.rw.RLock()\n\tdefer ks.rw.RUnlock()\n\treturn ks.Key, ks.Key != nil\n}"
        ],
        [
            "func (t *Transport) RegisterLocation(loc string, path string) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif t.loc == nil {\n\t\tt.loc = make(map[string]string)\n\t}\n\tif _, exists := t.loc[loc]; exists {\n\t\tpanic(\"location \" + loc + \" already registered\")\n\t}\n\tt.loc[loc] = path\n}"
        ],
        [
            "func NewArena(size uint32) *Arena {\n\t// Don't store data at position 0 in order to reserve offset=0 as a kind\n\t// of nil pointer.\n\tout := &Arena{\n\t\tn:   1,\n\t\tbuf: make([]byte, size),\n\t}\n\n\treturn out\n}"
        ],
        [
            "func NewSkiplist(arena *Arena) *Skiplist {\n\t// Allocate head and tail nodes.\n\thead, err := newNode(arena, maxHeight)\n\tif err != nil {\n\t\tpanic(\"arenaSize is not large enough to hold the head node\")\n\t}\n\n\ttail, err := newNode(arena, maxHeight)\n\tif err != nil {\n\t\tpanic(\"arenaSize is not large enough to hold the tail node\")\n\t}\n\n\t// Link all head/tail levels together.\n\theadOffset := arena.GetPointerOffset(unsafe.Pointer(head))\n\ttailOffset := arena.GetPointerOffset(unsafe.Pointer(tail))\n\tfor i := 0; i < maxHeight; i++ {\n\t\thead.tower[i].nextOffset = tailOffset\n\t\ttail.tower[i].prevOffset = headOffset\n\t}\n\n\tskl := &Skiplist{\n\t\tarena:  arena,\n\t\thead:   head,\n\t\ttail:   tail,\n\t\theight: 1,\n\t}\n\n\treturn skl\n}"
        ],
        [
            "func (it *Iterator) Init(list *Skiplist) {\n\tit.list = list\n\tit.arena = list.arena\n\tit.nd = nil\n\tit.value = 0\n}"
        ],
        [
            "func (it *Iterator) Value() []byte {\n\tvalOffset, valSize := decodeValue(it.value)\n\treturn it.arena.GetBytes(valOffset, uint32(valSize))\n}"
        ],
        [
            "func (it *Iterator) Set(val []byte, meta uint16) error {\n\tnew, err := it.list.allocVal(val, meta)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn it.trySetValue(new)\n}"
        ],
        [
            "func (it *Iterator) SetMeta(meta uint16) error {\n\t// Try to reuse the same value bytes. Do this only in the case where meta\n\t// is increasing, in order to avoid cases where the meta is changed, then\n\t// changed back to the original value, which would make it impossible to\n\t// detect updates had occurred in the interim.\n\tif meta > decodeMeta(it.value) {\n\t\tvalOffset, valSize := decodeValue(it.value)\n\t\tnew := encodeValue(valOffset, valSize, meta)\n\t\treturn it.trySetValue(new)\n\t}\n\n\treturn it.Set(it.Value(), meta)\n}"
        ],
        [
            "func (it *Iterator) Delete() error {\n\tif !atomic.CompareAndSwapUint64(&it.nd.value, it.value, deletedVal) {\n\t\tif it.setNode(it.nd, false) {\n\t\t\treturn ErrRecordUpdated\n\t\t}\n\n\t\treturn nil\n\t}\n\n\t// Deletion succeeded, so position iterator on next non-deleted node.\n\tnext := it.list.getNext(it.nd, 0)\n\tit.setNode(next, false)\n\treturn nil\n}"
        ],
        [
            "func isSameArray(val1, val2 []byte) bool {\n\tif len(val1) == len(val2) && len(val1) > 0 {\n\t\treturn &val1[0] == &val2[0]\n\t}\n\n\treturn false\n}"
        ],
        [
            "func New(\n\tctx context.Context,\n\thost string,\n\topts ClientOptions,\n\tdebug bool) (Client, error) {\n\n\tif host == \"\" {\n\t\treturn nil, errNewClient\n\t}\n\n\thost = strings.Replace(host, \"/api\", \"\", 1)\n\n\tc := &client{\n\t\thttp: &http.Client{},\n\t\thost: host,\n\t}\n\n\tif opts.Timeout != 0 {\n\t\tc.http.Timeout = opts.Timeout\n\t}\n\n\tif opts.Insecure {\n\t\tc.http.Transport = &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\tInsecureSkipVerify: true,\n\t\t\t},\n\t\t}\n\t}\n\n\tif opts.UseCerts {\n\t\tpool, err := x509.SystemCertPool()\n\t\tif err != nil {\n\t\t\treturn nil, errSysCerts\n\t\t}\n\t\tc.http.Transport = &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\tRootCAs:            pool,\n\t\t\t\tInsecureSkipVerify: opts.Insecure,\n\t\t\t},\n\t\t}\n\t}\n\n\tif opts.ShowHTTP {\n\t\tc.showHTTP = true\n\t}\n\n\tc.debug = debug\n\n\treturn c, nil\n}"
        ],
        [
            "func WriteIndentedN(w io.Writer, b []byte, n int) error {\n\ts := bufio.NewScanner(bytes.NewReader(b))\n\tif !s.Scan() {\n\t\treturn nil\n\t}\n\tl := s.Text()\n\tfor {\n\t\tfor x := 0; x < n; x++ {\n\t\t\tif _, err := fmt.Fprint(w, \" \"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif _, err := fmt.Fprint(w, l); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !s.Scan() {\n\t\t\tbreak\n\t\t}\n\t\tl = s.Text()\n\t\tif _, err := fmt.Fprint(w, \"\\n\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}"
        ],
        [
            "func WriteIndented(w io.Writer, b []byte) error {\n\treturn WriteIndentedN(w, b, 4)\n}"
        ],
        [
            "func NewReporter(bufferSize, poolSize int, transport http.RoundTripper) Reporter {\n\tr := new(BasicReporter)\n\tif transport == nil {\n\t\ttransport = &http.Transport{\n\t\t\t// Allow for an idle connection per goroutine.\n\t\t\tMaxIdleConnsPerHost: poolSize,\n\t\t}\n\t}\n\tr.client = &http.Client{Transport: transport}\n\tr.reports = make(chan *statReport, bufferSize)\n\tr.done = make(chan bool)\n\tr.wg = new(sync.WaitGroup)\n\tfor i := 0; i < poolSize; i++ {\n\t\tr.wg.Add(1)\n\t\tgo r.processReports()\n\t}\n\treturn r\n}"
        ],
        [
            "func PostCount(statKey, userKey string, count int) error {\n\treturn DefaultReporter.PostCount(statKey, userKey, count)\n}"
        ],
        [
            "func PostCountTime(statKey, userKey string, count int, timestamp int64) error {\n\treturn DefaultReporter.PostCountTime(statKey, userKey, count, timestamp)\n}"
        ],
        [
            "func PostValue(statKey, userKey string, value float64) error {\n\treturn DefaultReporter.PostValue(statKey, userKey, value)\n}"
        ],
        [
            "func PostValueTime(statKey, userKey string, value float64, timestamp int64) error {\n\treturn DefaultReporter.PostValueTime(statKey, userKey, value, timestamp)\n}"
        ],
        [
            "func PostEZCount(statName, ezkey string, count int) error {\n\treturn DefaultReporter.PostEZCount(statName, ezkey, count)\n}"
        ],
        [
            "func PostEZCountTime(statName, ezkey string, count int, timestamp int64) error {\n\treturn DefaultReporter.PostEZCountTime(statName, ezkey, count, timestamp)\n}"
        ],
        [
            "func PostEZValue(statName, ezkey string, value float64) error {\n\treturn DefaultReporter.PostEZValue(statName, ezkey, value)\n}"
        ],
        [
            "func PostEZValueTime(statName, ezkey string, value float64, timestamp int64) error {\n\treturn DefaultReporter.PostEZValueTime(statName, ezkey, value, timestamp)\n}"
        ],
        [
            "func (r *BasicReporter) PostCount(statKey, userKey string, count int) error {\n\tr.add(newClassicStatCount(statKey, userKey, count))\n\treturn nil\n}"
        ],
        [
            "func (r *BasicReporter) PostCountTime(statKey, userKey string, count int, timestamp int64) error {\n\tx := newClassicStatCount(statKey, userKey, count)\n\tx.Timestamp = timestamp\n\tr.add(x)\n\treturn nil\n}"
        ],
        [
            "func (r *BasicReporter) PostCountOne(statKey, userKey string) error {\n\treturn r.PostCount(statKey, userKey, 1)\n}"
        ],
        [
            "func (r *BasicReporter) PostValue(statKey, userKey string, value float64) error {\n\tr.add(newClassicStatValue(statKey, userKey, value))\n\treturn nil\n}"
        ],
        [
            "func (r *BasicReporter) PostValueTime(statKey, userKey string, value float64, timestamp int64) error {\n\tx := newClassicStatValue(statKey, userKey, value)\n\tx.Timestamp = timestamp\n\tr.add(x)\n\treturn nil\n}"
        ],
        [
            "func (r *BasicReporter) PostEZCountOne(statName, ezkey string) error {\n\treturn r.PostEZCount(statName, ezkey, 1)\n}"
        ],
        [
            "func (r *BasicReporter) PostEZCount(statName, ezkey string, count int) error {\n\tr.add(newEZStatCount(statName, ezkey, count))\n\treturn nil\n}"
        ],
        [
            "func (r *BasicReporter) PostEZCountTime(statName, ezkey string, count int, timestamp int64) error {\n\tx := newEZStatCount(statName, ezkey, count)\n\tx.Timestamp = timestamp\n\tr.add(x)\n\treturn nil\n}"
        ],
        [
            "func (r *BasicReporter) PostEZValue(statName, ezkey string, value float64) error {\n\tr.add(newEZStatValue(statName, ezkey, value))\n\treturn nil\n}"
        ],
        [
            "func (r *BasicReporter) PostEZValueTime(statName, ezkey string, value float64, timestamp int64) error {\n\tx := newEZStatValue(statName, ezkey, value)\n\tx.Timestamp = timestamp\n\tr.add(x)\n\treturn nil\n}"
        ],
        [
            "func NewBatchReporter(reporter Reporter, interval time.Duration) Reporter {\n\n\tbr := &BatchReporter{\n\t\tr:               reporter,\n\t\tbatchInterval:   interval,\n\t\tcaches:          make(map[string]*statCache),\n\t\tshutdownBatchCh: make(chan struct{}),\n\t}\n\n\tgo br.batchLoop()\n\n\treturn br\n}"
        ],
        [
            "func (host rawHost) cleanHost() Host {\n\toutput := Host{\n\t\tnil,\n\t\thost.Status.State,\n\t\thost.Address.Address,\n\t\thost.Address.AddressType,\n\t\t[]Hostname{},\n\t\t[]Port{},\n\t}\n\n\tfor _, hostname := range host.Hostnames.Hostnames {\n\t\toutput.Hostnames = append(output.Hostnames,\n\t\t\tHostname{hostname.Name, hostname.Type})\n\t}\n\tfor _, port := range host.Ports.Ports {\n\t\toutput.Ports = append(output.Ports, port.cleanPort())\n\t}\n\n\treturn output\n}"
        ],
        [
            "func (s Scan) GetHost(hostTarget string) (target Host, exists bool) {\n\ttarget, ok := s.Hosts[hostTarget]\n\tif ok {\n\t\treturn target, true\n\t}\n\n\tfor _, host := range s.Hosts {\n\t\tfor _, hostname := range host.Hostnames {\n\t\t\tif hostname.Name == hostTarget {\n\t\t\t\treturn host, true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Host{}, false\n}"
        ],
        [
            "func (h Host) Rescan() (scan Scan) {\n\treturn Init().\n\t\tAddPorts(h.parentScan.configPorts...).\n\t\tAddTCPPorts(h.parentScan.configTCPPorts...).\n\t\tAddUDPPorts(h.parentScan.configUDPPorts...).\n\t\tAddHosts(h.Address).\n\t\tAddFlags(h.parentScan.configOpts...)\n}"
        ],
        [
            "func (h Host) Diff(altHost Host) (added []Port, removed []Port) {\n\ttargetPorts := h.Ports\n\taltPorts := altHost.Ports\n\n\taddedWithClosed := array.Except(altPorts, targetPorts).([]Port)\n\tfor _, add := range addedWithClosed {\n\t\tif add.State != \"closed\" {\n\t\t\tadded = append(added, add)\n\t\t}\n\t}\n\tremovedWithClosed := array.Except(targetPorts, altPorts).([]Port)\n\tfor _, remove := range removedWithClosed {\n\t\tif remove.State != \"closed\" {\n\t\t\tremoved = append(removed, remove)\n\t\t}\n\t}\n\n\treturn\n}"
        ],
        [
            "func (h Host) ToString() (out string) {\n\tout += fmt.Sprintf(\"%s is %s\\n\", h.Address, h.State)\n\tif len(h.Hostnames) != 0 {\n\t\tout += \"Hostnames:\\n\"\n\t\tfor _, hostname := range h.Hostnames {\n\t\t\tout += fmt.Sprintf(\"  %s/%s\\n\", hostname.Name, hostname.Type)\n\t\t}\n\t}\n\tif len(h.Ports) != 0 {\n\t\tout += \"Ports:\\n\"\n\t\tfor _, port := range h.Ports {\n\t\t\tfor _, line := range strings.Split(port.ToString(), \"\\n\") {\n\t\t\t\tif line != \"\" {\n\t\t\t\t\tout += fmt.Sprintf(\"  %s\\n\", line)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}"
        ],
        [
            "func Init() Scan {\n\tscan := Scan{}\n\tscan.Hosts = make(map[string]Host, 0)\n\treturn scan\n}"
        ],
        [
            "func (s Scan) AddHosts(hosts ...string) Scan {\n\ts.configHosts = append(s.configHosts, hosts...)\n\treturn s\n}"
        ],
        [
            "func (s Scan) SetHosts(hosts ...string) Scan {\n\ts.configHosts = hosts\n\treturn s\n}"
        ],
        [
            "func (s Scan) AddPorts(ports ...uint16) Scan {\n\ts.configPorts = append(s.configPorts, ports...)\n\treturn s\n}"
        ],
        [
            "func (s Scan) SetPorts(ports ...uint16) Scan {\n\ts.configPorts = ports\n\treturn s\n}"
        ],
        [
            "func (s Scan) SetTCPPorts(ports ...uint16) Scan {\n\ts.configTCPPorts = ports\n\treturn s\n}"
        ],
        [
            "func (s Scan) SetUDPPorts(ports ...uint16) Scan {\n\ts.configUDPPorts = ports\n\treturn s\n}"
        ],
        [
            "func (s Scan) AddFlags(flags ...string) Scan {\n\tfor _, flag := range flags {\n\t\tif strings.Contains(flag, \" \") {\n\t\t\ts.configErr = errors.New(\"Flags must not have spaces in them\")\n\t\t\treturn s\n\t\t}\n\t\tfor _, df := range DisallowedFlags {\n\t\t\tif flag == df {\n\t\t\t\ts.configErr = &DisallowedFlagError{df}\n\t\t\t\treturn s\n\t\t\t}\n\t\t}\n\t}\n\n\ts.configOpts = append(s.configOpts, flags...)\n\treturn s\n}"
        ],
        [
            "func (s Scan) IntenseAllTCPPorts() Scan {\n\treturn s.Intense().\n\t\tSetPorts().\n\t\tSetUDPPorts().\n\t\tSetTCPPorts().\n\t\tAddPortRange(1, 65535)\n}"
        ],
        [
            "func (s Scan) ToString() (out string) {\n\tfor _, host := range s.Hosts {\n\t\tout += fmt.Sprintf(\"%s\\n\", host.ToString())\n\t}\n\treturn\n}"
        ],
        [
            "func (s Scan) CreateNmapArgs() ([]string, error) {\n\t// Parse arguments\n\targs := []string{\"-oX\", \"-\"}\n\tconst seperator string = \",\"\n\n\t// Set up ports\n\tportList := \"\"\n\tportList += strings.Join(uint16ListToStringList(s.configPorts), seperator)\n\tif len(s.configUDPPorts) != 0 {\n\t\tif portList != \"\" {\n\t\t\tportList += \",\"\n\t\t}\n\t\tportList += \"U:\"\n\t}\n\tportList += strings.Join(uint16ListToStringList(s.configUDPPorts), seperator)\n\tif len(s.configTCPPorts) != 0 {\n\t\tif portList != \"\" {\n\t\t\tportList += \",\"\n\t\t}\n\t\tportList += \"T:\"\n\t}\n\tportList += strings.Join(uint16ListToStringList(s.configTCPPorts), seperator)\n\n\t// Check to make sure all TCP/UDP flags are correct\n\t// Check TCP flags\n\ttcpOptions := []string{\"-sS\", \"-sT\", \"-sA\", \"-sW\", \"-sM\"}\n\tiflag := array.Intersection(tcpOptions, s.configOpts).([]string)\n\tif len(iflag) == 0 {\n\t\ts.configOpts = append(s.configOpts, tcpOptions[1])\n\t}\n\n\t// Check UDP flag\n\tif len(s.configUDPPorts) != 0 && !array.In(\"-sU\", s.configOpts) {\n\t\ts.configOpts = append(s.configOpts, \"-sU\")\n\t}\n\n\t// Append arguments\n\targs = append(args, s.configOpts...)\n\n\t// Append port list\n\tif portList != \"\" {\n\t\targs = append(args, \"-p\"+portList)\n\t}\n\t// Append hosts\n\tif len(s.configHosts) == 0 {\n\t\ts.configErr = errors.New(\"No hosts added\")\n\t}\n\targs = append(args, s.configHosts...)\n\n\tfmt.Println(args)\n\treturn args, nil\n}"
        ],
        [
            "func uint16ListToStringList(source []uint16) (o []string) {\n\tfor _, s := range source {\n\t\to = append(o, strconv.FormatUint(uint64(s), 10))\n\t}\n\treturn\n}"
        ],
        [
            "func (p Port) ToString() (out string) {\n\tout += fmt.Sprintf(\"Port %d/%s is %s\\n\", p.ID, p.Protocol, p.State)\n\tfor _, script := range p.Scripts {\n\t\toutput := \"\"\n\t\tfor _, line := range strings.Split(script.Output, \"\\n\") {\n\t\t\toutput += fmt.Sprintf(\"      %s\\n\", line)\n\t\t}\n\t\tout += fmt.Sprintf(\"  Script: %s\\n%s\\n\", script.Name, output)\n\t}\n\treturn\n}"
        ],
        [
            "func (otp HOTP) Counter() uint64 {\n\tcounter := binary.BigEndian.Uint64(otp.counter[:])\n\treturn counter\n}"
        ],
        [
            "func (otp HOTP) Increment() {\n\tfor i := ctrSize - 1; i >= 0; i-- {\n\t\tif otp.counter[i]++; otp.counter[i] != 0 {\n\t\t\treturn\n\t\t}\n\t}\n}"
        ],
        [
            "func NewHOTP(key []byte, counter uint64, digits int) *HOTP {\n\totp := &HOTP{\n\t\tKey:    key,\n\t\tDigits: digits,\n\t}\n\totp.counter = new([ctrSize]byte)\n\tbinary.BigEndian.PutUint64(otp.counter[:], counter)\n\n\treturn otp\n}"
        ],
        [
            "func (otp *HOTP) URL(label string) string {\n\tsecret := base32.StdEncoding.EncodeToString(otp.Key)\n\tu := url.URL{}\n\tv := url.Values{}\n\tu.Scheme = \"otpauth\"\n\tu.Host = \"hotp\"\n\tu.Path = label\n\tv.Add(\"secret\", secret)\n\tv.Add(\"counter\", fmt.Sprintf(\"%d\", otp.Counter()))\n\tu.RawQuery = v.Encode()\n\treturn u.String()\n}"
        ],
        [
            "func (otp *HOTP) QR(label string) ([]byte, error) {\n\tu := otp.URL(label)\n\tcode, err := qr.Encode(u, qr.Q)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn code.PNG(), nil\n}"
        ],
        [
            "func truncate(in []byte) int64 {\n\toffset := int(in[len(in)-1] & 0xF)\n\tp := in[offset : offset+4]\n\tvar binCode int32\n\tbinCode = int32((p[0] & 0x7f)) << 24\n\tbinCode += int32((p[1] & 0xff)) << 16\n\tbinCode += int32((p[2] & 0xff)) << 8\n\tbinCode += int32((p[3] & 0xff))\n\treturn int64(binCode) & 0x7FFFFFFF\n}"
        ],
        [
            "func FromURL(urlString string) (*HOTP, string, error) {\n\tu, err := url.Parse(urlString)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tif u.Scheme != \"otpauth\" {\n\t\treturn nil, \"\", ErrInvalidHOTPURL\n\t} else if u.Host != \"hotp\" {\n\t\treturn nil, \"\", ErrInvalidHOTPURL\n\t}\n\n\tv := u.Query()\n\tif len(v) == 0 {\n\t\treturn nil, \"\", ErrInvalidHOTPURL\n\t}\n\tif v.Get(\"secret\") == \"\" {\n\t\treturn nil, \"\", ErrInvalidHOTPURL\n\t} else if algo := v.Get(\"algorithm\"); algo != \"\" && algo != \"SHA1\" {\n\t\treturn nil, \"\", ErrInvalidHOTPURL\n\t}\n\n\tvar identity string\n\tif len(u.Path) > 1 {\n\t\tidentity = u.Path[1:]\n\t}\n\n\tvar counter uint64\n\tif ctr := v.Get(\"counter\"); ctr != \"\" {\n\t\tcounter, err = strconv.ParseUint(ctr, 10, 64)\n\t\tif err != nil {\n\t\t\treturn nil, \"\", ErrInvalidHOTPURL\n\t\t}\n\t}\n\n\tsecret, err := base32.StdEncoding.DecodeString(v.Get(\"secret\"))\n\tif err != nil {\n\t\treturn nil, \"\", ErrInvalidHOTPURL\n\t}\n\n\tvar digits int64 = 6\n\tif v.Get(\"digits\") != \"\" {\n\t\tdigits, err = strconv.ParseInt(v.Get(\"digits\"), 10, 8)\n\t\tif err != nil {\n\t\t\treturn nil, \"\", ErrInvalidHOTPURL\n\t\t}\n\t}\n\n\totp := NewHOTP(secret, counter, int(digits))\n\treturn otp, identity, nil\n}"
        ],
        [
            "func GenerateHOTP(digits int, randCounter bool) (*HOTP, error) {\n\tkey := make([]byte, sha1.Size)\n\t_, err := io.ReadFull(PRNG, key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar counter uint64\n\tif randCounter {\n\t\tctr, err := rand.Int(PRNG, big.NewInt(int64(math.MaxInt64)))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcounter = ctr.Uint64()\n\t}\n\n\treturn NewHOTP(key, counter, digits), nil\n}"
        ],
        [
            "func (otp *HOTP) YubiKey(in string) (string, string, bool) {\n\tif len(in) < otp.Digits {\n\t\treturn \"\", \"\", false\n\t}\n\n\totpStart := len(in) - otp.Digits\n\tcode := in[otpStart:]\n\tpubid := in[:otpStart]\n\treturn code, pubid, true\n}"
        ],
        [
            "func (otp *HOTP) IntegrityCheck() (string, uint64) {\n\th := hmac.New(sha1.New, otp.Key)\n\tcounter := make([]byte, 8)\n\th.Write(counter)\n\thash := h.Sum(nil)\n\tresult := truncate(hash)\n\n\tmod := new(big.Int).Exp(big.NewInt(10), big.NewInt(int64(otp.Digits)), nil)\n\tmod = mod.Mod(big.NewInt(result), mod)\n\tfmtStr := fmt.Sprintf(\"%%0%dd\", otp.Digits)\n\treturn fmt.Sprintf(fmtStr, mod.Uint64()), otp.Counter()\n}"
        ],
        [
            "func (otp *HOTP) Check(code string) bool {\n\tcodeBytes := []byte(code)\n\tgenCode := []byte(otp.OTP())\n\tif subtle.ConstantTimeCompare(codeBytes, genCode) != 1 {\n\t\totp.setCounter(otp.Counter() - 1)\n\t\treturn false\n\t}\n\treturn true\n}"
        ],
        [
            "func Marshal(otp *HOTP) ([]byte, error) {\n\tvar asnHOTP struct {\n\t\tKey     []byte\n\t\tCounter *big.Int\n\t\tDigits  int\n\t}\n\tasnHOTP.Key = otp.Key[:]\n\tasnHOTP.Counter = new(big.Int).SetUint64(otp.Counter())\n\tasnHOTP.Digits = otp.Digits\n\treturn asn1.Marshal(asnHOTP)\n}"
        ],
        [
            "func Unmarshal(in []byte) (otp *HOTP, err error) {\n\tvar asnHOTP struct {\n\t\tKey     []byte\n\t\tCounter *big.Int\n\t\tDigits  int\n\t}\n\t_, err = asn1.Unmarshal(in, &asnHOTP)\n\tif err != nil {\n\t\treturn\n\t}\n\n\totp = &HOTP{\n\t\tKey:    asnHOTP.Key[:],\n\t\tDigits: asnHOTP.Digits,\n\t}\n\totp.setCounter(asnHOTP.Counter.Uint64())\n\treturn\n}"
        ],
        [
            "func NewWriterPool(maxRate int, maxBurst time.Duration) *WriterPool {\n\treturn &WriterPool{\n\t\tmaxRate:  maxRate,\n\t\tmaxBurst: maxBurst,\n\t\tgivenOut: make(map[ThrottlerWriter]struct{}),\n\t}\n}"
        ],
        [
            "func (pool *WriterPool) Get(w io.Writer) (writer io.Writer, release func()) {\n\t// don't export a ThrottlerWriter to prevent users changing the rate\n\t// and expecting their change to be respected, since we might modify\n\t// the rate under their feet\n\n\t// make the initial rate be 0, the actual rate is\n\t// set in the call to `setSharedRates`.\n\twr := ThrottledWriter(w, 0, pool.maxBurst)\n\n\tpool.mu.Lock()\n\tpool.givenOut[wr] = struct{}{}\n\tpool.setSharedRates()\n\tpool.mu.Unlock()\n\n\treturn wr, func() {\n\t\tpool.mu.Lock()\n\t\tdelete(pool.givenOut, wr)\n\t\tpool.setSharedRates()\n\t\tpool.mu.Unlock()\n\t}\n}"
        ],
        [
            "func (pool *WriterPool) Len() int {\n\tpool.mu.Lock()\n\tl := len(pool.givenOut)\n\tpool.mu.Unlock()\n\treturn l\n}"
        ],
        [
            "func NewReaderPool(maxRate int, maxBurst time.Duration) *ReaderPool {\n\treturn &ReaderPool{\n\t\tmaxRate:  maxRate,\n\t\tmaxBurst: maxBurst,\n\t\tgivenOut: make(map[ThrottlerReader]struct{}),\n\t}\n}"
        ],
        [
            "func (pool *ReaderPool) Get(r io.Reader) (reader io.Reader, release func()) {\n\t// don't export a ThrottlerReader to prevent users changing the rate\n\t// and expecting their change to be respected, since we might modify\n\t// the rate under their feet\n\n\t// make the initial rate be 0, the actual rate is\n\t// set in the call to `setSharedRates`.\n\trd := ThrottledReader(r, 0, pool.maxBurst)\n\n\tpool.mu.Lock()\n\tpool.givenOut[rd] = struct{}{}\n\tpool.setSharedRates()\n\tpool.mu.Unlock()\n\n\treturn rd, func() {\n\t\tpool.mu.Lock()\n\t\tdelete(pool.givenOut, rd)\n\t\tpool.setSharedRates()\n\t\tpool.mu.Unlock()\n\t}\n}"
        ],
        [
            "func (pool *ReaderPool) SetRate(rate int) int {\n\tpool.mu.Lock()\n\told := pool.maxRate\n\tpool.maxRate = rate\n\tpool.setSharedRates()\n\tpool.mu.Unlock()\n\treturn old\n}"
        ],
        [
            "func (pool *ReaderPool) Len() int {\n\tpool.mu.Lock()\n\tdefer pool.mu.Unlock()\n\treturn len(pool.givenOut)\n}"
        ],
        [
            "func NewMeasuredWriter(w io.Writer) *MeasuredWriter {\n\treturn &MeasuredWriter{wrap: w, rate: newCounter()}\n}"
        ],
        [
            "func (m *MeasuredWriter) BytesPerSec() uint64 {\n\treturn uint64(m.rate.Rate(time.Second))\n}"
        ],
        [
            "func NewMeasuredReader(r io.Reader) *MeasuredReader {\n\treturn &MeasuredReader{wrap: r, rate: newCounter()}\n}"
        ],
        [
            "func (m *MeasuredReader) BytesPer(perPeriod time.Duration) uint64 {\n\treturn uint64(m.rate.Rate(perPeriod))\n}"
        ],
        [
            "func (m *MeasuredReader) BytesPerSec() uint64 {\n\treturn uint64(m.rate.Rate(time.Second))\n}"
        ],
        [
            "func ThrottledReader(r io.Reader, bytesPerSec int, maxBurst time.Duration) ThrottlerReader {\n\treturn &throttledReader{\n\t\twrap:    r,\n\t\tlimiter: newRateLimiter(bytesPerSec, maxBurst),\n\t}\n}"
        ],
        [
            "func ThrottledWriter(w io.Writer, bytesPerSec int, maxBurst time.Duration) ThrottlerWriter {\n\treturn &throttledWriter{\n\t\twrap:    w,\n\t\tlimiter: newRateLimiter(bytesPerSec, maxBurst),\n\t}\n}"
        ],
        [
            "func NewDNSServer(domain string) *DNSServer {\n\treturn &DNSServer{\n\t\tDomain:     domain + \".\",\n\t\taRecords:   map[string]net.IP{},\n\t\tsrvRecords: map[string][]SRVRecord{},\n\t\taMutex:     sync.RWMutex{},\n\t\tsrvMutex:   sync.RWMutex{},\n\t}\n}"
        ],
        [
            "func (ds *DNSServer) qualifySrv(service, protocol string) string {\n\treturn fmt.Sprintf(\"_%s._%s.%s\", service, protocol, ds.Domain)\n}"
        ],
        [
            "func (ds *DNSServer) qualifySrvHosts(srvs []SRVRecord) []SRVRecord {\n\tnewsrvs := []SRVRecord{}\n\n\tfor _, srv := range srvs {\n\t\tnewsrvs = append(newsrvs, SRVRecord{\n\t\t\tHost: ds.qualifyHost(srv.Host),\n\t\t\tPort: srv.Port,\n\t\t})\n\t}\n\n\treturn newsrvs\n}"
        ],
        [
            "func (ds *DNSServer) GetA(fqdn string) *dns.A {\n\tds.aMutex.RLock()\n\tdefer ds.aMutex.RUnlock()\n\tval, ok := ds.aRecords[fqdn]\n\n\tif ok {\n\t\treturn &dns.A{\n\t\t\tHdr: dns.RR_Header{\n\t\t\t\tName:   fqdn,\n\t\t\t\tRrtype: dns.TypeA,\n\t\t\t\tClass:  dns.ClassINET,\n\t\t\t\t// 0 TTL results in UB for DNS resolvers and generally causes problems.\n\t\t\t\tTtl: 1,\n\t\t\t},\n\t\t\tA: val,\n\t\t}\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (ds *DNSServer) SetA(host string, ip net.IP) {\n\tds.aMutex.Lock()\n\tds.aRecords[ds.qualifyHost(host)] = ip\n\tds.aMutex.Unlock()\n}"
        ],
        [
            "func (ds *DNSServer) DeleteA(host string) {\n\tds.aMutex.Lock()\n\tdelete(ds.aRecords, ds.qualifyHost(host))\n\tds.aMutex.Unlock()\n}"
        ],
        [
            "func (ds *DNSServer) SetSRV(service, protocol string, srvs []SRVRecord) {\n\tds.srvMutex.Lock()\n\tds.srvRecords[ds.qualifySrv(service, protocol)] = ds.qualifySrvHosts(srvs)\n\tds.srvMutex.Unlock()\n}"
        ],
        [
            "func (ds *DNSServer) DeleteSRV(service, protocol string) {\n\tds.srvMutex.Lock()\n\tdelete(ds.srvRecords, ds.qualifySrv(service, protocol))\n\tds.srvMutex.Unlock()\n}"
        ],
        [
            "func Json(data []byte) (Typed, error) {\n\tvar m map[string]interface{}\n\terr := json.Unmarshal(data, &m)\n\treturn Typed(m), err\n}"
        ],
        [
            "func Must(data []byte) Typed {\n\tvar m map[string]interface{}\n\tif err := json.Unmarshal(data, &m); err != nil {\n\t\tpanic(err)\n\t}\n\treturn Typed(m)\n}"
        ],
        [
            "func JsonReader(reader io.Reader) (Typed, error) {\n\tif data, err := ioutil.ReadAll(reader); err != nil {\n\t\treturn nil, err\n\t} else {\n\t\treturn Json(data)\n\t}\n}"
        ],
        [
            "func JsonFile(path string) (Typed, error) {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn Json(data)\n}"
        ],
        [
            "func JsonArray(data []byte) ([]Typed, error) {\n\tvar m []interface{}\n\terr := json.Unmarshal(data, &m)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tl := len(m)\n\tif l == 0 {\n\t\treturn nil, nil\n\t}\n\ttyped := make([]Typed, l)\n\tfor i := 0; i < l; i++ {\n\t\tvalue := m[i]\n\t\tif t, ok := value.(map[string]interface{}); ok {\n\t\t\ttyped[i] = t\n\t\t} else {\n\t\t\ttyped[i] = map[string]interface{}{\"0\": value}\n\t\t}\n\t}\n\treturn typed, nil\n}"
        ],
        [
            "func JsonFileArray(path string) ([]Typed, error) {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn JsonArray(data)\n}"
        ],
        [
            "func (t Typed) Bool(key string) bool {\n\treturn t.BoolOr(key, false)\n}"
        ],
        [
            "func (t Typed) BoolOr(key string, d bool) bool {\n\tif value, exists := t.BoolIf(key); exists {\n\t\treturn value\n\t}\n\treturn d\n}"
        ],
        [
            "func (t Typed) BoolMust(key string) bool {\n\tb, exists := t.BoolIf(key)\n\tif exists == false {\n\t\tpanic(\"expected boolean value for \" + key)\n\t}\n\treturn b\n}"
        ],
        [
            "func (t Typed) BoolIf(key string) (bool, bool) {\n\tvalue, exists := t[key]\n\tif exists == false {\n\t\treturn false, false\n\t}\n\tif n, ok := value.(bool); ok {\n\t\treturn n, true\n\t}\n\treturn false, false\n}"
        ],
        [
            "func (t Typed) IntOr(key string, d int) int {\n\tif value, exists := t.IntIf(key); exists {\n\t\treturn value\n\t}\n\treturn d\n}"
        ],
        [
            "func (t Typed) IntMust(key string) int {\n\ti, exists := t.IntIf(key)\n\tif exists == false {\n\t\tpanic(\"expected int value for \" + key)\n\t}\n\treturn i\n}"
        ],
        [
            "func (t Typed) IntIf(key string) (int, bool) {\n\tvalue, exists := t[key]\n\tif exists == false {\n\t\treturn 0, false\n\t}\n\n\tswitch t := value.(type) {\n\tcase int:\n\t\treturn t, true\n\tcase int16:\n\t\treturn int(t), true\n\tcase int32:\n\t\treturn int(t), true\n\tcase int64:\n\t\treturn int(t), true\n\tcase float64:\n\t\treturn int(t), true\n\tcase string:\n\t\ti, err := strconv.Atoi(t)\n\t\treturn i, err == nil\n\t}\n\treturn 0, false\n}"
        ],
        [
            "func (t Typed) FloatOr(key string, d float64) float64 {\n\tif value, exists := t.FloatIf(key); exists {\n\t\treturn value\n\t}\n\treturn d\n}"
        ],
        [
            "func (t Typed) FloatMust(key string) float64 {\n\tf, exists := t.FloatIf(key)\n\tif exists == false {\n\t\tpanic(\"expected float value for \" + key)\n\t}\n\treturn f\n}"
        ],
        [
            "func (t Typed) FloatIf(key string) (float64, bool) {\n\tvalue, exists := t[key]\n\tif exists == false {\n\t\treturn 0, false\n\t}\n\tswitch t := value.(type) {\n\tcase float64:\n\t\treturn t, true\n\tcase string:\n\t\tf, err := strconv.ParseFloat(t, 10)\n\t\treturn f, err == nil\n\t}\n\treturn 0, false\n}"
        ],
        [
            "func (t Typed) StringOr(key string, d string) string {\n\tif value, exists := t.StringIf(key); exists {\n\t\treturn value\n\t}\n\treturn d\n}"
        ],
        [
            "func (t Typed) StringMust(key string) string {\n\ts, exists := t.StringIf(key)\n\tif exists == false {\n\t\tpanic(\"expected string value for \" + key)\n\t}\n\treturn s\n}"
        ],
        [
            "func (t Typed) TimeOr(key string, d time.Time) time.Time {\n\tif value, exists := t.TimeIf(key); exists {\n\t\treturn value\n\t}\n\treturn d\n}"
        ],
        [
            "func (t Typed) TimeMust(key string) time.Time {\n\ttt, exists := t.TimeIf(key)\n\tif exists == false {\n\t\tpanic(\"expected time.Time value for \" + key)\n\t}\n\treturn tt\n}"
        ],
        [
            "func (t Typed) TimeIf(key string) (time.Time, bool) {\n\tvalue, exists := t[key]\n\tif exists == false {\n\t\treturn time.Time{}, false\n\t}\n\tif n, ok := value.(time.Time); ok {\n\t\treturn n, true\n\t}\n\treturn time.Time{}, false\n}"
        ],
        [
            "func (t Typed) ObjectMust(key string) Typed {\n\tt, exists := t.ObjectIf(key)\n\tif exists == false {\n\t\tpanic(\"expected map for \" + key)\n\t}\n\treturn t\n}"
        ],
        [
            "func (t Typed) InterfaceOr(key string, d interface{}) interface{} {\n\tif value, exists := t.InterfaceIf(key); exists {\n\t\treturn value\n\t}\n\treturn d\n}"
        ],
        [
            "func (t Typed) InterfaceMust(key string) interface{} {\n\ti, exists := t.InterfaceIf(key)\n\tif exists == false {\n\t\tpanic(\"expected map for \" + key)\n\t}\n\treturn i\n}"
        ],
        [
            "func (t Typed) InterfaceIf(key string) (interface{}, bool) {\n\tvalue, exists := t[key]\n\tif exists == false {\n\t\treturn nil, false\n\t}\n\treturn value, true\n}"
        ],
        [
            "func (t Typed) Bools(key string) []bool {\n\treturn t.BoolsOr(key, nil)\n}"
        ],
        [
            "func (t Typed) BoolsOr(key string, d []bool) []bool {\n\tn, ok := t.BoolsIf(key)\n\tif ok {\n\t\treturn n\n\t}\n\treturn d\n}"
        ],
        [
            "func (t Typed) Ints(key string) []int {\n\treturn t.IntsOr(key, nil)\n}"
        ],
        [
            "func (t Typed) Ints64(key string) []int64 {\n\treturn t.Ints64Or(key, nil)\n}"
        ],
        [
            "func (t Typed) Floats(key string) []float64 {\n\treturn t.FloatsOr(key, nil)\n}"
        ],
        [
            "func (t Typed) Strings(key string) []string {\n\treturn t.StringsOr(key, nil)\n}"
        ],
        [
            "func (t Typed) Objects(key string) []Typed {\n\tvalue, _ := t.ObjectsIf(key)\n\treturn value\n}"
        ],
        [
            "func (t Typed) ObjectsIf(key string) ([]Typed, bool) {\n\tvalue, exists := t[key]\n\tif exists == true {\n\t\tswitch t := value.(type) {\n\t\tcase []interface{}:\n\t\t\tl := len(t)\n\t\t\tn := make([]Typed, l)\n\t\t\tfor i := 0; i < l; i++ {\n\t\t\t\tswitch it := t[i].(type) {\n\t\t\t\tcase map[string]interface{}:\n\t\t\t\t\tn[i] = Typed(it)\n\t\t\t\tcase Typed:\n\t\t\t\t\tn[i] = it\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n, true\n\t\tcase []map[string]interface{}:\n\t\t\tl := len(t)\n\t\t\tn := make([]Typed, l)\n\t\t\tfor i := 0; i < l; i++ {\n\t\t\t\tn[i] = Typed(t[i])\n\t\t\t}\n\t\t\treturn n, true\n\t\tcase []Typed:\n\t\t\treturn t, true\n\t\t}\n\t}\n\treturn nil, false\n}"
        ],
        [
            "func (h *Handler) GetSessions(tkn, channel string) ([]data.Session, error) {\n\tlogger := h.logger.Add(\"method\", \"GetSessions\", \"channel\", channel)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\ttail, args := h.getSessionsConditions(channel)\n\n\tresult, err := h.selectAllFrom(\n\t\tlogger, data.SessionTable, tail, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsessions := make([]data.Session, len(result))\n\tfor i, item := range result {\n\t\tsessions[i] = *item.(*data.Session)\n\t}\n\n\treturn sessions, nil\n}"
        ],
        [
            "func (h *Handler) ObjectChange(ctx context.Context, tkn, objectType string,\n\tobjectIDs []string) (*rpc.Subscription, error) {\n\tlogger := h.logger.Add(\"method\", \"ObjectChange\",\n\t\t\"objectType\", objectType, \"objectIDs\", objectIDs)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\ttable, ok := objectChangeTables[objectType]\n\tif !ok {\n\t\tlogger.Warn(ErrBadObjectType.Error())\n\t\treturn nil, ErrBadObjectType\n\t}\n\n\tntf, ok := rpc.NotifierFromContext(ctx)\n\tif !ok {\n\t\tlogger.Error(\"no notifier found in context\")\n\t\treturn nil, ErrInternal\n\t}\n\n\tsub := ntf.CreateSubscription()\n\tcb := func(job *data.Job, result error) {\n\t\tobj, err := h.db.FindByPrimaryKeyFrom(table, job.RelatedID)\n\t\tif err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t}\n\n\t\tvar odata json.RawMessage\n\t\tif obj != nil {\n\t\t\todata, err = json.Marshal(obj)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err.Error())\n\t\t\t}\n\t\t}\n\n\t\terr = ntf.Notify(sub.ID,\n\t\t\t&ObjectChangeResult{odata, job, rpcsrv.ToError(result)})\n\t\tif err != nil {\n\t\t\tlogger.Warn(err.Error())\n\t\t}\n\t}\n\n\tsid := string(sub.ID)\n\terr := h.queue.Subscribe(objectIDs, sid, cb)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\tgo func() {\n\t\tfor err, ok := <-sub.Err(); ok; {\n\t\t\tif err != nil {\n\t\t\t\tlogger.Warn(err.Error())\n\t\t\t}\n\t\t}\n\n\t\terr := h.queue.Unsubscribe(objectIDs, sid)\n\t\tif err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t}\n\t}()\n\n\treturn sub, nil\n}"
        ],
        [
            "func AutoOfferingPopUp(logger log.Logger, abi abi.ABI, db *reform.DB,\n\tethBack eth.Backend, timeNowFunc func() time.Time,\n\tperiod uint) []*data.Job {\n\tlogger = logger.Add(\"method\", \"AutoOfferingPopUp\")\n\n\tdo, err := data.ReadBoolSetting(\n\t\tdb.Querier, data.SettingOfferingAutoPopUp)\n\tif err != nil {\n\t\tlogger.Warn(err.Error())\n\t}\n\n\tvar jobs []*data.Job\n\n\tif do {\n\t\tjobs = autoOfferingPopUp(logger, abi, db, ethBack,\n\t\t\ttimeNowFunc, period)\n\t\tlogger.Debug(fmt.Sprintf(\"found %d offerings to pop upped\",\n\t\t\tlen(jobs)))\n\t}\n\n\treturn jobs\n}"
        ],
        [
            "func (n Base64BigInt) MarshalJSON() ([]byte, error) {\n\tbuf, err := ToBytes(Base64String(n))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not decode base64: %v\", err)\n\t}\n\tv := big.NewInt(0)\n\tv.SetBytes(buf)\n\treturn []byte(v.String()), nil\n}"
        ],
        [
            "func (t *LogTopics) Scan(src interface{}) error {\n\tsomcData, ok := src.([]byte)\n\tif !ok {\n\t\treturn fmt.Errorf(\n\t\t\t\"type assertion .([]byte) failed, actual type is %T\",\n\t\t\tsrc,\n\t\t)\n\t}\n\n\treturn json.Unmarshal(somcData, &t)\n}"
        ],
        [
            "func NewWorker(logger log.Logger, db *reform.DB, ethBack eth.Backend,\n\tgasConc *GasConf, pscAddr common.Address, payAddr string,\n\tpwdGetter data.PWDGetter, countryConf *country.Config,\n\tdecryptKeyFunc data.ToPrivateKeyFunc, eptConf *ept.Config,\n\ttorHostname string, somcClientBuilder somc.ClientBuilderInterface) (*Worker, error) {\n\n\tl := logger.Add(\"type\", \"proc/worker.Worker\")\n\n\tabi, err := abi.JSON(\n\t\tstrings.NewReader(contract.PrivatixServiceContractABI))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\teptService, err := ept.New(db, logger, payAddr, eptConf.Timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Worker{\n\t\tabi:               abi,\n\t\tlogger:            l,\n\t\tdb:                db,\n\t\tdecryptKeyFunc:    decryptKeyFunc,\n\t\tgasConf:           gasConc,\n\t\tept:               eptService,\n\t\tethBack:           ethBack,\n\t\tpscAddr:           pscAddr,\n\t\tpwdGetter:         pwdGetter,\n\t\tcountryConfig:     countryConf,\n\t\ttorHostName:       data.FromBytes([]byte(torHostname)),\n\t\tsomcClientBuilder: somcClientBuilder,\n\t}, nil\n}"
        ],
        [
            "func NewLoggerBase(conf *BaseConfig, log LoggerFunc) (*LoggerBase, error) {\n\tif _, ok := levelNums[conf.Level]; !ok {\n\t\treturn nil, ErrBadLevel\n\t}\n\n\tif _, ok := levelNums[conf.StackLevel]; !ok {\n\t\treturn nil, ErrBadStackLevel\n\t}\n\n\tctx := map[string]interface{}{}\n\n\treturn &LoggerBase{conf: conf, log: log, ctx: ctx}, nil\n}"
        ],
        [
            "func (l *LoggerBase) Log(lvl Level, msg string) {\n\tlvln, ok := levelNums[lvl]\n\tif !ok {\n\t\tpanic(\"bad log level\")\n\t}\n\n\tif lvln < levelNums[l.conf.Level] {\n\t\treturn\n\t}\n\n\tvar stack *string\n\tif lvln >= levelNums[l.conf.StackLevel] {\n\t\ttmp := string(debug.Stack())\n\t\tstack = &tmp\n\t}\n\n\tif err := l.log(lvl, msg, l.ctx, stack); err != nil {\n\t\tpanic(\"failed to log: \" + err.Error())\n\t}\n\n\tif lvl == Fatal {\n\t\tpanic(\"fatal log event\")\n\t}\n}"
        ],
        [
            "func (w *Worker) PreAccountAddBalanceApprove(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"PreAccountAddBalanceApprove\", \"job\", job)\n\n\tacc, err := w.relatedAccount(logger, job,\n\t\tdata.JobPreAccountAddBalanceApprove)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"account\", acc)\n\n\tjobData, err := w.balanceData(logger, job)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse job data: %v\", err)\n\t}\n\n\taddr, err := data.HexToAddress(acc.EthAddr)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrParseEthAddr\n\t}\n\n\tamount, err := w.ethBack.PTCBalanceOf(&bind.CallOpts{}, addr)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrPTCRetrieveBalance\n\t}\n\n\tif amount.Uint64() < uint64(jobData.Amount) {\n\t\treturn ErrInsufficientPTCBalance\n\t}\n\n\tethBalance, err := w.ethBalance(logger, addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twantedEthBalance := w.gasConf.PTC.Approve * jobData.GasPrice\n\n\tif wantedEthBalance > ethBalance.Uint64() {\n\t\treturn ErrInsufficientEthBalance\n\t}\n\n\tkey, err := w.key(logger, acc.PrivateKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tauth := bind.NewKeyedTransactor(key)\n\tauth.GasLimit = w.gasConf.PTC.Approve\n\tauth.GasPrice = new(big.Int).SetUint64(jobData.GasPrice)\n\ttx, err := w.ethBack.PTCIncreaseApproval(auth,\n\t\tw.pscAddr, new(big.Int).SetUint64(jobData.Amount))\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrPTCIncreaseApproval\n\t}\n\n\treturn w.saveEthTX(logger, job, tx, \"PTCIncreaseApproval\", job.RelatedType,\n\t\tjob.RelatedID, acc.EthAddr, data.HexFromBytes(w.pscAddr.Bytes()))\n}"
        ],
        [
            "func (w *Worker) PreAccountAddBalance(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"PreAccountAddBalance\", \"job\", job)\n\n\tacc, err := w.relatedAccount(logger, job, data.JobPreAccountAddBalance)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tjobData, err := w.approvedBalanceData(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkey, err := w.key(logger, acc.PrivateKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tauth := bind.NewKeyedTransactor(key)\n\tauth.GasLimit = w.gasConf.PSC.AddBalanceERC20\n\tauth.GasPrice = new(big.Int).SetUint64(jobData.GasPrice)\n\ttx, err := w.ethBack.PSCAddBalanceERC20(auth, uint64(jobData.Amount))\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrPSCAddBalance\n\t}\n\n\treturn w.saveEthTX(logger, job, tx, \"PSCAddBalanceERC20\", job.RelatedType,\n\t\tjob.RelatedID, acc.EthAddr, data.HexFromBytes(w.pscAddr.Bytes()))\n}"
        ],
        [
            "func (w *Worker) AfterAccountAddBalance(job *data.Job) error {\n\treturn w.updateAccountBalancesJob(job, data.JobAfterAccountAddBalance)\n}"
        ],
        [
            "func (w *Worker) AfterAccountReturnBalance(job *data.Job) error {\n\treturn w.updateAccountBalancesJob(job, data.JobAfterAccountReturnBalance)\n}"
        ],
        [
            "func (w *Worker) AccountUpdateBalances(job *data.Job) error {\n\treturn w.updateAccountBalancesJob(job, data.JobAccountUpdateBalances)\n}"
        ],
        [
            "func (w *Worker) PreAccountReturnBalance(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"PreAccountReturnBalance\", \"job\", job)\n\tacc, err := w.relatedAccount(logger, job, data.JobPreAccountReturnBalance)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkey, err := w.key(logger, acc.PrivateKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tjobData, err := w.balanceData(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tauth := bind.NewKeyedTransactor(key)\n\n\tamount, err := w.ethBack.PSCBalanceOf(&bind.CallOpts{}, auth.From)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrPSCReturnBalance\n\t}\n\n\tif amount < uint64(jobData.Amount) {\n\t\treturn ErrInsufficientPSCBalance\n\t}\n\n\tethAmount, err := w.ethBalance(logger, auth.From)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twantedEthBalance := w.gasConf.PSC.ReturnBalanceERC20 * jobData.GasPrice\n\n\tif wantedEthBalance > ethAmount.Uint64() {\n\t\treturn ErrInsufficientEthBalance\n\t}\n\n\tauth.GasLimit = w.gasConf.PSC.ReturnBalanceERC20\n\tauth.GasPrice = new(big.Int).SetUint64(jobData.GasPrice)\n\n\ttx, err := w.ethBack.PSCReturnBalanceERC20(auth, uint64(jobData.Amount))\n\tif err != nil {\n\t\tlogger.Add(\"GasLimit\", auth.GasLimit,\n\t\t\t\"GasPrice\", auth.GasPrice).Error(err.Error())\n\t\treturn ErrPSCRetrieveBalance\n\t}\n\n\treturn w.saveEthTX(logger, job, tx, \"PSCReturnBalanceERC20\", job.RelatedType,\n\t\tjob.RelatedID, data.HexFromBytes(w.pscAddr.Bytes()), acc.EthAddr)\n}"
        ],
        [
            "func (h *Handler) GetOfferingUsage(password, offeringID string) (*uint, error) {\n\tlogger := h.logger.Add(\"method\", \"GetOfferingUsage\",\n\t\t\"offeringID\", offeringID)\n\n\treturn h.uintFromQuery(logger, password,\n\t\t`SELECT SUM(sessions.units_used)\n\t\t   FROM channels\n\t\t   \tJOIN sessions\n\t\t\tON sessions.channel=channels.id\n\t\t\t   AND channels.offering=$1`,\n\t\tofferingID)\n}"
        ],
        [
            "func (h *Handler) GetProductUsage(password, productID string) (*uint, error) {\n\tlogger := h.logger.Add(\"method\", \"GetProductUsage\",\n\t\t\"productID\", productID)\n\n\treturn h.uintFromQuery(logger, password,\n\t\t`SELECT SUM(sessions.units_used)\n\t\t   FROM offerings\n\t\t   \tJOIN channels\n\t\t\tON channels.offering=offerings.id\n\t\t\t   AND offerings.product=$1\n\t\t   \tJOIN sessions\n\t\t     \tON sessions.channel=channels.id`, productID)\n}"
        ],
        [
            "func (n *upnp) AddMapping(protocol string, extPort, intPort int,\n\tdesc string, lifetime time.Duration) error {\n\tip, err := n.internalAddress()\n\tif err != nil {\n\t\treturn nil\n\t}\n\tprotocol = strings.ToUpper(protocol)\n\tlifetimeS := uint32(lifetime / time.Second)\n\tn.DeleteMapping(protocol, extPort, intPort)\n\treturn n.client.AddPortMapping(\"\", uint16(extPort),\n\t\tprotocol, uint16(intPort), ip.String(), true, desc, lifetimeS)\n}"
        ],
        [
            "func (n *upnp) DeleteMapping(protocol string, extPort, intPort int) error {\n\treturn n.client.DeletePortMapping(\n\t\t\"\", uint16(extPort), strings.ToUpper(protocol))\n}"
        ],
        [
            "func PostCheque(db *reform.DB, channel string,\n\tpscAddr data.HexString, pass string, amount uint64,\n\ttls bool, timeout uint, pr *proc.Processor) error {\n\tpld, err := newPayload(db, channel, pscAddr, pass, amount)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn postPayload(db, channel, pld, tls, timeout, pr, srv.Send)\n}"
        ],
        [
            "func NewHTTPClient(sock uint) (*http.Client, error) {\n\ttorProxyURL, err := url.Parse(fmt.Sprint(\"socks5://127.0.0.1:\", sock))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set up a custom HTTP transport to use the proxy and create the client\n\ttorTransport := &http.Transport{Proxy: http.ProxyURL(torProxyURL)}\n\treturn &http.Client{\n\t\tTransport: torTransport,\n\t\tTimeout:   time.Second * 10,\n\t}, nil\n}"
        ],
        [
            "func NewServer(conf *Config) (*Server, error) {\n\trpcsrv := rpc.NewServer()\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(HTTPPath, rpcsrv.ServeHTTP)\n\tmux.Handle(WSPath, rpcsrv.WebsocketHandler(conf.AllowedOrigins))\n\n\thttpsrv := &http.Server{\n\t\tAddr:    conf.Addr,\n\t\tHandler: mux,\n\t}\n\n\treturn &Server{\n\t\tconf:    conf,\n\t\trpcsrv:  rpcsrv,\n\t\thttpsrv: httpsrv,\n\t}, nil\n}"
        ],
        [
            "func (s *Server) AddHandler(namespace string, handler interface{}) error {\n\treturn s.rpcsrv.RegisterName(namespace, handler)\n}"
        ],
        [
            "func (s *Server) ListenAndServe() error {\n\tif s.conf.TLS != nil {\n\t\treturn s.httpsrv.ListenAndServeTLS(\n\t\t\ts.conf.TLS.CertFile, s.conf.TLS.KeyFile)\n\t}\n\n\treturn s.httpsrv.ListenAndServe()\n}"
        ],
        [
            "func Recover(db *reform.DB) error {\n\tif err := recoverServiceStatuses(db); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (c DBConfig) ConnStr() string {\n\tcomps := []string{}\n\tfor k, v := range c.Conn {\n\t\tcomps = append(comps, k+\"=\"+v)\n\t}\n\treturn strings.Join(comps, \" \")\n}"
        ],
        [
            "func NewDBFromConnStr(connStr string) (*reform.DB, error) {\n\tconn, err := dbConnect(connStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newReform(conn), nil\n}"
        ],
        [
            "func NewDB(conf *DBConfig) (*reform.DB, error) {\n\tconn, err := dbConnect(conf.ConnStr())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn.SetMaxOpenConns(conf.MaxOpen)\n\tconn.SetMaxIdleConns(conf.MaxIddle)\n\treturn newReform(conn), nil\n}"
        ],
        [
            "func GetCountry(timeout uint64, url, field string) (string, error) {\n\tctx, cancel := context.WithTimeout(\n\t\tcontext.Background(), time.Millisecond*time.Duration(timeout))\n\tdefer cancel()\n\n\treq, err := http.NewRequest(http.MethodGet, url, nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tres, err := do(ctx, req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer res.Body.Close()\n\n\tobject := make(map[string]interface{})\n\tif err := json.NewDecoder(res.Body).Decode(&object); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tf, ok := object[field]\n\tif !ok {\n\t\treturn \"\", ErrMissingRequiredField\n\t}\n\n\tcountry, ok := f.(string)\n\tif !ok {\n\t\treturn \"\", ErrBadCountryValueType\n\t}\n\n\treturn strings.TrimSpace(strings.ToUpper(country)), nil\n}"
        ],
        [
            "func (h *Handler) Endpoint(key data.Base64String) (*data.Base64String, error) {\n\tlogger := h.logger.Add(\"type\", \"agent/tor-somc.Handler\")\n\n\tchannelsStructs, err := h.db.SelectAllFrom(data.ChannelTable, \"\")\n\tif err != nil {\n\t\th.logger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\tfor _, chanStruct := range channelsStructs {\n\t\tchannel := chanStruct.(*data.Channel)\n\t\tchannelKey, err := h.channelKey(logger, channel)\n\t\tif err != nil {\n\t\t\th.logger.Error(err.Error())\n\t\t\treturn nil, ErrInternal\n\t\t}\n\t\tif channelKey == key {\n\t\t\tendpoint, err := h.endpointByChannelID(logger, channel.ID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn &endpoint.RawMsg, nil\n\t\t}\n\t}\n\n\treturn nil, ErrChannelNotFound\n}"
        ],
        [
            "func NewServer(conf *Config, logger log.Logger, db *reform.DB) *Server {\n\ts := &Server{\n\t\tServer: srv.NewServer(conf.Config),\n\t\tlogger: logger.Add(\"type\", \"pay.Server\"),\n\t\tdb:     db,\n\t}\n\n\ts.HandleFunc(payPath,\n\t\ts.RequireHTTPMethods(s.logger, s.handlePay, http.MethodPost))\n\n\treturn s\n}"
        ],
        [
            "func NewMonitor(conf *Config, c Client, db *reform.DB, l log.Logger, psc,\n\tptc common.Address, role string, q Queue) (*Monitor, error) {\n\tabiJSON := contract.PrivatixServiceContractABI\n\tpscABI, err := abi.JSON(strings.NewReader(abiJSON))\n\tif err != nil {\n\t\tl.Error(err.Error())\n\t\treturn nil, ErrFailedToParseABI\n\t}\n\tabiJSON2 := contract.PrivatixTokenContractABI\n\tptcABI, err := abi.JSON(strings.NewReader(abiJSON2))\n\tif err != nil {\n\t\tl.Error(err.Error())\n\t\treturn nil, ErrFailedToParseABI\n\t}\n\tethCallTimeout := time.Duration(conf.EthCallTimeout) * time.Millisecond\n\tqueryPause := time.Duration(conf.QueryPause) * time.Millisecond\n\tm := &Monitor{\n\t\tdb:             db,\n\t\teth:            c,\n\t\tlogger:         l.Add(\"type\", \"monitor.Monitor\"),\n\t\tqueue:          q,\n\t\tethCallTimeout: ethCallTimeout,\n\t\tpscABI:         pscABI,\n\t\tptcABI:         ptcABI,\n\t\tpscAddr:        psc,\n\t\tqueryPause:     queryPause,\n\t}\n\n\tm.initLastProcessedBlock(role, conf.InitialBlocks)\n\n\tf := m.clientQueries\n\tm.jobsProducers = m.clientJobsProducers()\n\tif role == data.RoleAgent {\n\t\tf = m.agentQueries\n\t\tm.jobsProducers = m.agentJobsProducers()\n\t}\n\tm.getFilterLogQueries = func(from, to uint64) ([]ethereum.FilterQuery, error) {\n\t\treturn f(from, to, psc, ptc)\n\t}\n\n\treturn m, nil\n}"
        ],
        [
            "func (m *Monitor) initLastProcessedBlock(role string, initialBlocks uint64) {\n\tlogger := m.logger.Add(\"method\", \"initLastProcessedBlock\",\n\t\t\"role\", role, \"initialBlocks\", initialBlocks)\n\n\tblock, err := m.getLastProcessedBlockNumber()\n\tif block > 0 || err != nil || role != data.RoleClient ||\n\t\tinitialBlocks == 0 {\n\t\treturn\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(),\n\t\tm.ethCallTimeout)\n\tdefer cancel()\n\n\tlastBlock, err := m.eth.HeaderByNumber(ctx, nil)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn\n\t}\n\n\tlastEthBlockNum := lastBlock.Number.Uint64()\n\tlogger = logger.Add(\"lastEthBlockNum\", lastEthBlockNum)\n\n\tif initialBlocks > lastEthBlockNum {\n\t\tlogger.Warn(\"initialBlocks value is very big\")\n\t\treturn\n\t}\n\n\tlastProcessedBlock := lastEthBlockNum - initialBlocks\n\n\t_, err = m.db.Exec(`UPDATE settings SET value=$1 WHERE key=$2`,\n\t\tlastProcessedBlock, data.SettingLastProcessedBlock)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t}\n\tlogger.Debug(fmt.Sprintf(\"last processed block: %d\",\n\t\tlastProcessedBlock))\n}"
        ],
        [
            "func (m *Monitor) Start() {\n\tlogger := m.logger.Add(\"method\", \"Start\")\n\tctx, cancel := context.WithCancel(context.Background())\n\tticker := time.NewTicker(m.queryPause)\n\tm.stopMonitor = func() {\n\t\tticker.Stop()\n\t\tcancel()\n\t}\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\terr := m.queryLogsAndCreateJobs(\n\t\t\t\t\tm.getFilterLogQueries, m.jobsProducers)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Warn(err.Error())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n}"
        ],
        [
            "func newClient(cfg *Config, logger log.Logger) (*client, error) {\n\tlogger2 := logger.Add(\"method\", \"newClient\", \"config\", cfg)\n\n\tu, err := url.Parse(cfg.GethURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tc := &client{cancel: cancel, cfg: cfg, logger: logger}\n\n\tvar rpcClient *rpc.Client\n\n\tswitch u.Scheme {\n\tcase httpProtocol, https:\n\t\thttpTransport := transport(cfg.HTTPClient)\n\n\t\trpcClient, err = rpc.DialHTTPWithClient(cfg.GethURL,\n\t\t\thttpClient(cfg.HTTPClient, httpTransport))\n\n\t\tc.httpTransport = httpTransport\n\tcase ws, wss:\n\t\trpcClient, err = rpc.DialWebsocket(ctx, cfg.GethURL, \"\")\n\tcase stdIO:\n\t\trpcClient, err = rpc.DialStdIO(ctx)\n\tcase ipc:\n\t\trpcClient, err = rpc.DialIPC(ctx, cfg.GethURL)\n\tdefault:\n\t\tlogger2.Add(\"scheme\", u.Scheme).Error(err.Error())\n\t\treturn nil, ErrURLScheme\n\t}\n\tif err != nil {\n\t\tlogger2.Error(err.Error())\n\t\treturn nil, ErrCreateClient\n\t}\n\n\tc.client = ethclient.NewClient(rpcClient)\n\treturn c, nil\n}"
        ],
        [
            "func Loop(ctx context.Context, logger log.Logger, db *reform.DB,\n\tqueue job.Queue, duration time.Duration, f func() []*data.Job) {\n\ttik := time.NewTicker(duration)\n\tlogger = logger.Add(\"method\", \"Loop\")\n\n\tgo loop(ctx, tik, db, queue, f, logger, nil)\n}"
        ],
        [
            "func (c *Client) Offering(hash data.HexString) (data.Base64String, error) {\n\treturn c.requestWithPayload(\"api_offering\", string(hash))\n}"
        ],
        [
            "func (c *Client) Endpoint(channelKey data.Base64String) (data.Base64String, error) {\n\treturn c.requestWithPayload(\"api_endpoint\", string(channelKey))\n}"
        ],
        [
            "func (c *Client) Ping() error {\n\t_, err := c.client.Head(c.url())\n\treturn err\n}"
        ],
        [
            "func (h *Handler) GetEthTransactions(tkn, relType, relID string,\n\toffset, limit uint) (*GetEthTransactionsResult, error) {\n\tlogger := h.logger.Add(\"method\", \"GetEthTransactions\", \"relatedType\",\n\t\trelType, \"relatedID\", relID, \"limit\", limit, \"offset\", offset)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tconds := make([]string, 0)\n\targs := make([]interface{}, 0)\n\t// If the relType is `accountAggregated`, then gets an Ethereum\n\t// address of the account and find all transactions where this address\n\t// is the sender.\n\tif relType == AccountAggregatedType {\n\t\tvar acc data.Account\n\t\tif err := h.findByPrimaryKey(\n\t\t\tlogger, ErrAccountNotFound, &acc, relID); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\targs = append(args, acc.EthAddr)\n\t\tconds = append(\n\t\t\tconds,\n\t\t\t\"addr_from=\"+h.db.Placeholder(len(args)))\n\t} else if relType != \"\" {\n\t\targs = append(args, relType)\n\t\tconds = append(\n\t\t\tconds,\n\t\t\t\"related_type=\"+h.db.Placeholder(len(args)))\n\t}\n\tif relID != \"\" && relType != AccountAggregatedType {\n\t\targs = append(args, relID)\n\t\tconds = append(\n\t\t\tconds,\n\t\t\t\"related_id=\"+h.db.Placeholder(len(args)))\n\t}\n\n\ttail := \"\"\n\tif len(conds) > 0 {\n\t\ttail = \"WHERE \" + strings.Join(conds, \" AND \")\n\t}\n\n\tcount, err := h.numberOfObjects(\n\t\tlogger, data.EthTxTable.Name(), tail, args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\toffsetLimit := h.offsetLimit(offset, limit)\n\n\tsorting := `ORDER BY issued DESC`\n\n\ttail = fmt.Sprintf(\"%s %s %s\", tail, sorting, offsetLimit)\n\n\ttxs, err := h.selectAllFrom(logger, data.EthTxTable, tail, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tret := make([]data.EthTx, len(txs))\n\n\tfor i, v := range txs {\n\t\tret[i] = *v.(*data.EthTx)\n\t}\n\treturn &GetEthTransactionsResult{ret, count}, nil\n}"
        ],
        [
            "func AgentSeal(msg, clientPub []byte, agentKey *ecdsa.PrivateKey) ([]byte, error) {\n\tpubKey, err := ethcrypto.UnmarshalPubkey(clientPub)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpub := ecies.ImportECDSAPublic(pubKey)\n\tmsgEncrypted, err := ecies.Encrypt(rand.Reader, pub, msg, nil, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn PackWithSignature(msgEncrypted, agentKey)\n}"
        ],
        [
            "func ClientOpen(c, agentPub []byte, clientPrv *ecdsa.PrivateKey) ([]byte, error) {\n\tsealed, sig := UnpackSignature(c)\n\thash := ethcrypto.Keccak256(sealed)\n\n\tif !VerifySignature(agentPub, hash, sig) {\n\t\treturn nil, ErrWrongSignature\n\t}\n\n\tprv := ecies.ImportECDSA(clientPrv)\n\n\topened, err := prv.Decrypt(sealed, nil, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn opened, nil\n}"
        ],
        [
            "func PackWithSignature(msg []byte, key *ecdsa.PrivateKey) ([]byte, error) {\n\tsig, err := signature(key, msg)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn packSignature(msg, sig), nil\n}"
        ],
        [
            "func UnpackSignature(c []byte) (msg []byte, sig []byte) {\n\tmsg = c[:len(c)-sigLen]\n\tsig = c[len(c)-sigLen:]\n\treturn\n}"
        ],
        [
            "func VerifySignature(pubk, msg, sig []byte) bool {\n\treturn ethcrypto.VerifySignature(pubk, msg, sig)\n}"
        ],
        [
            "func signature(key *ecdsa.PrivateKey, msg []byte) ([]byte, error) {\n\thash := ethcrypto.Keccak256(msg)\n\tsig, err := ethcrypto.Sign(hash, key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsig = sig[:len(sig)-1]\n\treturn sig, nil\n}"
        ],
        [
            "func (h *Handler) GetObject(\n\ttkn, objectType, id string) (json.RawMessage, error) {\n\tlogger := h.logger.Add(\"method\", \"GetObject\",\n\t\t\"type\", objectType, \"id\", id)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\ttable, ok := objectTypes[objectType]\n\tif !ok {\n\t\tlogger.Warn(ErrBadObjectType.Error())\n\t\treturn nil, ErrBadObjectType\n\t}\n\n\tobj, err := h.db.FindByPrimaryKeyFrom(table, id)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrObjectNotFound\n\t}\n\n\traw, err := json.Marshal(obj)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\treturn raw, nil\n}"
        ],
        [
            "func (h *Handler) GetObjectByHash(\n\ttkn, objectType, hash string) (json.RawMessage, error) {\n\tlogger := h.logger.Add(\"method\", \"GetObjectByHash\",\n\t\t\"type\", objectType, \"hash\", hash)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\ttable, ok := objectWithHashTypes[objectType]\n\tif !ok {\n\t\tlogger.Warn(ErrBadObjectType.Error())\n\t\treturn nil, ErrBadObjectType\n\t}\n\n\tobj, err := h.db.FindOneFrom(table, \"hash\", hash)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrObjectNotFound\n\t}\n\n\traw, err := json.Marshal(obj)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\treturn raw, nil\n}"
        ],
        [
            "func ToError(err error) *Error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\tif err, ok := err.(rpc.Error); ok {\n\t\treturn &Error{Code: err.ErrorCode(), Message: err.Error()}\n\t}\n\n\treturn &Error{Message: err.Error()}\n}"
        ],
        [
            "func (h *Handler) SetPassword(password string) error {\n\tlogger := h.logger.Add(\"method\", \"SetPassword\")\n\n\tlogger.Debug(\"trying to set password\")\n\n\tif password == \"\" {\n\t\tlogger.Warn(\"received empty password\")\n\t\treturn ErrEmptyPassword\n\t}\n\n\tif err := h.validatePasswordNotSet(logger); err != nil {\n\t\treturn err\n\t}\n\n\tsalt := util.NewUUID()\n\n\thashed, err := hashedPassword(logger, password, salt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttx, err := beginTX(logger, h.db)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer tx.Rollback()\n\n\tif err := insert(logger, tx.Querier,\n\t\tsaltSetting(salt), passwordHashSetting(hashed)); err != nil {\n\t\treturn err\n\t}\n\n\treturn commitTX(logger, tx)\n}"
        ],
        [
            "func (h *Handler) UpdatePassword(current, new string) error {\n\tlogger := h.logger.Add(\"method\", \"UpdatePassword\")\n\n\tif err := h.checkPassword(logger, current); err != nil {\n\t\treturn err\n\t}\n\n\tlogger.Debug(\"updating password\")\n\n\tif new == \"\" {\n\t\tlogger.Warn(\"received empty password for update\")\n\t\treturn ErrEmptyPassword\n\t}\n\n\tsalt := util.NewUUID()\n\n\thashed, err := hashedPassword(logger, new, salt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttx, err := beginTX(logger, h.db)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer tx.Rollback()\n\n\tif err := h.updatePrivateKeys(logger, tx, current, new); err != nil {\n\t\treturn err\n\t}\n\n\tif err := update(logger, tx.Querier,\n\t\tsaltSetting(salt), passwordHashSetting(hashed)); err != nil {\n\t\treturn err\n\t}\n\n\terr = commitTX(logger, tx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\th.token.Make()\n\n\treturn nil\n}"
        ],
        [
            "func (h *Handler) GetToken(password string) (*string, error) {\n\tlogger := h.logger.Add(\"method\", \"GetToken\")\n\n\tif err := h.checkPassword(logger, password); err != nil {\n\t\treturn nil, err\n\t}\n\n\tlogger.Debug(\"making access token\")\n\n\tv, err := h.token.Make()\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\treturn &v, nil\n}"
        ],
        [
            "func NewProcessor(\n\tconf *Config, db *reform.DB, queue job.Queue) *Processor {\n\treturn &Processor{\n\t\tconf:  conf,\n\t\tdb:    db,\n\t\tqueue: queue,\n\t}\n}"
        ],
        [
            "func NewConfig() *Config {\n\treturn &Config{\n\t\tCollectJobs:   100,\n\t\tCollectPeriod: 1000,\n\t\tWorkerBufLen:  10,\n\t\tWorkers:       0,\n\n\t\tTypeConfig: TypeConfig{\n\t\t\tTryLimit:  3,\n\t\t\tTryPeriod: 60000,\n\t\t},\n\t\tTypes: make(map[string]TypeConfig),\n\t}\n}"
        ],
        [
            "func NewQueue(conf *Config, logger log.Logger, db *reform.DB,\n\thandlers HandlerMap) Queue {\n\tl := logger.Add(\"type\", \"job.Queue\")\n\treturn &queue{\n\t\tconf:     conf,\n\t\tlogger:   l,\n\t\tdb:       db,\n\t\thandlers: handlers,\n\t\tsubs:     map[string][]subEntry{},\n\t}\n}"
        ],
        [
            "func AddWithDataAndDelay(q Queue, tx *reform.TX,\n\tjobType, relatedType, relatedID, creator string,\n\tjobData interface{}, delay time.Duration) error {\n\tdata2, err := json.Marshal(jobData)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn q.Add(tx, &data.Job{\n\t\tType:        jobType,\n\t\tRelatedType: relatedType,\n\t\tRelatedID:   relatedID,\n\t\tCreatedBy:   creator,\n\t\tData:        data2,\n\t\tNotBefore:   time.Now().Add(delay),\n\t})\n}"
        ],
        [
            "func AddWithData(q Queue, tx *reform.TX,\n\tjobType, relatedType, relatedID, creator string,\n\tjobData interface{}) error {\n\treturn AddWithDataAndDelay(q, tx, jobType,\n\t\trelatedType, relatedID, creator, jobData, time.Duration(0))\n}"
        ],
        [
            "func AddSimple(q Queue, tx *reform.TX,\n\tjobType, relatedType, relatedID, creator string) error {\n\treturn AddWithData(q, tx,\n\t\tjobType, relatedType, relatedID, creator, &struct{}{})\n}"
        ],
        [
            "func AddWithDelay(q Queue, tx *reform.TX,\n\tjobType, relatedType, relatedID, creator string,\n\tdelay time.Duration) error {\n\treturn AddWithDataAndDelay(q, tx,\n\t\tjobType, relatedType, relatedID, creator, &struct{}{}, delay)\n}"
        ],
        [
            "func (q *queue) Subscribe(\n\tsubKeys []string, subID string, subFunc SubFunc) error {\n\tq.subsMtx.Lock()\n\tdefer q.subsMtx.Unlock()\n\n\tfor i, v := range subKeys {\n\t\tif err := q.subscribe(v, subID, subFunc); err != nil {\n\t\t\tfor j := 0; j < i; j++ {\n\t\t\t\tq.unsubscribe(subKeys[j], subID)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (q *queue) Unsubscribe(subKeys []string, subID string) error {\n\tq.subsMtx.Lock()\n\tdefer q.subsMtx.Unlock()\n\n\tvar err error\n\tfor _, v := range subKeys {\n\t\tif err2 := q.unsubscribe(v, subID); err == nil {\n\t\t\terr = err2\n\t\t}\n\t}\n\n\treturn err\n}"
        ],
        [
            "func (h *Handler) TopUpChannel(\n\ttkn, channel string, deposit, gasPrice uint64) error {\n\tlogger := h.logger.Add(\"method\", \"TopUpChannel\",\n\t\t\"channel\", channel, \"deposit\", deposit, \"gasPrice\", gasPrice)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn ErrAccessDenied\n\t}\n\n\tch := &data.Channel{}\n\tif err := h.findByPrimaryKey(logger,\n\t\tErrChannelNotFound, ch, channel); err != nil {\n\t\treturn err\n\t}\n\n\tjobData, err := h.topUpChannelJobData(logger, deposit, gasPrice)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn job.AddWithData(h.queue, nil, data.JobClientPreChannelTopUp,\n\t\tdata.JobChannel, ch.ID, data.JobUser, jobData)\n}"
        ],
        [
            "func (h *Handler) ChangeChannelStatus(tkn, channel, action string) error {\n\tlogger := h.logger.Add(\"method\", \"ChangeChannelStatus\",\n\t\t\"channel\", channel, \"action\", action, \"userRole\", h.userRole)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn ErrAccessDenied\n\t}\n\n\tcondition := fmt.Sprintf(\"WHERE id = %s \", h.db.Placeholder(1))\n\n\tisAgent := h.userRole == data.RoleAgent\n\n\tif !isAgent {\n\t\tcondition = fmt.Sprintf(\"%s AND %s\",\n\t\t\tcondition, clientChannelsCondition)\n\t}\n\n\titems, err := h.selectAllFrom(\n\t\tlogger, data.ChannelTable, condition, channel)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\tif len(items) != 1 {\n\t\tlogger.Error(ErrChannelNotFound.Error())\n\t\treturn ErrChannelNotFound\n\t}\n\n\tswitch action {\n\tcase ChannelPauseAction:\n\t\t_, err = h.processor.SuspendChannel(\n\t\t\tchannel, data.JobUser, isAgent)\n\tcase ChannelResumeAction:\n\t\t_, err = h.processor.ActivateChannel(\n\t\t\tchannel, data.JobUser, isAgent)\n\tcase ChannelTerminateAction:\n\t\t_, err = h.processor.TerminateChannel(\n\t\t\tchannel, data.JobUser, isAgent)\n\tcase ChannelCloseAction:\n\t\tif isAgent {\n\t\t\tlogger.Error(ErrNotAllowedForAgent.Error())\n\t\t\treturn ErrNotAllowedForAgent\n\t\t}\n\t\tif err := h.createPreUncooperativeCloseRequest(\n\t\t\tchannel, logger); err != nil {\n\t\t\treturn ErrInternal\n\t\t}\n\tdefault:\n\t\tlogger.Warn(ErrBadAction.Error())\n\t\treturn ErrBadAction\n\t}\n\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (h *Handler) GetAgentChannels(tkn string,\n\tchannelStatus, serviceStatus []string,\n\toffset, limit uint) (*GetAgentChannelsResult, error) {\n\tlogger := h.logger.Add(\"method\", \"GetAgentChannels\",\n\t\t\"channelStatus\", channelStatus, \"serviceStatus\", serviceStatus)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tchannels, total, err := h.getChannels(\n\t\tlogger, channelStatus, serviceStatus,\n\t\tagentChannelsCondition, offset, limit)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &GetAgentChannelsResult{channels, total}, err\n}"
        ],
        [
            "func (h *Handler) GetChannelsUsage(tkn string, ids []string) (map[string]Usage, error) {\n\tlogger := h.logger.Add(\"method\", \"GetChannelsUsage\", \"objectType\", \"channel\", \"objectIDs\", ids)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\treturn h.getChannelsUsages(logger, ids)\n}"
        ],
        [
            "func (h *Handler) GetClientChannels(tkn string, channelStatus,\n\tserviceStatus []string, offset,\n\tlimit uint) (*GetClientChannelsResult, error) {\n\tlogger := h.logger.Add(\"method\", \"GetClientChannels\",\n\t\t\"channelStatus\", channelStatus, \"serviceStatus\", serviceStatus)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tchs, total, err := h.getChannels(logger, channelStatus, serviceStatus,\n\t\tclientChannelsCondition, offset, limit)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\titems := make([]ClientChannelInfo, 0)\n\tfor _, channel := range chs {\n\t\tresult, err := h.createClientChannelResult(logger, &channel)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\titems = append(items, *result)\n\t}\n\n\treturn &GetClientChannelsResult{items, total}, nil\n}"
        ],
        [
            "func ReadSetting(db *reform.Querier, key string) (string, error) {\n\tvar st Setting\n\tif err := FindByPrimaryKeyTo(db, &st, key); err != nil {\n\t\treturn \"\", fmt.Errorf(\n\t\t\t\"failed to find '%s' setting: %s\", key, err)\n\t}\n\treturn st.Value, nil\n}"
        ],
        [
            "func ReadUintSetting(db *reform.Querier, key string) (uint, error) {\n\tval, err := ReadSetting(db, key)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tval2, err := strconv.ParseUint(val, 10, 32)\n\tif err != nil {\n\t\treturn 0, newSettingParseError(key, err)\n\t}\n\n\treturn uint(val2), nil\n}"
        ],
        [
            "func ReadBoolSetting(db *reform.Querier, key string) (bool, error) {\n\tval, err := ReadSetting(db, key)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tval2, err := strconv.ParseBool(val)\n\tif err != nil {\n\t\treturn false, newSettingParseError(key, err)\n\t}\n\n\treturn bool(val2), nil\n}"
        ],
        [
            "func (p *Processor) SuspendChannel(id, jobCreator string,\n\tagent bool) (string, error) {\n\tvar jobType string\n\tif agent {\n\t\tjobType = data.JobAgentPreServiceSuspend\n\t} else {\n\t\tjobType = data.JobClientPreServiceSuspend\n\t}\n\n\treturn p.alterServiceStatus(id, jobCreator,\n\t\tjobType, \"\", suspendTransitions, false)\n}"
        ],
        [
            "func (p *Processor) ActivateChannel(id, jobCreator string,\n\tagent bool) (string, error) {\n\tvar jobType string\n\tif agent {\n\t\tjobType = data.JobAgentPreServiceUnsuspend\n\t} else {\n\t\tjobType = data.JobClientPreServiceUnsuspend\n\t}\n\n\treturn p.alterServiceStatus(id, jobCreator,\n\t\tjobType, \"\", activateTransitions, false)\n}"
        ],
        [
            "func (p *Processor) TerminateChannel(id, jobCreator string,\n\tagent bool) (string, error) {\n\tvar jobType string\n\tif agent {\n\t\tjobType = data.JobAgentPreServiceTerminate\n\t} else {\n\t\tjobType = data.JobClientPreServiceTerminate\n\t}\n\n\treturn p.alterServiceStatus(id, jobCreator,\n\t\tjobType, jobType, terminateTransitions, true)\n}"
        ],
        [
            "func (h *Handler) ExportPrivateKey(tkn, account string) ([]byte, error) {\n\tlogger := h.logger.Add(\"method\", \"ExportPrivateKey\",\n\t\t\"account\", account)\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tvar acc data.Account\n\terr := h.db.FindByPrimaryKeyTo(&acc, account)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\tif err == reform.ErrNoRows {\n\t\t\treturn nil, ErrAccountNotFound\n\t\t}\n\t\treturn nil, ErrInternal\n\t}\n\tkey, err := data.ToBytes(acc.PrivateKey)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\treturn key, nil\n}"
        ],
        [
            "func (h *Handler) GetAccounts(tkn string) ([]data.Account, error) {\n\tlogger := h.logger.Add(\"method\", \"GetAccounts\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\taccounts, err := h.selectAllFrom(logger, data.AccountTable, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := make([]data.Account, len(accounts))\n\n\tfor k, v := range accounts {\n\t\tresult[k] = *v.(*data.Account)\n\t}\n\n\treturn result, nil\n}"
        ],
        [
            "func (h *Handler) GenerateAccount(\n\ttkn string, params *AccountParams) (*string, error) {\n\tlogger := h.logger.Add(\"method\", \"GenerateAccount\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\taccount := params.prefilledAccount()\n\n\tid, err := h.fillAndSaveAccount(\n\t\tlogger, account, crypto.GenerateKey, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &id, nil\n}"
        ],
        [
            "func (h *Handler) ImportAccountFromHex(\n\ttkn string, params *AccountParamsWithHexKey) (*string, error) {\n\tlogger := h.logger.Add(\"method\", \"ImportAccountFromHex\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tmakeECDSAFunc := h.hexPrivateKeyToECDSA(params.PrivateKeyHex)\n\n\taccount := params.prefilledAccount()\n\n\tid, err := h.fillAndSaveAccount(logger, account, makeECDSAFunc, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &id, nil\n}"
        ],
        [
            "func (h *Handler) ImportAccountFromJSON(\n\ttkn string, params *AccountParams, jsonBlob json.RawMessage,\n\tjsonKeyStorePassword string) (*string, error) {\n\tlogger := h.logger.Add(\"method\", \"ImportAccountFromJSON\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\taccount := params.prefilledAccount()\n\n\tmakeECDSAFunc := h.jsonPrivateKeyToECDSA(\n\t\tjsonBlob, jsonKeyStorePassword)\n\n\tid, err := h.fillAndSaveAccount(\n\t\tlogger, account, makeECDSAFunc, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &id, nil\n}"
        ],
        [
            "func (h *Handler) TransferTokens(\n\ttkn, account, destination string, amount, gasPrice uint64) error {\n\tlogger := h.logger.Add(\"method\", \"TransferTokens\", \"destination\",\n\t\tdestination, \"amount\", amount, \"gasPrice\", gasPrice)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn ErrAccessDenied\n\t}\n\n\tif amount == 0 {\n\t\tlogger.Error(ErrTokenAmountTooSmall.Error())\n\t\treturn ErrTokenAmountTooSmall\n\t}\n\n\tif destination != data.ContractPSC && destination != data.ContractPTC {\n\t\tlogger.Error(ErrBadDestination.Error())\n\t\treturn ErrBadDestination\n\t}\n\n\terr := h.findByPrimaryKey(\n\t\tlogger, ErrAccountNotFound, &data.Account{}, account)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tjobType := data.JobPreAccountAddBalanceApprove\n\tif destination == data.ContractPTC {\n\t\tjobType = data.JobPreAccountReturnBalance\n\t}\n\n\tjobData := &data.JobBalanceData{\n\t\tAmount:   amount,\n\t\tGasPrice: gasPrice,\n\t}\n\n\terr = job.AddWithData(h.queue, nil, jobType,\n\t\tdata.JobAccount, account, data.JobUser, jobData)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (h *Handler) UpdateBalance(tkn, account string) error {\n\tlogger := h.logger.Add(\"method\", \"UpdateBalance\",\n\t\t\"account\", account)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn ErrAccessDenied\n\t}\n\n\terr := h.findByPrimaryKey(\n\t\tlogger, ErrAccountNotFound, &data.Account{}, account)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = job.AddSimple(h.queue, nil, data.JobAccountUpdateBalances,\n\t\tdata.JobAccount, account, data.JobUser)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (h *Handler) UpdateAccount(tkn, account, name string,\n\tisDefault, inUse bool) error {\n\tlogger := h.logger.Add(\"method\", \"UpdateAccount\",\n\t\t\"account\", account)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn ErrAccessDenied\n\t}\n\n\tacc := data.Account{}\n\terr := h.findByPrimaryKey(\n\t\tlogger, ErrAccountNotFound, &acc, account)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif name != \"\" {\n\t\tacc.Name = name\n\t}\n\n\tacc.IsDefault = isDefault\n\tacc.InUse = inUse\n\n\treturn update(logger, h.db.Querier, &acc)\n}"
        ],
        [
            "func (h *Handler) GetLastBlockNumber(tkn string) (*uint64, error) {\n\tlogger := h.logger.Add(\"method\", \"GetLastBlockNumber\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tminConfirmations, err := h.minConfirmations(logger)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar queryRet sql.NullInt64\n\trow := h.db.QueryRow(\"SELECT max((data->'ethereumLog'->>'block') :: bigint) from jobs\")\n\tif err := row.Scan(&queryRet); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\tlogger.Error(fmt.Sprint(queryRet.Int64))\n\tret := uint64(queryRet.Int64) + minConfirmations\n\treturn &ret, nil\n}"
        ],
        [
            "func (h *Handler) GetEndpoint(\n\tproduct, productPassword, clientKey string) (*data.Endpoint, error) {\n\tlogger := h.logger.Add(\"method\", \"GetEndpoint\",\n\t\t\"product\", product, \"clientKey\", clientKey)\n\n\tlogger.Info(\"channel endpoint request\")\n\n\tprod, err := h.checkProductPassword(logger, product, productPassword)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tch, err := h.findClientChannel(logger, prod, clientKey, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar ept data.Endpoint\n\tif err := h.db.FindOneTo(&ept, \"channel\", ch.ID); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrEndpointNotFound\n\t}\n\n\treturn &ept, nil\n}"
        ],
        [
            "func (h *Handler) SetProductConfig(\n\tproduct, productPassword string, config map[string]string) error {\n\tlogger := h.logger.Add(\"method\", \"SetProductConfig\",\n\t\t\"product\", product, \"config\", config)\n\n\tlogger.Info(\"product config update\")\n\n\tprod, err := h.checkProductPassword(logger, product, productPassword)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(config) == 0 {\n\t\tlogger.Warn(ErrBadProductConfig.Error())\n\t\treturn ErrBadProductConfig\n\t}\n\n\tprod.ServiceEndpointAddress = serviceEndpointAddress(prod, config)\n\tdelete(config, ProductExternalIP)\n\n\tif prod.ServiceEndpointAddress != nil {\n\t\tcountry2 := h.findCountry(logger, *prod.ServiceEndpointAddress)\n\t\tif len(country2) != 2 {\n\t\t\tcountry2 = country.UndefinedCountry\n\t\t}\n\t\tprod.Country = &country2\n\t}\n\n\tif prod.Config, err = json.Marshal(config); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\tif err := h.db.Update(prod); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func NewWriterLogger(conf *WriterConfig, out io.Writer) (Logger, error) {\n\tl := &writerLogger{}\n\n\tbase, err := NewLoggerBase(conf.BaseConfig, l.log)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tflags := log.LstdFlags\n\tif conf.UTC {\n\t\tflags |= log.LUTC\n\t}\n\n\tl.logger = log.New(out, conf.Prefix, flags)\n\tl.LoggerBase = base\n\n\treturn l, nil\n}"
        ],
        [
            "func NewFileLogger(conf *FileConfig) (Logger, io.Closer, error) {\n\tnow := time.Now()\n\tif conf.UTC {\n\t\tnow = now.UTC()\n\t}\n\n\tfile, err := os.OpenFile(\n\t\ttimeutil.Strftime(&now, conf.Filename),\n\t\tos.O_APPEND|os.O_CREATE|os.O_WRONLY, conf.FileMode)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tlogger, err := NewWriterLogger(conf.WriterConfig, file)\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, nil, err\n\t}\n\n\treturn logger, file, nil\n}"
        ],
        [
            "func (b *ClientBuilder) NewClient(somcType uint8, somcData data.Base64String) (Client, error) {\n\tif somcType == data.OfferingSOMCTor {\n\t\thostnameBytes, err := data.ToBytes(somcData)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttorClient, err := tor.NewHTTPClient(b.torSocks)\n\t\treturn somcsrv.NewClient(torClient, string(hostnameBytes)), nil\n\t}\n\n\treturn nil, ErrUnknownSOMCType\n}"
        ],
        [
            "func Parse(config *Config) (Interface, error) {\n\tswitch config.Mechanism {\n\tcase \"any\":\n\t\treturn any(config), nil\n\tcase \"upnp\":\n\t\treturn uPnP(config), nil\n\tcase \"pmp\":\n\t\treturn pmp(), nil\n\tdefault:\n\t\treturn nil, ErrBadMechanism\n\t}\n}"
        ],
        [
            "func Map(ctx context.Context, conf *Config, logger log.Logger, m Interface,\n\tprotocol string, extPort, intPort int, name string) error {\n\n\tmapUpdateInterval := time.Duration(\n\t\tconf.MapUpdateInterval) * time.Millisecond\n\n\tmapTimeout := time.Duration(conf.MapTimeout) * time.Millisecond\n\n\tlogger = logger.Add(\"proto\", protocol, \"extPort\", extPort,\n\t\t\"intPort\", intPort, \"mapUpdateInterval\", mapUpdateInterval,\n\t\t\"mapTimeout\", mapTimeout, \"name\", name)\n\n\tif err := m.AddMapping(protocol, extPort, intPort,\n\t\tname, mapTimeout); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrAddMapping\n\t}\n\tlogger.Info(\"mapped network port\")\n\tgo func() {\n\t\ttimer := time.NewTimer(mapUpdateInterval)\n\n\t\tdefer func() {\n\t\t\ttimer.Stop()\n\t\t\tlogger.Debug(\"deleting port mapping\")\n\t\t\tm.DeleteMapping(protocol, extPort, intPort)\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-timer.C:\n\t\t\t\tlogger.Debug(\"refreshing port mapping\")\n\t\t\t\tif err := m.AddMapping(protocol, extPort,\n\t\t\t\t\tintPort, name, mapTimeout); err != nil {\n\t\t\t\t\tlogger.Warn(\"couldn't add\" +\n\t\t\t\t\t\t\" port mapping, error: \" +\n\t\t\t\t\t\terr.Error())\n\t\t\t\t}\n\t\t\t\ttimer.Reset(mapUpdateInterval)\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}"
        ],
        [
            "func (n *discovery) AddMapping(protocol string, extPort, intPort int,\n\tname string, lifetime time.Duration) error {\n\tif err := n.wait(); err != nil {\n\t\treturn err\n\t}\n\treturn n.found.AddMapping(protocol, extPort, intPort, name, lifetime)\n}"
        ],
        [
            "func (n *discovery) DeleteMapping(protocol string, extPort, intPort int) error {\n\tif err := n.wait(); err != nil {\n\t\treturn err\n\t}\n\treturn n.found.DeleteMapping(protocol, extPort, intPort)\n}"
        ],
        [
            "func ReadFile(name string) ([]byte, error) {\n\tfs, err := fs.New()\n\tif err != nil {\n\t\treturn nil, ErrOpenFS\n\t}\n\n\tfile, err := fs.Open(name)\n\tif err != nil {\n\t\treturn nil, ErrOpenFile\n\t}\n\tdefer file.Close()\n\n\tdata, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\treturn nil, ErrReadFile\n\t}\n\n\treturn data, nil\n}"
        ],
        [
            "func (h *Handler) GetUserRole(tkn string) (*string, error) {\n\tlogger := h.logger.Add(\"method\", \"GetUserRole\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\treturn &h.userRole, nil\n}"
        ],
        [
            "func NewHandler(logger log.Logger, db *reform.DB,\n\tqueue job.Queue, pwdStorage data.PWDGetSetter,\n\tencryptKeyFunc data.EncryptedKeyFunc,\n\tdecryptKeyFunc data.ToPrivateKeyFunc, userRole string,\n\tprocessor *proc.Processor,\n\tsomcClientBuilder somc.ClientBuilderInterface,\n\ttoken TokenMakeChecker) *Handler {\n\tlogger = logger.Add(\"type\", \"ui.Handler\")\n\treturn &Handler{\n\t\tlogger:            logger,\n\t\tdb:                db,\n\t\tqueue:             queue,\n\t\tpwdStorage:        pwdStorage,\n\t\tencryptKeyFunc:    encryptKeyFunc,\n\t\tdecryptKeyFunc:    decryptKeyFunc,\n\t\tuserRole:          userRole,\n\t\tprocessor:         processor,\n\t\tsomcClientBuilder: somcClientBuilder,\n\t\ttoken:             token,\n\t}\n}"
        ],
        [
            "func NewBackend(cfg *Config, logger log.Logger) Backend {\n\tconn, ptc, psc, err := newInstance(cfg, logger)\n\tif err != nil {\n\t\tlogger.Fatal(err.Error())\n\t}\n\n\tb := &backendInstance{cfg: cfg, ptc: ptc, psc: psc,\n\t\tconn: conn, logger: logger,\n\t}\n\n\tgo b.connectionControl()\n\n\treturn b\n}"
        ],
        [
            "func (b *backendInstance) addTimeout(\n\tctx context.Context) (context.Context, context.CancelFunc) {\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\treturn context.WithTimeout(ctx,\n\t\ttime.Duration(b.cfg.Timeout)*time.Millisecond)\n}"
        ],
        [
            "func (b *backendInstance) PendingNonceAt(ctx context.Context, account common.Address) (uint64, error) {\n\tctx, cancel := b.addTimeout(ctx)\n\tdefer cancel()\n\treturn b.conn.ethClient().PendingNonceAt(ctx, account)\n}"
        ],
        [
            "func (b *backendInstance) SuggestGasPrice(\n\tctx context.Context) (*big.Int, error) {\n\tctx2, cancel := b.addTimeout(ctx)\n\tdefer cancel()\n\n\tgasPrice, err := b.conn.ethClient().SuggestGasPrice(ctx2)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get\"+\n\t\t\t\" suggested gas price: %s\", err)\n\t}\n\treturn gasPrice, err\n}"
        ],
        [
            "func (b *backendInstance) EstimateGas(\n\tctx context.Context, call ethereum.CallMsg) (gas uint64, err error) {\n\tctx2, cancel := b.addTimeout(ctx)\n\tdefer cancel()\n\n\tgas, err = b.conn.ethClient().EstimateGas(ctx2, call)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to estimated gas: %s\", err)\n\t}\n\treturn gas, err\n}"
        ],
        [
            "func (b *backendInstance) CooperativeClose(opts *bind.TransactOpts,\n\tagent common.Address, block uint32, offeringHash [common.HashLength]byte,\n\tbalance uint64, balanceSig, closingSig []byte) (*types.Transaction, error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\n\ttx, err := b.psc.CooperativeClose(opts, agent, block, offeringHash,\n\t\tbalance, balanceSig, closingSig)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to do cooperative close: %s\", err)\n\t}\n\treturn tx, nil\n}"
        ],
        [
            "func (b *backendInstance) GetTransactionByHash(ctx context.Context,\n\thash common.Hash) (*types.Transaction, bool, error) {\n\tctx2, cancel := b.addTimeout(ctx)\n\tdefer cancel()\n\n\ttx, pending, err := b.conn.ethClient().TransactionByHash(ctx2, hash)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to get transaction by hash: %s\", err)\n\t}\n\treturn tx, pending, err\n}"
        ],
        [
            "func (b *backendInstance) RegisterServiceOffering(opts *bind.TransactOpts,\n\tofferingHash [common.HashLength]byte,\n\tminDeposit uint64, maxSupply uint16,\n\tsomcType uint8, somcData data.Base64String) (*types.Transaction, error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\n\ttx, err := b.psc.RegisterServiceOffering(opts, offeringHash,\n\t\tminDeposit, maxSupply, somcType, string(somcData))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\n\t\t\t\"failed to register service offering: %s\", err)\n\t}\n\treturn tx, nil\n}"
        ],
        [
            "func (b *backendInstance) PTCBalanceOf(opts *bind.CallOpts,\n\towner common.Address) (*big.Int, error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\n\tval, err := b.ptc.BalanceOf(opts, owner)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to get PTC balance: %s\", err)\n\t}\n\treturn val, err\n}"
        ],
        [
            "func (b *backendInstance) PTCIncreaseApproval(opts *bind.TransactOpts,\n\tspender common.Address, addedVal *big.Int) (*types.Transaction, error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\n\ttx, err := b.ptc.IncreaseApproval(opts, spender, addedVal)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to PTC increase approval: %s\", err)\n\t}\n\treturn tx, nil\n}"
        ],
        [
            "func (b *backendInstance) PSCBalanceOf(opts *bind.CallOpts,\n\towner common.Address) (uint64, error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\n\tval, err := b.psc.BalanceOf(opts, owner)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to get PSC balance: %s\", err)\n\t}\n\treturn val, err\n}"
        ],
        [
            "func (b *backendInstance) PSCAddBalanceERC20(opts *bind.TransactOpts,\n\tamount uint64) (*types.Transaction, error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\n\ttx, err := b.psc.AddBalanceERC20(opts, amount)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to add ERC20 balance: %s\", err)\n\t}\n\treturn tx, nil\n}"
        ],
        [
            "func (b *backendInstance) PSCGetOfferingInfo(opts *bind.CallOpts,\n\thash [common.HashLength]byte) (agentAddr common.Address,\n\tminDeposit uint64, maxSupply uint16, currentSupply uint16,\n\tupdateBlockNumber uint32, active bool, err error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\n\tagentAddr, minDeposit, maxSupply, currentSupply,\n\t\tupdateBlockNumber, err = b.psc.GetOfferingInfo(opts, hash)\n\tactive = updateBlockNumber != 0\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to get PSC offering supply: %s\", err)\n\t}\n\treturn agentAddr, minDeposit, maxSupply, currentSupply,\n\t\tupdateBlockNumber, active, err\n}"
        ],
        [
            "func (b *backendInstance) PSCGetChannelInfo(opts *bind.CallOpts,\n\tclient common.Address, agent common.Address,\n\tblockNumber uint32,\n\thash [common.HashLength]byte) (uint64, uint32, uint64, error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\treturn b.psc.GetChannelInfo(opts, client, agent, blockNumber, hash)\n}"
        ],
        [
            "func (b *backendInstance) EthBalanceAt(ctx context.Context,\n\towner common.Address) (*big.Int, error) {\n\tctx2, cancel := b.addTimeout(ctx)\n\tdefer cancel()\n\n\treturn b.conn.ethClient().BalanceAt(ctx2, owner, nil)\n}"
        ],
        [
            "func (b *backendInstance) PSCSettle(opts *bind.TransactOpts,\n\tagent common.Address, blockNumber uint32,\n\thash [common.HashLength]byte) (*types.Transaction, error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\n\ttx, err := b.psc.Settle(opts, agent, blockNumber, hash)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to settle\"+\n\t\t\t\" PSC channel: %s\", err)\n\t}\n\treturn tx, err\n}"
        ],
        [
            "func (b *backendInstance) PSCRemoveServiceOffering(opts *bind.TransactOpts,\n\tofferingHash [32]byte) (*types.Transaction, error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\n\ttx, err := b.psc.RemoveServiceOffering(opts, offeringHash)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to remove\"+\n\t\t\t\" service offering: %v\", err)\n\t}\n\treturn tx, err\n}"
        ],
        [
            "func (b *backendInstance) PSCPopupServiceOffering(opts *bind.TransactOpts,\n\tofferingHash [32]byte, somcType uint8, somcData data.Base64String) (*types.Transaction, error) {\n\tctx2, cancel := b.addTimeout(opts.Context)\n\tdefer cancel()\n\n\topts.Context = ctx2\n\n\ttx, err := b.psc.PopupServiceOffering(opts, offeringHash,\n\t\tsomcType, string(somcData))\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to pop up service offering: %v\", err)\n\t}\n\treturn tx, err\n}"
        ],
        [
            "func (b *backendInstance) FilterLogs(ctx context.Context,\n\tq ethereum.FilterQuery) ([]types.Log, error) {\n\treturn b.conn.ethClient().FilterLogs(ctx, q)\n}"
        ],
        [
            "func (b *backendInstance) HeaderByNumber(ctx context.Context,\n\tnumber *big.Int) (*types.Header, error) {\n\treturn b.conn.ethClient().HeaderByNumber(ctx, number)\n}"
        ],
        [
            "func (b *backendInstance) PTCAddress() common.Address {\n\treturn common.HexToAddress(b.cfg.Contract.PTCAddrHex)\n}"
        ],
        [
            "func (b *backendInstance) PSCAddress() common.Address {\n\treturn common.HexToAddress(b.cfg.Contract.PSCAddrHex)\n}"
        ],
        [
            "func NewHandler(db *reform.DB, logger log.Logger) *Handler {\n\treturn &Handler{db: db, logger: logger.Add(\"type\", \"tor-somc.Handler\")}\n}"
        ],
        [
            "func (w *Worker) keyFromChannelData(logger log.Logger,\n\tchannel string) (data.Base64String, error) {\n\tch, err := w.channel(logger, channel)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\toffering, err := w.offering(logger, ch.Offering)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tkey, err := data.ChannelKey(ch.Client, ch.Agent,\n\t\tch.Block, offering.Hash)\n\t// internal\n\tif err != nil {\n\t\tlogger.Add(\"channel\", ch, \"offering\", offering).Error(err.Error())\n\t\treturn \"\", ErrInternal\n\t}\n\treturn data.FromBytes(key), nil\n}"
        ],
        [
            "func (w *Worker) AgentAfterChannelCreate(job *data.Job) error {\n\tif w.isJobInvalid(job, data.JobAgentAfterChannelCreate, data.JobChannel) {\n\t\treturn ErrInvalidJob\n\t}\n\n\tlogger := w.logger.Add(\"method\", \"AgentAfterChannelCreate\", \"job\", job)\n\n\tethLog, err := w.ethLog(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tethLogTx, err := w.ethLogTx(logger, ethLog)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tclient, newUser, err := w.newUser(logger, ethLogTx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"client\", client)\n\n\ttx, err := w.db.Begin()\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\tdefer tx.Rollback()\n\n\tif newUser {\n\t\tif err := tx.Insert(client); err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t\treturn ErrInternal\n\t\t}\n\t}\n\n\tlogChannelCreated, err := extractLogChannelCreated(logger, ethLog)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toffering, err := w.offeringByHash(logger, logChannelCreated.offeringHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toffering.CurrentSupply--\n\tif err := tx.Update(offering); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\tchannel := &data.Channel{\n\t\tID:            job.RelatedID,\n\t\tClient:        data.HexFromBytes(logChannelCreated.clientAddr.Bytes()),\n\t\tAgent:         data.HexFromBytes(logChannelCreated.agentAddr.Bytes()),\n\t\tTotalDeposit:  logChannelCreated.deposit.Uint64(),\n\t\tChannelStatus: data.ChannelActive,\n\t\tServiceStatus: data.ServicePending,\n\t\tOffering:      offering.ID,\n\t\tBlock:         uint32(ethLog.Block),\n\t}\n\n\tif err := tx.Insert(channel); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\tif err := w.addJob(logger, tx, data.JobAgentPreEndpointMsgCreate,\n\t\tdata.JobChannel, channel.ID); err != nil {\n\t\treturn err\n\t}\n\n\tif err := tx.Commit(); err != nil {\n\t\tlogger.Error(\"unable to commit changes: \" + err.Error())\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (w *Worker) AgentAfterChannelTopUp(job *data.Job) error {\n\treturn w.afterChannelTopUp(job, data.JobAgentAfterChannelTopUp)\n}"
        ],
        [
            "func (w *Worker) AgentAfterUncooperativeCloseRequest(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"AgentAfterUncooperativeCloseRequest\",\n\t\t\"job\", job)\n\tchannel, err := w.relatedChannel(logger, job,\n\t\tdata.JobAgentAfterUncooperativeCloseRequest)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"channel\", channel)\n\n\tif channel.ServiceStatus != data.ServiceTerminated {\n\t\t_, err = w.processor.TerminateChannel(\n\t\t\tchannel.ID, data.JobTask, true)\n\t\tif err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t\treturn ErrTerminateChannel\n\t\t}\n\t}\n\n\tchannel.ChannelStatus = data.ChannelInChallenge\n\tif err = w.db.Update(channel); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (w *Worker) AgentAfterUncooperativeClose(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"AgentAfterUncooperativeClose\",\n\t\t\"job\", job)\n\n\tchannel, err := w.relatedChannel(logger, job,\n\t\tdata.JobAgentAfterUncooperativeClose)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif channel.ServiceStatus != data.ServiceTerminated {\n\t\t_, err = w.processor.TerminateChannel(\n\t\t\tchannel.ID, data.JobTask, true)\n\t\tif err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t\treturn ErrTerminateChannel\n\t\t}\n\t}\n\n\tchannel.ChannelStatus = data.ChannelClosedUncoop\n\tif err = w.db.Update(channel); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\tif err := w.incrementCurrentSupply(logger,\n\t\tw.db.Querier, channel.Offering); err != nil {\n\t\treturn err\n\t}\n\n\tagent, err := w.account(logger, channel.Agent)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn w.addJob(logger, nil,\n\t\tdata.JobAccountUpdateBalances, data.JobAccount, agent.ID)\n}"
        ],
        [
            "func (w *Worker) AgentAfterCooperativeClose(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"AgentAfterCooperativeClose\",\n\t\t\"job\", job)\n\tchannel, err := w.relatedChannel(logger,\n\t\tjob, data.JobAgentAfterCooperativeClose)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn w.db.InTransaction(func(tx *reform.TX) error {\n\t\tchannel.ChannelStatus = data.ChannelClosedCoop\n\t\tif err := tx.Update(channel); err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t\treturn ErrInternal\n\t\t}\n\n\t\tif err := w.incrementCurrentSupply(logger, tx.Querier,\n\t\t\tchannel.Offering); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tagent, err := w.account(logger, channel.Agent)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn w.addJob(logger, tx,\n\t\t\tdata.JobAccountUpdateBalances, data.JobAccount, agent.ID)\n\t})\n}"
        ],
        [
            "func (w *Worker) AgentPreServiceSuspend(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"AgentPreServiceSuspend\", \"job\", job)\n\t_, err := w.agentUpdateServiceStatus(logger, job,\n\t\tdata.JobAgentPreServiceSuspend)\n\treturn err\n}"
        ],
        [
            "func (w *Worker) AgentPreServiceUnsuspend(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"AgentPreServiceSuspend\", \"job\", job)\n\t_, err := w.agentUpdateServiceStatus(logger, job,\n\t\tdata.JobAgentPreServiceUnsuspend)\n\treturn err\n}"
        ],
        [
            "func (w *Worker) AgentPreServiceTerminate(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"AgentPreServiceSuspend\", \"job\", job)\n\tchannel, err := w.agentUpdateServiceStatus(logger, job,\n\t\tdata.JobAgentPreServiceTerminate)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif channel.ReceiptBalance == 0 {\n\t\treturn nil\n\t}\n\n\treturn w.agentCooperativeClose(logger, job, channel)\n}"
        ],
        [
            "func (w *Worker) AgentAfterOfferingMsgBCPublish(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"AgentAfterOfferingMsgBCPublish\",\n\t\t\"job\", job)\n\toffering, err := w.relatedOffering(logger, job,\n\t\tdata.JobAgentAfterOfferingMsgBCPublish)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tethLog, err := w.ethLog(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"ethLog\", ethLog)\n\n\toffering.Status = data.OfferRegistered\n\toffering.BlockNumberUpdated = ethLog.Block\n\tif err = w.db.Update(offering); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\tagent, err := w.account(logger, offering.Agent)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn w.addJob(logger, nil,\n\t\tdata.JobAccountUpdateBalances, data.JobAccount, agent.ID)\n}"
        ],
        [
            "func (w *Worker) AgentAfterOfferingDelete(job *data.Job) error {\n\tlogger := w.logger.Add(\n\t\t\"method\", \"AgentAfterOfferingDelete\", \"job\", job)\n\n\toffering, err := w.relatedOffering(\n\t\tlogger, job, data.JobAgentAfterOfferingDelete)\n\tif err != nil {\n\t\treturn err\n\t}\n\toffering.Status = data.OfferRemoved\n\n\tif err := w.saveRecord(logger, w.db.Querier, offering); err != nil {\n\t\treturn err\n\t}\n\n\tagent, err := w.account(logger, offering.Agent)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn w.addJob(logger, nil,\n\t\tdata.JobAccountUpdateBalances, data.JobAccount, agent.ID)\n}"
        ],
        [
            "func (w *Worker) AgentPreOfferingDelete(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"AgentPreOfferingDelete\", \"job\", job)\n\n\toffering, err := w.relatedOffering(logger,\n\t\tjob, data.JobAgentPreOfferingDelete)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif offering.Status != data.OfferRegistered &&\n\t\toffering.Status != data.OfferPoppedUp {\n\t\treturn ErrOfferNotRegistered\n\t}\n\n\tjobDate, err := w.publishData(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkey, err := w.accountKey(logger, offering.Agent)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tofferingHash, err := data.HexToHash(offering.Hash)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn err\n\t}\n\n\terr = w.checkInPeriod(logger, offeringHash, data.SettingsPeriodRemove,\n\t\tErrOfferingDeletePeriodIsNotOver)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tauth := bind.NewKeyedTransactor(key)\n\tauth.GasLimit = w.gasConf.PSC.RemoveServiceOffering\n\tauth.GasPrice = new(big.Int).SetUint64(jobDate.GasPrice)\n\n\ttx, err := w.ethBack.PSCRemoveServiceOffering(auth, offeringHash)\n\tif err != nil {\n\t\tlogger.Add(\"GasLimit\", auth.GasLimit,\n\t\t\t\"GasPrice\", auth.GasPrice).Error(err.Error())\n\t\treturn ErrPSCRemoveOffering\n\t}\n\n\toffering.Status = data.OfferRemoving\n\tif err := w.saveRecord(logger, w.db.Querier,\n\t\toffering); err != nil {\n\t\treturn err\n\t}\n\n\treturn w.saveEthTX(logger, job, tx, \"RemoveServiceOffering\",\n\t\tjob.RelatedType, job.RelatedID, offering.Agent,\n\t\tdata.HexFromBytes(w.pscAddr.Bytes()))\n}"
        ],
        [
            "func (w *Worker) checkInPeriod(logger log.Logger, hash common.Hash,\n\tperiodKey string, periodErr error) error {\n\tupdateBlockNumber, err := w.getOfferingBlockNumber(logger, hash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlastBlock, err := w.ethBack.LatestBlockNumber(context.Background())\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\tremovePeriod, err := data.ReadUintSetting(w.db.Querier, periodKey)\n\tif err != nil {\n\t\treturn periodErr\n\t}\n\n\tif uint64(updateBlockNumber)+uint64(removePeriod) > lastBlock.Uint64() {\n\t\treturn periodErr\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (w *Worker) AgentPreOfferingPopUp(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"AgentPreOfferingPopUp\", \"job\", job)\n\toffering, err := w.relatedOffering(logger,\n\t\tjob, data.JobAgentPreOfferingPopUp)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"offering\", offering.ID)\n\n\tif offering.Status != data.OfferRegistered &&\n\t\toffering.Status != data.OfferPoppedUp {\n\t\treturn ErrOfferNotRegistered\n\t}\n\n\tjobDate, err := w.publishData(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tofferingHash, err := data.HexToHash(offering.Hash)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\terr = w.agentOfferingPopUpFindRelatedJobs(logger, offering.ID, job.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = w.checkInPeriod(logger, offeringHash, data.SettingsPeriodPopUp,\n\t\tErrPopUpPeriodIsNotOver)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkey, err := w.accountKey(logger, offering.Agent)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tauth := bind.NewKeyedTransactor(key)\n\tauth.GasLimit = w.gasConf.PSC.PopupServiceOffering\n\tauth.GasPrice = new(big.Int).SetUint64(jobDate.GasPrice)\n\n\ttx, err := w.ethBack.PSCPopupServiceOffering(auth, offeringHash,\n\t\toffering.SOMCType, offering.SOMCData)\n\tif err != nil {\n\t\tlogger.Add(\"GasLimit\", auth.GasLimit,\n\t\t\t\"GasPrice\", auth.GasPrice).Error(err.Error())\n\t\treturn ErrPSCPopUpOffering\n\t}\n\n\toffering.Status = data.OfferPoppingUp\n\tif err := w.saveRecord(logger, w.db.Querier, offering); err != nil {\n\t\treturn err\n\t}\n\n\treturn w.saveEthTX(logger, job, tx, \"PopupServiceOffering\",\n\t\tjob.RelatedType, job.RelatedID, offering.Agent,\n\t\tdata.HexFromBytes(w.pscAddr.Bytes()))\n}"
        ],
        [
            "func (w *Worker) AgentAfterOfferingPopUp(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"AgentAfterOfferingPopUp\", \"job\", job)\n\n\tethLog, err := w.ethLog(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"ethLog\", ethLog)\n\n\tlogOfferingPopUp, err := extractLogOfferingPopUp(logger, ethLog)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toffering := data.Offering{}\n\thash := data.HexFromBytes(logOfferingPopUp.offeringHash.Bytes())\n\terr = w.db.FindOneTo(&offering, \"hash\", hash)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\toffering.BlockNumberUpdated = ethLog.Block\n\toffering.Status = data.OfferPoppedUp\n\n\treturn w.saveRecord(logger, w.db.Querier, &offering)\n}"
        ],
        [
            "func Print(run bool, commit, version string) {\n\tif run {\n\t\tfmt.Println(Message(commit, version))\n\t\tos.Exit(0)\n\t}\n}"
        ],
        [
            "func (e Error) Error() string {\n\tif msg, ok := Message(e); ok {\n\t\treturn fmt.Sprintf(\"%s (%d)\", msg, e)\n\t}\n\treturn \"unknown error\"\n}"
        ],
        [
            "func Message(e Error) (string, bool) {\n\tmsg, ok := msgs[e]\n\treturn msg, ok\n}"
        ],
        [
            "func (s *Server) RespondResult(logger log.Logger, w http.ResponseWriter,\n\tresult interface{}) {\n\tlogger = logger.Add(\"result\", result)\n\tdata, err := json.Marshal(result)\n\tif err != nil {\n\t\tlogger.Error(\"failed to marhsal respond result: \" + err.Error())\n\t\ts.RespondError(logger, w, ErrInternalServerError)\n\t\treturn\n\t}\n\n\ts.respond(logger, w, &Response{Result: data})\n}"
        ],
        [
            "func (s *Server) RespondError(logger log.Logger, w http.ResponseWriter, err *Error) {\n\ts.respond(logger, w, &Response{Error: err})\n}"
        ],
        [
            "func (s *Server) handlePay(\n\tw http.ResponseWriter, r *http.Request, ctx *srv.Context) {\n\tlogger := s.logger.Add(\"method\", \"handlePay\", \"sender\", r.RemoteAddr)\n\n\tpayload := &paymentPayload{}\n\tif !s.ParseRequest(logger, w, r, payload) {\n\t\treturn\n\t}\n\tlogger = logger.Add(\"payload\", *payload)\n\n\tch, ok := s.findChannel(logger, w,\n\t\tpayload.OfferingHash,\n\t\tpayload.AgentAddress, payload.OpenBlockNumber)\n\n\tlogger = logger.Add(\"channel\", ch)\n\n\tif ok && s.isServiceTerminated(logger, w, ch) {\n\t\treturn\n\t}\n\n\tif !ok || !s.validateChannelForPayment(logger, w, ch, payload) ||\n\t\t!s.updateChannelWithPayment(logger, w, ch, payload) {\n\t\treturn\n\t}\n\n\ts.RespondResult(logger, w, struct{}{})\n\n\tlogger.Info(fmt.Sprintf(\"received payment: %d, from: %s\", payload.Balance, ch.Client))\n}"
        ],
        [
            "func (m *Monitor) getOpenBlockNumber(\n\tel *data.JobEthLog) (block uint32, ok bool, err error) {\n\tvar event string\n\tswitch el.Topics[0] {\n\tcase eth.ServiceChannelToppedUp:\n\t\tevent = logChannelToppedUp\n\tcase eth.ServiceChannelCloseRequested:\n\t\tevent = logChannelCloseRequested\n\tcase eth.ServiceCooperativeChannelClose:\n\t\tevent = logCooperativeChannelClose\n\tcase eth.ServiceUnCooperativeChannelClose:\n\t\tevent = logUnCooperativeChannelClose\n\tdefault:\n\t\treturn\n\t}\n\n\tif event != \"\" {\n\t\tblock, err = m.blockNumber(el.Data,\n\t\t\tlogChannelToppedUp)\n\t\tok = true\n\t}\n\treturn\n}"
        ],
        [
            "func (h *Handler) Offering(hash data.HexString) (*data.Base64String, error) {\n\tlogger := h.logger.Add(\"method\", \"Offering\")\n\n\toffering, err := h.offeringByHash(logger, hash)\n\tif err != nil {\n\t\tif err == ErrOfferingNotFound {\n\t\t\tlogger.Warn(\"unexpected request for offering: \" + string(hash))\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn &offering.RawMsg, nil\n}"
        ],
        [
            "func HandlersMap(worker *worker.Worker) job.HandlerMap {\n\treturn job.HandlerMap{\n\t\t// Agent jobs.\n\t\tdata.JobAgentAfterChannelCreate:             worker.AgentAfterChannelCreate,\n\t\tdata.JobAgentAfterChannelTopUp:              worker.AgentAfterChannelTopUp,\n\t\tdata.JobAgentAfterUncooperativeCloseRequest: worker.AgentAfterUncooperativeCloseRequest,\n\t\tdata.JobAgentAfterUncooperativeClose:        worker.AgentAfterUncooperativeClose,\n\t\tdata.JobAgentAfterCooperativeClose:          worker.AgentAfterCooperativeClose,\n\t\tdata.JobAgentPreServiceSuspend:              worker.AgentPreServiceSuspend,\n\t\tdata.JobAgentPreServiceUnsuspend:            worker.AgentPreServiceUnsuspend,\n\t\tdata.JobAgentPreServiceTerminate:            worker.AgentPreServiceTerminate,\n\t\tdata.JobAgentPreEndpointMsgCreate:           worker.AgentPreEndpointMsgCreate,\n\t\tdata.JobAgentPreOfferingMsgBCPublish:        worker.AgentPreOfferingMsgBCPublish,\n\t\tdata.JobAgentAfterOfferingMsgBCPublish:      worker.AgentAfterOfferingMsgBCPublish,\n\t\tdata.JobAgentPreOfferingPopUp:               worker.AgentPreOfferingPopUp,\n\t\tdata.JobAgentAfterOfferingPopUp:             worker.AgentAfterOfferingPopUp,\n\t\tdata.JobAgentPreOfferingDelete:              worker.AgentPreOfferingDelete,\n\t\tdata.JobAgentAfterOfferingDelete:            worker.AgentAfterOfferingDelete,\n\n\t\t// Client jobs.\n\t\tdata.JobClientAfterOfferingDelete:            worker.ClientAfterOfferingDelete,\n\t\tdata.JobClientAfterOfferingPopUp:             worker.ClientAfterOfferingPopUp,\n\t\tdata.JobClientPreChannelCreate:               worker.ClientPreChannelCreate,\n\t\tdata.JobClientAfterChannelCreate:             worker.ClientAfterChannelCreate,\n\t\tdata.JobClientEndpointRestore:                worker.ClientEndpointCreate,\n\t\tdata.JobClientAfterUncooperativeClose:        worker.ClientAfterUncooperativeClose,\n\t\tdata.JobClientAfterCooperativeClose:          worker.ClientAfterCooperativeClose,\n\t\tdata.JobClientPreUncooperativeClose:          worker.ClientPreUncooperativeClose,\n\t\tdata.JobClientPreChannelTopUp:                worker.ClientPreChannelTopUp,\n\t\tdata.JobClientAfterChannelTopUp:              worker.ClientAfterChannelTopUp,\n\t\tdata.JobClientPreUncooperativeCloseRequest:   worker.ClientPreUncooperativeCloseRequest,\n\t\tdata.JobClientAfterUncooperativeCloseRequest: worker.ClientAfterUncooperativeCloseRequest,\n\t\tdata.JobClientPreServiceTerminate:            worker.ClientPreServiceTerminate,\n\t\tdata.JobClientPreServiceSuspend:              worker.ClientPreServiceSuspend,\n\t\tdata.JobClientPreServiceUnsuspend:            worker.ClientPreServiceUnsuspend,\n\t\tdata.JobClientAfterOfferingMsgBCPublish:      worker.ClientAfterOfferingMsgBCPublish,\n\t\tdata.JobClientCompleteServiceTransition:      worker.ClientCompleteServiceTransition,\n\n\t\t// Common jobs.\n\t\tdata.JobPreAccountAddBalanceApprove: worker.PreAccountAddBalanceApprove,\n\t\tdata.JobPreAccountAddBalance:        worker.PreAccountAddBalance,\n\t\tdata.JobAfterAccountAddBalance:      worker.AfterAccountAddBalance,\n\t\tdata.JobPreAccountReturnBalance:     worker.PreAccountReturnBalance,\n\t\tdata.JobAfterAccountReturnBalance:   worker.AfterAccountReturnBalance,\n\t\tdata.JobAccountUpdateBalances:       worker.AccountUpdateBalances,\n\t\tdata.JobDecrementCurrentSupply:      worker.DecrementCurrentSupply,\n\t\tdata.JobIncrementCurrentSupply:      worker.IncrementCurrentSupply,\n\t}\n}"
        ],
        [
            "func Version(connStr string) (int64, error) {\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer db.Close()\n\treturn goose.GetDBVersion(db)\n}"
        ],
        [
            "func Migrate(connStr string, version int64) error {\n\tdb, err := sql.Open(\"postgres\", connStr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer db.Close()\n\n\tif version == 0 {\n\t\tmigrations, err := goose.CollectMigrations(\".\", minVersion, maxVersion)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlast, err := migrations.Last()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tversion = last.Version\n\t}\n\n\treturn executeMigrationScripts(db, version)\n}"
        ],
        [
            "func NewMonitor(interval uint64, db *reform.DB,\n\tlogger log.Logger, pr *proc.Processor) (*Monitor, error) {\n\tif db == nil || logger == nil || pr == nil || interval == 0 {\n\t\treturn nil, ErrInput\n\t}\n\n\treturn &Monitor{\n\t\tdb:       db,\n\t\tlogger:   logger.Add(\"type\", \"agent/bill.Monitor\"),\n\t\tpr:       pr,\n\t\tinterval: interval,\n\t}, nil\n}"
        ],
        [
            "func (m *Monitor) Run() error {\n\tm.logger.Info(\"Billing monitor started\")\n\n\tfor {\n\t\tif err := m.processRound(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttime.Sleep(time.Duration(m.interval) * time.Millisecond)\n\t}\n}"
        ],
        [
            "func (m *Monitor) VerifyBillingLags() error {\n\t// Checking billing lags.\n\t// All channels, that are not suspended and are not terminated,\n\t// but are suffering from the billing lags - must be suspended.\n\tquery := `\n              SELECT channels.id :: text\n\t\tFROM channels\n                     LEFT JOIN sessions ses\n                     ON channels.id = ses.channel\n\n                     LEFT JOIN offerings offer\n                     ON channels.offering = offer.id\n\n                     INNER JOIN accounts acc\n                     ON channels.agent = acc.eth_addr\n               WHERE channels.service_status IN ('pending', 'active')\n                     AND channels.channel_status NOT IN ('pending')\n                     AND acc.in_use\n               GROUP BY channels.id, offer.billing_interval,\n                     offer.setup_price, offer.unit_price,\n                     offer.max_billing_unit_lag\n              HAVING COALESCE(SUM(ses.units_used), 0) /\n\t      offer.billing_interval - (channels.receipt_balance - offer.setup_price ) /\n\t      offer.unit_price > offer.max_billing_unit_lag;`\n\n\treturn m.processEachChannel(query, m.suspendService)\n}"
        ],
        [
            "func (m *Monitor) VerifySuspendedChannelsAndTryToUnsuspend() error {\n\t// All channels, that are suspended,\n\t// but now seems to be payed - must be unsuspended.\n\tquery := `\n              SELECT channels.id :: text\n\t\tFROM channels\n                     LEFT JOIN sessions ses\n                     ON channels.id = ses.channel\n\n                     LEFT JOIN offerings offer\n                     ON channels.offering = offer.id\n\n                     INNER JOIN accounts acc\n                     ON channels.agent = acc.eth_addr\n               WHERE channels.service_status IN ('suspended')\n                 AND channels.channel_status NOT IN ('pending')\n                 AND acc.in_use\n               GROUP BY channels.id, offer.billing_interval,\n                     offer.setup_price, offer.unit_price,\n                     offer.max_billing_unit_lag\n              HAVING COALESCE(SUM(ses.units_used), 0) /\n\t      offer.billing_interval - (channels.receipt_balance - offer.setup_price) /\n\t      offer.unit_price <= offer.max_billing_unit_lag;`\n\n\treturn m.processEachChannel(query, m.unsuspendService)\n}"
        ],
        [
            "func (m *Monitor) VerifyChannelsForInactivity() error {\n\tquery := `\n              SELECT channels.id::text\n\t\tFROM channels\n                     LEFT JOIN sessions ses\n                     ON channels.id = ses.channel\n                     LEFT JOIN offerings offer\n                     ON channels.offering = offer.id\n                     INNER JOIN accounts acc\n                     ON channels.agent = acc.eth_addr\n               WHERE channels.service_status IN ('pending', 'active', 'suspended')\n                 AND channels.channel_status NOT IN ('pending')\n                 AND acc.in_use\n               GROUP BY channels.id, offer.max_inactive_time_sec\n              HAVING GREATEST(MAX(ses.last_usage_time), channels.service_changed_time) +\n\t      (offer.max_inactive_time_sec * INTERVAL '1 second') < now();`\n\n\treturn m.processEachChannel(query, m.terminateService)\n}"
        ],
        [
            "func (m *Monitor) VerifySuspendedChannelsAndTryToTerminate() error {\n\tquery := `\n              SELECT channels.id::text\n\t\tFROM channels\n                     LEFT JOIN offerings offer\n                     ON channels.offering = offer.id\n\n                     INNER JOIN accounts acc\n                     ON channels.agent = acc.eth_addr\n               WHERE channels.service_status = 'suspended'\n                 AND channels.channel_status NOT IN ('pending')\n                 AND acc.in_use\n                 AND channels.service_changed_time + (offer.max_suspended_time * INTERVAL '1 SECOND') < now();`\n\n\treturn m.processEachChannel(query, m.terminateService)\n}"
        ],
        [
            "func NewLogger(conf *Config, db *reform.DB) (log.Logger, error) {\n\tl := &dbLogger{db: db}\n\n\tbase, err := log.NewLoggerBase(conf.BaseConfig, l.log)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tl.LoggerBase = base\n\treturn l, nil\n}"
        ],
        [
            "func BalanceClosingHash(clientAddr, pscAddr common.Address, block uint32,\n\tofferingHash common.Hash, balance uint64) []byte {\n\tblockBytes := data.Uint32ToBytes(block)\n\tbalanceBytes := data.Uint64ToBytes(balance)\n\treturn crypto.Keccak256(\n\t\t[]byte(\"\\x19Ethereum Signed Message:\\n32\"),\n\t\tcrypto.Keccak256(\n\t\t\t[]byte(\"Privatix: receiver closing signature\"),\n\t\t\tclientAddr.Bytes(),\n\t\t\tblockBytes[:],\n\t\t\tofferingHash.Bytes(),\n\t\t\tbalanceBytes[:],\n\t\t\tpscAddr.Bytes(),\n\t\t),\n\t)\n}"
        ],
        [
            "func Run(ctx context.Context, conf *Config,\n\tlogger log.Logger, ports []uint16) {\n\tif conf.Mechanism == \"\" {\n\t\tlogger.Debug(\"traversal NAT is not needed.\")\n\t\treturn\n\t}\n\n\tservice, err := Parse(conf)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn\n\t}\n\n\tfor k := range ports {\n\t\t// Remove old rules.\n\t\tservice.DeleteMapping(\"tcp\", int(ports[k]), int(ports[k]))\n\n\t\tname := fmt.Sprintf(\"service-%d\", k)\n\t\tif err := Map(ctx, conf, logger, service, \"tcp\",\n\t\t\tint(ports[k]), int(ports[k]), name); err != nil {\n\t\t\tmsg := fmt.Sprintf(\"failed to add port\"+\n\t\t\t\t\" mapping to %d port\", ports[k])\n\t\t\tlogger.Warn(msg)\n\t\t\treturn\n\t\t}\n\t}\n\n\textIP, err := ipify.GetIp()\n\tif err != nil {\n\t\tlogger.Warn(\"failed to determine\" +\n\t\t\t\" a external ip address, error: \" + err.Error())\n\t\treturn\n\t}\n\n\tlogger = logger.Add(\"externalIP\", extIP)\n\n\ttimeout := time.Duration(conf.CheckTimeout) * time.Millisecond\n\n\tcheckSrv := func(port uint16) {\n\t\tif util.CheckConnection(\n\t\t\t\"tcp\", extIP, int(port), timeout) {\n\t\t\tlogger.Info(fmt.Sprintf(\"port %d is available\"+\n\t\t\t\t\" on the Internet\", port))\n\t\t\treturn\n\t\t}\n\t\tlogger.Warn(fmt.Sprintf(\"port %d is not available\"+\n\t\t\t\" on the Internet\", port))\n\t}\n\n\tfor k := range ports {\n\t\tcheckSrv(ports[k])\n\t}\n}"
        ],
        [
            "func RecoverPubKey(signer types.Signer, tx *types.Transaction) (*ecdsa.PublicKey, error) {\n\tV, R, S := tx.RawSignatureValues()\n\thash := signer.Hash(tx)\n\tr, s := R.Bytes(), S.Bytes()\n\tsig := make([]byte, 65)\n\tcopy(sig[32-len(r):32], r)\n\tcopy(sig[64-len(s):64], s)\n\tsig[64] = byte(V.Uint64() - 27)\n\t// recover the public key from the signature\n\tpub, err := crypto.Ecrecover(hash[:], sig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn crypto.UnmarshalPubkey(pub)\n}"
        ],
        [
            "func (h *Handler) GetTemplates(tkn, tplType string) ([]data.Template, error) {\n\tlogger := h.logger.Add(\n\t\t\"method\", \"GetTemplates\", \"type\", tplType)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tvar templates []reform.Struct\n\n\tvar err error\n\tif tplType != \"\" {\n\t\ttemplates, err = h.selectAllFrom(\n\t\t\tlogger, data.TemplateTable,\n\t\t\t\"WHERE kind = $1\", tplType)\n\t} else {\n\t\ttemplates, err = h.selectAllFrom(\n\t\t\tlogger, data.TemplateTable, \"\")\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult := make([]data.Template, 0)\n\n\tfor _, v := range templates {\n\t\tresult = append(result, *v.(*data.Template))\n\t}\n\n\treturn result, nil\n}"
        ],
        [
            "func (h *Handler) CreateTemplate(\n\ttkn string, template *data.Template) (*string, error) {\n\tlogger := h.logger.Add(\"method\", \"CreateTemplate\",\n\t\t\"template\", template)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\terr := checkTemplate(logger, template)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttemplate.ID = util.NewUUID()\n\ttemplate.Hash = data.HexFromBytes(crypto.Keccak256(template.Raw))\n\n\terr = h.insertObject(template)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &template.ID, nil\n}"
        ],
        [
            "func (h *Handler) CreateProduct(tkn string,\n\tproduct data.Product) (*string, error) {\n\tlogger := h.logger.Add(\"method\", \"CreateProduct\", \"product\", product)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tif product.ServiceEndpointAddress != nil &&\n\t\t!isValidSEAddress(*product.ServiceEndpointAddress) {\n\t\treturn nil, ErrBadServiceEndpointAddress\n\t}\n\n\tproduct.ID = util.NewUUID()\n\tif err := insert(logger, h.db.Querier, &product); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &product.ID, nil\n}"
        ],
        [
            "func (h *Handler) UpdateProduct(tkn string, product data.Product) error {\n\tlogger := h.logger.Add(\"method\", \"UpdateProduct\", \"product\", product)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn ErrAccessDenied\n\t}\n\n\toldProduct := &data.Product{}\n\tif err := h.findByPrimaryKey(logger,\n\t\tErrProductNotFound, oldProduct, product.ID); err != nil {\n\t\treturn err\n\t}\n\n\tif product.Salt == 0 {\n\t\tproduct.Salt = oldProduct.Salt\n\t}\n\n\tif product.Password == \"\" {\n\t\tproduct.Password = oldProduct.Password\n\t}\n\n\tif product.ServiceEndpointAddress != nil &&\n\t\t!isValidSEAddress(*product.ServiceEndpointAddress) {\n\t\treturn ErrBadServiceEndpointAddress\n\t}\n\n\tif err := update(logger, h.db.Querier, &product); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (h *Handler) GetProducts(tkn string) ([]data.Product, error) {\n\tlogger := h.logger.Add(\"method\", \"GetProducts\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tresult, err := h.db.SelectAllFrom(data.ProductTable,\n\t\t\"WHERE products.is_server\")\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\tproducts := make([]data.Product, len(result))\n\tfor i, item := range result {\n\t\tproducts[i] = *item.(*data.Product)\n\t}\n\n\treturn products, nil\n}"
        ],
        [
            "func NewHandler(logger log.Logger, db *reform.DB,\n\tcountryConf *country.Config, queue job.Queue) *Handler {\n\tlogger = logger.Add(\"type\", \"sess.Handler\")\n\treturn &Handler{\n\t\tdb:          db,\n\t\tlogger:      logger,\n\t\tcountryConf: countryConf,\n\t\tqueue:       queue,\n\t}\n}"
        ],
        [
            "func EncryptedKey(pkey *ecdsa.PrivateKey, auth string) (Base64String, error) {\n\tkey := keystore.NewKeyForDirectICAP(rand.Reader)\n\tkey.Address = crypto.PubkeyToAddress(pkey.PublicKey)\n\tkey.PrivateKey = pkey\n\tencryptedBytes, err := keystore.EncryptKey(key, auth,\n\t\tkeystore.StandardScryptN,\n\t\tkeystore.StandardScryptP)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn FromBytes(encryptedBytes), nil\n}"
        ],
        [
            "func ExecuteCommand(args []string) error {\n\tif len(args) == 0 {\n\t\treturn nil\n\t}\n\n\tswitch args[0] {\n\tcase \"db-create\":\n\t\tf := readFlags(args)\n\t\tif err := createDatabase(f.connection); err != nil {\n\t\t\tpanic(\"failed to create database: \" + err.Error())\n\t\t}\n\t\tos.Exit(0)\n\tcase \"db-migrate\":\n\t\tf := readFlags(args)\n\t\terr := migration.Migrate(f.connection, f.version)\n\t\tif err != nil {\n\t\t\tpanic(\"failed to run migration: \" + err.Error())\n\t\t}\n\t\tos.Exit(0)\n\tcase \"db-init-data\":\n\t\tf := readFlags(args)\n\t\tif err := initData(f.connection); err != nil {\n\t\t\tpanic(\"failed to init database: \" + err.Error())\n\t\t}\n\t\tos.Exit(0)\n\tcase \"db-version\":\n\t\tf := readFlags(args)\n\t\tversion, err := migration.Version(f.connection)\n\t\tif err != nil {\n\t\t\tmsg := \"failed to print database schema version: \"\n\t\t\tpanic(msg + err.Error())\n\t\t}\n\t\tfmt.Println(\"database schema version:\", version)\n\t\tos.Exit(0)\n\t}\n\treturn nil\n}"
        ],
        [
            "func (n *npmp) AddMapping(protocol string, extPort, intPort int,\n\tname string, lifetime time.Duration) error {\n\tif lifetime <= 0 {\n\t\treturn ErrTooShortLifetime\n\t}\n\t_, err := n.c.AddPortMapping(strings.ToLower(protocol),\n\t\tintPort, extPort, int(lifetime/time.Second))\n\treturn err\n}"
        ],
        [
            "func (n *npmp) DeleteMapping(protocol string, extPort, intPort int) (err error) {\n\t_, err = n.c.AddPortMapping(strings.ToLower(protocol), intPort, 0, 0)\n\treturn err\n}"
        ],
        [
            "func NewMonitor(conf *Config, logger log.Logger, db *reform.DB,\n\tpr *proc.Processor, pscAddr string, pw data.PWDGetter) *Monitor {\n\treturn &Monitor{\n\t\tconf:   conf,\n\t\tlogger: logger.Add(\"type\", \"client/bill.Monitor\"),\n\t\tdb:     db,\n\t\tpr:     pr,\n\t\tpsc:    pscAddr,\n\t\tpw:     pw,\n\t\tpost:   pay.PostCheque,\n\t}\n}"
        ],
        [
            "func (h *Handler) GetOfferingIncome(\n\ttkn, offeringID string) (*uint, error) {\n\tlogger := h.logger.Add(\"method\", \"GetOfferingIncome\",\n\t\t\"offeringID\", offeringID)\n\n\treturn h.uintFromQuery(logger, tkn,\n\t\t`SELECT SUM(channels.receipt_balance)\n\t\t     FROM channels\n\t\t   WHERE channels.offering=$1`, offeringID)\n}"
        ],
        [
            "func (h *Handler) GetProductIncome(\n\ttkn, productID string) (*uint, error) {\n\tlogger := h.logger.Add(\"method\", \"GetProductIncome\",\n\t\t\"productID\", productID)\n\n\treturn h.uintFromQuery(logger, tkn,\n\t\t`SELECT SUM(channels.receipt_balance)\n\t\t     FROM offerings\n\t\t\t  JOIN channels\n\t\t\t  ON channels.offering=offerings.id\n\t\t     \t     AND offerings.product=$1`, productID)\n}"
        ],
        [
            "func (h *Handler) GetTotalIncome(tkn string) (*uint, error) {\n\tlogger := h.logger.Add(\"method\", \"GetTotalIncome\")\n\n\treturn h.uintFromQuery(logger, tkn,\n\t\t`SELECT SUM(channels.receipt_balance)\n\t\t\tFROM channels`)\n}"
        ],
        [
            "func Up00001(tx *sql.Tx) error {\n\tquery, err := statik.ReadFile(\"/scripts/migration/00001_schema_up.sql\")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn exec(string(query), tx)\n}"
        ],
        [
            "func (h *Handler) GetSettings(tkn string) (map[string]SettingUI, error) {\n\tlogger := h.logger.Add(\"method\", \"GetSettings\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tresult := make(map[string]SettingUI)\n\n\tsettings, err := h.selectAllFrom(\n\t\tlogger, data.SettingTable, settingsCondition)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, v := range settings {\n\t\tsetting := *v.(*data.Setting)\n\t\tresult[setting.Key] = SettingUI{setting.Value,\n\t\t\tPermissionsToString[setting.Permissions]}\n\t}\n\n\treturn result, err\n}"
        ],
        [
            "func (h *Handler) UpdateSettings(tkn string, items map[string]string) error {\n\tlogger := h.logger.Add(\"method\", \"UpdateSettings\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn ErrAccessDenied\n\t}\n\n\terr := h.db.InTransaction(func(tx *reform.TX) error {\n\t\tfor k, v := range items {\n\t\t\tif err := h.validateSetting(logger, k, v); err != nil {\n\t\t\t\tlogger.Add(\"key\", k, \"value\", v).Error(err.Error())\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tfor k, v := range items {\n\t\t\tlogger = logger.Add(\"key\", k, \"value\", v)\n\n\t\t\tvar settingFromDB data.Setting\n\n\t\t\t// gets setting from database\n\t\t\terr := tx.FindByPrimaryKeyTo(&settingFromDB, k)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err.Error())\n\t\t\t\treturn ErrInternal\n\t\t\t}\n\n\t\t\t// if settings.permissions != data.ReadWrite\n\t\t\t// then setting ignored\n\t\t\tif settingFromDB.Permissions != data.ReadWrite {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsetting := settingFromDB\n\t\t\tsetting.Value = v\n\n\t\t\terr = tx.Update(&setting)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err.Error())\n\t\t\t\treturn ErrInternal\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn h.catchError(logger, err)\n\t}\n\treturn nil\n}"
        ],
        [
            "func IsIPv4(s string) bool {\n\tip := net.ParseIP(s)\n\treturn ip != nil\n}"
        ],
        [
            "func IsHostname(s string) bool {\n\taddrs, err := net.LookupHost(s)\n\tif err != nil || len(addrs) == 0 {\n\t\treturn false\n\t}\n\treturn true\n}"
        ],
        [
            "func IsNetPort(str string) bool {\n\tif _, err := strconv.ParseUint(\n\t\tstr, 10, 16); err != nil {\n\t\treturn false\n\t}\n\treturn true\n}"
        ],
        [
            "func IsTLSCert(block string) bool {\n\tvar cert tls.Certificate\n\n\tpemBlock := []byte(block)\n\n\tfor {\n\t\tvar derBlock *pem.Block\n\t\tderBlock, pemBlock = pem.Decode(pemBlock)\n\t\tif derBlock == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif derBlock.Type == certificate {\n\t\t\tcert.Certificate =\n\t\t\t\tappend(cert.Certificate, derBlock.Bytes)\n\t\t}\n\t}\n\n\tif len(cert.Certificate) == 0 {\n\t\treturn false\n\t}\n\n\treturn true\n}"
        ],
        [
            "func ValidateJSON(schema, data []byte) bool {\n\tsloader := gojsonschema.NewBytesLoader(schema)\n\tdloader := gojsonschema.NewBytesLoader(data)\n\tresult, err := gojsonschema.Validate(sloader, dloader)\n\treturn err == nil && result.Valid() && len(result.Errors()) == 0\n}"
        ],
        [
            "func NewConfig() *Config {\n\treturn &Config{\n\t\tCheckTimeout: 20000,\n\t\tTimeout:      10000,\n\t\tHTTPClient: &httpClientConf{\n\t\t\tDialTimeout:           5,\n\t\t\tTLSHandshakeTimeout:   2,\n\t\t\tResponseHeaderTimeout: 8,\n\t\t\tRequestTimeout:        10,\n\t\t\tIdleConnTimeout:       30,\n\t\t\tKeepAliveTimeout:      60,\n\t\t},\n\t}\n}"
        ],
        [
            "func ReadJSONFile(name string, data interface{}) error {\n\tfile, err := os.Open(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\treturn json.NewDecoder(file).Decode(data)\n}"
        ],
        [
            "func WriteJSONFile(name, prefix, indent string, data interface{}) error {\n\tfile, err := os.Create(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tenc := json.NewEncoder(file)\n\tenc.SetIndent(prefix, indent)\n\treturn enc.Encode(data)\n}"
        ],
        [
            "func IsUUID(s string) bool {\n\t_, err := uuid.FromString(s)\n\treturn err == nil\n}"
        ],
        [
            "func ExeDirJoin(elem ...string) string {\n\texe, err := os.Executable()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\telem = append([]string{filepath.Dir(exe)}, elem...)\n\treturn filepath.Join(elem...)\n}"
        ],
        [
            "func RootPath() string {\n\t_, file, _, ok := runtime.Caller(0)\n\tif !ok {\n\t\treturn \"?\"\n\t}\n\treturn filepath.Dir(filepath.Dir(file))\n}"
        ],
        [
            "func Caller() string {\n\t_, file, line, ok := runtime.Caller(2)\n\tif !ok {\n\t\treturn \"?\"\n\t}\n\n\trel, err := filepath.Rel(RootPath(), file)\n\tif err != nil {\n\t\treturn \"?\"\n\t}\n\n\treturn fmt.Sprintf(\"%s:%d\", rel, line)\n}"
        ],
        [
            "func CheckConnection(network, ip string, port int, timeout time.Duration) bool {\n\tconn, _ := net.DialTimeout(network,\n\t\tnet.JoinHostPort(ip, strconv.Itoa(port)), timeout)\n\tif conn != nil {\n\t\tconn.Close()\n\t\treturn true\n\t}\n\treturn false\n}"
        ],
        [
            "func (w *Worker) ClientAfterChannelCreate(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientAfterChannelCreate\", \"job\", job)\n\n\tch, err := w.relatedChannel(logger, job, data.JobClientAfterChannelCreate)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tethLog, err := w.ethLog(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"channel\", ch, \"ethLog\", ethLog)\n\n\tch.Block = uint32(ethLog.Block)\n\tch.ChannelStatus = data.ChannelActive\n\tif err = w.saveRecord(logger, w.db.Querier, ch); err != nil {\n\t\treturn err\n\t}\n\n\tkey, err := w.keyFromChannelData(logger, ch.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"endpointKey\", key)\n\n\tvar endpointMsgSealed []byte\n\n\toffering, err := w.offering(logger, ch.Offering)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err == nil {\n\t\tclient, err := w.somcClientBuilder.NewClient(offering.SOMCType, offering.SOMCData)\n\t\tif err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t\treturn ErrGetEndpoint\n\t\t}\n\t\trawMsg, err := client.Endpoint(key)\n\t\tif err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t\treturn ErrGetEndpoint\n\t\t}\n\t\tendpointMsgSealed, err = data.ToBytes(rawMsg)\n\t\tif err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t\treturn ErrGetEndpoint\n\t\t}\n\t}\n\n\terr = w.addJobWithData(logger, nil, data.JobClientEndpointRestore,\n\t\tdata.JobChannel, ch.ID, &data.JobEndpointCreateData{EndpointSealed: endpointMsgSealed})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tclient, err := w.account(logger, ch.Client)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn w.addJob(logger, nil,\n\t\tdata.JobAccountUpdateBalances, data.JobAccount, client.ID)\n}"
        ],
        [
            "func (w *Worker) ClientEndpointCreate(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientEndpointCreate\",\n\t\t\"job\", job)\n\n\tch, err := w.relatedChannel(logger, job,\n\t\tdata.JobClientEndpointRestore)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar jdata data.JobEndpointCreateData\n\tif err := w.unmarshalDataTo(logger, job.Data, &jdata); err != nil {\n\t\treturn err\n\t}\n\n\tmsg, err := w.extractEndpointMessage(logger, ch, jdata.EndpointSealed)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toffer, err := w.offering(logger, ch.Offering)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\turl := strings.Replace(w.countryConfig.URLTemplate,\n\t\t\"{{ip}}\", msg.ServiceEndpointAddress, 1)\n\n\tvar countryStatus string\n\n\tc, err := country.GetCountry(w.countryConfig.Timeout, url,\n\t\tw.countryConfig.Field)\n\tif err != nil || len(c) != 2 {\n\t\tcountryStatus = data.CountryStatusUnknown\n\t} else if c == offer.Country {\n\t\tcountryStatus = data.CountryStatusValid\n\t} else {\n\t\tcountryStatus = data.CountryStatusInvalid\n\t}\n\n\tparams, _ := json.Marshal(msg.AdditionalParams)\n\n\treturn w.db.InTransaction(func(tx *reform.TX) error {\n\t\traddr := pointer.ToString(msg.PaymentReceiverAddress)\n\t\tsaddr := pointer.ToString(msg.ServiceEndpointAddress)\n\t\tendp := data.Endpoint{\n\t\t\tID:                     util.NewUUID(),\n\t\t\tTemplate:               offer.Template,\n\t\t\tChannel:                ch.ID,\n\t\t\tHash:                   msg.TemplateHash,\n\t\t\tRawMsg:                 data.FromBytes(jdata.EndpointSealed),\n\t\t\tPaymentReceiverAddress: raddr,\n\t\t\tServiceEndpointAddress: saddr,\n\t\t\tUsername:               pointer.ToString(msg.Username),\n\t\t\tPassword:               pointer.ToString(msg.Password),\n\t\t\tAdditionalParams:       params,\n\t\t\tCountryStatus:          pointer.ToString(countryStatus),\n\t\t}\n\t\tif err = w.db.Insert(&endp); err != nil {\n\t\t\tlogger.Add(\"endpoint\", endp).Error(err.Error())\n\t\t\treturn ErrInternal\n\t\t}\n\n\t\tch.ServiceStatus = data.ServiceSuspended\n\t\tchangedTime := time.Now()\n\t\tch.ServiceChangedTime = &changedTime\n\t\t// TODO: Review flow with service_changed_time.\n\t\tch.PreparedAt = changedTime\n\t\terr = w.saveRecord(logger, w.db.Querier, ch)\n\t\tif err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t\treturn ErrInternal\n\t\t}\n\n\t\treturn nil\n\t})\n}"
        ],
        [
            "func (w *Worker) ClientAfterUncooperativeClose(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientAfterUncooperativeClose\",\n\t\t\"job\", job)\n\tch, err := w.relatedChannel(logger, job, data.JobClientAfterUncooperativeClose)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"channel\", ch)\n\n\tch.ChannelStatus = data.ChannelClosedUncoop\n\tif err := w.saveRecord(logger, w.db.Querier, ch); err != nil {\n\t\treturn err\n\t}\n\n\tclient, err := w.account(logger, ch.Client)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn w.addJob(logger, nil,\n\t\tdata.JobAccountUpdateBalances, data.JobAccount, client.ID)\n}"
        ],
        [
            "func (w *Worker) ClientAfterCooperativeClose(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientAfterCooperativeClose\",\n\t\t\"job\", job)\n\n\tch, err := w.relatedChannel(logger, job,\n\t\tdata.JobClientAfterCooperativeClose)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"channel\", ch)\n\n\tch.ChannelStatus = data.ChannelClosedCoop\n\tif err := w.saveRecord(logger, w.db.Querier, ch); err != nil {\n\t\treturn err\n\t}\n\n\tif ch.ServiceStatus != data.ServiceTerminated {\n\t\t_, err = w.processor.TerminateChannel(ch.ID, data.JobTask, false)\n\t\tif err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t\treturn ErrTerminateChannel\n\t\t}\n\t}\n\n\tclient, err := w.account(logger, ch.Client)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn w.addJob(logger, nil,\n\t\tdata.JobAccountUpdateBalances, data.JobAccount, client.ID)\n}"
        ],
        [
            "func (w *Worker) ClientPreServiceTerminate(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientPreServiceTerminate\", \"job\", job)\n\n\tch, err := w.relatedChannel(logger,\n\t\tjob, data.JobClientPreServiceTerminate)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"channel\", ch)\n\n\tif ch.ServiceStatus == data.ServiceActive {\n\t\tch.ServiceStatus = data.ServiceTerminating\n\t} else {\n\t\tch.ServiceStatus = data.ServiceTerminated\n\t}\n\n\tchangedTime := time.Now()\n\tch.ServiceChangedTime = &changedTime\n\terr = w.saveRecord(logger, w.db.Querier, ch)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
        ],
        [
            "func (w *Worker) ClientPreServiceSuspend(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientPreServiceSuspend\", \"job\", job)\n\n\tch, err := w.relatedChannel(logger, job, data.JobClientPreServiceSuspend)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"channel\", ch)\n\n\tch.ServiceStatus = data.ServiceSuspending\n\tchangedTime := time.Now()\n\tch.ServiceChangedTime = &changedTime\n\terr = w.saveRecord(logger, w.db.Querier, ch)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
        ],
        [
            "func (w *Worker) ClientPreServiceUnsuspend(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientPreServiceUnsuspend\",\n\t\t\"job\", job)\n\n\tch, err := w.relatedChannel(logger, job, data.JobClientPreServiceUnsuspend)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"channel\", ch)\n\n\tch.ServiceStatus = data.ServiceActivating\n\tchangedTime := time.Now()\n\tch.ServiceChangedTime = &changedTime\n\treturn w.saveRecord(logger, w.db.Querier, ch)\n}"
        ],
        [
            "func (w *Worker) ClientPreUncooperativeClose(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientPreUncooperativeClose\",\n\t\t\"job\", job)\n\n\t// If cooperative close was created for this channel, skip this job.\n\terr := w.db.SelectOneTo(&data.Job{},\n\t\t\"WHERE related_id=$1 AND related_type=$2 AND type=$3\",\n\t\tjob.RelatedID, job.RelatedType, data.JobClientAfterCooperativeClose)\n\tif err == nil {\n\t\tjob.Status = data.JobCanceled\n\t\tw.db.Save(job)\n\t\treturn nil\n\t}\n\n\tch, err := w.relatedChannel(logger, job,\n\t\tdata.JobClientPreUncooperativeClose)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif ch.ChannelStatus == data.ChannelClosedCoop {\n\t\tlogger.Warn(\"channel closed cooperatively\")\n\t\treturn nil\n\t}\n\n\tlogger = logger.Add(\"channel\", ch)\n\n\tagent, err := data.HexToAddress(ch.Agent)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrParseEthAddr\n\t}\n\n\tclient, err := data.HexToAddress(ch.Client)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrParseEthAddr\n\t}\n\n\tacc, err := w.account(logger, ch.Client)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toffer, err := w.offering(logger, ch.Offering)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tofferHash, err := data.HexToHash(offer.Hash)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrParseOfferingHash\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tblocks, err := w.blocksTillChallangeEnd(ctx, logger, client, agent, ch.Block, offerHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif blocks > 0 {\n\t\tlogger.Add(\"blocksTillChallangeEnd\", blocks).Warn(\"in challange period\")\n\t\treturn ErrChallengePeriodIsNotOver\n\t}\n\n\ttx, err := w.settle(ctx, logger, acc, agent, ch.Block, offerHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := w.saveEthTX(logger, job, tx, \"Settle\",\n\t\tdata.JobChannel, ch.ID, acc.EthAddr,\n\t\tdata.HexFromBytes(w.pscAddr.Bytes())); err != nil {\n\t\treturn err\n\t}\n\n\tch.ChannelStatus = data.ChannelWaitUncoop\n\n\treturn w.saveRecord(logger, w.db.Querier, ch)\n}"
        ],
        [
            "func (w *Worker) ClientPreChannelTopUp(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientPreChannelTopUp\", \"job\", job)\n\n\tch, err := w.relatedChannel(logger, job, data.JobClientPreChannelTopUp)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toffer, err := w.offering(logger, ch.Offering)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tacc, err := w.account(logger, ch.Client)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"channel\", ch, \"offering\", offer)\n\n\tvar jdata data.JobTopUpChannelData\n\tif err := w.unmarshalDataTo(logger, job.Data, &jdata); err != nil {\n\t\treturn err\n\t}\n\n\tif err := w.checkDeposit(logger, acc, offer, jdata.Deposit); err != nil {\n\t\treturn err\n\t}\n\n\treturn w.clientPreChannelTopUpSaveTx(logger, job, ch, acc, offer,\n\t\tjdata.GasPrice, uint64(jdata.Deposit))\n}"
        ],
        [
            "func (w *Worker) ClientAfterChannelTopUp(job *data.Job) error {\n\treturn w.afterChannelTopUp(job, data.JobClientAfterChannelTopUp)\n}"
        ],
        [
            "func (w *Worker) ClientPreUncooperativeCloseRequest(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientPreUncooperativeCloseRequest\",\n\t\t\"job\", job)\n\n\tch, err := w.relatedChannel(logger, job,\n\t\tdata.JobClientPreUncooperativeCloseRequest)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tjdata, err := w.publishData(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toffer, err := w.offering(logger, ch.Offering)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tacc, err := w.account(logger, ch.Client)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := w.clientValidateChannelForClose(ch); err != nil {\n\t\treturn err\n\t}\n\n\treturn w.doClientPreUncooperativeCloseRequestAndSaveTx(logger, job, ch,\n\t\tacc, offer, jdata.GasPrice)\n}"
        ],
        [
            "func (w *Worker) ClientAfterUncooperativeCloseRequest(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientAfterUncooperativeCloseRequest\",\n\t\t\"job\", job)\n\n\tch, err := w.relatedChannel(logger, job,\n\t\tdata.JobClientAfterUncooperativeCloseRequest)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tch.ChannelStatus = data.ChannelInChallenge\n\tif err = w.db.Update(ch); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\tchallengePeriod, err := data.ReadUintSetting(w.db.Querier,\n\t\tdata.SettingsPeriodChallange)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn w.addJobWithDelay(logger, nil,\n\t\tdata.JobClientPreUncooperativeClose, data.JobChannel,\n\t\tch.ID, time.Duration(challengePeriod)*eth.BlockDuration)\n}"
        ],
        [
            "func (w *Worker) ClientAfterOfferingMsgBCPublish(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientAfterOfferingMsgBCPublish\",\n\t\t\"job\", job)\n\n\tethLog, err := w.ethLog(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogOfferingCreated, err := extractLogOfferingCreated(logger, ethLog)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn w.clientRetrieveAndSaveOffering(logger, job,\n\t\tethLog.Block, logOfferingCreated.somcType,\n\t\tlogOfferingCreated.somcData, logOfferingCreated.agentAddr,\n\t\tlogOfferingCreated.offeringHash, logOfferingCreated.currentSupply)\n}"
        ],
        [
            "func (w *Worker) ClientAfterOfferingPopUp(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"ClientAfterOfferingPopUp\", \"job\", job)\n\n\tethLog, err := w.ethLog(logger, job)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger = logger.Add(\"ethLog\", ethLog)\n\n\tlogOfferingPopUp, err := extractLogOfferingPopUp(logger, ethLog)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toffering := data.Offering{}\n\thash := data.HexFromBytes(logOfferingPopUp.offeringHash.Bytes())\n\terr = w.db.FindOneTo(&offering, \"hash\", hash)\n\tif err == sql.ErrNoRows {\n\t\t// New offering.\n\t\treturn w.clientRetrieveAndSaveOffering(logger, job,\n\t\t\tethLog.Block, logOfferingPopUp.somcType,\n\t\t\tlogOfferingPopUp.somcData, logOfferingPopUp.agentAddr,\n\t\t\tlogOfferingPopUp.offeringHash, logOfferingPopUp.currentSupply)\n\t}\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\t// Existing offering, just update offering status.\n\toffering.BlockNumberUpdated = ethLog.Block\n\toffering.Status = data.OfferPoppedUp\n\n\treturn w.saveRecord(logger, w.db.Querier, &offering)\n}"
        ],
        [
            "func (w *Worker) ClientAfterOfferingDelete(job *data.Job) error {\n\treturn w.updateRelatedOffering(\n\t\tjob, data.JobClientAfterOfferingDelete, data.OfferRemoved)\n}"
        ],
        [
            "func (w *Worker) DecrementCurrentSupply(job *data.Job) error {\n\tlogger := w.logger.Add(\"method\", \"DecrementCurrentSupply\", \"job\", job)\n\toffering, err := w.relatedOffering(logger, job, data.JobDecrementCurrentSupply)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toffering.CurrentSupply--\n\n\terr = data.Save(w.db.Querier, offering)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (h *Handler) GetEndpoints(\n\ttkn, channel, template string) ([]data.Endpoint, error) {\n\tlogger := h.logger.Add(\"method\", \"GetEndpoints\",\n\t\t\"channel\", channel, \"template\", template)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\ttail, args := h.getEndpointsConditions(channel, template)\n\n\tresult, err := h.selectAllFrom(\n\t\tlogger, data.EndpointTable, tail, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tendpoints := make([]data.Endpoint, len(result))\n\tfor i, item := range result {\n\t\tendpoints[i] = *item.(*data.Endpoint)\n\t}\n\n\treturn endpoints, nil\n}"
        ],
        [
            "func (h *Handler) GetGUISettings(tkn string) (map[string]interface{}, error) {\n\tlogger := h.logger.Add(\"method\", \"GetGUISettings\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tretStr, err := data.ReadSetting(h.db.Querier, data.SettingGUI)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\tret := make(map[string]interface{})\n\n\terr = json.Unmarshal([]byte(retStr), &ret)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\treturn ret, nil\n}"
        ],
        [
            "func (h *Handler) SetGUISettings(tkn string, v map[string]interface{}) error {\n\tlogger := h.logger.Add(\"method\", \"SetGUISettings\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn ErrAccessDenied\n\t}\n\n\td, err := json.Marshal(&v)\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\t_, err = h.db.Exec(`\n\t\tUPDATE settings \n\t\t   SET value = $1\n\t\t WHERE key=$2`, string(d), data.SettingGUI)\n\tif err != nil {\n\t\tlogger.Error(fmt.Sprintf(\"failed to set gui settings: %v\", err))\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (s *Server) HandleFunc(pattern string, handler HandlerFunc) {\n\ts.Mux().HandleFunc(pattern,\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\thandler(w, r, &Context{})\n\t\t})\n}"
        ],
        [
            "func (s *Server) RequireHTTPMethods(logger log.Logger,\n\thandler HandlerFunc, methods ...string) HandlerFunc {\n\tl := logger.Add(\"method\", \"RequireHTTPMethods\")\n\treturn func(w http.ResponseWriter, r *http.Request, ctx *Context) {\n\t\tfor _, v := range methods {\n\t\t\tif v == r.Method {\n\t\t\t\thandler(w, r, ctx)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tl.Add(\"sender\", r.RemoteAddr).Warn(\"not allowed HTTP method\")\n\t\ts.RespondError(logger, w, ErrMethodNotAllowed)\n\t}\n}"
        ],
        [
            "func (s *Server) RequireBasicAuth(logger log.Logger,\n\thandler HandlerFunc, auth AuthFunc) HandlerFunc {\n\tl := logger.Add(\"method\", \"RequireBasicAuth\")\n\treturn func(w http.ResponseWriter, r *http.Request, ctx *Context) {\n\t\tname, pass, ok := r.BasicAuth()\n\t\tif !ok || !auth(name, pass) {\n\t\t\tl.Add(\"sender\", r.RemoteAddr).Warn(\"access denied\")\n\t\t\ts.RespondError(logger, w, ErrAccessDenied)\n\t\t\treturn\n\t\t}\n\n\t\tctx.Username = name\n\t\thandler(w, r, ctx)\n\t}\n}"
        ],
        [
            "func New(db *reform.DB, logger log.Logger, payAddr string,\n\ttimeout uint) (*Service, error) {\n\treturn &Service{\n\t\tdb:      db,\n\t\tmsgChan: make(chan *req),\n\t\tpayAddr: payAddr,\n\t\ttimeout: time.Duration(timeout) * time.Millisecond,\n\t\tlogger:  logger.Add(\"type\", \"messages/ept.Service\"),\n\t}, nil\n}"
        ],
        [
            "func (s *Service) EndpointMessage(channelID string) (*Message, error) {\n\tc := make(chan *result)\n\tdone := make(chan bool)\n\n\treq := &req{channelID: channelID, callback: c, done: done}\n\n\tgo s.processing(req)\n\n\tselect {\n\tcase result := <-c:\n\t\treturn result.msg, result.err\n\tcase <-time.After(s.timeout):\n\t\tclose(done)\n\t\treturn nil, ErrTimeOut\n\t}\n}"
        ],
        [
            "func (h *Handler) ConnChange(ctx context.Context,\n\tproduct, productPassword string) (*rpc.Subscription, error) {\n\tlogger := h.logger.Add(\"method\", \"ConnChange\", \"product\", product)\n\n\tlogger.Info(\"subscribing to adapter connection changes\")\n\n\t_, err := h.checkProductPassword(logger, product, productPassword)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tntf, ok := rpc.NotifierFromContext(ctx)\n\tif !ok {\n\t\tlogger.Error(\"no notifier found in context\")\n\t\treturn nil, ErrInternal\n\t}\n\n\tsub := ntf.CreateSubscription()\n\tcb := func(job *data.Job, result error) {\n\t\tif result == nil {\n\t\t\th.handleConnChange(product, logger, ntf, sub, job)\n\t\t}\n\t}\n\tjobTypes := []string{\n\t\tdata.JobClientPreServiceSuspend,\n\t\tdata.JobClientPreServiceUnsuspend,\n\t\tdata.JobClientPreServiceTerminate,\n\t}\n\n\t// TODO: testing. fix it later.\n\tsid := string(sub.ID)\n\tif err = h.queue.Subscribe(jobTypes, sid, cb); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\tgo func() {\n\t\tfor err, ok := <-sub.Err(); ok; {\n\t\t\tif err != nil {\n\t\t\t\tlogger.Warn(err.Error())\n\t\t\t}\n\t\t}\n\n\t\terr := h.queue.Unsubscribe(jobTypes, sid)\n\t\tif err != nil {\n\t\t\tlogger.Error(err.Error())\n\t\t}\n\t}()\n\n\treturn sub, nil\n}"
        ],
        [
            "func FromBase64ToHex(s Base64String) (string, error) {\n\tb, err := ToBytes(s)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn hex.EncodeToString(b), nil\n}"
        ],
        [
            "func HexToBytes(s HexString) ([]byte, error) {\n\ts2 := string(s)\n\tif strings.HasPrefix(s2, \"0x\") || strings.HasPrefix(s2, \"0X\") {\n\t\ts2 = s2[2:]\n\t}\n\treturn hex.DecodeString(s2)\n}"
        ],
        [
            "func ToBytes(s Base64String) ([]byte, error) {\n\treturn base64.URLEncoding.DecodeString(strings.TrimSpace(string(s)))\n}"
        ],
        [
            "func ToHash(h Base64String) (common.Hash, error) {\n\thashBytes, err := ToBytes(h)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to parse ethereum hash: %s\", err)\n\t}\n\treturn common.BytesToHash(hashBytes), err\n}"
        ],
        [
            "func HexToHash(h HexString) (common.Hash, error) {\n\thashBytes, err := HexToBytes(h)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to parse ethereum hash: %s\", err)\n\t}\n\treturn common.BytesToHash(hashBytes), err\n}"
        ],
        [
            "func HexToAddress(addr HexString) (common.Address, error) {\n\taddrBytes, err := HexToBytes(addr)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to parse ethereum addr: %s\", err)\n\t}\n\treturn common.BytesToAddress(addrBytes), err\n}"
        ],
        [
            "func BytesToUint32(b []byte) (uint32, error) {\n\tif len(b) != 4 {\n\t\treturn 0, fmt.Errorf(\"wrong len\")\n\t}\n\treturn binary.BigEndian.Uint32(b), nil\n}"
        ],
        [
            "func Uint32ToBytes(x uint32) [4]byte {\n\tvar xBytes [4]byte\n\tbinary.BigEndian.PutUint32(xBytes[:], x)\n\treturn xBytes\n}"
        ],
        [
            "func Uint64ToBytes(x uint64) [8]byte {\n\tvar xBytes [8]byte\n\tbinary.BigEndian.PutUint64(xBytes[:], x)\n\treturn xBytes\n}"
        ],
        [
            "func Uint192ToBytes(x *big.Int) [24]byte {\n\tvar ret [24]byte\n\txBytes := x.Bytes()\n\tfor i, v := range xBytes {\n\t\tret[24-len(xBytes)+i] = v\n\t}\n\treturn ret\n}"
        ],
        [
            "func HashPassword(password, salt string) (Base64String, error) {\n\tsalted := []byte(password + salt)\n\tpasswordHash, err := bcrypt.GenerateFromPassword(salted, bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn FromBytes(passwordHash), nil\n}"
        ],
        [
            "func ValidatePassword(hash Base64String, password, salt string) error {\n\tsalted := []byte(fmt.Sprint(password, salt))\n\thashB, err := ToBytes(hash)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn bcrypt.CompareHashAndPassword(hashB, salted)\n}"
        ],
        [
            "func GetUint64Setting(db *reform.DB, key string) (uint64, error) {\n\tvar setting Setting\n\terr := db.FindByPrimaryKeyTo(&setting, key)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn 0, fmt.Errorf(\"key %s is not exist\"+\n\t\t\t\t\" in Setting table\", key)\n\t\t}\n\t\treturn 0, err\n\t}\n\n\tvalue, err := strconv.ParseUint(setting.Value, 10, 64)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to parse %s setting: %v\",\n\t\t\tkey, err)\n\t}\n\n\treturn value, nil\n\n}"
        ],
        [
            "func ChannelKey(client, agent HexString, block uint32,\n\tofferingHash HexString) ([]byte, error) {\n\tclientAddr, err := HexToAddress(client)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tagentAddr, err := HexToAddress(agent)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thash, err := base64.URLEncoding.DecodeString(\n\t\tstrings.TrimSpace(string(offeringHash)))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tblockBytes := Uint32ToBytes(block)\n\n\treturn crypto.Keccak256(clientAddr.Bytes(),\n\t\tagentAddr.Bytes(), blockBytes[:],\n\t\tcommon.BytesToHash(hash).Bytes()), nil\n}"
        ],
        [
            "func MinDeposit(offering *Offering) uint64 {\n\treturn offering.MinUnits*offering.UnitPrice + offering.SetupPrice\n}"
        ],
        [
            "func (h *Handler) AcceptOffering(tkn string, account data.HexString,\n\toffering string, deposit, gasPrice uint64) (*string, error) {\n\tlogger := h.logger.Add(\"method\", \"AcceptOffering\",\n\t\t\"account\", account, \"offering\", offering,\n\t\t\"deposit\", deposit, \"gasPrice\", gasPrice)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tvar acc data.Account\n\tif err := h.findByColumn(logger, ErrAccountNotFound,\n\t\t&acc, \"eth_addr\", account); err != nil {\n\t\treturn nil, err\n\t}\n\n\toffer, err := h.findActiveOfferingByID(logger, offering)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tminDeposit := data.MinDeposit(offer)\n\n\tif deposit == 0 {\n\t\tdeposit = minDeposit\n\t} else if deposit < minDeposit {\n\t\tlogger.Error(ErrDepositTooSmall.Error())\n\t\treturn nil, ErrDepositTooSmall\n\t}\n\n\tif err := h.pingOffering(logger, offer); err != nil {\n\t\treturn nil, err\n\t}\n\n\trid := util.NewUUID()\n\tjobData := &worker.ClientPreChannelCreateData{Account: acc.ID,\n\t\tOffering: offering, GasPrice: gasPrice, Deposit: deposit}\n\tif err := job.AddWithData(h.queue, nil, data.JobClientPreChannelCreate,\n\t\tdata.JobChannel, rid, data.JobUser, jobData); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\treturn &rid, nil\n}"
        ],
        [
            "func (h *Handler) ChangeOfferingStatus(\n\ttkn, offering, action string, gasPrice uint64) error {\n\tlogger := h.logger.Add(\"method\", \"ChangeOfferingStatus\",\n\t\t\"offering\", offering, \"action\", action, \"gasPrice\", gasPrice)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn ErrAccessDenied\n\t}\n\n\tjobType, ok := OfferingChangeActions[action]\n\tif !ok {\n\t\tlogger.Warn(ErrBadOfferingStatusAction.Error())\n\t\treturn ErrBadOfferingStatusAction\n\t}\n\n\toffer := &data.Offering{}\n\terr := h.findByPrimaryKey(logger, ErrOfferingNotFound, offer, offering)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tjobData := &data.JobPublishData{GasPrice: gasPrice}\n\tif err := job.AddWithData(h.queue, nil, jobType, data.JobOffering,\n\t\toffering, data.JobUser, jobData); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (h *Handler) GetClientOfferings(tkn string, agent data.HexString,\n\tminUnitPrice, maxUnitPrice uint64, countries []string,\n\toffset, limit uint) (*GetClientOfferingsResult, error) {\n\tlogger := h.logger.Add(\"method\", \"GetClientOfferings\",\n\t\t\"agent\", agent, \"minUnitPrice\", minUnitPrice,\n\t\t\"maxUnitPrice\", maxUnitPrice, \"countries\", countries, \"offset\", offset,\n\t\t\"limit\", limit)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tif minUnitPrice != 0 && maxUnitPrice != 0 &&\n\t\tminUnitPrice > maxUnitPrice {\n\t\tlogger.Error(ErrBadUnitPriceRange.Error())\n\t\treturn nil, ErrBadUnitPriceRange\n\t}\n\n\tcond, args := h.getClientOfferingsConditions(agent, minUnitPrice,\n\t\tmaxUnitPrice, countries)\n\n\tcount, err := h.numberOfObjects(\n\t\tlogger, data.OfferingTable.Name(), cond, args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\toffsetLimit := h.offsetLimit(offset, limit)\n\n\ttail := fmt.Sprintf(\"%s %s %s\",\n\t\tcond, activeOfferingSorting, offsetLimit)\n\n\tresult, err := h.selectAllFrom(\n\t\tlogger, data.OfferingTable, tail, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tofferings := make([]data.Offering, len(result))\n\n\tfor k, v := range result {\n\t\tofferings[k] = *v.(*data.Offering)\n\t}\n\n\treturn &GetClientOfferingsResult{offerings, count}, nil\n}"
        ],
        [
            "func (h *Handler) GetAgentOfferings(tkn, product string, statuses []string,\n\toffset, limit uint) (*GetAgentOfferingsResult, error) {\n\tlogger := h.logger.Add(\"method\", \"GetAgentOfferings\",\n\t\t\"product\", product, \"status\", statuses)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tconditions, args := h.getAgentOfferingsConditions(product, statuses)\n\n\tcount, err := h.numberOfObjects(\n\t\tlogger, data.OfferingTable.Name(), conditions, args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\toffsetLimit := h.offsetLimit(offset, limit)\n\n\tsorting := `ORDER BY block_number_updated DESC`\n\n\ttail := fmt.Sprintf(\"%s %s %s\", conditions, sorting, offsetLimit)\n\n\tresult, err := h.selectAllFrom(\n\t\tlogger, data.OfferingTable, tail, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tofferings := make([]data.Offering, len(result))\n\n\tfor k, v := range result {\n\t\tofferings[k] = *v.(*data.Offering)\n\t}\n\n\treturn &GetAgentOfferingsResult{offerings, count}, nil\n}"
        ],
        [
            "func (h *Handler) setOfferingHash(logger log.Logger, offering *data.Offering,\n\ttemplate *data.Template, agent *data.Account) error {\n\thandleErr := func(err error) error {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\tmsg := offer.OfferingMessage(agent, template, offering)\n\n\tmsgBytes, err := json.Marshal(msg)\n\tif err != nil {\n\t\treturn handleErr(err)\n\t}\n\n\tagentKey, err := h.decryptKeyFunc(agent.PrivateKey, h.pwdStorage.Get())\n\tif err != nil {\n\t\treturn handleErr(err)\n\t}\n\n\tpacked, err := messages.PackWithSignature(msgBytes, agentKey)\n\tif err != nil {\n\t\treturn handleErr(err)\n\t}\n\n\toffering.RawMsg = data.FromBytes(packed)\n\n\thashBytes := common.BytesToHash(crypto.Keccak256(packed))\n\n\toffering.Hash = data.HexFromBytes(hashBytes.Bytes())\n\n\treturn nil\n}"
        ],
        [
            "func (h *Handler) fillOffering(\n\tlogger log.Logger, offering *data.Offering) error {\n\tagent := &data.Account{}\n\t// TODO: This is definitely wrong, should be:\n\t// `h.findByColumn(..., \"eth_addr\", offering.Agent)`\n\tif err := h.findByPrimaryKey(logger,\n\t\tErrAccountNotFound, agent, string(offering.Agent)); err != nil {\n\t\treturn err\n\t}\n\n\ttemplate := &data.Template{}\n\tif err := h.findByPrimaryKey(logger,\n\t\tErrTemplateNotFound, template, offering.Template); err != nil {\n\t\treturn err\n\t}\n\n\toffering.ID = util.NewUUID()\n\toffering.Status = data.OfferEmpty\n\toffering.Agent = agent.EthAddr\n\toffering.BlockNumberUpdated = 1\n\toffering.CurrentSupply = offering.Supply\n\t// TODO: remove once prepaid is implemented.\n\toffering.BillingType = data.BillingPostpaid\n\n\treturn h.setOfferingHash(logger, offering, template, agent)\n}"
        ],
        [
            "func (h *Handler) UpdateOffering(tkn string, offering *data.Offering) error {\n\tlogger := h.logger.Add(\n\t\t\"method\", \"UpdateOffering\", \"offering\", offering)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn ErrAccessDenied\n\t}\n\n\terr := h.findByPrimaryKey(\n\t\tlogger, ErrOfferingNotFound, &data.Offering{}, offering.ID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = update(logger, h.db.Querier, offering)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (h *Handler) CreateOffering(tkn string,\n\toffering *data.Offering) (*string, error) {\n\tlogger := h.logger.Add(\n\t\t\"method\", \"CreateOffering\", \"offering\", offering)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\terr := h.prepareOffering(logger, offering)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = insert(logger, h.db.Querier, offering)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &offering.ID, nil\n}"
        ],
        [
            "func (h *Handler) GetClientOfferingsFilterParams(\n\ttkn string) (*GetClientOfferingsFilterParamsResult, error) {\n\tlogger := h.logger.Add(\"method\", \"GetClientOfferingsFilterParams\")\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tcountries, err := h.offeringCountries(logger)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmin, max, err := h.offeringsMinMaxPrice(logger)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &GetClientOfferingsFilterParamsResult{countries, min, max}, nil\n}"
        ],
        [
            "func (h *Handler) PingOfferings(tkn string, ids []string) (map[string]bool, error) {\n\tlogger := h.logger.Add(\"method\", \"PingOfferings\", \"ids\", ids)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\tnow := time.Now()\n\tret := make(map[string]bool)\n\n\twg := new(sync.WaitGroup)\n\twg.Add(len(ids))\n\tfor _, id := range ids {\n\t\toffering, err := h.findActiveOfferingByID(logger, id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgo func(offering *data.Offering) {\n\t\t\terr := h.pingOffering(logger, offering)\n\t\t\tif err == nil {\n\t\t\t\tret[offering.ID] = true\n\t\t\t\toffering.SOMCSuccessPing = &now\n\t\t\t\terr = update(logger, h.db.Querier, offering)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.Warn(err.Error())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret[offering.ID] = false\n\t\t\t\tlogger.Debug(err.Error())\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(offering)\n\t}\n\twg.Wait()\n\treturn ret, nil\n}"
        ],
        [
            "func NewServer(conf *Config) *Server {\n\ts := &Server{\n\t\tconf: conf,\n\t\tsrv: http.Server{\n\t\t\tAddr:    conf.Addr,\n\t\t\tHandler: http.NewServeMux(),\n\t\t},\n\t}\n\treturn s\n}"
        ],
        [
            "func (s *Server) Mux() *http.ServeMux {\n\treturn s.srv.Handler.(*http.ServeMux)\n}"
        ],
        [
            "func NewLogger(conf *Config) (log.Logger, error) {\n\tl := &reportLogger{}\n\n\tbase, err := log.NewLoggerBase(conf.BaseConfig, l.log)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tl.LoggerBase = base\n\treturn l, nil\n}"
        ],
        [
            "func (l *reportLogger) Printf(format string, v ...interface{}) {\n\tif l.logger != nil {\n\t\tl.logger.Debug(fmt.Sprintf(format, v...))\n\t}\n}"
        ],
        [
            "func GetURL(conf *Config, path string) string {\n\tvar proto = \"http\"\n\tif conf.TLS != nil {\n\t\tproto += \"s\"\n\t}\n\n\treturn proto + \"://\" + conf.Addr + path\n}"
        ],
        [
            "func NewHTTPRequest(conf *Config, method,\n\tpath string, req *Request) (*http.Request, error) {\n\treturn NewHTTPRequestWithURL(method, GetURL(conf, path), req)\n}"
        ],
        [
            "func NewHTTPRequestWithURL(method, url string, req *Request) (*http.Request, error) {\n\tdata, err := json.Marshal(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn http.NewRequest(\n\t\tmethod, url, bytes.NewReader(data))\n}"
        ],
        [
            "func Send(req *http.Request) (*Response, error) {\n\tclient := &http.Client{}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar resp2 Response\n\tif err = json.NewDecoder(resp.Body).Decode(&resp2); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &resp2, nil\n}"
        ],
        [
            "func (t *SimpleToken) Check(s string) bool {\n\tt.mtx.RLock()\n\tdefer t.mtx.RUnlock()\n\treturn s == t.token\n}"
        ],
        [
            "func (t *SimpleToken) Make() (string, error) {\n\tb := make([]byte, 32)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tt.mtx.Lock()\n\tdefer t.mtx.Unlock()\n\tt.token = string(data.FromBytes(b))\n\treturn t.token, nil\n}"
        ],
        [
            "func (h *Handler) GetLogs(tkn string, levels []string, searchText,\n\tdateFrom, dateTo string, offset, limit uint) (*GetLogsResult, error) {\n\tlogger := h.logger.Add(\"method\", \"GetLogs\", \"searchText\",\n\t\tsearchText, \"levels\", levels, \"dateFrom\", dateFrom, \"dateTo\",\n\t\tdateTo, \"offset\", offset, \"limit\", limit)\n\n\tif !h.token.Check(tkn) {\n\t\tlogger.Warn(\"access denied\")\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\targs := &getLogsArgs{\n\t\tlevel:      levels,\n\t\tdateTo:     dateTo,\n\t\tdateFrom:   dateFrom,\n\t\tsearchText: searchText,\n\t}\n\n\tconditions, arguments := h.getLogsConditions(args)\n\ttotalItems, err := h.getTotalLogEvents(logger, conditions, arguments)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult, err := h.getLogs(logger, conditions, arguments, offset, limit)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &GetLogsResult{result, totalItems}, err\n}"
        ],
        [
            "func (h *Handler) AuthClient(product, productPassword,\n\tclientKey, clientPassword string) error {\n\tlogger := h.logger.Add(\"method\", \"AuthClient\",\n\t\t\"product\", product, \"clientKey\", clientKey)\n\n\tlogger.Info(\"session auth request\")\n\n\tprod, err := h.checkProductPassword(logger, product, productPassword)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tch, err := h.findClientChannel(logger, prod, clientKey, false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = data.ValidatePassword(\n\t\tch.Password, clientPassword, string(ch.Salt))\n\tif err != nil {\n\t\tlogger.Warn(\"failed to validate client password: \" +\n\t\t\terr.Error())\n\t\treturn ErrBadClientPassword\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (h *Handler) StartSession(product, productPassword,\n\tclientKey, ip string, port uint16) (*data.Offering, error) {\n\tlogger := h.logger.Add(\"method\", \"StartSession\", \"product\", product,\n\t\t\"clientKey\", clientKey, \"ip\", ip, \"port\", port)\n\n\tlogger.Info(\"session start request\")\n\n\tprod, err := h.checkProductPassword(logger, product, productPassword)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tch, err := h.findClientChannel(logger, prod, clientKey, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar offer data.Offering\n\tif err := h.db.FindByPrimaryKeyTo(&offer, ch.Offering); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\tnow := time.Now()\n\n\tvar ipPtr *string\n\tif len(ip) != 0 {\n\t\tipPtr = pointer.ToString(ip)\n\t}\n\n\tvar portPtr *uint16\n\tif port != 0 {\n\t\tportPtr = pointer.ToUint16(port)\n\t}\n\n\terr = h.db.InTransaction(func(tx *reform.TX) error {\n\t\tsess := data.Session{\n\t\t\tID:            util.NewUUID(),\n\t\t\tChannel:       ch.ID,\n\t\t\tStarted:       now,\n\t\t\tLastUsageTime: now,\n\t\t\tClientIP:      ipPtr,\n\t\t\tClientPort:    portPtr,\n\t\t}\n\t\tif err := tx.Insert(&sess); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif ch.ServiceStatus == data.ServiceActivating {\n\t\t\terr := job.AddWithData(h.queue, tx,\n\t\t\t\tdata.JobClientCompleteServiceTransition,\n\t\t\t\tdata.JobChannel, ch.ID, data.JobSessionServer,\n\t\t\t\tdata.ServiceActive)\n\t\t\tif err != nil && err != job.ErrDuplicatedJob {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn nil, ErrInternal\n\t}\n\n\treturn &offer, nil\n}"
        ],
        [
            "func (h *Handler) UpdateSession(product, productPassword, clientKey string,\n\tunits uint64, stopSession bool) error {\n\tlogger := h.logger.Add(\"method\", \"UpdateSession\", \"product\", product,\n\t\t\"clientKey\", clientKey, \"units\", units,\n\t\t\"stopSession\", stopSession)\n\n\tif stopSession {\n\t\tlogger.Info(\"session stop request\")\n\t} else {\n\t\tlogger.Info(\"session update request\")\n\t}\n\n\tprod, err := h.checkProductPassword(logger, product, productPassword)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tch, err := h.findClientChannel(logger, prod, clientKey, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Make the server adapter to kill the session for non-active channel.\n\tif prod.IsServer && ch.ServiceStatus != data.ServiceActive {\n\t\tlogger.Warn(\"non-active channel\")\n\t\treturn ErrNonActiveChannel\n\t}\n\n\tclientStop := !prod.IsServer && stopSession\n\n\tif clientStop {\n\t\tif ch.ServiceStatus == data.ServiceTerminated {\n\t\t\tlogger.Warn(\"already terminated channel\")\n\t\t\treturn nil\n\t\t}\n\n\t\tstatus := data.ServiceSuspended\n\t\tif ch.ServiceStatus == data.ServiceTerminating {\n\t\t\tstatus = data.ServiceTerminated\n\t\t}\n\n\t\terr := job.AddWithData(h.queue, nil,\n\t\t\tdata.JobClientCompleteServiceTransition,\n\t\t\tdata.JobChannel, ch.ID, data.JobSessionServer,\n\t\t\tstatus)\n\t\tif err != nil && err != job.ErrDuplicatedJob {\n\t\t\tlogger.Error(err.Error())\n\t\t\treturn err\n\t\t}\n\t}\n\n\tsess, err := h.findCurrentSession(logger, ch.ID)\n\tif err != nil {\n\t\t// Client adapter can signal failure immediately, when no\n\t\t// session is yet created.\n\t\tif err == ErrSessionNotFound && clientStop {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\tlogger = logger.Add(\"session\", sess)\n\n\tif units != 0 {\n\t\t// TODO: Use unit size instead of this hardcode.\n\t\tunits /= 1024 * 1024\n\n\t\tswitch prod.UsageRepType {\n\t\tcase data.ProductUsageIncremental:\n\t\t\tsess.UnitsUsed += units\n\t\tcase data.ProductUsageTotal:\n\t\t\tsess.UnitsUsed = units\n\t\tdefault:\n\t\t\tlogger.Fatal(\"unsupported product usage\")\n\t\t}\n\t}\n\n\tsess.LastUsageTime = time.Now()\n\tif stopSession {\n\t\tsess.Stopped = pointer.ToTime(sess.LastUsageTime)\n\t}\n\n\tlogger.Info(\"updating session\")\n\n\tif err := h.db.Save(sess); err != nil {\n\t\tlogger.Error(err.Error())\n\t\treturn ErrInternal\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func OfferingMessage(agent *data.Account, template *data.Template,\n\toffering *data.Offering) *Message {\n\tmsg := &Message{\n\t\tAgentPubKey:        agent.PublicKey,\n\t\tTemplateHash:       template.Hash,\n\t\tCountry:            offering.Country,\n\t\tServiceSupply:      offering.Supply,\n\t\tUnitName:           offering.UnitName,\n\t\tUnitType:           offering.UnitType,\n\t\tBillingType:        offering.BillingType,\n\t\tSetupPrice:         offering.SetupPrice,\n\t\tUnitPrice:          offering.UnitPrice,\n\t\tMinUnits:           offering.MinUnits,\n\t\tMaxUnit:            offering.MaxUnit,\n\t\tBillingInterval:    offering.BillingInterval,\n\t\tMaxBillingUnitLag:  offering.MaxBillingUnitLag,\n\t\tMaxSuspendTime:     offering.MaxSuspendTime,\n\t\tMaxInactiveTimeSec: offering.MaxInactiveTimeSec,\n\t\tFreeUnits:          offering.FreeUnits,\n\t\tNonce:              offering.ID,\n\t\tServiceSpecificParameters: offering.AdditionalParams,\n\t}\n\treturn msg\n}"
        ],
        [
            "func ValidMsg(schema json.RawMessage, msg Message) bool {\n\tsch := gojsonschema.NewBytesLoader(schema)\n\tloader := gojsonschema.NewGoLoader(msg)\n\n\tresult, err := gojsonschema.Validate(sch, loader)\n\tif err != nil || !result.Valid() || len(result.Errors()) != 0 {\n\t\treturn false\n\t}\n\treturn true\n}"
        ],
        [
            "func NewClient(\n\tcfg *Config, db *reform.DB, log Log, version string) (*Client, error) {\n\tif log == nil {\n\t\treturn nil, fmt.Errorf(\"no log object specified\")\n\t}\n\n\texcludedPackagesMap := make(map[string]bool)\n\n\tfor _, pkg := range cfg.ExcludedPackages {\n\t\texcludedPackagesMap[pkg] = true\n\t}\n\n\tpkgSlice, err := pkgList(excludedPackagesMap)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbugsnag.Configure(bugsnag.Configuration{\n\t\tAPIKey:              currentAPIKey,\n\t\tLogger:              log,\n\t\tPanicHandler:        func() {}, // we use our panic processor\n\t\tProjectPackages:     pkgSlice,\n\t\tReleaseStage:        cfg.ReleaseStage,\n\t\tNotifyReleaseStages: []string{production, staging},\n\t\tAppVersion:          version,\n\t})\n\n\tcli := new(Client)\n\tcli.db = db\n\tcli.logger = log\n\tcli.notifier = bugsnag.New(user(cfg.UserID))\n\n\t//check enable service\n\te := cli.allowed()\n\tcli.enable = e\n\tenable = e\n\tnotifier = cli.notifier\n\treturn cli, nil\n}"
        ],
        [
            "func PanicHunter() {\n\tif panicIgnore {\n\t\treturn\n\t}\n\n\tif err := recover(); err != nil {\n\t\tif enable && notifier != nil {\n\t\t\tnotifier.NotifySync(\n\t\t\t\terrors.New(err, 3), true,\n\t\t\t\tmetadata([]data.HexString{defaultAccEth}))\n\t\t}\n\t\tpanic(err)\n\t}\n}"
        ],
        [
            "func (s *Server) ParseRequest(logger log.Logger,\n\tw http.ResponseWriter, r *http.Request, args interface{}) bool {\n\tvar req Request\n\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n\t\tlogger.Warn(\"failed to parse request: \" + err.Error())\n\t\ts.RespondError(logger, w, ErrFailedToParseRequest)\n\t\treturn false\n\t}\n\tr.Body.Close()\n\n\tif err := json.Unmarshal(req.Args, args); err != nil {\n\t\tlogger.Add(\"arguments\", req.Args).Warn(\n\t\t\t\"failed to parse request arguments: \" + err.Error())\n\t\ts.RespondError(logger, w, ErrFailedToParseRequest)\n\t\treturn false\n\t}\n\n\treturn true\n}"
        ],
        [
            "func (i *Ipvs) Save() error {\n\tout, err := backendRun([]string{\"ipvsadm\", \"-S\", \"-n\"})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ti.Services = make([]Service, 0, 0)\n\tserviceStrings := strings.Split(string(out), \"-A\")\n\tfor j := range serviceStrings {\n\t\tif serviceStrings[j] == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tserverStrings := strings.Split(serviceStrings[j], \"-a\")\n\t\tserviceString := serverStrings[0]\n\t\tserverStrings = serverStrings[1:]\n\t\t// fmt.Println(\"Service: \", serviceString)\n\t\tservice := parseService(serviceString)\n\t\tfor k := range serverStrings {\n\t\t\t// fmt.Println(\"Server: \", serverStrings[j])\n\t\t\tserver := parseServer(serverStrings[k])\n\t\t\tservice.Servers = append(service.Servers, server)\n\t\t}\n\t\ti.Services = append(i.Services, service)\n\t}\n\treturn nil\n}"
        ],
        [
            "func NewClient(httpClient *http.Client, mode, clientID, clientSecret, accessToken string) *Client {\n\tb := sling.New().Client(httpClient).Base(baseURL)\n\tb.QueryStruct(struct {\n\t\tV            string `url:\"v\"`\n\t\tM            string `url:\"m\"`\n\t\tClientID     string `url:\"client_id\"`\n\t\tClientSecret string `url:\"client_secret,omitempty\"`\n\t\tAccessToken  string `url:\"access_token,omitempty\"`\n\t}{\n\t\tV:            version,\n\t\tM:            mode,\n\t\tClientID:     clientID,\n\t\tClientSecret: clientSecret,\n\t\tAccessToken:  accessToken,\n\t})\n\n\treturn &Client{\n\t\tsling:  b,\n\t\tVenues: newVenueService(b.New()),\n\t}\n}"
        ],
        [
            "func ParseRate(resp *http.Response) *RateLimit {\n\tlimit := resp.Header.Get(headerRateLimit)\n\tpath := resp.Header.Get(headerRatePath)\n\tremain := resp.Header.Get(headerRateRemaining)\n\n\tl, _ := strconv.Atoi(limit)\n\tr, _ := strconv.Atoi(remain)\n\n\treturn &RateLimit{\n\t\tLimit:     l,\n\t\tPath:      path,\n\t\tRemaining: r,\n\t}\n}"
        ],
        [
            "func (t *BTTracer) SetOutputPath(path string, perm os.FileMode) error {\n\treturn nil\n}"
        ],
        [
            "func UpdateConfig(c GlobalConfig) {\n\tstate.m.Lock()\n\tdefer state.m.Unlock()\n\n\tstate.c = c\n}"
        ],
        [
            "func (t *BTTracer) SetTracerPath(path string) {\n\tt.m.Lock()\n\tdefer t.m.Unlock()\n\n\tt.cmd = path\n}"
        ],
        [
            "func (t *BTTracer) SetOutputPath(path string, perm os.FileMode) error {\n\tif perm == 0 {\n\t\tperm = 0755\n\t}\n\n\tif err := os.MkdirAll(path, perm); err != nil {\n\t\tt.Logf(LogError, \"Failed to create output directory: %v\\n\", err)\n\t\treturn err\n\t}\n\n\tt.m.Lock()\n\tdefer t.m.Unlock()\n\n\tt.outputDir = path\n\n\treturn nil\n}"
        ],
        [
            "func (t *BTTracer) SetPipes(stdin io.Reader, stderr io.Writer) {\n\tt.m.Lock()\n\tdefer t.m.Unlock()\n\n\tt.p.stdin = stdin\n\tt.p.stderr = stderr\n}"
        ],
        [
            "func AppendOptionWithPrefix(options []string, prefix string, v string) []string {\n\tfor i, opt := range options {\n\t\tif strings.HasPrefix(opt, prefix) == true {\n\t\t\tnew_opt := opt + \",\" + v\n\t\t\toptions[i] = new_opt\n\t\t\treturn options\n\t\t}\n\t}\n\treturn append(options, prefix + v)\n}"
        ],
        [
            "func (m *Marshaller) MarshalRaw(bs []byte) {\n\tif m.Error != nil {\n\t\treturn\n\t}\n\tif len(m.Data) < m.offset+len(bs) {\n\t\tm.Error = io.ErrShortBuffer\n\t\treturn\n\t}\n\n\tm.offset += copy(m.Data[m.offset:], bs)\n}"
        ],
        [
            "func (m *Marshaller) MarshalString(s string) {\n\tif m.Error != nil {\n\t\treturn\n\t}\n\tif len(m.Data) < m.offset+4+len(s)+Padding(len(s)) {\n\t\tm.Error = io.ErrShortBuffer\n\t\treturn\n\t}\n\n\tm.MarshalUint32(uint32(len(s)))\n\tm.offset += copy(m.Data[m.offset:], s)\n\tm.offset += copy(m.Data[m.offset:], padBytes[:Padding(len(s))])\n}"
        ],
        [
            "func (m *Marshaller) MarshalBytes(bs []byte) {\n\tif m.Error != nil {\n\t\treturn\n\t}\n\tif len(m.Data) < m.offset+4+len(bs)+Padding(len(bs)) {\n\t\tm.Error = io.ErrShortBuffer\n\t\treturn\n\t}\n\n\tm.MarshalUint32(uint32(len(bs)))\n\tm.offset += copy(m.Data[m.offset:], bs)\n\tm.offset += copy(m.Data[m.offset:], padBytes[:Padding(len(bs))])\n}"
        ],
        [
            "func (m *Marshaller) MarshalBool(v bool) {\n\tif v {\n\t\tm.MarshalUint8(1)\n\t} else {\n\t\tm.MarshalUint8(0)\n\t}\n}"
        ],
        [
            "func (m *Marshaller) MarshalUint32(v uint32) {\n\tif m.Error != nil {\n\t\treturn\n\t}\n\tif len(m.Data) < m.offset+4 {\n\t\tm.Error = io.ErrShortBuffer\n\t\treturn\n\t}\n\n\tm.Data[m.offset+0] = byte(v >> 24)\n\tm.Data[m.offset+1] = byte(v >> 16)\n\tm.Data[m.offset+2] = byte(v >> 8)\n\tm.Data[m.offset+3] = byte(v)\n\tm.offset += 4\n}"
        ],
        [
            "func (m *Marshaller) MarshalUint64(v uint64) {\n\tif m.Error != nil {\n\t\treturn\n\t}\n\tif len(m.Data) < m.offset+8 {\n\t\tm.Error = io.ErrShortBuffer\n\t\treturn\n\t}\n\n\tm.Data[m.offset+0] = byte(v >> 56)\n\tm.Data[m.offset+1] = byte(v >> 48)\n\tm.Data[m.offset+2] = byte(v >> 40)\n\tm.Data[m.offset+3] = byte(v >> 32)\n\tm.Data[m.offset+4] = byte(v >> 24)\n\tm.Data[m.offset+5] = byte(v >> 16)\n\tm.Data[m.offset+6] = byte(v >> 8)\n\tm.Data[m.offset+7] = byte(v)\n\tm.offset += 8\n}"
        ],
        [
            "func ElementSizeExceeded(field string, size, limit int) error {\n\treturn fmt.Errorf(\"%s exceeds size limit; %d > %d\", field, size, limit)\n}"
        ],
        [
            "func (e *encoder) nextSpecialChar(p []byte) (i int) {\n\tfor i = 0; i < len(p); i++ {\n\t\t// ASCII 32-126 (printable) + '\\t' - '=' can appear in the qprintable stream\n\t\tif !((p[i] >= 32 && p[i] <= 126 && p[i] != byte('=')) || p[i] == byte('\\t')) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn i\n}"
        ],
        [
            "func (d *decoder) nextSpecialChar(p []byte) (i int) {\n\tfor i = 0; i < len(p); i++ {\n\t\tif p[i] == byte('=') || (d.enc.isText && p[i] == byte('\\r')) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn i\n}"
        ],
        [
            "func NewDecoder(enc *Encoding, r io.Reader) io.Reader {\n\treturn &decoder{enc: enc, r: r,\n\t\tbuf:       bytes.NewBuffer(nil),\n\t\tleftovers: bytes.NewBuffer(nil)}\n}"
        ],
        [
            "func (di *dependencyInjector) Register(constructorFunc interface{}) error {\n\tconstructorType := reflect.TypeOf(constructorFunc)\n\n\tif (constructorType.Kind() != reflect.Func) || (constructorType.NumOut() != 1) {\n\t\treturn constructorErr\n\t}\n\toutType := constructorType.Out(0)\n\n\t// make sure we can resolve the constuctor arguments\n\tfor i := 0; i < constructorType.NumIn(); i++ {\n\t\tinType := constructorType.In(i)\n\t\t_, ok := di.registry[inType]\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"Can't resolve function arguments - can't find a %s for a %s\\n\", inType, outType)\n\t\t}\n\t}\n\n\tdi.registry[outType] = constructorFunc\n\n\treturn nil\n}"
        ],
        [
            "func (di *dependencyInjector) MustRegister(constructorFunc interface{}) {\n\terr := di.Register(constructorFunc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}"
        ],
        [
            "func (di *dependencyInjector) Create(avar interface{}) interface{} {\n\tvarType := reflect.TypeOf(avar)\n\n\tif di.caching {\n\t\treturn di.cachedCreateFromType(varType).Interface()\n\t} else {\n\t\treturn di.CreateFromType(varType).Interface()\n\t}\n}"
        ],
        [
            "func (di *dependencyInjector) cachedCreateFromType(atype reflect.Type) reflect.Value {\n\t_, exists := di.instances[atype]\n\n\tif !exists {\n\t\tdi.instances[atype] = di.createFromType(atype)\n\t}\n\n\treturn di.instances[atype]\n}"
        ],
        [
            "func NewDependencyInjector() DependencyInjector {\n\treturn &dependencyInjector{\n\t\tregistry:  make(map[reflect.Type]interface{}),\n\t\tinstances: make(map[reflect.Type]reflect.Value),\n\t}\n}"
        ],
        [
            "func NewServiceContainer() ServiceContainer {\n\treturn &dependencyInjector{\n\t\tregistry:  make(map[reflect.Type]interface{}),\n\t\tinstances: make(map[reflect.Type]reflect.Value),\n\t\tcaching:   true,\n\t}\n}"
        ],
        [
            "func (s *prefixPipeline) AssetUrl(name string) (url string, err error) {\n\turl, err = s.AssetPipeline.AssetUrl(name)\n\tif err == nil {\n\t\turl = s.prefix + url\n\t}\n\n\treturn\n}"
        ],
        [
            "func Prefix(prefix string, p AssetPipeline) AssetPipeline {\n\tif prefix == \"\" {\n\t\treturn p\n\t}\n\n\treturn &prefixPipeline{\n\t\tprefix:        prefix,\n\t\tAssetPipeline: p,\n\t}\n}"
        ],
        [
            "func (handler ControllerHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\thandler.getResponse(r).Send(w)\n}"
        ],
        [
            "func (handler ControllerHandler) getResponse(r *http.Request) Response {\n\tcontroller := handler.factory()\n\tcontroller.SetRequest(r)\n\tcontroller.Init()\n\trController := reflect.ValueOf(controller)\n\tmethod := rController.MethodByName(handler.methodName)\n\n\t// get args from gorilla mux\n\tvar args []reflect.Value\n\tfor _, val := range mux.Vars(r) {\n\t\targs = append(args, reflect.ValueOf(val))\n\t}\n\n\t// make sure number of args matches the controller method\n\texpected := len(args)\n\tactual := method.Type().NumIn()\n\tif expected != actual {\n\t\tpanic(fmt.Sprintf(\"Method '%s' has %d args, expected %d\", handler.methodName, actual, expected))\n\t}\n\n\tout := method.Call(args)\n\tif out[0].IsNil() {\n\t\tpanic(\"Response from controller was nil\")\n\t}\n\n\tresp := out[0].Interface().(Response)\n\tif resp == nil {\n\t\tpanic(\"Response from controller was not Response interface\")\n\t}\n\n\tcontroller.Session().WriteToResponse(resp)\n\treturn resp\n}"
        ],
        [
            "func (handler ControllerHandler) isValid() bool {\n\tcontroller := handler.factory()\n\trController := reflect.ValueOf(controller)\n\tmethod := rController.MethodByName(handler.methodName)\n\tif (method == reflect.Value{}) {\n\t\tpanic(\"No such method: \" + handler.methodName)\n\t}\n\ttypeOfMethod := method.Type()\n\n\tvar r *Response\n\tresponseType := reflect.TypeOf(r).Elem()\n\n\treturn (method.Kind() == reflect.Func) &&\n\t\t(typeOfMethod.NumMethod() == 0) &&\n\t\t(typeOfMethod.NumOut() == 1) &&\n\t\ttypeOfMethod.Out(0) == responseType\n\n}"
        ],
        [
            "func NewHandler(factory ControllerFactoryFunc, methodName string) ControllerHandler {\n\thandler := ControllerHandler{factory: factory, methodName: methodName}\n\tif !handler.isValid() {\n\t\tpanic(\"Invalid handler: \" + methodName)\n\t}\n\treturn handler\n}"
        ],
        [
            "func Handler(gf GoannaHandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tgr := &Request{Request: r}\n\t\tgf(gr).Send(w)\n\t}\n}"
        ],
        [
            "func (c *Controller) SetRequest(req *http.Request) {\n\tc.Request = &Request{Request: req}\n}"
        ],
        [
            "func (c *Controller) Session() Session {\n\tif c.Request.session == nil {\n\t\tc.Request.session = c.sessionFinder(c.Request)\n\t}\n\treturn c.Request.session\n}"
        ],
        [
            "func (c *Controller) RenderView(templateStr string, vars interface{}) []byte {\n\tt, err := template.New(\"RenderView\").Parse(templateStr)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn c.RenderTemplate(t, vars)\n}"
        ],
        [
            "func RenderTemplate(t *template.Template, vars interface{}) []byte {\n\tout := bytes.NewBuffer(nil)\n\terr := t.Execute(out, vars)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn out.Bytes()\n}"
        ],
        [
            "func (c *Controller) RedirectRoute(routeName string, args ...string) *RedirectResponse {\n\treturn NewRedirectResponse(c.UrlFor(routeName, args...).String())\n}"
        ],
        [
            "func (c *Controller) UrlFor(routeName string, args ...string) *url.URL {\n\treturn UrlFor(routeName, args...)\n}"
        ],
        [
            "func (r *Request) CookieValue(name string) string {\n\tc, err := r.Cookie(name)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn c.Value\n}"
        ],
        [
            "func (r *Request) BodyData() []byte {\n\tvar err error\n\tif !r.bodyRead {\n\t\tif r.Body != nil {\n\t\t\tr.bodyData, err = ioutil.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\t// catch i/o timeout errors\n\t\t\t\tneterr, isNetError := err.(net.Error)\n\t\t\t\tif isNetError && neterr.Timeout() {\n\t\t\t\t\tpanic(ghttp.NewHttpError(err, http.StatusRequestTimeout))\n\t\t\t\t} else {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr.bodyRead = true\n\t}\n\n\treturn r.bodyData\n}"
        ],
        [
            "func (r *Request) QueryValue(key string) string {\n\treturn r.URL.Query().Get(key)\n}"
        ],
        [
            "func (r *Request) FormValueOrDefault(key string, def string) string {\n\tval := r.FormValue(key)\n\tif val == \"\" {\n\t\tval = def\n\t}\n\n\treturn val\n}"
        ],
        [
            "func (r *Request) UrlValue(key string) string {\n\treturn mux.Vars(r.Request)[key]\n}"
        ],
        [
            "func Contains(s string, substrs []string) bool {\n\tfor _, substr := range substrs {\n\t\tif strings.Contains(s, substr) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}"
        ],
        [
            "func RemoveStringsFromString(s string, substrs []string) string {\n\tfor loop := true; loop; {\n\t\tloop = false\n\t\tfor _, substr := range substrs {\n\t\t\tlastS := s\n\t\t\ts = strings.Join(strings.Split(s, substr), \"\")\n\t\t\tif lastS != s {\n\t\t\t\tloop = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn s\n}"
        ],
        [
            "func Map(ss []string, callback func(string) string) []string {\n\tnewStrings := make([]string, len(ss))\n\tfor i, s := range ss {\n\t\tnewStrings[i] = callback(s)\n\t}\n\n\treturn newStrings\n}"
        ],
        [
            "func Equal(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i, v := range a {\n\t\tif v != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
        ],
        [
            "func Uniq(items []string) (uniqItems []string) {\n\tsort.Strings(items)\n\n\tlastitem := \"\"\n\tfor _, item := range items {\n\t\tif item != lastitem {\n\t\t\tuniqItems = append(uniqItems, item)\n\t\t\tlastitem = item\n\t\t}\n\t}\n\n\treturn\n}"
        ],
        [
            "func NewCookieSigner(key []byte) CookieSigner {\n\treturn CookieSigner{signer: hmac.New(sha256.New, key)}\n}"
        ],
        [
            "func (c CookieSigner) EncodeCookie(cookie *http.Cookie) {\n\tcookie.Value = c.EncodeValue(cookie.Value)\n}"
        ],
        [
            "func (c CookieSigner) DecodeCookie(cookie *http.Cookie) error {\n\tdata, err := c.DecodeValue(cookie.Value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcookie.Value = data\n\n\treturn nil\n}"
        ],
        [
            "func (c CookieSigner) DecodeValue(encodedvalue string) (string, error) {\n\tparts := strings.SplitN(encodedvalue, \".\", 2)\n\tif len(parts) != 2 {\n\t\treturn \"\", errors.New(\"Wrong number of parts\")\n\t}\n\tmac, err := base64.URLEncoding.DecodeString(parts[0])\n\tvalue := parts[1]\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif !hmac.Equal(c.mac(value), mac) {\n\t\treturn \"\", errors.New(\"Bad signature\")\n\t}\n\n\treturn value, nil\n}"
        ],
        [
            "func (c CookieSigner) EncodeValue(value string) string {\n\treturn fmt.Sprintf(\"%s.%s\",\n\t\tbase64.URLEncoding.EncodeToString(c.mac(value)),\n\t\tvalue)\n}"
        ],
        [
            "func (sh *StatsdLogHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\trequestStartTime := time.Now()\n\tsh.handler.ServeHTTP(w, req)\n\trequestDuration := time.Now().Sub(requestStartTime)\n\n\tdescription := sh.RequestFormatter(req)\n\tif description != \"\" {\n\t\tsh.statter.Counter(1.0, sh.prefix+\".\"+description+\".requests\", 1)\n\t\tsh.statter.Timing(1.0, sh.prefix+\".\"+description+\".responsetime\", requestDuration)\n\t}\n}"
        ],
        [
            "func NewSprocketsServer(target *url.URL) (*SprocketsServer, error) {\n\ts := SprocketsServer{\n\t\tHandler: httputil.NewSingleHostReverseProxy(target),\n\t\ttarget:  target,\n\t}\n\n\treturn &s, nil\n}"
        ],
        [
            "func normaliseKey(key string) string {\n\tnewkey := url.QueryEscape(key)\n\tif len(newkey) > 250 {\n\t\tnewkey = newkey[:250]\n\t}\n\n\treturn newkey\n}"
        ],
        [
            "func (m *Monitor) StopAndLog(sectionName string) error {\n\terr := m.Stop(sectionName)\n\tif err == nil {\n\t\tm.Log(sectionName)\n\t}\n\n\treturn err\n}"
        ],
        [
            "func (m *Monitor) MonitorFunc(section string, myfunc interface{}) []reflect.Value {\n\treturn m.MonitorReflectedFunc(section, reflect.ValueOf(myfunc), []reflect.Value{})\n}"
        ],
        [
            "func (m *Monitor) MonitorReflectedFunc(section string, reflectedFunc reflect.Value, args []reflect.Value) []reflect.Value {\n\tm.Start(section)\n\tdefer m.StopAndLog(section)\n\n\treturn reflectedFunc.Call(args)\n}"
        ],
        [
            "func LogRequest(r *Request, v ...string) {\n\tserializedHeaders := bytes.Buffer{}\n\tr.Header.Write(&serializedHeaders)\n\n\tprintf := log.Printf\n\tif Logger != nil {\n\t\tprintf = Logger.Printf\n\t}\n\n\tprintf(\n\t\tLogRequestTemplate,\n\t\tstrings.Join(v, \" \"),\n\t\tr.URL.String(),\n\t\tr.Method,\n\t\ttime.Now(),\n\t\tserializedHeaders.String(),\n\t\tstring(r.BodyData()),\n\t\tdebug.Stack(),\n\t)\n}"
        ],
        [
            "func CommonLogHandler(logger *log.Logger, templ string, h http.Handler) http.Handler {\n\tif logger == nil {\n\t\tlogger = log.New(os.Stdout, \"\", 0)\n\t}\n\tif templ == \"\" {\n\t\ttempl = CommonLogFormat\n\t}\n\n\treturn &commonLogHandler{\n\t\thandler:  h,\n\t\tlogger:   logger,\n\t\ttemplate: template.Must(template.New(\"\").Parse(templ)),\n\t}\n}"
        ],
        [
            "func (lh *commonLogHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\t// take a copy of the request (so it's immutable)\n\t// watch the writer and capture the status and size\n\tlogData := LogData{\n\t\tRequest:  *req,\n\t\tResponse: WatchResponseWriter(w),\n\t}\n\n\tlogData.Start = time.Now()\n\tlh.handler.ServeHTTP(logData.Response, req)\n\tlogData.End = time.Now()\n\n\tlogOutput := bytes.Buffer{}\n\terr := lh.template.Execute(&logOutput, logData)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tlh.logger.Println(logOutput.String())\n}"
        ],
        [
            "func (this LogData) UrlUsername() string {\n\tif this.Request.URL.User != nil {\n\t\treturn this.Request.URL.User.Username()\n\t}\n\treturn \"\"\n}"
        ],
        [
            "func UrlFor(name string, args ...string) *url.URL {\n\tr := Router.Get(name)\n\tif r == nil {\n\t\tlog.Panicf(\"UrlFor: No such route '%s'\\n\", name)\n\t}\n\tu, err := r.URL(args...)\n\tif err != nil {\n\t\tlog.Panicln(\"UrlFor: \" + err.Error())\n\t}\n\treturn u\n}"
        ],
        [
            "func AbsoluteUrlFor(name string, args ...string) *url.URL {\n\tu := UrlFor(name, args...)\n\tu.Host = UrlBase.Host\n\tu.Scheme = UrlBase.Scheme\n\treturn u\n}"
        ],
        [
            "func Parse(jsondata []byte, v interface{}) {\n\terr := json.Unmarshal(jsondata, v)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}"
        ],
        [
            "func LoadFromEnv(v interface{}, prefix string) (result []MarshalledEnvironmentVar) {\n\tpointerValue := reflect.ValueOf(v)\n\tstructValue := pointerValue.Elem()\n\tstructType := structValue.Type()\n\n\tfor i := 0; i < structValue.NumField(); i++ {\n\t\tstructField := structType.Field(i)\n\t\tfieldValue := structValue.Field(i)\n\n\t\tif fieldValue.CanSet() {\n\t\t\tenvKey := strings.ToUpper(prefix) + gocase.ToUpperSnake(structField.Name)\n\t\t\tenvVal := os.Getenv(envKey)\n\n\t\t\tif envVal != \"\" {\n\t\t\t\t// create a json blob with the env data\n\t\t\t\tjsonStr := \"\"\n\t\t\t\tif fieldValue.Kind() == reflect.String {\n\t\t\t\t\tjsonStr = fmt.Sprintf(`{\"%s\": \"%s\"}`, structField.Name, envVal)\n\t\t\t\t} else {\n\t\t\t\t\tjsonStr = fmt.Sprintf(`{\"%s\": %s}`, structField.Name, envVal)\n\t\t\t\t}\n\n\t\t\t\terr := json.Unmarshal([]byte(jsonStr), v)\n\t\t\t\tresult = append(result, MarshalledEnvironmentVar{envKey, envVal, structField.Name, err})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}"
        ],
        [
            "func RegexPath(reg *regexp.Regexp, h http.Handler) http.Handler {\n\tif reg == nil {\n\t\treturn h\n\t}\n\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tmatches := reg.FindStringSubmatch(r.URL.Path)\n\t\tif len(matches) > 1 {\n\t\t\tr.URL.Path = matches[1]\n\t\t\th.ServeHTTP(w, r)\n\t\t} else {\n\t\t\thttp.NotFound(w, r)\n\t\t}\n\t})\n}"
        ],
        [
            "func CacheControl(maxage uint, delegate http.Handler) http.Handler {\n\treturn &cacheDecorator{delegate, maxage}\n}"
        ],
        [
            "func transform(in interface{}) (_ interface{}, err error) {\n\tswitch in.(type) {\n\tcase map[interface{}]interface{}:\n\t\to := make(map[string]interface{})\n\t\tfor k, v := range in.(map[interface{}]interface{}) {\n\t\t\tsk := \"\"\n\t\t\tswitch k.(type) {\n\t\t\tcase string:\n\t\t\t\tsk = k.(string)\n\t\t\tcase int:\n\t\t\t\tsk = strconv.Itoa(k.(int))\n\t\t\tdefault:\n\t\t\t\treturn nil, errors.New(\n\t\t\t\t\tfmt.Sprintf(\"type not match: expect map key string or int get: %T\", k))\n\t\t\t}\n\t\t\tv, err = transform(v)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\to[sk] = v\n\t\t}\n\t\treturn o, nil\n\tcase []interface{}:\n\t\tin1 := in.([]interface{})\n\t\tlen1 := len(in1)\n\t\to := make([]interface{}, len1)\n\t\tfor i := 0; i < len1; i++ {\n\t\t\to[i], err = transform(in1[i])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn o, nil\n\tdefault:\n\t\treturn in, nil\n\t}\n}"
        ],
        [
            "func DiscoverWalk(app App, insecure discovery.InsecureOption, discoverFn DiscoverWalkFunc) (err error) {\n\tvar (\n\t\teps *Endpoints\n\t)\n\n\tparts := strings.Split(string(app.Name), \"/\")\n\tfor i := range parts {\n\t\tend := len(parts) - i\n\t\tpre := strings.Join(parts[:end], \"/\")\n\n\t\teps, err = doDiscover(pre, app, insecure)\n\t\tif derr := discoverFn(pre, eps, err); derr != nil {\n\t\t\treturn derr\n\t\t}\n\t}\n\n\treturn\n}"
        ],
        [
            "func DiscoverEndpoints(app App, insecure discovery.InsecureOption) (out *Endpoints, attempts []FailedAttempt, err error) {\n\tout = &Endpoints{}\n\ttestFn := func(pre string, eps *Endpoints, err error) error {\n\t\tif len(out.ACIEndpoints) != 0 || len(out.Keys) != 0 || len(out.ACIPushEndpoints) != 0 {\n\t\t\treturn errEnough\n\t\t}\n\t\treturn nil\n\t}\n\n\terr = DiscoverWalk(app, insecure, walker(out, &attempts, testFn))\n\tif err != nil && err != errEnough {\n\t\treturn nil, attempts, err\n\t}\n\n\treturn out, attempts, nil\n}"
        ],
        [
            "func JSONFieldsFromStruct(v reflect.Value) []string {\n\tif v.Kind() != reflect.Struct {\n\t\treturn nil\n\t}\n\n\tm := getType2jfm(v.Type())\n\tm.lock.Lock()\n\tdefer m.lock.Unlock()\n\n\tl := make([]string, 0, len(m.fields))\n\tfor k := range m.fields {\n\t\tl = append(l, k)\n\t}\n\treturn l\n}"
        ],
        [
            "func StructFieldFromJSONName(v reflect.Value, name string) string {\n\tif v.Kind() != reflect.Struct {\n\t\treturn \"\"\n\t}\n\n\tm := getType2jfm(v.Type())\n\tm.lock.Lock()\n\tdefer m.lock.Unlock()\n\n\ts, ok := m.fields[name]\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn s\n}"
        ],
        [
            "func (dict Dictionary) Enumerate(cancel <-chan struct{}) Enumerator {\n\tif dict.root == nil {\n\t\treturn Empty.Enumerate(cancel)\n\t}\n\treturn dict.root.Enumerate(cancel)\n}"
        ],
        [
            "func (m *Message) Release() {\n\tif m != nil {\n\t\tm.Text = nil\n\t\tm.List = m.List[:0]\n\t\tmessagePool.Put(m)\n\t}\n}"
        ],
        [
            "func Wrap(err error, text ...string) Error {\n\treturn causer(newError(nil, err, text...))\n}"
        ],
        [
            "func causer(e *errorT) Error {\n\tif e.err == nil {\n\t\treturn e\n\t}\n\treturn &causerT{\n\t\terrorT: e,\n\t}\n}"
        ],
        [
            "func From(ctx context.Context) Context {\n\tif c, ok := ctx.(Context); ok {\n\t\treturn c\n\t}\n\treturn &contextT{ctx: ctx}\n}"
        ],
        [
            "func (c *contextT) With(keyvals ...interface{}) context.Context {\n\treturn &contextT{ctx: newContext(c.ctx, keyvals)}\n}"
        ],
        [
            "func (c *contextT) Format(f fmt.State, ch rune) {\n\tif ch == 'v' && f.Flag('+') {\n\t\tfmt.Fprint(f, c.ctx)\n\t\treturn\n\t}\n\tbuf := pool.AllocBuffer()\n\tlist := List(fromContext(c.ctx))\n\tlist.writeToBuffer(buf)\n\tf.Write(buf.Bytes())\n\tpool.ReleaseBuffer(buf)\n}"
        ],
        [
            "func NewWriter(out io.Writer) *Writer {\n\tw := &Writer{\n\t\tprinter: newPrinter(out),\n\t}\n\treturn w\n}"
        ],
        [
            "func (w *Writer) Levels() map[string]string {\n\tw.mutex.Lock()\n\tdefer w.mutex.Unlock()\n\n\tif w.levels == nil {\n\t\tw.setLevels(Levels)\n\t}\n\tlevels := make(map[string]string)\n\tfor level, effect := range w.levels {\n\t\tlevels[level] = effect\n\t}\n\n\treturn levels\n}"
        ],
        [
            "func (w *Writer) SetLevel(level string, effect string) {\n\tlevels := w.Levels()\n\tlevels[level] = effect\n\tw.SetLevels(levels)\n}"
        ],
        [
            "func (w *Writer) Suppress(levels ...string) {\n\tp := w.Levels()\n\tfor _, level := range levels {\n\t\tp[level] = \"hide\"\n\t}\n\tw.SetLevels(p)\n}"
        ],
        [
            "func (w *Writer) IsSuppressed(level string) bool {\n\t_, ok := w.suppressMap[level]\n\treturn ok\n}"
        ],
        [
            "func (w *Writer) Handle(h Handler) {\n\tw.mutex.Lock()\n\tdefer w.mutex.Unlock()\n\n\tif h != nil {\n\t\tw.handlers = append(w.handlers, h)\n\t}\n}"
        ],
        [
            "func (w *Writer) SetOutput(out io.Writer) {\n\tw.mutex.Lock()\n\tw.printer = newPrinter(out)\n\tw.mutex.Unlock()\n}"
        ],
        [
            "func (d Directory) Enumerate(cancel <-chan struct{}) Enumerator {\n\tresults := make(chan interface{})\n\n\tgo func() {\n\t\tdefer close(results)\n\n\t\tfilepath.Walk(d.Location, func(currentLocation string, info os.FileInfo, openErr error) (err error) {\n\t\t\tif openErr != nil {\n\t\t\t\terr = openErr\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif d.Location == currentLocation {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif info.IsDir() && 0 == d.Options&DirectoryOptionsRecursive {\n\t\t\t\terr = filepath.SkipDir\n\t\t\t}\n\n\t\t\tif d.applyOptions(currentLocation, info) {\n\t\t\t\tselect {\n\t\t\t\tcase results <- currentLocation:\n\t\t\t\t\t// Intentionally Left Blank\n\t\t\t\tcase <-cancel:\n\t\t\t\t\terr = errors.New(\"directory enumeration cancelled\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn\n\t\t})\n\t}()\n\n\treturn results\n}"
        ],
        [
            "func All(subject Enumerable, p Predicate) bool {\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\treturn subject.Enumerate(done).All(p)\n}"
        ],
        [
            "func (iter Enumerator) All(p Predicate) bool {\n\tfor entry := range iter {\n\t\tif !p(entry) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
        ],
        [
            "func Any(iterator Enumerable) bool {\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\tfor range iterator.Enumerate(done) {\n\t\treturn true\n\t}\n\treturn false\n}"
        ],
        [
            "func Anyp(iterator Enumerable, p Predicate) bool {\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\tfor element := range iterator.Enumerate(done) {\n\t\tif p(element) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"
        ],
        [
            "func AsEnumerable(entries ...interface{}) Enumerable {\n\tif len(entries) != 1 {\n\t\treturn enumerableSlice(entries)\n\t}\n\n\tval := reflect.ValueOf(entries[0])\n\n\tif kind := val.Kind(); kind == reflect.Slice || kind == reflect.Array {\n\t\treturn enumerableValue{\n\t\t\tValue: val,\n\t\t}\n\t}\n\treturn enumerableSlice(entries)\n}"
        ],
        [
            "func First(subject Enumerable) (retval interface{}, err error) {\n\tdone := make(chan struct{})\n\n\terr = errNoElements\n\n\tvar isOpen bool\n\n\tif retval, isOpen = <-subject.Enumerate(done); isOpen {\n\t\terr = nil\n\t}\n\tclose(done)\n\n\treturn\n}"
        ],
        [
            "func (iter Enumerator) Merge(others ...Enumerator) Enumerator {\n\tretval := make(chan interface{})\n\n\tvar wg sync.WaitGroup\n\twg.Add(len(others) + 1)\n\n\tfunnel := func(prevResult Enumerator) {\n\t\tfor entry := range prevResult {\n\t\t\tretval <- entry\n\t\t}\n\t\twg.Done()\n\t}\n\n\tgo funnel(iter)\n\tfor _, item := range others {\n\t\tgo funnel(item)\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(retval)\n\t}()\n\treturn retval\n}"
        ],
        [
            "func ParallelSelect(original Enumerable, operation Transform) Enumerable {\n\treturn parallelSelecter{\n\t\toriginal:  original,\n\t\toperation: operation,\n\t}\n}"
        ],
        [
            "func (iter Enumerator) ParallelSelect(operation Transform) Enumerator {\n\tif cpus := runtime.NumCPU(); cpus != 1 {\n\t\tintermediate := iter.splitN(operation, uint(cpus))\n\t\treturn intermediate[0].Merge(intermediate[1:]...)\n\t}\n\treturn iter\n}"
        ],
        [
            "func (iter Enumerator) Reverse() Enumerator {\n\tcache := NewStack()\n\tfor entry := range iter {\n\t\tcache.Push(entry)\n\t}\n\n\tretval := make(chan interface{})\n\n\tgo func() {\n\t\tfor !cache.IsEmpty() {\n\t\t\tval, _ := cache.Pop()\n\t\t\tretval <- val\n\t\t}\n\t\tclose(retval)\n\t}()\n\treturn retval\n}"
        ],
        [
            "func Select(subject Enumerable, transform Transform) Enumerable {\n\treturn selecter{\n\t\toriginal:  subject,\n\t\ttransform: transform,\n\t}\n}"
        ],
        [
            "func (iter Enumerator) Select(transform Transform) Enumerator {\n\tretval := make(chan interface{})\n\n\tgo func() {\n\t\tfor item := range iter {\n\t\t\tretval <- transform(item)\n\t\t}\n\t\tclose(retval)\n\t}()\n\n\treturn retval\n}"
        ],
        [
            "func SelectMany(subject Enumerable, toMany Unfolder) Enumerable {\n\treturn selectManyer{\n\t\toriginal: subject,\n\t\ttoMany:   toMany,\n\t}\n}"
        ],
        [
            "func (iter Enumerator) SelectMany(lister Unfolder) Enumerator {\n\tretval := make(chan interface{})\n\n\tgo func() {\n\t\tfor parent := range iter {\n\t\t\tfor child := range lister(parent) {\n\t\t\t\tretval <- child\n\t\t\t}\n\t\t}\n\t\tclose(retval)\n\t}()\n\n\treturn retval\n}"
        ],
        [
            "func Single(iter Enumerable) (retval interface{}, err error) {\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\terr = errNoElements\n\n\tfirstPass := true\n\tfor entry := range iter.Enumerate(done) {\n\t\tif firstPass {\n\t\t\tretval = entry\n\t\t\terr = nil\n\t\t} else {\n\t\t\tretval = nil\n\t\t\terr = errMultipleElements\n\t\t\tbreak\n\t\t}\n\t\tfirstPass = false\n\t}\n\treturn\n}"
        ],
        [
            "func Singlep(iter Enumerable, pred Predicate) (retval interface{}, err error) {\n\titer = Where(iter, pred)\n\treturn Single(iter)\n}"
        ],
        [
            "func Skip(subject Enumerable, n uint) Enumerable {\n\treturn skipper{\n\t\toriginal:  subject,\n\t\tskipCount: n,\n\t}\n}"
        ],
        [
            "func (iter Enumerator) splitN(operation Transform, n uint) []Enumerator {\n\tresults, cast := make([]chan interface{}, n, n), make([]Enumerator, n, n)\n\n\tfor i := uint(0); i < n; i++ {\n\t\tresults[i] = make(chan interface{})\n\t\tcast[i] = results[i]\n\t}\n\n\tgo func() {\n\t\tfor i := uint(0); i < n; i++ {\n\t\t\tgo func(addr uint) {\n\t\t\t\tdefer close(results[addr])\n\t\t\t\tfor {\n\t\t\t\t\tread, ok := <-iter\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tresults[addr] <- operation(read)\n\t\t\t\t}\n\t\t\t}(i)\n\t\t}\n\t}()\n\n\treturn cast\n}"
        ],
        [
            "func Take(subject Enumerable, n uint) Enumerable {\n\treturn taker{\n\t\toriginal: subject,\n\t\tn:        n,\n\t}\n}"
        ],
        [
            "func (iter Enumerator) Take(n uint) Enumerator {\n\tresults := make(chan interface{})\n\n\tgo func() {\n\t\tdefer close(results)\n\t\ti := uint(0)\n\t\tfor entry := range iter {\n\t\t\tif i >= n {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ti++\n\t\t\tresults <- entry\n\t\t}\n\t}()\n\n\treturn results\n}"
        ],
        [
            "func TakeWhile(subject Enumerable, criteria func(interface{}, uint) bool) Enumerable {\n\treturn takeWhiler{\n\t\toriginal: subject,\n\t\tcriteria: criteria,\n\t}\n}"
        ],
        [
            "func (iter Enumerator) TakeWhile(criteria func(interface{}, uint) bool) Enumerator {\n\tresults := make(chan interface{})\n\n\tgo func() {\n\t\tdefer close(results)\n\t\ti := uint(0)\n\t\tfor entry := range iter {\n\t\t\tif !criteria(entry, i) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ti++\n\t\t\tresults <- entry\n\t\t}\n\t}()\n\n\treturn results\n}"
        ],
        [
            "func (iter Enumerator) Tee() (Enumerator, Enumerator) {\n\tleft, right := make(chan interface{}), make(chan interface{})\n\n\tgo func() {\n\t\tfor entry := range iter {\n\t\t\tleft <- entry\n\t\t\tright <- entry\n\t\t}\n\t\tclose(left)\n\t\tclose(right)\n\t}()\n\n\treturn left, right\n}"
        ],
        [
            "func (iter Enumerator) ToSlice() []interface{} {\n\tretval := make([]interface{}, 0)\n\tfor entry := range iter {\n\t\tretval = append(retval, entry)\n\t}\n\treturn retval\n}"
        ],
        [
            "func Where(original Enumerable, p Predicate) Enumerable {\n\treturn wherer{\n\t\toriginal: original,\n\t\tfilter:   p,\n\t}\n}"
        ],
        [
            "func (iter Enumerator) Where(predicate Predicate) Enumerator {\n\tretval := make(chan interface{})\n\tgo func() {\n\t\tfor item := range iter {\n\t\t\tif predicate(item) {\n\t\t\t\tretval <- item\n\t\t\t}\n\t\t}\n\t\tclose(retval)\n\t}()\n\n\treturn retval\n}"
        ],
        [
            "func ReleaseBuffer(buf *bytes.Buffer) {\n\tif buf != nil {\n\t\tbuf.Reset()\n\t\tbufferPool.Put(buf)\n\t}\n}"
        ],
        [
            "func NewStack(entries ...interface{}) *Stack {\n\tretval := &Stack{}\n\tretval.underlyer = NewLinkedList()\n\n\tfor _, entry := range entries {\n\t\tretval.Push(entry)\n\t}\n\treturn retval\n}"
        ],
        [
            "func (stack *Stack) Enumerate(cancel <-chan struct{}) Enumerator {\n\tstack.key.RLock()\n\tdefer stack.key.RUnlock()\n\n\treturn stack.underlyer.Enumerate(cancel)\n}"
        ],
        [
            "func (stack *Stack) IsEmpty() bool {\n\tstack.key.RLock()\n\tdefer stack.key.RUnlock()\n\treturn stack.underlyer == nil || stack.underlyer.IsEmpty()\n}"
        ],
        [
            "func (stack *Stack) Push(entry interface{}) {\n\tstack.key.Lock()\n\tdefer stack.key.Unlock()\n\n\tif nil == stack.underlyer {\n\t\tstack.underlyer = NewLinkedList()\n\t}\n\tstack.underlyer.AddFront(entry)\n}"
        ],
        [
            "func (stack *Stack) Pop() (interface{}, bool) {\n\tstack.key.Lock()\n\tdefer stack.key.Unlock()\n\n\tif nil == stack.underlyer {\n\t\treturn nil, false\n\t}\n\treturn stack.underlyer.RemoveFront()\n}"
        ],
        [
            "func (stack *Stack) Peek() (interface{}, bool) {\n\tstack.key.RLock()\n\tdefer stack.key.RUnlock()\n\treturn stack.underlyer.PeekFront()\n}"
        ],
        [
            "func (stack *Stack) Size() uint {\n\tstack.key.RLock()\n\tdefer stack.key.RUnlock()\n\tif stack.underlyer == nil {\n\t\treturn 0\n\t}\n\treturn stack.underlyer.Length()\n}"
        ],
        [
            "func NewLinkedList(entries ...interface{}) *LinkedList {\n\tlist := &LinkedList{}\n\n\tfor _, entry := range entries {\n\t\tlist.AddBack(entry)\n\t}\n\n\treturn list\n}"
        ],
        [
            "func (list *LinkedList) AddBack(entry interface{}) {\n\ttoAppend := &llNode{\n\t\tpayload: entry,\n\t}\n\n\tlist.key.Lock()\n\tdefer list.key.Unlock()\n\n\tlist.length++\n\n\tif list.first == nil {\n\t\tlist.first = toAppend\n\t\tlist.last = toAppend\n\t\treturn\n\t}\n\n\tlist.last.next = toAppend\n\tlist.last = toAppend\n}"
        ],
        [
            "func (list *LinkedList) Enumerate(cancel <-chan struct{}) Enumerator {\n\tretval := make(chan interface{})\n\n\tgo func() {\n\t\tlist.key.RLock()\n\t\tdefer list.key.RUnlock()\n\t\tdefer close(retval)\n\n\t\tcurrent := list.first\n\t\tfor current != nil {\n\t\t\tselect {\n\t\t\tcase retval <- current.payload:\n\t\t\t\tbreak\n\t\t\tcase <-cancel:\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcurrent = current.next\n\t\t}\n\t}()\n\n\treturn retval\n}"
        ],
        [
            "func (list *LinkedList) Get(pos uint) (interface{}, bool) {\n\tlist.key.RLock()\n\tdefer list.key.RUnlock()\n\tnode, ok := get(list.first, pos)\n\tif ok {\n\t\treturn node.payload, true\n\t}\n\treturn nil, false\n}"
        ],
        [
            "func (list *LinkedList) IsEmpty() bool {\n\tlist.key.RLock()\n\tdefer list.key.RUnlock()\n\n\treturn list.first == nil\n}"
        ],
        [
            "func (list *LinkedList) Length() uint {\n\tlist.key.RLock()\n\tdefer list.key.RUnlock()\n\n\treturn list.length\n}"
        ],
        [
            "func (list *LinkedList) PeekBack() (interface{}, bool) {\n\tlist.key.RLock()\n\tdefer list.key.RUnlock()\n\n\tif list.last == nil {\n\t\treturn nil, false\n\t}\n\treturn list.last.payload, true\n}"
        ],
        [
            "func (list *LinkedList) PeekFront() (interface{}, bool) {\n\tlist.key.RLock()\n\tdefer list.key.RUnlock()\n\n\tif list.first == nil {\n\t\treturn nil, false\n\t}\n\treturn list.first.payload, true\n}"
        ],
        [
            "func (list *LinkedList) RemoveFront() (interface{}, bool) {\n\tlist.key.Lock()\n\tdefer list.key.Unlock()\n\n\tif list.first == nil {\n\t\treturn nil, false\n\t}\n\n\tretval := list.first.payload\n\n\tlist.first = list.first.next\n\tlist.length--\n\n\tif 0 == list.length {\n\t\tlist.last = nil\n\t}\n\n\treturn retval, true\n}"
        ],
        [
            "func (list *LinkedList) RemoveBack() (interface{}, bool) {\n\tlist.key.Lock()\n\tdefer list.key.Unlock()\n\n\tif list.last == nil {\n\t\treturn nil, false\n\t}\n\n\tretval := list.last.payload\n\tlist.length--\n\n\tif list.length == 0 {\n\t\tlist.first = nil\n\t} else {\n\t\tnode, _ := get(list.first, list.length-1)\n\t\tnode.next = nil\n\t}\n\treturn retval, true\n}"
        ],
        [
            "func (list *LinkedList) Sort(comparator Comparator) error {\n\tlist.key.Lock()\n\tdefer list.key.Unlock()\n\tvar err error\n\tlist.first, err = mergeSort(list.first, comparator)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlist.last = findLast(list.first)\n\treturn err\n}"
        ],
        [
            "func (list *LinkedList) Sorta() error {\n\tlist.key.Lock()\n\tdefer list.key.Unlock()\n\n\tvar err error\n\tlist.first, err = mergeSort(list.first, func(a, b interface{}) (int, error) {\n\t\tcastA, ok := a.(string)\n\t\tif !ok {\n\t\t\treturn 0, ErrUnexpectedType\n\t\t}\n\t\tcastB, ok := b.(string)\n\t\tif !ok {\n\t\t\treturn 0, ErrUnexpectedType\n\t\t}\n\n\t\treturn strings.Compare(castA, castB), nil\n\t})\n\tlist.last = findLast(list.first)\n\treturn err\n}"
        ],
        [
            "func (list *LinkedList) Sorti() (err error) {\n\tlist.key.Lock()\n\tdefer list.key.Unlock()\n\n\tlist.first, err = mergeSort(list.first, func(a, b interface{}) (int, error) {\n\t\tcastA, ok := a.(int)\n\t\tif !ok {\n\t\t\treturn 0, ErrUnexpectedType\n\t\t}\n\t\tcastB, ok := b.(int)\n\t\tif !ok {\n\t\t\treturn 0, ErrUnexpectedType\n\t\t}\n\n\t\treturn castA - castB, nil\n\t})\n\tif err != nil {\n\t\treturn\n\t}\n\tlist.last = findLast(list.first)\n\treturn\n}"
        ],
        [
            "func (list *LinkedList) String() string {\n\tlist.key.RLock()\n\tdefer list.key.RUnlock()\n\n\tbuilder := bytes.NewBufferString(\"[\")\n\tcurrent := list.first\n\tfor i := 0; i < 15 && current != nil; i++ {\n\t\tbuilder.WriteString(fmt.Sprintf(\"%v \", current.payload))\n\t\tcurrent = current.next\n\t}\n\tif current == nil || current.next == nil {\n\t\tbuilder.Truncate(builder.Len() - 1)\n\t} else {\n\t\tbuilder.WriteString(\"...\")\n\t}\n\tbuilder.WriteRune(']')\n\treturn builder.String()\n}"
        ],
        [
            "func (list *LinkedList) Swap(x, y uint) error {\n\tlist.key.Lock()\n\tdefer list.key.Unlock()\n\n\tvar xNode, yNode *llNode\n\tif temp, ok := get(list.first, x); ok {\n\t\txNode = temp\n\t} else {\n\t\treturn fmt.Errorf(\"index out of bounds 'x', wanted less than %d got %d\", list.length, x)\n\t}\n\tif temp, ok := get(list.first, y); ok {\n\t\tyNode = temp\n\t} else {\n\t\treturn fmt.Errorf(\"index out of bounds 'y', wanted less than %d got %d\", list.length, y)\n\t}\n\n\ttemp := xNode.payload\n\txNode.payload = yNode.payload\n\tyNode.payload = temp\n\treturn nil\n}"
        ],
        [
            "func merge(left, right *llNode, comparator Comparator) (first *llNode, err error) {\n\tcurLeft := left\n\tcurRight := right\n\n\tvar last *llNode\n\n\tappendResults := func(updated *llNode) {\n\t\tif last == nil {\n\t\t\tlast = updated\n\t\t} else {\n\t\t\tlast.next = updated\n\t\t\tlast = last.next\n\t\t}\n\t\tif first == nil {\n\t\t\tfirst = last\n\t\t}\n\t}\n\n\tfor curLeft != nil && curRight != nil {\n\t\tvar res int\n\t\tif res, err = comparator(curLeft.payload, curRight.payload); nil != err {\n\t\t\tbreak // Don't return, stitch the remaining elements back on.\n\t\t} else if res < 0 {\n\t\t\tappendResults(curLeft)\n\t\t\tcurLeft = curLeft.next\n\t\t} else {\n\t\t\tappendResults(curRight)\n\t\t\tcurRight = curRight.next\n\t\t}\n\t}\n\n\tif curLeft != nil {\n\t\tappendResults(curLeft)\n\t}\n\tif curRight != nil {\n\t\tappendResults(curRight)\n\t}\n\treturn\n}"
        ],
        [
            "func split(head *llNode) (left, right *llNode) {\n\tleft = head\n\tif head == nil || head.next == nil {\n\t\treturn\n\t}\n\tright = head\n\tsprinter := head\n\tprev := head\n\tfor sprinter != nil && sprinter.next != nil {\n\t\tprev = right\n\t\tright = right.next\n\t\tsprinter = sprinter.next.next\n\t}\n\tprev.next = nil\n\treturn\n}"
        ],
        [
            "func (q *Queue) Add(entry interface{}) {\n\tq.key.Lock()\n\tdefer q.key.Unlock()\n\tif nil == q.underlyer {\n\t\tq.underlyer = NewLinkedList()\n\t}\n\tq.underlyer.AddBack(entry)\n}"
        ],
        [
            "func (q *Queue) Enumerate(cancel <-chan struct{}) Enumerator {\n\tq.key.RLock()\n\tdefer q.key.RUnlock()\n\treturn q.underlyer.Enumerate(cancel)\n}"
        ],
        [
            "func (q *Queue) IsEmpty() bool {\n\tq.key.RLock()\n\tdefer q.key.RUnlock()\n\treturn q.underlyer == nil || q.underlyer.IsEmpty()\n}"
        ],
        [
            "func (q *Queue) Length() uint {\n\tq.key.RLock()\n\tdefer q.key.RUnlock()\n\tif nil == q.underlyer {\n\t\treturn 0\n\t}\n\treturn q.underlyer.length\n}"
        ],
        [
            "func (q *Queue) Next() (interface{}, bool) {\n\tq.key.Lock()\n\tdefer q.key.Unlock()\n\tif q.underlyer == nil {\n\t\treturn nil, false\n\t}\n\treturn q.underlyer.RemoveFront()\n}"
        ],
        [
            "func (q *Queue) Peek() (interface{}, bool) {\n\tq.key.RLock()\n\tdefer q.key.RUnlock()\n\tif q.underlyer == nil {\n\t\treturn nil, false\n\t}\n\treturn q.underlyer.PeekFront()\n}"
        ],
        [
            "func (q *Queue) ToSlice() []interface{} {\n\tq.key.RLock()\n\tdefer q.key.RUnlock()\n\n\tif q.underlyer == nil {\n\t\treturn []interface{}{}\n\t}\n\treturn q.underlyer.ToSlice()\n}"
        ],
        [
            "func EnableVirtualTerminalProcessing(fd int) error {\n\tvar st uint32\n\terr := windows.GetConsoleMode(windows.Handle(fd), &st)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif st&windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING == 0 {\n\t\treturn windows.SetConsoleMode(windows.Handle(fd), st|windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING)\n\t}\n\treturn nil\n}"
        ],
        [
            "func unquote(input []byte, buf []byte) (unquoted []byte, remainder []byte) {\n\tvar (\n\t\terrorIndicator = []byte(\"???\")\n\t)\n\tif len(input) < 2 {\n\t\treturn errorIndicator, buf\n\n\t}\n\tquote := input[0]\n\tinput = input[1:]\n\tif input[len(input)-1] == quote {\n\t\tinput = input[:len(input)-1]\n\t}\n\tindex := bytes.IndexRune(input, '\\\\')\n\tif index < 0 {\n\t\t// input does not contain any escaped chars\n\t\tremainder = buf\n\t\tunquoted = input\n\t\treturn unquoted, remainder\n\t}\n\tif len(buf) > 0 {\n\t\tunquoted = buf[:0]\n\t}\n\tstrinput := toString(input)\n\tfor len(strinput) > 0 {\n\t\tr, mb, tail, err := strconv.UnquoteChar(strinput, quote)\n\t\tif err != nil {\n\t\t\treturn errorIndicator, buf\n\t\t}\n\t\tstrinput = tail\n\t\tif mb {\n\t\t\t// ensure that there is enough room for the multibyte char\n\t\t\truneLen := utf8.RuneLen(r)\n\t\t\tunquotedLen := len(unquoted)\n\t\t\tfor i := 0; i < runeLen; i++ {\n\t\t\t\tunquoted = append(unquoted, 0)\n\t\t\t}\n\t\t\tutf8.EncodeRune(unquoted[unquotedLen:], r)\n\t\t} else {\n\t\t\tunquoted = append(unquoted, byte(r))\n\t\t}\n\t}\n\n\tif len(buf) < len(unquoted) {\n\t\t// used buf up and resorted to memory allocation\n\t\tremainder = nil\n\t} else {\n\t\tremainder = buf[len(unquoted):]\n\t}\n\n\treturn unquoted, remainder\n}"
        ],
        [
            "func countScalars(input []interface{}) int {\n\tfor i := 0; i < len(input); i++ {\n\t\tswitch input[i].(type) {\n\t\tcase keyvalser:\n\t\t\treturn i\n\t\t}\n\t}\n\treturn len(input)\n}"
        ],
        [
            "func IsTerminal(writer io.Writer) bool {\n\tif fd, ok := fileDescriptor(writer); ok {\n\t\treturn terminal.IsTerminal(fd)\n\t}\n\treturn false\n}"
        ],
        [
            "func (l *List) Add(entries ...interface{}) {\n\tl.key.Lock()\n\tdefer l.key.Unlock()\n\tl.underlyer = append(l.underlyer, entries...)\n}"
        ],
        [
            "func (l *List) AddAt(pos uint, entries ...interface{}) {\n\tl.key.Lock()\n\tdefer l.key.Unlock()\n\n\tl.underlyer = append(l.underlyer[:pos], append(entries, l.underlyer[pos:]...)...)\n}"
        ],
        [
            "func (l *List) Enumerate(cancel <-chan struct{}) Enumerator {\n\tretval := make(chan interface{})\n\n\tgo func() {\n\t\tl.key.RLock()\n\t\tdefer l.key.RUnlock()\n\t\tdefer close(retval)\n\n\t\tfor _, entry := range l.underlyer {\n\t\t\tselect {\n\t\t\tcase retval <- entry:\n\t\t\t\tbreak\n\t\t\tcase <-cancel:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn retval\n}"
        ],
        [
            "func (l *List) Get(pos uint) (interface{}, bool) {\n\tl.key.RLock()\n\tdefer l.key.RUnlock()\n\n\tif pos > uint(len(l.underlyer)) {\n\t\treturn nil, false\n\t}\n\treturn l.underlyer[pos], true\n}"
        ],
        [
            "func (l *List) IsEmpty() bool {\n\tl.key.RLock()\n\tdefer l.key.RUnlock()\n\treturn 0 == len(l.underlyer)\n}"
        ],
        [
            "func (l *List) Length() uint {\n\tl.key.RLock()\n\tdefer l.key.RUnlock()\n\treturn uint(len(l.underlyer))\n}"
        ],
        [
            "func (l *List) Remove(pos uint) (interface{}, bool) {\n\tl.key.Lock()\n\tdefer l.key.Unlock()\n\n\tif pos > uint(len(l.underlyer)) {\n\t\treturn nil, false\n\t}\n\tretval := l.underlyer[pos]\n\tl.underlyer = append(l.underlyer[:pos], l.underlyer[pos+1:]...)\n\treturn retval, true\n}"
        ],
        [
            "func (l *List) Set(pos uint, val interface{}) bool {\n\tl.key.Lock()\n\tdefer l.key.Unlock()\n\tvar retval bool\n\tcount := uint(len(l.underlyer))\n\tif pos > count {\n\t\tretval = false\n\t} else {\n\t\tl.underlyer[pos] = val\n\t\tretval = true\n\t}\n\treturn retval\n}"
        ],
        [
            "func (l *List) String() string {\n\tl.key.RLock()\n\tdefer l.key.RUnlock()\n\n\tbuilder := bytes.NewBufferString(\"[\")\n\n\tfor i, entry := range l.underlyer {\n\t\tif i >= 15 {\n\t\t\tbuilder.WriteString(\"... \")\n\t\t\tbreak\n\t\t}\n\t\tbuilder.WriteString(fmt.Sprintf(\"%v \", entry))\n\t}\n\tbuilder.Truncate(builder.Len() - 1)\n\tbuilder.WriteRune(']')\n\treturn builder.String()\n}"
        ],
        [
            "func (l *List) Swap(x, y uint) bool {\n\tl.key.Lock()\n\tdefer l.key.Unlock()\n\treturn l.swap(x, y)\n}"
        ],
        [
            "func (l List) MarshalText() (text []byte, err error) {\n\tvar buf bytes.Buffer\n\tl.writeToBuffer(&buf)\n\treturn buf.Bytes(), nil\n}"
        ],
        [
            "func (l *List) UnmarshalText(text []byte) error {\n\tm := parse.Bytes(text)\n\tdefer m.Release()\n\tcapacity := len(m.List)\n\tif len(m.Text) == 0 {\n\t\tcapacity += 2\n\t}\n\tlist := make(List, 0, capacity)\n\n\tif len(m.Text) > 0 {\n\t\tlist = append(list, \"msg\", string(m.Text))\n\t}\n\tfor _, v := range m.List {\n\t\tlist = append(list, string(v))\n\t}\n\t*l = list\n\treturn nil\n}"
        ],
        [
            "func repl(match string, t time.Time) string {\n\tif match == \"%%\" {\n\t\treturn \"%\"\n\t}\n\n\tformatFunc, ok := formats[match]\n\tif ok {\n\t\treturn formatFunc(t)\n\t}\n\treturn formatNanoForMatch(match, t)\n}"
        ],
        [
            "func Format(format string, t time.Time) string {\n\tfn := func(match string) string {\n\t\treturn repl(match, t)\n\t}\n\treturn fmtRe.ReplaceAllStringFunc(format, fn)\n}"
        ],
        [
            "func logName(logger, tag string, t time.Time) (name, link string) {\n\tname = fmt.Sprintf(\"%s.%s.%s.log.%s.%s.%04d%02d%02d-%02d%02d%02d.%d\",\n\t\tprogram,\n\t\thost,\n\t\tuserName,\n\t\tlogger,\n\t\ttag,\n\t\tt.Year(),\n\t\tt.Month(),\n\t\tt.Day(),\n\t\tt.Hour(),\n\t\tt.Minute(),\n\t\tt.Second(),\n\t\tpid)\n\treturn name, program + \".\" + tag\n}"
        ],
        [
            "func Monotonic() time.Duration {\n\tsec, nsec := monotime()\n\treturn time.Duration(sec*1000000000 + int64(nsec))\n}"
        ],
        [
            "func (s *Severity) set(val Severity) {\n\tatomic.StoreInt32((*int32)(s), int32(val))\n}"
        ],
        [
            "func (s *Severity) Set(value string) error {\n\tvar threshold Severity\n\t// Is it a known name?\n\tif v, ok := severityByName(value); ok {\n\t\tthreshold = v\n\t} else {\n\t\tv, err := strconv.Atoi(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthreshold = Severity(v)\n\t}\n\t*s = threshold\n\treturn nil\n}"
        ],
        [
            "func (l *Level) set(val Level) {\n\tatomic.StoreInt32((*int32)(l), int32(val))\n}"
        ],
        [
            "func (m *modulePat) match(file string) bool {\n\tif m.literal {\n\t\treturn file == m.pattern\n\t}\n\tmatch, _ := filepath.Match(m.pattern, file)\n\treturn match\n}"
        ],
        [
            "func (f *filepathPat) match(path string) bool {\n\treturn f.regexp.MatchString(path)\n}"
        ],
        [
            "func (t *TraceLocation) match(file string, line int) bool {\n\tif t.line != line {\n\t\treturn false\n\t}\n\tif i := strings.LastIndex(file, \"/\"); i >= 0 {\n\t\tfile = file[i+1:]\n\t}\n\treturn t.file == file\n}"
        ],
        [
            "func NewLogger(name string, skip int) *Log {\n\tlogging := &Log{stats: new(Stats)}\n\tlogging.setVState(0, nil, nil, false)\n\tlogging.skip = 2 + skip\n\tlogging.maxStackBufSize = 4096 * 1024\n\tlogging.name = name\n\n\t// Default stderrThreshold is ERROR.\n\tlogging.stderrThreshold = ErrorLog\n\tlogging.setVState(0, nil, nil, false)\n\n\tlogging.severityStats[InfoLog] = &logging.stats.Info\n\tlogging.severityStats[WarningLog] = &logging.stats.Warning\n\tlogging.severityStats[ErrorLog] = &logging.stats.Error\n\n\tlogging.logDirs = append(logging.logDirs, os.TempDir())\n\tgo logging.flushDaemon()\n\treturn logging\n}"
        ],
        [
            "func (l *Log) SetLogDir(logDir string) {\n\tif logDir != \"\" {\n\t\tl.mu.Lock()\n\t\tdefer l.mu.Unlock()\n\t\tl.logDirs = append([]string{logDir}, l.logDirs...)\n\t}\n}"
        ],
        [
            "func (l *Log) SetLogToStderr(f bool) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.toStderr = f\n\n}"
        ],
        [
            "func (l *Log) SetAlsoLogToStderr(f bool) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.alsoToStderr = f\n\n}"
        ],
        [
            "func (l *Log) setVState(verbosity Level, modules []modulePat, filepaths []filepathPat, setFilter bool) {\n\t// Turn verbosity off so V will not fire while we are in transition.\n\tl.verbosity.set(0)\n\t// Ditto for filter length.\n\tatomic.StoreInt32(&l.filterLength, 0)\n\n\t// Set the new filters and wipe the pc->Level map if the filter has changed.\n\tnfilters := 0\n\tif setFilter {\n\t\tif modules != nil {\n\t\t\tl.vmodule.filter = modules\n\t\t}\n\t\tif filepaths != nil {\n\t\t\tl.vfilepath.filter = filepaths\n\t\t}\n\t\tnfilters = len(l.vmodule.filter) + len(l.vfilepath.filter)\n\t\tl.vmap = make(map[uintptr]Level)\n\t}\n\n\t// Things are consistent now, so enable filtering and verbosity.\n\t// They are enabled in order opposite to that in V.\n\tatomic.StoreInt32(&l.filterLength, int32(nfilters))\n\tl.verbosity.set(verbosity)\n}"
        ],
        [
            "func (l *Log) getBuffer() *buffer {\n\tl.freeListMu.Lock()\n\tb := l.freeList\n\tif b != nil {\n\t\tl.freeList = b.next\n\t}\n\tl.freeListMu.Unlock()\n\tif b == nil {\n\t\tb = new(buffer)\n\t} else {\n\t\tb.next = nil\n\t\tb.Reset()\n\t}\n\treturn b\n}"
        ],
        [
            "func (l *Log) putBuffer(b *buffer) {\n\tif b.Len() >= 256 {\n\t\t// Let big buffers die a natural death.\n\t\treturn\n\t}\n\tl.freeListMu.Lock()\n\tb.next = l.freeList\n\tl.freeList = b\n\tl.freeListMu.Unlock()\n}"
        ],
        [
            "func (l *Log) output(s Severity, buf *buffer, file string, line int) {\n\tl.mu.Lock()\n\tif l.traceLocation.isSet() {\n\t\tif l.traceLocation.match(file, line) {\n\t\t\tbuf.Write(stacks(false, l.maxStackBufSize))\n\t\t}\n\t}\n\tdata := buf.Bytes()\n\tif l.toStderr {\n\t\tos.Stderr.Write(data)\n\t} else {\n\t\tif l.alsoToStderr || s >= l.stderrThreshold.get() {\n\t\t\tos.Stderr.Write(data)\n\t\t}\n\t\tif l.file[s] == nil {\n\t\t\tif err := l.createFiles(s); err != nil {\n\t\t\t\tos.Stderr.Write(data) // Make sure the message appears somewhere.\n\t\t\t\tl.exit(err)\n\t\t\t}\n\t\t}\n\t\tswitch s {\n\t\tcase FatalLog:\n\t\t\tl.file[FatalLog].Write(data)\n\t\t\tfallthrough\n\t\tcase ErrorLog:\n\t\t\tl.file[ErrorLog].Write(data)\n\t\t\tfallthrough\n\t\tcase WarningLog:\n\t\t\tl.file[WarningLog].Write(data)\n\t\t\tfallthrough\n\t\tcase InfoLog:\n\t\t\tl.file[InfoLog].Write(data)\n\t\t}\n\t}\n\tif s == FatalLog {\n\t\t// Make sure we see the trace for the current goroutine on standard error.\n\t\tif !l.toStderr {\n\t\t\tos.Stderr.Write(stacks(false, l.maxStackBufSize))\n\t\t}\n\t\t// Write the stack trace for all goroutines to the files.\n\t\ttrace := stacks(true, l.maxStackBufSize)\n\t\tlogExitFunc = func(error) {} // If we get a write error, we'll still exit below.\n\t\tfor log := FatalLog; log >= InfoLog; log-- {\n\t\t\tif f := l.file[log]; f != nil { // Can be nil if -logtostderr is set.\n\t\t\t\tf.Write(trace)\n\t\t\t}\n\t\t}\n\t\tl.mu.Unlock()\n\t\ttimeoutFlush(l, 10*time.Second)\n\t\tos.Exit(255) // C++ uses -1, which is silly because it's anded with 255 anyway.\n\t}\n\tl.putBuffer(buf)\n\tl.mu.Unlock()\n\tif stats := l.severityStats[s]; stats != nil {\n\t\tatomic.AddInt64(&stats.lines, 1)\n\t\tatomic.AddInt64(&stats.bytes, int64(len(data)))\n\t}\n}"
        ],
        [
            "func timeoutFlush(l *Log, timeout time.Duration) {\n\tdone := make(chan bool, 1)\n\tgo func() {\n\t\tl.lockAndFlushAll()\n\t\tdone <- true\n\t}()\n\tselect {\n\tcase <-done:\n\tcase <-time.After(timeout):\n\t\tfmt.Fprintln(os.Stderr, \"glog: Flush took longer than\", timeout)\n\t}\n}"
        ],
        [
            "func stacks(all bool, max int) []byte {\n\t// We don't know how big the traces are, so grow a few times if they don't fit. Start large, though.\n\tn := initialMaxStackBufSize\n\tvar trace []byte\n\tfor n <= max {\n\t\ttrace = make([]byte, n)\n\t\tnbytes := runtime.Stack(trace, all)\n\t\tif nbytes < len(trace) {\n\t\t\treturn trace[:nbytes]\n\t\t}\n\t\tn *= 2\n\t}\n\treturn trace\n}"
        ],
        [
            "func (l *Log) exit(err error) {\n\tfmt.Fprintf(os.Stderr, \"log: exiting because of error: %s\\n\", err)\n\t// If logExitFunc is set, we do that instead of exiting.\n\tif logExitFunc != nil {\n\t\tlogExitFunc(err)\n\t\treturn\n\t}\n\tl.flushAll()\n\tos.Exit(2)\n}"
        ],
        [
            "func (sb *syncBuffer) rotateFile(now time.Time) error {\n\tif sb.file != nil {\n\t\tsb.Flush()\n\t\tsb.file.Close()\n\t}\n\tvar err error\n\tsb.file, _, err = sb.logger.create(severityName[sb.sev], now)\n\tsb.nbytes = 0\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsb.Writer = bufio.NewWriterSize(sb.file, bufferSize)\n\n\t// Write header.\n\tvar buf bytes.Buffer\n\tfmt.Fprintf(&buf, \"Log file created at: %s\\n\", now.Format(\"2006/01/02 15:04:05\"))\n\tfmt.Fprintf(&buf, \"Running on machine: %s\\n\", host)\n\tfmt.Fprintf(&buf, \"Binary: Built with %s %s for %s/%s\\n\", runtime.Compiler, runtime.Version(), runtime.GOOS, runtime.GOARCH)\n\tfmt.Fprintf(&buf, \"Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg\\n\")\n\tn, err := sb.file.Write(buf.Bytes())\n\tsb.nbytes += uint64(n)\n\treturn err\n}"
        ],
        [
            "func (l *Log) createFiles(sev Severity) error {\n\tnow := time.Now()\n\t// Files are created in decreasing severity order, so as soon as we find one\n\t// has already been created, we can stop.\n\tfor s := sev; s >= InfoLog && l.file[s] == nil; s-- {\n\t\tw, err := newFlushSyncWriter(l, s, now)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tl.file[s] = w\n\t}\n\treturn nil\n}"
        ],
        [
            "func (l *Log) flushDaemon() {\n\tfor _ = range time.NewTicker(flushInterval).C {\n\t\tl.lockAndFlushAll()\n\t}\n}"
        ],
        [
            "func (l *Log) lockAndFlushAll() {\n\tl.mu.Lock()\n\tl.flushAll()\n\tl.mu.Unlock()\n}"
        ],
        [
            "func (l *Log) flushAll() {\n\t// Flush from fatal down, in case there's trouble flushing.\n\tfor s := FatalLog; s >= InfoLog; s-- {\n\t\tfile := l.file[s]\n\t\tif file != nil {\n\t\t\tfile.Flush() // ignore error\n\t\t\tfile.Sync()  // ignore error\n\t\t}\n\t}\n}"
        ],
        [
            "func (b *Bundle) Add(f func(context.Context) error) {\n\tb.waitGroup.Add(1)\n\n\t// Run the function in the background.\n\tgo func() {\n\t\tdefer b.waitGroup.Done()\n\n\t\terr := f(b.context)\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\n\t\t// On first error, cancel the context and save the error.\n\t\tb.errorOnce.Do(func() {\n\t\t\tb.firstError = err\n\t\t\tb.cancel()\n\t\t})\n\t}()\n}"
        ],
        [
            "func (b *Bundle) Join() error {\n\tb.waitGroup.Wait()\n\n\t// context.WithCancel requires that we arrange for this to be called\n\t// eventually in order to avoid leaking resources. Since everything is done,\n\t// to do so now is harmless.\n\tb.cancel()\n\n\treturn b.firstError\n}"
        ],
        [
            "func NewBundle(parent context.Context) *Bundle {\n\tb := &Bundle{}\n\tb.context, b.cancel = context.WithCancel(parent)\n\n\treturn b\n}"
        ],
        [
            "func (tokens Tokens) Expand() (result Tokens, err error) {\n\tvar updated bool\n\tfor i := 0; i < len(tokens); i++ {\n\t\tvar start int\n\t\tquote := Token{symbolToken, \":\"}\n\t\tif *tokens[i] != quote {\n\t\t\tresult = append(result, tokens[i])\n\t\t} else {\n\t\t\tupdated = true\n\t\t\tfor start = i + 1; *tokens[start] == quote; start++ {\n\t\t\t\tresult = append(result, tokens[start])\n\t\t\t}\n\t\t\tif tokens[i+1].typ == openToken {\n\t\t\t\tif i, err = tokens.findClose(start + 1); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ti = start\n\t\t\t}\n\t\t\tresult = append(result, &Token{openToken, \"(\"}, &Token{symbolToken, \"quote\"})\n\t\t\tresult = append(result, tokens[start:i+1]...)\n\t\t\tresult = append(result, &Token{closeToken, \")\"})\n\t\t}\n\t}\n\tif updated {\n\t\tresult, err = result.Expand()\n\t}\n\treturn\n}"
        ],
        [
            "func CacheFunc(bodyHandler func(http.ResponseWriter, *http.Request), expiration time.Duration) http.HandlerFunc {\n\treturn Cache(http.HandlerFunc(bodyHandler), expiration).ServeHTTP\n}"
        ],
        [
            "func CacheFasthttp(bodyHandler fasthttp.RequestHandler, expiration time.Duration) *fhttp.Handler {\n\treturn fhttp.NewHandler(bodyHandler, expiration)\n}"
        ],
        [
            "func CacheFasthttpFunc(bodyHandler fasthttp.RequestHandler, expiration time.Duration) fasthttp.RequestHandler {\n\treturn CacheFasthttp(bodyHandler, expiration).ServeHTTP\n}"
        ],
        [
            "func (r *Response) ContentType() string {\n\tif r.contentType == \"\" {\n\t\tr.contentType = \"text/html; charset=utf-8\"\n\t}\n\treturn r.contentType\n}"
        ],
        [
            "func (s *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// println(\"Request to the remote service has been established\")\n\tkey := getURLParam(r, cfg.QueryCacheKey)\n\tif key == \"\" {\n\t\t// println(\"return because key was empty\")\n\t\tw.WriteHeader(cfg.FailStatus)\n\t\treturn\n\t}\n\n\t// we always need the Entry, so get it now\n\tentry := s.store.Get(key)\n\n\tif entry == nil && r.Method != methodPost {\n\t\t// if it's nil then means it never setted before\n\t\t// it doesn't exists, and client doesn't wants to\n\t\t// add a cache entry, so just return\n\t\t//\n\t\t// no delete action is valid\n\t\t// no get action is valid\n\t\t// no post action is requested\n\t\tw.WriteHeader(cfg.FailStatus)\n\t\treturn\n\t}\n\n\tswitch r.Method {\n\tcase methodGet:\n\t\t{\n\t\t\t// get from the cache and send to client\n\t\t\tres, ok := entry.Response()\n\t\t\tif !ok {\n\t\t\t\t// entry exists but it has been expired\n\t\t\t\t// return\n\t\t\t\tw.WriteHeader(cfg.FailStatus)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// entry exists and response is valid\n\t\t\t// send it to the client\n\t\t\tw.Header().Set(cfg.ContentTypeHeader, res.ContentType())\n\t\t\tw.WriteHeader(res.StatusCode())\n\t\t\tw.Write(res.Body())\n\t\t}\n\tcase methodPost:\n\t\t{\n\t\t\t// save a new cache entry if entry ==nil or\n\t\t\t// update an existing if entry !=nil\n\n\t\t\tbody, err := ioutil.ReadAll(r.Body)\n\t\t\tif err != nil || len(body) == 0 {\n\t\t\t\t// println(\"body's request was empty, return fail\")\n\t\t\t\tw.WriteHeader(cfg.FailStatus)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tstatusCode, _ := getURLParamInt(r, cfg.QueryCacheStatusCode)\n\t\t\tcontentType := getURLParam(r, cfg.QueryCacheContentType)\n\n\t\t\t// now that we have the information\n\t\t\t// we want to see if this is a totally new cache entry\n\t\t\t// or just update an existing one with the new information\n\t\t\t// (an update can change the status code, content type\n\t\t\t//     and ofcourse the body and expiration time by header)\n\n\t\t\tif entry == nil {\n\t\t\t\t// get the information by its url\n\t\t\t\t// println(\"we have a post request method, let's save a cached entry \")\n\t\t\t\t// get the cache expiration via url param\n\t\t\t\texpirationSeconds, err := getURLParamInt64(r, cfg.QueryCacheDuration)\n\t\t\t\t// get the body from the requested body\n\t\t\t\t// get the expiration from the \"cache-control's maxage\" if no url param is setted\n\t\t\t\tif expirationSeconds <= 0 || err != nil {\n\t\t\t\t\texpirationSeconds = int64(nethttp.GetMaxAge(r)().Seconds())\n\t\t\t\t}\n\t\t\t\t// if not setted then try to get it via\n\t\t\t\tif expirationSeconds <= 0 {\n\t\t\t\t\texpirationSeconds = int64(cfg.MinimumCacheDuration.Seconds())\n\t\t\t\t}\n\n\t\t\t\tcacheDuration := time.Duration(expirationSeconds) * time.Second\n\n\t\t\t\t// store by its url+the key in order to be unique key among different servers with the same paths\n\t\t\t\ts.store.Set(key, statusCode, contentType, body, cacheDuration)\n\t\t\t} else {\n\t\t\t\t// update an existing one and change its duration  based on the header\n\t\t\t\t// (if > existing duration)\n\t\t\t\tentry.Reset(statusCode, contentType, body, nethttp.GetMaxAge(r))\n\t\t\t}\n\n\t\t\tw.WriteHeader(cfg.SuccessStatus)\n\t\t}\n\tcase methodDelete:\n\t\t{\n\t\t\t// remove the entry entirely from the cache\n\t\t\t// manually DELETE cache should remove this entirely\n\t\t\t// no just invalidate it\n\t\t\ts.store.Remove(key)\n\t\t\tw.WriteHeader(cfg.SuccessStatus)\n\t\t}\n\tdefault:\n\t\tw.WriteHeader(cfg.FailStatus)\n\t}\n\n}"
        ],
        [
            "func New(addr string, store Store) *http.Server {\n\tif store == nil {\n\t\tstore = NewMemoryStore()\n\t}\n\th := &Handler{store: store}\n\treturn &http.Server{\n\t\tAddr:    addr,\n\t\tHandler: h,\n\t}\n}"
        ],
        [
            "func AcquireResponseRecorder(underline http.ResponseWriter) *ResponseRecorder {\n\tv := rpool.Get()\n\tvar res *ResponseRecorder\n\tif v != nil {\n\t\tres = v.(*ResponseRecorder)\n\t} else {\n\t\tres = &ResponseRecorder{}\n\t}\n\tres.underline = underline\n\treturn res\n}"
        ],
        [
            "func ReleaseResponseRecorder(res *ResponseRecorder) {\n\tres.underline = nil\n\tres.statusCode = 0\n\tres.chunks = res.chunks[0:0]\n\trpool.Put(res)\n}"
        ],
        [
            "func (v *validatorRule) Claim(r *http.Request) bool {\n\t// check for pre-cache validators, if at least one of them return false\n\t// for this specific request, then skip the whole cache\n\tfor _, shouldProcess := range v.preValidators {\n\t\tif !shouldProcess(r) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
        ],
        [
            "func (h *Handler) Rule(r rule.Rule) *Handler {\n\tif r == nil {\n\t\t// if nothing passed then use the allow-everyting rule\n\t\tr = rule.Satisfied()\n\t}\n\th.rule = r\n\n\treturn h\n}"
        ],
        [
            "func (e *Entry) Reset(statusCode int, contentType string,\n\tbody []byte, lifeChanger LifeChanger) {\n\n\tif e.response == nil {\n\t\te.response = &Response{}\n\t}\n\tif statusCode > 0 {\n\t\te.response.statusCode = statusCode\n\t}\n\n\tif contentType != \"\" {\n\t\te.response.contentType = contentType\n\t}\n\n\te.response.body = body\n\t// check if a given life changer provided\n\t// and if it does then execute the change life time\n\tif lifeChanger != nil {\n\t\te.ChangeLifetime(lifeChanger)\n\t}\n\te.expiresAt = time.Now().Add(e.life)\n}"
        ],
        [
            "func NoCache(reqCtx *fasthttp.RequestCtx) {\n\treqCtx.Response.Header.Set(cfg.NoCacheHeader, \"true\")\n}"
        ],
        [
            "func clientOAuth(tokens *oauthTokens) *clientOAuthAuthentication {\n\ta := clientOAuthAuthentication{\n\t\tTokens:  tokens,\n\t\tBaseUrl: config.BaseUrl,\n\t\tClient: http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tDial: dialTimeout,\n\t\t\t},\n\t\t},\n\t}\n\treturn &a\n}"
        ],
        [
            "func (a clientOAuthAuthentication) authenticate(req *http.Request, endpoint string, params []byte) error {\n\t// Ensure tokens havent expired\n\tif time.Now().UTC().Unix() > a.Tokens.ExpireTime {\n\t\treturn errors.New(\"The OAuth tokens are expired. Use refreshTokens to refresh them\")\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+a.Tokens.AccessToken)\n\treturn nil\n}"
        ],
        [
            "func apiKeyAuth(key string, secret string) *apiKeyAuthentication {\n\ta := apiKeyAuthentication{\n\t\tKey:     key,\n\t\tSecret:  secret,\n\t\tBaseUrl: config.BaseUrl,\n\t\tClient: http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tDial: dialTimeout,\n\t\t\t},\n\t\t},\n\t}\n\treturn &a\n}"
        ],
        [
            "func (a apiKeyAuthentication) authenticate(req *http.Request, endpoint string, params []byte) error {\n\n\tnonce := strconv.FormatInt(time.Now().UTC().UnixNano(), 10)\n\tmessage := nonce + endpoint + string(params) //As per Coinbase Documentation\n\n\treq.Header.Set(\"ACCESS_KEY\", a.Key)\n\n\th := hmac.New(sha256.New, []byte(a.Secret))\n\th.Write([]byte(message))\n\n\tsignature := hex.EncodeToString(h.Sum(nil))\n\n\treq.Header.Set(\"ACCESS_SIGNATURE\", signature)\n\treq.Header.Set(\"ACCESS_NONCE\", nonce)\n\n\treturn nil\n}"
        ],
        [
            "func serviceOAuth(certFilePath string) (*serviceOAuthAuthentication, error) {\n\t// First we read the cert\n\tcerts := x509.NewCertPool()\n\tpemData, err := ioutil.ReadFile(certFilePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcerts.AppendCertsFromPEM(pemData)\n\tmTLSConfig := &tls.Config{\n\t\tRootCAs: certs, //Add the cert as a TLS config\n\t}\n\ta := serviceOAuthAuthentication{\n\t\tBaseUrl: \"https://coinbase.com/\",\n\t\tClient: http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tDial:            dialTimeout,\n\t\t\t\tTLSClientConfig: mTLSConfig,\n\t\t\t},\n\t\t},\n\t}\n\treturn &a, nil\n}"
        ],
        [
            "func (a serviceOAuthAuthentication) authenticate(req *http.Request, endpoint string, params []byte) error {\n\treturn nil // No additional headers needed for service OAuth requests\n}"
        ],
        [
            "func OAuthService(clientId string, clientSecret string, redirectUri string) (*OAuth, error) {\n\tcertFilePath := basePath + \"/ca-coinbase.crt\"\n\tserviceAuth, err := serviceOAuth(certFilePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\to := OAuth{\n\t\tClientId:     clientId,\n\t\tClientSecret: clientSecret,\n\t\tRedirectUri:  redirectUri,\n\t\tRpc: rpc{\n\t\t\tauth: serviceAuth,\n\t\t\tmock: false,\n\t\t},\n\t}\n\treturn &o, nil\n}"
        ],
        [
            "func (o OAuth) CreateAuthorizeUrl(scope []string) string {\n\tUrl, _ := url.Parse(\"https://coinbase.com\")\n\tUrl.Path += \"/oauth/authorize\"\n\n\tparameters := url.Values{}\n\tparameters.Add(\"response_type\", \"code\")\n\tparameters.Add(\"client_id\", o.ClientId)\n\tparameters.Add(\"redirect_uri\", o.RedirectUri)\n\tparameters.Add(\"scope\", strings.Join(scope, \" \"))\n\tUrl.RawQuery = parameters.Encode()\n\n\treturn Url.String()\n}"
        ],
        [
            "func (o OAuth) RefreshTokens(oldTokens map[string]interface{}) (*oauthTokens, error) {\n\trefresh_token := oldTokens[\"refresh_token\"].(string)\n\treturn o.GetTokens(refresh_token, \"refresh_token\")\n}"
        ],
        [
            "func (o OAuth) NewTokens(code string) (*oauthTokens, error) {\n\treturn o.GetTokens(code, \"authorization_code\")\n}"
        ],
        [
            "func (o OAuth) NewTokensFromRequest(req *http.Request) (*oauthTokens, error) {\n\tquery := req.URL.Query()\n\tcode := query.Get(\"code\")\n\treturn o.GetTokens(code, \"authorization_code\")\n}"
        ],
        [
            "func (r rpc) Request(method string, endpoint string, params interface{}, holder interface{}) error {\n\n\tjsonParams, err := json.Marshal(params)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trequest, err := r.createRequest(method, endpoint, jsonParams)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar data []byte\n\tif r.mock == true { // Mock mode: Replace actual request with expected JSON from file\n\t\tdata, err = r.simulateRequest(endpoint, method)\n\t} else {\n\t\tdata, err = r.executeRequest(request)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := json.Unmarshal(data, &holder); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (r rpc) createRequest(method string, endpoint string, params []byte) (*http.Request, error) {\n\n\tendpoint = r.auth.getBaseUrl() + endpoint //BaseUrl depends on Auth type used\n\n\treq, err := http.NewRequest(method, endpoint, bytes.NewBuffer(params))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Authenticate the request\n\tr.auth.authenticate(req, endpoint, params)\n\n\treq.Header.Set(\"User-Agent\", \"CoinbaseGo/v1\")\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\treturn req, nil\n}"
        ],
        [
            "func (r rpc) executeRequest(req *http.Request) ([]byte, error) {\n\tresp, err := r.auth.getClient().Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tbuf := new(bytes.Buffer)\n\tbuf.ReadFrom(resp.Body)\n\tbytes := buf.Bytes()\n\tif resp.StatusCode != 200 {\n\t\tif len(bytes) == 0 { // Log response body for debugging purposes\n\t\t\tlog.Printf(\"Response body was empty\")\n\t\t} else {\n\t\t\tlog.Printf(\"Response body:\\n\\t%s\\n\", bytes)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"%s %s failed. Response code was %s\", req.Method, req.URL, resp.Status)\n\t}\n\treturn bytes, nil\n}"
        ],
        [
            "func (r rpc) simulateRequest(endpoint string, method string) ([]byte, error) {\n\t// Test files conform to replacing '/' in endpoint with '_'\n\tfileName := strings.Replace(endpoint, \"/\", \"_\", -1)\n\t// file names also have method type prepended to ensure uniqueness\n\tfilePath := basePath + \"/test_data/\" + method + \"_\" + fileName + \".json\"\n\tdata, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}"
        ],
        [
            "func ApiKeyClient(key string, secret string) Client {\n\tc := Client{\n\t\trpc: rpc{\n\t\t\tauth: apiKeyAuth(key, secret),\n\t\t\tmock: false,\n\t\t},\n\t}\n\treturn c\n}"
        ],
        [
            "func OAuthClient(tokens *oauthTokens) Client {\n\tc := Client{\n\t\trpc: rpc{\n\t\t\tauth: clientOAuth(tokens),\n\t\t\tmock: false,\n\t\t},\n\t}\n\treturn c\n}"
        ],
        [
            "func (c Client) Get(path string, params interface{}, holder interface{}) error {\n\treturn c.rpc.Request(\"GET\", path, params, &holder)\n}"
        ],
        [
            "func (c Client) GetBalance() (float64, error) {\n\tbalance := map[string]string{}\n\tif err := c.Get(\"account/balance\", nil, &balance); err != nil {\n\t\treturn 0.0, err\n\t}\n\tbalanceFloat, err := strconv.ParseFloat(balance[\"amount\"], 64)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn balanceFloat, nil\n}"
        ],
        [
            "func (c Client) GetAllAddresses(params *AddressesParams) (*addresses, error) {\n\tholder := addressesHolder{}\n\tif err := c.Get(\"addresses\", params, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\taddresses := addresses{\n\t\tpaginationStats: holder.paginationStats,\n\t}\n\t// Remove one layer of nesting\n\tfor _, addr := range holder.Addresses {\n\t\taddresses.Addresses = append(addresses.Addresses, addr.Address)\n\t}\n\treturn &addresses, nil\n}"
        ],
        [
            "func (c Client) GenerateReceiveAddress(params *AddressParams) (string, error) {\n\tholder := map[string]interface{}{}\n\tif err := c.Post(\"account/generate_receive_address\", params, &holder); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn holder[\"address\"].(string), nil\n}"
        ],
        [
            "func (c Client) SendMoney(params *TransactionParams) (*transactionConfirmation, error) {\n\treturn c.transactionRequest(\"POST\", \"send_money\", params)\n}"
        ],
        [
            "func (c Client) RequestMoney(params *TransactionParams) (*transactionConfirmation, error) {\n\treturn c.transactionRequest(\"POST\", \"request_money\", params)\n}"
        ],
        [
            "func (c Client) ResendRequest(id string) (bool, error) {\n\tholder := map[string]interface{}{}\n\tif err := c.Put(\"transactions/\"+id+\"/resend_request\", nil, &holder); err != nil {\n\t\treturn false, err\n\t}\n\tif holder[\"success\"].(bool) {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}"
        ],
        [
            "func (c Client) CancelRequest(id string) (bool, error) {\n\tholder := map[string]interface{}{}\n\tif err := c.Delete(\"transactions/\"+id+\"/cancel_request\", nil, &holder); err != nil {\n\t\treturn false, err\n\t}\n\tif holder[\"success\"].(bool) {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}"
        ],
        [
            "func (c Client) CompleteRequest(id string) (*transactionConfirmation, error) {\n\treturn c.transactionRequest(\"PUT\", id+\"/complete_request\", nil)\n}"
        ],
        [
            "func (c Client) CreateButton(params *Button) (*Button, error) {\n\tfinalParams := &struct {\n\t\tButton *Button `json:\"button\"`\n\t}{\n\t\tButton: params,\n\t}\n\tholder := buttonHolder{}\n\tif err := c.Post(\"buttons\", finalParams, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := checkApiErrors(holder.response, \"CreateButton\"); err != nil {\n\t\treturn nil, err\n\t}\n\tbutton := holder.Button\n\tbutton.EmbedHtml = \"<div class=\\\"coinbase-button\\\" data-code=\\\"\" + button.Code + \"\\\"></div><script src=\\\"https://coinbase.com/assets/button.js\\\" type=\\\"text/javascript\\\"></script>\"\n\treturn &button, nil\n}"
        ],
        [
            "func (c Client) CreateOrderFromButtonCode(buttonCode string) (*order, error) {\n\tholder := orderHolder{}\n\tif err := c.Post(\"buttons/\"+buttonCode+\"/create_order\", nil, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := checkApiErrors(holder.response, \"CreateOrderFromButtonCode\"); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &holder.Order, nil\n}"
        ],
        [
            "func (c Client) CreateUser(email string, password string) (*user, error) {\n\tparams := map[string]interface{}{\n\t\t\"user[email]\":    email,\n\t\t\"user[password]\": password,\n\t}\n\tholder := userHolder{}\n\tif err := c.Post(\"users\", params, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := checkApiErrors(holder.response, \"CreateUser\"); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &holder.User, nil\n}"
        ],
        [
            "func (c Client) Buy(amount float64, agreeBtcAmountVaries bool) (*transfer, error) {\n\tparams := map[string]interface{}{\n\t\t\"qty\": amount,\n\t\t\"agree_btc_amount_varies\": agreeBtcAmountVaries,\n\t}\n\tholder := transferHolder{}\n\tif err := c.Post(\"buys\", params, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := checkApiErrors(holder.response, \"Buy\"); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &holder.Transfer, nil\n}"
        ],
        [
            "func (c Client) GetContacts(params *ContactsParams) (*contactsHolder, error) {\n\tholder := contactsHolder{}\n\tif err := c.Get(\"contacts\", params, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, contact := range holder.Contacts {\n\t\tif contact.Contact.Email != \"\" {\n\t\t\tholder.Emails = append(holder.Emails, contact.Contact.Email)\n\t\t}\n\t}\n\treturn &holder, nil\n}"
        ],
        [
            "func (c Client) GetCurrencies() ([]currency, error) {\n\tholder := [][]string{}\n\tif err := c.Get(\"currencies\", nil, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\tfinalData := []currency{}\n\tfor _, curr := range holder {\n\t\tclass := currency{\n\t\t\tName: curr[0],\n\t\t\tIso:  curr[1],\n\t\t}\n\t\tfinalData = append(finalData, class)\n\t}\n\treturn finalData, nil\n}"
        ],
        [
            "func (c Client) GetExchangeRates() (map[string]string, error) {\n\tholder := map[string]string{}\n\tif err := c.Get(\"currencies/exchange_rates\", nil, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\treturn holder, nil\n}"
        ],
        [
            "func (c Client) GetExchangeRate(from string, to string) (float64, error) {\n\texchanges, err := c.GetExchangeRates()\n\tif err != nil {\n\t\treturn 0.0, err\n\t}\n\tkey := from + \"_to_\" + to\n\tif exchanges[key] == \"\" {\n\t\treturn 0.0, errors.New(\"The exchange rate does not exist for this currency pair\")\n\t}\n\texchangeFloat, err := strconv.ParseFloat(exchanges[key], 64)\n\tif err != nil {\n\t\treturn 0.0, err\n\t}\n\treturn exchangeFloat, nil\n}"
        ],
        [
            "func (c Client) GetTransactions(page int) (*transactions, error) {\n\tparams := map[string]int{\n\t\t\"page\": page,\n\t}\n\tholder := transactionsHolder{}\n\tif err := c.Get(\"transactions\", params, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\ttransactions := transactions{\n\t\tpaginationStats: holder.paginationStats,\n\t}\n\t// Remove one layer of nesting\n\tfor _, tx := range holder.Transactions {\n\t\ttransactions.Transactions = append(transactions.Transactions, tx.Transaction)\n\t}\n\treturn &transactions, nil\n}"
        ],
        [
            "func (c Client) GetOrders(page int) (*orders, error) {\n\tholder := ordersHolder{}\n\tparams := map[string]int{\n\t\t\"page\": page,\n\t}\n\tif err := c.Get(\"orders\", params, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\torders := orders{\n\t\tpaginationStats: holder.paginationStats,\n\t}\n\t// Remove one layer of nesting\n\tfor _, o := range holder.Orders {\n\t\torders.Orders = append(orders.Orders, o.Order)\n\t}\n\treturn &orders, nil\n}"
        ],
        [
            "func (c Client) GetTransfers(page int) (*transfers, error) {\n\tparams := map[string]int{\n\t\t\"page\": page,\n\t}\n\tholder := transfersHolder{}\n\tif err := c.Get(\"transfers\", params, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\ttransfers := transfers{\n\t\tpaginationStats: holder.paginationStats,\n\t}\n\t// Remove one layer of nesting\n\tfor _, t := range holder.Transfers {\n\t\ttransfers.Transfers = append(transfers.Transfers, t.Transfer)\n\t}\n\treturn &transfers, nil\n}"
        ],
        [
            "func (c Client) GetBuyPrice(qty int) (*pricesHolder, error) {\n\treturn c.getPrice(\"buy\", qty)\n}"
        ],
        [
            "func (c Client) GetSellPrice(qty int) (*pricesHolder, error) {\n\treturn c.getPrice(\"sell\", qty)\n}"
        ],
        [
            "func (c Client) GetTransaction(id string) (*transaction, error) {\n\tholder := transactionHolder{}\n\tif err := c.Get(\"transactions/\"+id, nil, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := checkApiErrors(holder.response, \"GetTransaction\"); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &holder.Transaction, nil\n}"
        ],
        [
            "func (c Client) GetOrder(id string) (*order, error) {\n\tholder := orderHolder{}\n\tif err := c.Get(\"orders/\"+id, nil, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := checkApiErrors(holder.response, \"GetOrder\"); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &holder.Order, nil\n}"
        ],
        [
            "func (c Client) GetUser() (*user, error) {\n\tholder := usersHolder{}\n\tif err := c.Get(\"users\", nil, &holder); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &holder.Users[0].User, nil\n}"
        ],
        [
            "func NewSerialDispatcher(handlers []Handler) Dispatcher {\n\treturn &SerialDispatcher{\n\t\thandlers: handlers,\n\t\tmutex:    sync.RWMutex{},\n\t}\n}"
        ],
        [
            "func (d *SerialDispatcher) AppendHandlers(handlers ...Handler) {\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\nLoop:\n\tfor _, newHandler := range handlers {\n\t\tfor _, existingHandler := range d.handlers {\n\t\t\tif newHandler == existingHandler {\n\t\t\t\tcontinue Loop\n\t\t\t}\n\t\t}\n\t\td.handlers = append(d.handlers, newHandler)\n\t}\n}"
        ],
        [
            "func (d *SerialDispatcher) DispatchOptional(cmd interface{}) (err error) {\n\td.mutex.RLock()\n\tdefer d.mutex.RUnlock()\n\n\terr = d.Dispatch(cmd)\n\tswitch err.(type) {\n\tcase *NoHandlerFoundError:\n\t\treturn nil\n\tdefault:\n\t\treturn err\n\t}\n}"
        ],
        [
            "func NewParallelDispatcher(handlers []Handler) Dispatcher {\n\treturn &ParallelDispatcher{\n\t\thandlers: handlers,\n\t\tmutex:    sync.RWMutex{},\n\t}\n}"
        ],
        [
            "func (c *secureConn) ReleaseMsg(m []byte) {\n\tc.secure.ReadWriter().ReleaseMsg(m)\n}"
        ],
        [
            "func ReleaseBuffer(b []byte) {\n\tlog.Debugf(\"Releasing buffer! (cap,size = %d, %d)\", cap(b), len(b))\n\tmpool.ByteSlicePool.Put(uint32(cap(b)), b)\n}"
        ],
        [
            "func (c *singleConn) Close() error {\n\tc.eventMu.Lock()\n\tif c.event != nil {\n\t\tevt := c.event\n\t\tc.event = nil\n\t\tdefer evt.Close()\n\t}\n\tc.eventMu.Unlock()\n\n\t// close underlying connection\n\treturn c.maconn.Close()\n}"
        ],
        [
            "func (c *singleConn) Write(buf []byte) (int, error) {\n\treturn c.maconn.Write(buf)\n}"
        ],
        [
            "func (l *listener) Accept() (transport.Conn, error) {\n\tif c, ok := <-l.incoming; ok {\n\t\treturn c.conn, c.err\n\t}\n\treturn nil, fmt.Errorf(\"listener is closed\")\n}"
        ],
        [
            "func (d *Dialer) AddDialer(pd transport.Dialer) {\n\td.Dialers = append(d.Dialers, pd)\n}"
        ],
        [
            "func (d *Dialer) subDialerForAddr(raddr ma.Multiaddr) transport.Dialer {\n\tfor _, pd := range d.Dialers {\n\t\tif pd.Matches(raddr) {\n\t\t\treturn pd\n\t\t}\n\t}\n\n\tif d.fallback.Matches(raddr) {\n\t\treturn d.fallback\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (d *Dialer) rawConnDial(ctx context.Context, raddr ma.Multiaddr, remote peer.ID) (transport.Conn, error) {\n\tif strings.HasPrefix(raddr.String(), \"/ip4/0.0.0.0\") {\n\t\tlog.Event(ctx, \"connDialZeroAddr\", lgbl.Dial(\"conn\", d.LocalPeer, remote, nil, raddr))\n\t\treturn nil, fmt.Errorf(\"Attempted to connect to zero address: %s\", raddr)\n\t}\n\n\tsd := d.subDialerForAddr(raddr)\n\tif sd == nil {\n\t\treturn nil, fmt.Errorf(\"no dialer for %s\", raddr)\n\t}\n\n\treturn sd.DialContext(ctx, raddr)\n}"
        ],
        [
            "func MultiaddrProtocolsMatch(a, b ma.Multiaddr) bool {\n\tap := a.Protocols()\n\tbp := b.Protocols()\n\n\tif len(ap) != len(bp) {\n\t\treturn false\n\t}\n\n\tfor i, api := range ap {\n\t\tif api.Code != bp[i].Code {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}"
        ],
        [
            "func MultiaddrNetMatch(tgt ma.Multiaddr, srcs []ma.Multiaddr) ma.Multiaddr {\n\tfor _, a := range srcs {\n\t\tif MultiaddrProtocolsMatch(tgt, a) {\n\t\t\treturn a\n\t\t}\n\t}\n\treturn nil\n}"
        ],
        [
            "func get(values map[string]interface{}, key string) interface{} {\n\tif len(key) == 0 || values == nil {\n\t\treturn nil\n\t}\n\n\tkey = strings.ToLower(key)\n\tval, ok := values[key]\n\n\tif ok {\n\t\tswitch val.(type) {\n\t\tcase []interface{}:\n\t\t\treturn nil\n\t\tdefault:\n\t\t\treturn val\n\t\t}\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func getArray(values map[string]interface{}, key string) []interface{} {\n\tif len(key) == 0 || values == nil {\n\t\treturn nil\n\t}\n\n\tkey = strings.ToLower(key)\n\tval, ok := values[key]\n\n\tif ok {\n\t\tswitch v := val.(type) {\n\t\tcase []interface{}:\n\t\t\treturn v\n\t\tdefault:\n\t\t\tretVal := make([]interface{}, 1)\n\t\t\tretVal[0] = val\n\t\t\treturn retVal\n\t\t}\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func buildParams(options *ImageOptions) ([]string, error) {\n\ta := []string{}\n\n\tif options.Input == \"\" {\n\t\treturn []string{}, errors.New(\"Must provide input\")\n\t}\n\n\t// silence extra wkhtmltoimage output\n\t// might want to add --javascript-delay too?\n\ta = append(a, \"-q\")\n\ta = append(a, \"--disable-plugins\")\n\n\ta = append(a, \"--format\")\n\tif options.Format != \"\" {\n\t\ta = append(a, options.Format)\n\t} else {\n\t\ta = append(a, \"png\")\n\t}\n\n\tif options.Height != 0 {\n\t\ta = append(a, \"--height\")\n\t\ta = append(a, strconv.Itoa(options.Height))\n\t}\n\n\tif options.Width != 0 {\n\t\ta = append(a, \"--width\")\n\t\ta = append(a, strconv.Itoa(options.Width))\n\t}\n\n\tif options.Quality != 0 {\n\t\ta = append(a, \"--quality\")\n\t\ta = append(a, strconv.Itoa(options.Quality))\n\t}\n\n\t// url and output come last\n\tif options.Input != \"-\" {\n\t\t// make sure we dont pass stdin if we aren't expecting it\n\t\toptions.Html = \"\"\n\t}\n\n\ta = append(a, options.Input)\n\n\tif options.Output == \"\" {\n\t\ta = append(a, \"-\")\n\t} else {\n\t\ta = append(a, options.Output)\n\t}\n\n\treturn a, nil\n}"
        ],
        [
            "func unsetenvGPGAgentInfo() {\n\tv := C.CString(\"GPG_AGENT_INFO=\")\n\tdefer C.free(unsafe.Pointer(v))\n\tC.putenv(v)\n}"
        ],
        [
            "func (c *Context) AssuanSend(\n\tcmd string,\n\tdata AssuanDataCallback,\n\tinquiry AssuanInquireCallback,\n\tstatus AssuanStatusCallback,\n) error {\n\tvar operr C.gpgme_error_t\n\n\tdataPtr := callbackAdd(&data)\n\tinquiryPtr := callbackAdd(&inquiry)\n\tstatusPtr := callbackAdd(&status)\n\tcmdCStr := C.CString(cmd)\n\tdefer C.free(unsafe.Pointer(cmdCStr))\n\terr := C.gogpgme_op_assuan_transact_ext(\n\t\tc.ctx,\n\t\tcmdCStr,\n\t\tC.uintptr_t(dataPtr),\n\t\tC.uintptr_t(inquiryPtr),\n\t\tC.uintptr_t(statusPtr),\n\t\t&operr,\n\t)\n\n\tif handleError(operr) != nil {\n\t\treturn handleError(operr)\n\t}\n\treturn handleError(err)\n}"
        ],
        [
            "func NewData() (*Data, error) {\n\td := newData()\n\treturn d, handleError(C.gpgme_data_new(&d.dh))\n}"
        ],
        [
            "func NewDataFile(f *os.File) (*Data, error) {\n\td := newData()\n\treturn d, handleError(C.gpgme_data_new_from_fd(&d.dh, C.int(f.Fd())))\n}"
        ],
        [
            "func NewDataBytes(b []byte) (*Data, error) {\n\td := newData()\n\tvar cb *C.char\n\tif len(b) != 0 {\n\t\tcb = (*C.char)(unsafe.Pointer(&b[0]))\n\t}\n\treturn d, handleError(C.gpgme_data_new_from_mem(&d.dh, cb, C.size_t(len(b)), 1))\n}"
        ],
        [
            "func NewDataReader(r io.Reader) (*Data, error) {\n\td := newData()\n\td.r = r\n\td.cbs.read = C.gpgme_data_read_cb_t(C.gogpgme_readfunc)\n\tcbc := callbackAdd(d)\n\td.cbc = cbc\n\treturn d, handleError(C.gogpgme_data_new_from_cbs(&d.dh, &d.cbs, C.uintptr_t(cbc)))\n}"
        ],
        [
            "func NewDataWriter(w io.Writer) (*Data, error) {\n\td := newData()\n\td.w = w\n\td.cbs.write = C.gpgme_data_write_cb_t(C.gogpgme_writefunc)\n\tcbc := callbackAdd(d)\n\td.cbc = cbc\n\treturn d, handleError(C.gogpgme_data_new_from_cbs(&d.dh, &d.cbs, C.uintptr_t(cbc)))\n}"
        ],
        [
            "func NewDataReadWriter(rw io.ReadWriter) (*Data, error) {\n\td := newData()\n\td.r = rw\n\td.w = rw\n\td.cbs.read = C.gpgme_data_read_cb_t(C.gogpgme_readfunc)\n\td.cbs.write = C.gpgme_data_write_cb_t(C.gogpgme_writefunc)\n\tcbc := callbackAdd(d)\n\td.cbc = cbc\n\treturn d, handleError(C.gogpgme_data_new_from_cbs(&d.dh, &d.cbs, C.uintptr_t(cbc)))\n}"
        ],
        [
            "func NewDataReadWriteSeeker(rw io.ReadWriteSeeker) (*Data, error) {\n\td := newData()\n\td.r = rw\n\td.w = rw\n\td.s = rw\n\td.cbs.read = C.gpgme_data_read_cb_t(C.gogpgme_readfunc)\n\td.cbs.write = C.gpgme_data_write_cb_t(C.gogpgme_writefunc)\n\td.cbs.seek = C.gpgme_data_seek_cb_t(C.gogpgme_seekfunc)\n\tcbc := callbackAdd(d)\n\td.cbc = cbc\n\treturn d, handleError(C.gogpgme_data_new_from_cbs(&d.dh, &d.cbs, C.uintptr_t(cbc)))\n}"
        ],
        [
            "func (d *Data) Close() error {\n\tif d.dh == nil {\n\t\treturn nil\n\t}\n\tif d.cbc > 0 {\n\t\tcallbackDelete(d.cbc)\n\t}\n\t_, err := C.gpgme_data_release(d.dh)\n\td.dh = nil\n\treturn err\n}"
        ],
        [
            "func (d *Data) Name() string {\n\treturn C.GoString(C.gpgme_data_get_file_name(d.dh))\n}"
        ],
        [
            "func NewCommand(name string, args ...string) *Command {\n\treturn &Command{\n\t\tname: name,\n\t\targs: args,\n\t}\n}"
        ],
        [
            "func (c *Command) Arg(v interface{}) *Command {\n\tc.args = append(c.args, fmt.Sprintf(\"%v\", v))\n\treturn c\n}"
        ],
        [
            "func (c Command) String() string {\n\ts := fmt.Sprintf(\"COMMAND [%d] %s\", time.Now().Unix(), c.name)\n\tif len(c.args) > 0 {\n\t\ts += \";\" + strings.Join(c.args, \";\")\n\t}\n\ts += \"\\n\\n\"\n\n\treturn s\n}"
        ],
        [
            "func (r Record) Columns() []string {\n\tcols := []string{}\n\tfor k := range r {\n\t\tcols = append(cols, k)\n\t}\n\tsort.Strings(cols)\n\n\treturn cols\n}"
        ],
        [
            "func (r Record) Get(column string) (interface{}, error) {\n\tv, ok := r[column]\n\tif !ok {\n\t\treturn nil, ErrUnknownColumn\n\t}\n\n\treturn v, nil\n}"
        ],
        [
            "func (r Record) GetBool(column string) (bool, error) {\n\tv, err := r.getKey(reflect.Float64, column)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn v == 1.0, nil\n}"
        ],
        [
            "func (r Record) GetInt(column string) (int64, error) {\n\tv, err := r.getKey(reflect.Float64, column)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn int64(v.(float64)), nil\n}"
        ],
        [
            "func (r Record) GetSlice(column string) ([]interface{}, error) {\n\tv, err := r.getKey(reflect.Slice, column)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trv := reflect.ValueOf(v)\n\tn := rv.Len()\n\tout := make([]interface{}, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tout[i] = rv.Index(i).Interface()\n\t}\n\n\treturn out, nil\n}"
        ],
        [
            "func (r Record) GetString(column string) (string, error) {\n\tv, err := r.getKey(reflect.String, column)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn v.(string), nil\n}"
        ],
        [
            "func (r Record) GetTime(column string) (time.Time, error) {\n\tv, err := r.getKey(reflect.Float64, column)\n\tif err != nil {\n\t\treturn time.Time{}, err\n\t}\n\n\treturn time.Unix(int64(v.(float64)), 0), nil\n}"
        ],
        [
            "func ChangeContactModattr(\n\tcontact_name string,\n\tvalue string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"CHANGE_CONTACT_MODATTR\",\n\t\tstringifyArg(\"contact_name\", \"string\", contact_name),\n\t\tstringifyArg(\"value\", \"string\", value),\n\t)\n}"
        ],
        [
            "func ChangeContactModhattr(\n\tcontact_name string,\n\tvalue string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"CHANGE_CONTACT_MODHATTR\",\n\t\tstringifyArg(\"contact_name\", \"string\", contact_name),\n\t\tstringifyArg(\"value\", \"string\", value),\n\t)\n}"
        ],
        [
            "func ChangeContactModsattr(\n\tcontact_name string,\n\tvalue string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"CHANGE_CONTACT_MODSATTR\",\n\t\tstringifyArg(\"contact_name\", \"string\", contact_name),\n\t\tstringifyArg(\"value\", \"string\", value),\n\t)\n}"
        ],
        [
            "func ChangeCustomContactVar(\n\tcontact_name string,\n\tvarname string,\n\tvarvalue string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"CHANGE_CUSTOM_CONTACT_VAR\",\n\t\tstringifyArg(\"contact_name\", \"string\", contact_name),\n\t\tstringifyArg(\"varname\", \"string\", varname),\n\t\tstringifyArg(\"varvalue\", \"string\", varvalue),\n\t)\n}"
        ],
        [
            "func ChangeCustomHostVar(\n\thost_name string,\n\tvarname string,\n\tvarvalue string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"CHANGE_CUSTOM_HOST_VAR\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"varname\", \"string\", varname),\n\t\tstringifyArg(\"varvalue\", \"string\", varvalue),\n\t)\n}"
        ],
        [
            "func ChangeCustomSvcVar(\n\thost_name string,\n\tservice_description string,\n\tvarname string,\n\tvarvalue string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"CHANGE_CUSTOM_SVC_VAR\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t\tstringifyArg(\"varname\", \"string\", varname),\n\t\tstringifyArg(\"varvalue\", \"string\", varvalue),\n\t)\n}"
        ],
        [
            "func ChangeHostCheckTimeperiod(\n\thost_name string,\n\ttimeperiod string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"CHANGE_HOST_CHECK_TIMEPERIOD\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"timeperiod\", \"string\", timeperiod),\n\t)\n}"
        ],
        [
            "func ChangeHostModattr(\n\thost_name string,\n\tvalue string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"CHANGE_HOST_MODATTR\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"value\", \"string\", value),\n\t)\n}"
        ],
        [
            "func ChangeSvcModattr(\n\thost_name string,\n\tservice_description string,\n\tvalue string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"CHANGE_SVC_MODATTR\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t\tstringifyArg(\"value\", \"string\", value),\n\t)\n}"
        ],
        [
            "func DelAllSvcComments(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"DEL_ALL_SVC_COMMENTS\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func DisablePassiveSvcChecks(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"DISABLE_PASSIVE_SVC_CHECKS\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func DisableServiceFlapDetection(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"DISABLE_SERVICE_FLAP_DETECTION\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func DisableSvcCheck(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"DISABLE_SVC_CHECK\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func DisableSvcEventHandler(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"DISABLE_SVC_EVENT_HANDLER\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func DisableSvcFlapDetection(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"DISABLE_SVC_FLAP_DETECTION\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func DisableSvcNotifications(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"DISABLE_SVC_NOTIFICATIONS\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func EnablePassiveSvcChecks(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"ENABLE_PASSIVE_SVC_CHECKS\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func EnableSvcCheck(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"ENABLE_SVC_CHECK\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func EnableSvcEventHandler(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"ENABLE_SVC_EVENT_HANDLER\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func EnableSvcFlapDetection(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"ENABLE_SVC_FLAP_DETECTION\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func EnableSvcNotifications(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"ENABLE_SVC_NOTIFICATIONS\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func RemoveSvcAcknowledgement(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"REMOVE_SVC_ACKNOWLEDGEMENT\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func StartObsessingOverSvc(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"START_OBSESSING_OVER_SVC\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func StopObsessingOverSvc(\n\thost_name string,\n\tservice_description string,\n) *livestatus.Command {\n\treturn livestatus.NewCommand(\n\t\t\"STOP_OBSESSING_OVER_SVC\",\n\t\tstringifyArg(\"host_name\", \"string\", host_name),\n\t\tstringifyArg(\"service_description\", \"string\", service_description),\n\t)\n}"
        ],
        [
            "func NewQuery(table string) *Query {\n\treturn &Query{\n\t\ttable:   table,\n\t\theaders: []string{},\n\t\tcolumns: []string{},\n\t}\n}"
        ],
        [
            "func (q *Query) Columns(names ...string) *Query {\n\tq.headers = append(q.headers, \"Columns: \"+strings.Join(names, \" \"))\n\tq.columns = names\n\treturn q\n}"
        ],
        [
            "func (q *Query) Filter(rule string) *Query {\n\tq.headers = append(q.headers, \"Filter: \"+rule)\n\treturn q\n}"
        ],
        [
            "func (q *Query) And(n int) *Query {\n\tq.headers = append(q.headers, fmt.Sprintf(\"And: %d\", n))\n\treturn q\n}"
        ],
        [
            "func (q *Query) Negate() *Query {\n\tq.headers = append(q.headers, \"Negate:\")\n\treturn q\n}"
        ],
        [
            "func (q *Query) WaitObject(name string) *Query {\n\tq.headers = append(q.headers, \"WaitObject: \"+name)\n\treturn q\n}"
        ],
        [
            "func (q *Query) WaitCondition(rule string) *Query {\n\tq.headers = append(q.headers, \"WaitCondition: \"+rule)\n\treturn q\n}"
        ],
        [
            "func (q *Query) WaitConditionNegate() *Query {\n\tq.headers = append(q.headers, \"WaitConditionNegate:\")\n\treturn q\n}"
        ],
        [
            "func (q *Query) WaitTrigger(event string) *Query {\n\tq.headers = append(q.headers, \"WaitTrigger: \"+event)\n\treturn q\n}"
        ],
        [
            "func (q *Query) WaitTimeout(d time.Duration) *Query {\n\tq.headers = append(q.headers, fmt.Sprintf(\"WaitTimeout: %d\", d/time.Millisecond))\n\treturn q\n}"
        ],
        [
            "func (q *Query) KeepAlive() *Query {\n\tq.headers = append(q.headers, \"KeepAlive: on\")\n\tq.keepalive = true\n\treturn q\n}"
        ],
        [
            "func (q *Query) ReadTimeout(timeout time.Duration) *Query {\n\tq.readTimeout = timeout\n\treturn q\n}"
        ],
        [
            "func (q Query) String() string {\n\ts := \"GET \" + q.table\n\tif len(q.headers) > 0 {\n\t\ts += \"\\n\" + strings.Join(q.headers, \"\\n\")\n\t}\n\ts += \"\\nResponseHeader: fixed16\\nOutputFormat: json\\n\\n\"\n\n\treturn s\n}"
        ],
        [
            "func NewClient(network, address string) *Client {\n\treturn NewClientWithDialer(network, address, new(net.Dialer))\n}"
        ],
        [
            "func NewClientWithDialer(network, address string, dialer *net.Dialer) *Client {\n\treturn &Client{\n\t\tnetwork: network,\n\t\taddress: address,\n\t\tdialer:  dialer,\n\t}\n}"
        ],
        [
            "func (c *Client) Exec(r Request) (*Response, error) {\n\tvar err error\n\n\t// Initialize connection if none available\n\tif c.conn == nil {\n\t\tc.conn, err = c.dialer.Dial(c.network, c.address)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif r.keepAlive() {\n\t\t\tswitch c.network {\n\t\t\tcase \"tcp\":\n\t\t\t\tc.conn.(*net.TCPConn).SetKeepAlive(true)\n\t\t\t}\n\t\t} else {\n\t\t\tdefer c.Close()\n\t\t}\n\t}\n\n\treturn r.handle(c.conn)\n}"
        ],
        [
            "func xtoi2(s string, e byte) (byte, bool) {\n\tif len(s) > 2 && s[2] != e {\n\t\treturn 0, false\n\t}\n\tn, ei, ok := xtoi(s[:2], 0)\n\treturn byte(n), ok && ei == 2\n}"
        ],
        [
            "func (address HardwareAddr) Mask(mask []byte) []byte {\n\tn := len(address)\n\tif n != len(mask) {\n\t\treturn nil\n\t}\n\tout := make([]byte, n)\n\tfor i := 0; i < n; i++ {\n\t\tout[i] = address[i] & mask[i]\n\t}\n\treturn out\n}"
        ],
        [
            "func New(file string) *OuiDb {\n\tdb := &OuiDb{}\n\tif err := db.Load(file); err != nil {\n\t\treturn nil\n\t}\n\treturn db\n}"
        ],
        [
            "func (m *OuiDb) Lookup(address HardwareAddr) *AddressBlock {\n\tfor _, block := range m.Blocks {\n\t\tif block.Contains(address) {\n\t\t\treturn &block\n\t\t}\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (m *OuiDb) VendorLookup(s string) (string, error) {\n\taddr, err := net.ParseMAC(s)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tblock := m.Lookup(HardwareAddr(addr))\n\tif block == nil {\n\t\treturn \"\", ErrInvalidMACAddress\n\t}\n\treturn block.Organization, nil\n}"
        ],
        [
            "func (b *AddressBlock) Contains(address HardwareAddr) bool {\n\t//fmt.Println(\"%v %v %v %v\", b.Oui, len(b.Oui), address.Mask(CIDRMask(b.Mask, len(b.Oui)*8)), CIDRMask(b.Mask, len(b.Oui)*8))\n\n\treturn (bytes.Equal(address.Mask(CIDRMask(b.Mask, len(b.Oui)*8)), b.Oui))\n}"
        ],
        [
            "func ThrottledReader(\n\tctx context.Context,\n\tr io.Reader,\n\tthrottle Throttle) io.Reader {\n\treturn &throttledReader{\n\t\tctx:      ctx,\n\t\twrapped:  r,\n\t\tthrottle: throttle,\n\t}\n}"
        ],
        [
            "func NewThrottledBucket(\n\topThrottle Throttle,\n\tegressThrottle Throttle,\n\twrapped gcs.Bucket) (b gcs.Bucket) {\n\tb = &throttledBucket{\n\t\topThrottle:     opThrottle,\n\t\tegressThrottle: egressThrottle,\n\t\twrapped:        wrapped,\n\t}\n\n\treturn\n}"
        ],
        [
            "func NewCmdWithRunner(cmdName string, runner func()) (*CmdWithRunner, error) {\n\tif cmdName == \"\" {\n\t\treturn nil, errors.New(\"cmdName cannot be blank\")\n\t}\n\n\tfor _, r := range cmdName {\n\t\tif unicode.IsSpace(r) {\n\t\t\treturn nil, errors.Errorf(\"cmdName cannot contain whitespace: %q\", cmdName)\n\t\t}\n\t}\n\n\treturn &CmdWithRunner{\n\t\tcmdName: cmdName,\n\t\trunner:  runner,\n\t}, nil\n}"
        ],
        [
            "func MustNewCmdWithRunner(cmdName string, runner func()) *CmdWithRunner {\n\tcmdWithRunner, err := NewCmdWithRunner(cmdName, runner)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cmdWithRunner\n}"
        ],
        [
            "func importBreakPaths(file *ast.File) []string {\n\tvar output []string\n\n\tfor _, decl := range file.Decls {\n\t\tif gen, ok := decl.(*ast.GenDecl); ok && gen.Tok == token.IMPORT {\n\t\t\tfor srcIndex, currSpec := range gen.Specs {\n\t\t\t\tif srcIndex > 0 {\n\t\t\t\t\t// if there was a previous element, check if the group has changed\n\t\t\t\t\tcurrGroup := importGroup(importPath(currSpec))\n\t\t\t\t\tprevGroup := importGroup(importPath(gen.Specs[srcIndex-1]))\n\t\t\t\t\tif currGroup != prevGroup {\n\t\t\t\t\t\t// if group has changed, add path to the output\n\t\t\t\t\t\toutput = append(output, importPath(gen.Specs[srcIndex]))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// assume that only one import token block exists\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn output\n}"
        ],
        [
            "func SelfProxyCmderSupplier() CmderSupplier {\n\treturn func(cmd Cmd) (Cmder, error) {\n\t\tselfCmder, err := selfCmder()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn CmderWithPrependedArgs(selfCmder, proxyCmd(cmd).Name()), nil\n\t}\n}"
        ],
        [
            "func SupplierWithPrependedArgs(s CmderSupplier, argsFunc func(cmd Cmd) []string) CmderSupplier {\n\treturn func(cmd Cmd) (Cmder, error) {\n\t\tr, err := s(cmd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn CmderWithPrependedArgs(r, argsFunc(cmd)...), nil\n\t}\n}"
        ],
        [
            "func selfCmder() (Cmder, error) {\n\tpathToSelf, err := osext.Executable()\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to determine path for current executable\")\n\t}\n\treturn PathCmder(pathToSelf), nil\n}"
        ],
        [
            "func CmderWithPrependedArgs(r Cmder, prependedArgs ...string) Cmder {\n\treturn &wrappedCmder{\n\t\tinner:         r,\n\t\tprependedArgs: prependedArgs,\n\t}\n}"
        ],
        [
            "func NewSeeforRouter() *Seefor {\n\tc4 := &Seefor{}\n\tc4.afters = make([]After, 0)\n\tc4.befores = make([]Before, 0)\n\tc4.roots = make(map[string]*rootNode)\n\tc4.HandleMethodNotAllowed = true\n\treturn c4\n}"
        ],
        [
            "func (c4 *Seefor) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tstarted := time.Now()\n\tc4.handleBeforeMiddlewares(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\tbeforeEnd := time.Now()\n\t\tif root, exist := c4.roots[req.Method]; exist {\n\t\t\thandler, params, route := root.match(req.URL.Path)\n\t\t\tif handler != nil {\n\t\t\t\tif c4.timer != nil {\n\t\t\t\t\tafter := time.Now()\n\t\t\t\t\tc4.handleAfterMiddlewares(handler, w, req, params)\n\t\t\t\t\tc4.timer.Get(route).Accumulate(started, beforeEnd, after, time.Now())\n\t\t\t\t} else {\n\t\t\t\t\tc4.handleAfterMiddlewares(handler, w, req, params)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tc4.Router.handleMissing(w, req)\n\t}), w, req)\n}"
        ],
        [
            "func (c4 *Seefor) Before(middleware ...Before) {\n\tc4.befores = append(c4.befores, middleware...)\n}"
        ],
        [
            "func (c4 *Seefor) After(middleware ...After) {\n\tc4.afters = append(c4.afters, middleware...)\n}"
        ],
        [
            "func (c4 *Seefor) UseTimer(timer *Timer) *Timer {\n\tif timer == nil {\n\t\tif c4.timer != nil {\n\t\t\treturn c4.timer\n\t\t}\n\t\ttimer = NewTimer()\n\t}\n\tc4.timer = timer\n\n\treturn c4.timer\n}"
        ],
        [
            "func NewRouter() *Router {\n\tr := &Router{}\n\tr.roots = make(map[string]*rootNode)\n\tr.HandleMethodNotAllowed = true\n\treturn r\n}"
        ],
        [
            "func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\t//now := time.Now()\n\tif root, exist := r.roots[req.Method]; exist {\n\t\thandler, params, _ := root.match(req.URL.Path)\n\t\tif handler != nil {\n\t\t\thandler.ServeHTTP(w, req, params)\n\t\t\t//log.Println(time.Now().Sub(now))\n\t\t\treturn\n\t\t}\n\t}\n\tr.handleMissing(w, req)\n}"
        ],
        [
            "func (r *Router) Group(path string, fn func(r *GroupRouter)) {\n\tgr := NewGroupRouter(r, path)\n\tfn(gr)\n}"
        ],
        [
            "func (n *routeNode) findChild(nn *routeNode) *routeNode {\n\tfor _, c := range n.children {\n\t\tif c.path == nn.path {\n\t\t\t// same node\n\t\t\treturn c\n\t\t}\n\t}\n\treturn nil\n}"
        ],
        [
            "func (n *routeNode) insertChild(nn *routeNode) *routeNode {\n\tif child := n.findChild(nn); child != nil {\n\t\treturn child\n\t}\n\n\tif n.paramChild != nil && nn.paramNode {\n\t\t// only allow one param child, unique param name\n\t\tif n.paramChild.paramName != nn.paramName {\n\t\t\tpanic(\"Param name must be same for\")\n\t\t}\n\t\treturn n.paramChild\n\t}\n\tif nn.paramNode {\n\t\tn.paramChild = nn\n\t} else {\n\t\tn.children = append(n.children, nn)\n\t}\n\treturn nn\n}"
        ],
        [
            "func (t *Timer) Get(name string) *Counter {\n\tif c, exist := t.routes[name]; exist {\n\t\treturn c\n\t}\n\tt.mux.Lock()\n\tdefer t.mux.Unlock()\n\t// could be a race so check again\n\t// could loose som small data but good not to\n\tif c, exist := t.routes[name]; exist {\n\t\treturn c\n\t}\n\tt.routes[name] = &Counter{}\n\tt.routes[name].Min = 1<<63 - 1\n\treturn t.routes[name]\n}"
        ],
        [
            "func (t *Timer) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\n\treq.ParseForm()\n\tsortBy := req.Form.Get(\"sort\")\n\n\tstats := &Stats{}\n\tstats.SortBy = strings.ToLower(sortBy)\n\tstats.Generated = time.Now()\n\tstats.UpTime = fmt.Sprintf(\"%s\", stats.Generated.Sub(t.Since))\n\t// Read access OK for map?\n\tstats.Result = make([]*Stat, 0, len(t.routes))\n\tfor k, v := range t.routes {\n\t\tstat := &Stat{}\n\t\tstat.Route = k\n\t\tstat.Count = v.Count\n\t\tstat.Tot = v.Tot\n\t\tstat.Avg = time.Duration(int64(v.Tot) / v.Count)\n\t\tstat.AvgAfter = time.Duration(int64(v.AfterTot) / v.Count)\n\t\tstat.AvgBefore = time.Duration(int64(v.BeforeTot) / v.Count)\n\t\tstat.Max = v.Max\n\t\tstat.Min = v.Min\n\t\tstats.Result = append(stats.Result, stat)\n\t}\n\tsort.Sort(sort.Reverse(stats))\n\tjsonData, _ := json.Marshal(stats)\n\tw.Write(jsonData)\n}"
        ],
        [
            "func main() {\n\trouter := r2router.NewSeeforRouter()\n\t\n\t// basic auth for entire router\n\trouter.Before(httpauth.SimpleBasicAuth(\"testuser\", \"testpw\"))\n\t\n\trouter.Get(\"/hello/:name\", func(w http.ResponseWriter, r *http.Request, p r2router.Params) {\n\t\tw.Write([]byte( p.Get(\"name\")))\n\t})\n\n\thttp.ListenAndServe(\"127.0.0.1:8080\", router)\n}"
        ],
        [
            "func NewGroupRouter(r *Router, path string) *GroupRouter {\n\tgr := &GroupRouter{}\n\tgr.router = r\n\tgr.path = strings.TrimRight(path, \"/\")\n\treturn gr\n}"
        ],
        [
            "func RouteMiddleware(next r2router.HandlerFunc) r2router.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request, p r2router.Params) {\n\t\tp.AppSet(\"say\", \"Hello\")\n\t\tnext(w, r, p)\n\t}\n}"
        ],
        [
            "func RouteHandlerFunc(next http.HandlerFunc) r2router.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request, _ r2router.Params) {\n\t\tnext(w, r)\n\t}\n}"
        ],
        [
            "func RectFromSphere(c Vec3, r float32) Rectangle {\n\treturn RectWHD(c[0]-r, c[1]-r, c[2]-r, 2*r, 2*r, 2*r)\n}"
        ],
        [
            "func CopyRect(r Rectangle) Rectangle {\n\tr1 := NewRect()\n\tr1.Min.Assign(r.Min)\n\tr1.Max.Assign(r.Max)\n\treturn r1\n}"
        ],
        [
            "func (r Rectangle) Size() Vec3 {\n\treturn Vec3{\n\t\tr.Max[0] - r.Min[0],\n\t\tr.Max[1] - r.Min[1],\n\t\tr.Max[2] - r.Min[2],\n\t}\n}"
        ],
        [
            "func (r Rectangle) Overlaps(s Rectangle) bool {\n\treturn !r.Empty() && !s.Empty() &&\n\t\tr.Min[0] < s.Max[0] && s.Min[0] < r.Max[0] &&\n\t\tr.Min[1] < s.Max[1] && s.Min[1] < r.Max[1] &&\n\t\tr.Min[2] < s.Max[2] && s.Min[2] < r.Max[2]\n}"
        ],
        [
            "func (r Rectangle) String() string {\n\treturn fmt.Sprintf(\"(Min:%v,Max:%v)\", r.Min, r.Max)\n}"
        ],
        [
            "func (r Rectangle) Dx() float64 {\n\treturn r.Max.X - r.Min.X\n}"
        ],
        [
            "func (r Rectangle) Dy() float64 {\n\treturn r.Max.Y - r.Min.Y\n}"
        ],
        [
            "func (r Rectangle) In(s Rectangle) bool {\n\tif r.Empty() {\n\t\treturn true\n\t}\n\t// Note that r.Max is an exclusive bound for r, so that r.In(s)\n\t// does not require that r.Max.In(s).\n\treturn s.Min[0] <= r.Min[0] && r.Max[0] <= s.Max[0] &&\n\t\ts.Min[1] <= r.Min[1] && r.Max[1] <= s.Max[1]\n}"
        ],
        [
            "func Approx(x, y float64) bool {\n\teps := epsilon64 * 100\n\treturn math.Abs(x-y) < eps*(1.0+math.Max(math.Abs(x), math.Abs(y)))\n}"
        ],
        [
            "func ApproxEpsilon(x, y float64, eps float64) bool {\n\treturn math.Abs(x-y) < eps*(1.0+math.Max(math.Abs(x), math.Abs(y)))\n}"
        ],
        [
            "func (v Vec3) SetXYZ(x, y, z float32) {\n\tv[0] = x\n\tv[1] = y\n\tv[2] = z\n}"
        ],
        [
            "func Vec3Dist2DSqr(v1, v2 Vec3) float32 {\n\tdx := v1[0] - v2[0]\n\tdz := v1[2] - v2[2]\n\treturn dx*dx + dz*dz\n}"
        ],
        [
            "func (v Vec3) Copy(dst Vec3) {\n\tdst[0] = v[0]\n\tdst[1] = v[1]\n\tdst[2] = v[2]\n}"
        ],
        [
            "func (v Vec3) Assign(v1 Vec3) {\n\tv[0] = v1[0]\n\tv[1] = v1[1]\n\tv[2] = v1[2]\n}"
        ],
        [
            "func (v Vec3) Dist2D(v1 Vec3) float32 {\n\tdx := v1[0] - v[0]\n\tdz := v1[2] - v[2]\n\treturn math32.Sqrt(dx*dx + dz*dz)\n}"
        ],
        [
            "func (v Vec3) Dist2DSqr(v1 Vec3) float32 {\n\tdx := v1[0] - v[0]\n\tdz := v1[2] - v[2]\n\treturn dx*dx + dz*dz\n}"
        ],
        [
            "func (v Vec3) Cross(v1 Vec3) Vec3 {\n\treturn Vec3{\n\t\tv[1]*v1[2] - v[2]*v1[1],\n\t\tv[2]*v1[0] - v[0]*v1[2],\n\t\tv[0]*v1[1] - v[1]*v1[0],\n\t}\n}"
        ],
        [
            "func (v Vec3) Dot2D(u Vec3) float32 {\n\treturn v[0]*u[0] + v[2]*u[2]\n}"
        ],
        [
            "func NewRay(o, v Vec) Ray {\n\t//v = v.Normalize()\n\treturn Ray{\n\t\to:    o,\n\t\tv:    v,\n\t\tinvv: Vec{1.0 / v.X, 1.0 / v.Y},\n\t}\n}"
        ],
        [
            "func (r Ray) IntersectRect(b Rectangle) bool {\n\tt1 := (b.Min.X - r.o.X) * r.invv.X\n\tt2 := (b.Max.X - r.o.X) * r.invv.X\n\n\ttmin := math.Min(t1, t2)\n\ttmax := math.Max(t1, t2)\n\n\t// x\n\tt1 = (b.Min.X - r.o.X) * r.invv.X\n\tt2 = (b.Max.X - r.o.X) * r.invv.X\n\ttmin = math.Max(tmin, math.Min(t1, t2))\n\ttmax = math.Min(tmax, math.Max(t1, t2))\n\n\t// y\n\tt1 = (b.Min.Y - r.o.Y) * r.invv.Y\n\tt2 = (b.Max.Y - r.o.Y) * r.invv.Y\n\ttmin = math.Max(tmin, math.Min(t1, t2))\n\ttmax = math.Min(tmax, math.Max(t1, t2))\n\n\treturn tmax >= math.Max(tmin, 0.0)\n}"
        ],
        [
            "func SupportedFunc(opts *ServerOptions) func(*Request) error {\n\tsubjectMap := map[SubjectType]bool{}\n\tfor _, subjectType := range opts.SubjectTypes {\n\t\tsubjectMap[subjectType] = true\n\t}\n\tidentityMap := map[string]bool{}\n\tfor _, identity := range opts.Identities {\n\t\tidentityMap[string(identity.Type)+string(identity.Format)] = true\n\t}\n\treturn func(req *Request) error {\n\t\tif _, ok := subjectMap[req.SubjectRequestType]; !ok {\n\t\t\treturn ErrUnsupportedRequestType(req.SubjectRequestType)\n\t\t}\n\t\tfor _, identity := range req.SubjectIdentities {\n\t\t\tif _, ok := identityMap[string(identity.Type)+string(identity.Format)]; !ok {\n\t\t\t\treturn ErrUnsupportedIdentity(identity)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}"
        ],
        [
            "func NewSigner(opts *KeyOptions) (Signer, error) {\n\tprivateKey := opts.KeyBytes\n\tif opts.KeyPath != \"\" {\n\t\traw, err := ioutil.ReadFile(opts.KeyPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tprivateKey = raw\n\t}\n\tblock, _ := pem.Decode(privateKey)\n\tblockBytes := block.Bytes\n\t// Decode the PEM key if a password is set\n\tif x509.IsEncryptedPEMBlock(block) {\n\t\tb, err := x509.DecryptPEMBlock(block, opts.Password)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tblockBytes = b\n\t}\n\tparsed, err := x509.ParsePKCS8PrivateKey(blockBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprivKey, ok := parsed.(*rsa.PrivateKey)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"unsupported private key\")\n\t}\n\treturn &rsaSigner{privKey: privKey}, nil\n}"
        ],
        [
            "func NewVerifier(opts *KeyOptions) (Verifier, error) {\n\tpublicKey := opts.KeyBytes\n\tif opts.KeyPath != \"\" {\n\t\traw, err := ioutil.ReadFile(opts.KeyPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpublicKey = raw\n\t}\n\tblock, _ := pem.Decode(publicKey)\n\tcert, err := x509.ParseCertificate(block.Bytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// TODO\n\t// Currently only support RSA keys\n\t// Need to consider DSA/ECDSA\n\tif cert.PublicKeyAlgorithm != x509.RSA {\n\t\treturn nil, fmt.Errorf(\"unsupported public key type\")\n\t}\n\treturn &rsaVerifier{publicKey: cert.PublicKey.(*rsa.PublicKey), cert: cert}, nil\n}"
        ],
        [
            "func (c *Client) Request(req *Request) (*Response, error) {\n\tbuf := bytes.NewBuffer(nil)\n\terr := json.NewEncoder(buf).Encode(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treqResp := &Response{}\n\tresp, err := c.caller.Call(\"POST\", c.endpoint+\"/opengdpr_requests\", buf)\n\treturn reqResp, c.json(resp, err, true, reqResp)\n}"
        ],
        [
            "func (c *Client) Status(id string) (*StatusResponse, error) {\n\tstatResp := &StatusResponse{}\n\tresp, err := c.caller.Call(\"GET\", c.endpoint+\"/opengdpr_requests/\"+id, nil)\n\treturn statResp, c.json(resp, err, true, statResp)\n}"
        ],
        [
            "func (c *Client) Cancel(id string) (*CancellationResponse, error) {\n\tcancelResp := &CancellationResponse{}\n\tresp, err := c.caller.Call(\"DELETE\", c.endpoint+\"/opengdpr_requests/\"+id, nil)\n\treturn cancelResp, c.json(resp, err, true, cancelResp)\n}"
        ],
        [
            "func (c *Client) Discovery() (*DiscoveryResponse, error) {\n\tdiscResp := &DiscoveryResponse{}\n\tresp, err := c.caller.Call(\"GET\", c.endpoint+\"/discovery\", nil)\n\treturn discResp, c.json(resp, err, false, discResp)\n}"
        ],
        [
            "func NewClient(opts *ClientOptions) *Client {\n\tcli := opts.Client\n\tif cli == nil {\n\t\tcli = http.DefaultClient\n\t}\n\tclient := &Client{\n\t\tcaller: &defaultCaller{\n\t\t\tclient: cli,\n\t\t\theaders: map[string]string{\n\t\t\t\t\"GDPR-Version\": ApiVersion,\n\t\t\t\t\"Content-Type\": \"Application/JSON\",\n\t\t\t},\n\t\t},\n\t\tendpoint: opts.Endpoint,\n\t\tverifier: opts.Verifier,\n\t}\n\treturn client\n}"
        ],
        [
            "func (s *VecStack) Push(value *Vec) {\n\ts.top = &item{value, s.top}\n\ts.size++\n}"
        ],
        [
            "func (s *VecStack) Pop() (value *Vec) {\n\tif s.size > 0 {\n\t\tvalue, s.top = s.top.value, s.top.next\n\t\ts.size--\n\t\treturn\n\t}\n\treturn nil\n}"
        ],
        [
            "func (s *VecStack) PopLast() (value *Vec) {\n\tif lastElem := s.popLast(s.top); s.size >= 2 && lastElem != nil {\n\t\treturn lastElem.value\n\t}\n\treturn nil\n}"
        ],
        [
            "func (s *VecStack) Peek() (value *Vec, exists bool) {\n\texists = false\n\tif s.size > 0 {\n\t\tvalue = s.top.value\n\t\texists = true\n\t}\n\treturn\n}"
        ],
        [
            "func (s *VecStack) PeekN(n int) []*Vec {\n\tvar (\n\t\tN   []*Vec\n\t\tcur *item\n\t)\n\tN = make([]*Vec, 0, n)\n\tcur = s.top\n\tfor len(N) < n {\n\t\tif cur == nil {\n\t\t\tbreak\n\t\t}\n\t\tN = append(N, cur.value)\n\t\tcur = cur.next\n\t}\n\treturn N\n}"
        ],
        [
            "func Vecf32(x, y float32) Vec {\n\treturn Vec{float64(x), float64(y)}\n}"
        ],
        [
            "func Veci(x, y int) Vec {\n\treturn Vec{float64(x), float64(y)}\n}"
        ],
        [
            "func (v Vec) Add(v2 Vec) Vec {\n\treturn Vec{v.X + v2.X, v.Y + v2.Y}\n}"
        ],
        [
            "func (v Vec) Sub(v2 Vec) Vec {\n\treturn Vec{v.X - v2.X, v.Y - v2.Y}\n}"
        ],
        [
            "func (v Vec) In(r Rectangle) bool {\n\treturn r.Min.X <= v.X && v.X < r.Max.X &&\n\t\tr.Min.Y <= v.Y && v.Y < r.Max.Y\n}"
        ],
        [
            "func (v Vec) Len() float64 {\n\treturn float64(math.Hypot(float64(v.X), float64(v.Y)))\n}"
        ],
        [
            "func (v Vec) ApproxFuncEqual(v2 Vec, eq func(float64, float64) bool) bool {\n\tif !eq(v.X, v2.X) {\n\t\treturn false\n\t}\n\tif !eq(v.Y, v2.Y) {\n\t\treturn false\n\t}\n\treturn true\n}"
        ],
        [
            "func (hm HandlerMap) Merge(other HandlerMap) {\n\tfor key, methods := range other {\n\t\tif _, ok := hm[key]; !ok {\n\t\t\thm[key] = map[string]Builder{}\n\t\t}\n\t\tfor method, builder := range methods {\n\t\t\thm[key][method] = builder\n\t\t}\n\t}\n}"
        ],
        [
            "func (s *Server) respCode(r *http.Request) int {\n\tif r.URL.Path == \"/opengdpr_requests\" && r.Method == \"POST\" {\n\t\treturn http.StatusCreated\n\t}\n\treturn http.StatusOK\n}"
        ],
        [
            "func NewServer(opts *ServerOptions) *Server {\n\tserver := &Server{\n\t\tsigner:          opts.Signer,\n\t\tverifier:        opts.Verifier,\n\t\tisProcessor:     hasProcessor(opts),\n\t\tisController:    hasController(opts),\n\t\theaders:         http.Header{},\n\t\tprocessorDomain: opts.ProcessorDomain,\n\t}\n\tserver.headers.Set(\"Accept\", \"application/json\")\n\tserver.headers.Set(\"Content-Type\", \"application/json\")\n\tif hasProcessor(opts) {\n\t\tserver.headers.Set(\"X-OpenGDPR-ProcessorDomain\", opts.ProcessorDomain)\n\t}\n\trouter := httprouter.New()\n\thm := buildHandlerMap(opts)\n\tfor path, methods := range hm {\n\t\tfor method, builder := range methods {\n\t\t\trouter.Handle(method, path, server.handle(builder(opts)))\n\t\t}\n\t}\n\tserver.handlerFn = router.ServeHTTP\n\treturn server\n}"
        ],
        [
            "func Callback(cbReq *CallbackRequest, opts *CallbackOptions) error {\n\tclient := opts.Client\n\tif client == nil {\n\t\tclient = http.DefaultClient\n\t}\n\tbuf := bytes.NewBuffer(nil)\n\terr := json.NewEncoder(buf).Encode(cbReq)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsignature, err := opts.Signer.Sign(buf.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\treq, err := http.NewRequest(\"POST\", cbReq.StatusCallbackUrl, buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"X-OpenGDPR-Processor-Domain\", opts.ProcessorDomain)\n\treq.Header.Set(\"X-OpenGDPR-Signature\", signature)\n\t// Attempt to make callback\n\tfor i := 0; i < opts.MaxAttempts; i++ {\n\t\tresp, err := client.Do(req)\n\t\tif err != nil || resp.StatusCode != 200 {\n\t\t\ttime.Sleep(opts.Backoff)\n\t\t\tcontinue\n\t\t}\n\t\t// Success\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"callback timed out for %s\", cbReq.StatusCallbackUrl)\n}"
        ],
        [
            "func ErrNotFound(id string) error {\n\treturn ErrorResponse{\n\t\tCode:    http.StatusNotFound,\n\t\tMessage: fmt.Sprintf(\"request %s not found\", id),\n\t}\n}"
        ],
        [
            "func ErrUnsupportedRequestType(st SubjectType) error {\n\treturn ErrorResponse{\n\t\tCode:    http.StatusNotImplemented,\n\t\tMessage: fmt.Sprintf(\"unsupported request type: %s\", st),\n\t}\n}"
        ],
        [
            "func ErrUnsupportedIdentity(id Identity) error {\n\treturn ErrorResponse{\n\t\tCode:    http.StatusNotImplemented,\n\t\tMessage: fmt.Sprintf(\"unsupported identity: %s/%s\", id.Type, id.Format),\n\t}\n}"
        ],
        [
            "func ErrMissingRequiredField(field string) error {\n\treturn ErrorResponse{\n\t\tCode:    http.StatusBadRequest,\n\t\tMessage: fmt.Sprintf(\"missing required field: %s\", field),\n\t}\n}"
        ],
        [
            "func ErrInvalidRequestSignature(signature string, err error) error {\n\treturn ErrorResponse{\n\t\tCode:    http.StatusForbidden,\n\t\tMessage: fmt.Sprintf(\"could not validate request signature: %s\", signature),\n\t\tErrors:  []Error{Error{Message: err.Error()}},\n\t}\n}"
        ],
        [
            "func (c *Client) DatabaseServers() ([]DatabaseServer, error) {\n\tvar dbs []DatabaseServer\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/database_servers\", nil, &dbs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn dbs, err\n}"
        ],
        [
            "func (c *Client) SnapshotDatabaseServer(identifier string) (*DatabaseSnapshot, error) {\n\tdbs := new(DatabaseServer)\n\tres, err := c.MakeApiRequest(\"POST\", \"/1.0/database_servers/\"+identifier+\"/snapshot\", nil, &dbs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsnapID := getLinkRel(res.Header.Get(\"Link\"), \"dbi\", \"snapshot\")\n\tif snapID != nil {\n\t\tsnap := new(DatabaseSnapshot)\n\t\tsnap.Id = *snapID\n\t\treturn snap, nil\n\t}\n\treturn nil, nil\n}"
        ],
        [
            "func (c *Client) ResetPasswordForDatabaseServer(identifier string) (*DatabaseServer, error) {\n\tdbs := new(DatabaseServer)\n\t_, err := c.MakeApiRequest(\"POST\", \"/1.0/database_servers/\"+identifier+\"/reset_password\", nil, &dbs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn dbs, nil\n}"
        ],
        [
            "func (c *Client) Servers() ([]Server, error) {\n\tvar servers []Server\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/servers\", nil, &servers)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn servers, err\n}"
        ],
        [
            "func (c *Client) Server(identifier string) (*Server, error) {\n\tserver := new(Server)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/servers/\"+identifier, nil, server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn server, err\n}"
        ],
        [
            "func (c *Client) DestroyServer(identifier string) error {\n\t_, err := c.MakeApiRequest(\"DELETE\", \"/1.0/servers/\"+identifier, nil, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
        ],
        [
            "func (c *Client) LockServer(identifier string) error {\n\treturn c.LockResource(Server{Id: identifier})\n}"
        ],
        [
            "func (c *Client) UnlockServer(identifier string) error {\n\treturn c.UnLockResource(Server{Id: identifier})\n}"
        ],
        [
            "func (c *Client) SnapshotServer(identifier string) (*Image, error) {\n\tres, err := c.MakeApiRequest(\"POST\", \"/1.0/servers/\"+identifier+\"/snapshot\", nil, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\timageID := getLinkRel(res.Header.Get(\"Link\"), \"img\", \"snapshot\")\n\tif imageID != nil {\n\t\timg := new(Image)\n\t\timg.Id = *imageID\n\t\treturn img, nil\n\t}\n\treturn nil, nil\n}"
        ],
        [
            "func (s *Server) FullConsoleUrl() string {\n\tif s.ConsoleUrl == \"\" || s.ConsoleToken == \"\" {\n\t\treturn s.ConsoleUrl\n\t}\n\tu, err := url.Parse(s.ConsoleUrl)\n\tif u == nil || err != nil {\n\t\treturn s.ConsoleUrl\n\t}\n\tvalues := u.Query()\n\tif values.Get(\"password\") != \"\" {\n\t\treturn s.ConsoleUrl\n\t}\n\tvalues.Set(\"password\", s.ConsoleToken)\n\tu.RawQuery = values.Encode()\n\treturn u.String()\n}"
        ],
        [
            "func (c *Client) FirewallRule(identifier string) (*FirewallRule, error) {\n\trule := new(FirewallRule)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/firewall_rules/\"+identifier, nil, rule)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn rule, err\n}"
        ],
        [
            "func (c *Client) ServerGroups() ([]ServerGroup, error) {\n\tvar groups []ServerGroup\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/server_groups\", nil, &groups)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn groups, err\n}"
        ],
        [
            "func (c *Client) ServerGroup(identifier string) (*ServerGroup, error) {\n\tgroup := new(ServerGroup)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/server_groups/\"+identifier, nil, group)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn group, err\n}"
        ],
        [
            "func (c *Client) AddServersToServerGroup(identifier string, serverIds []string) (*ServerGroup, error) {\n\tgroup := new(ServerGroup)\n\topts := new(serverGroupMemberOptions)\n\tfor _, id := range serverIds {\n\t\topts.Servers = append(opts.Servers, serverGroupMember{Server: id})\n\t}\n\t_, err := c.MakeApiRequest(\"POST\", \"/1.0/server_groups/\"+identifier+\"/add_servers\", opts, &group)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn group, nil\n}"
        ],
        [
            "func (c *Client) MoveServersToServerGroup(src string, dst string, serverIds []string) (*ServerGroup, error) {\n\tgroup := new(ServerGroup)\n\topts := serverGroupMemberOptions{Destination: dst}\n\tfor _, id := range serverIds {\n\t\topts.Servers = append(opts.Servers, serverGroupMember{Server: id})\n\t}\n\t_, err := c.MakeApiRequest(\"POST\", \"/1.0/server_groups/\"+src+\"/move_servers\", opts, &group)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn group, nil\n}"
        ],
        [
            "func (c *Client) LoadBalancers() ([]LoadBalancer, error) {\n\tvar lbs []LoadBalancer\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/load_balancers\", nil, &lbs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn lbs, err\n}"
        ],
        [
            "func (c *Client) LoadBalancer(identifier string) (*LoadBalancer, error) {\n\tlb := new(LoadBalancer)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/load_balancers/\"+identifier, nil, lb)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn lb, err\n}"
        ],
        [
            "func (c *Client) AddNodesToLoadBalancer(loadBalancerID string, nodes []LoadBalancerNode) (*LoadBalancer, error) {\n\tlb := new(LoadBalancer)\n\t_, err := c.MakeApiRequest(\"POST\", \"/1.0/load_balancers/\"+loadBalancerID+\"/add_nodes\", nodes, &lb)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn lb, nil\n}"
        ],
        [
            "func (c *Client) RemoveListenersFromLoadBalancer(loadBalancerID string, listeners []LoadBalancerListener) (*LoadBalancer, error) {\n\tlb := new(LoadBalancer)\n\t_, err := c.MakeApiRequest(\"POST\", \"/1.0/load_balancers/\"+loadBalancerID+\"/remove_listeners\", listeners, &lb)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn lb, nil\n}"
        ],
        [
            "func (c *Client) LockResource(resource interface{}) error {\n\trpath, err := resourcePath(resource)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = c.MakeApiRequest(\"PUT\", fmt.Sprintf(\"/1.0/%s/lock_resource\", rpath), nil, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
        ],
        [
            "func (c *Client) FirewallPolicies() ([]FirewallPolicy, error) {\n\tvar policies []FirewallPolicy\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/firewall_policies\", nil, &policies)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn policies, err\n}"
        ],
        [
            "func (c *Client) FirewallPolicy(identifier string) (*FirewallPolicy, error) {\n\tpolicy := new(FirewallPolicy)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/firewall_policies/\"+identifier, nil, policy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn policy, err\n}"
        ],
        [
            "func (c *Client) ApplyFirewallPolicy(policyId string, serverGroupId string) (*FirewallPolicy, error) {\n\tpolicy := new(FirewallPolicy)\n\t_, err := c.MakeApiRequest(\"POST\", \"/1.0/firewall_policies/\"+policyId+\"/apply_to\",\n\t\tmap[string]string{\"server_group\": serverGroupId}, &policy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn policy, nil\n}"
        ],
        [
            "func (r GetAuthResult) Extract() (*AuthResult, error) {\n\tvar s *AuthResult\n\terr := r.ExtractInto(&s)\n\treturn s, err\n}"
        ],
        [
            "func (c *Client) ApiClients() ([]ApiClient, error) {\n\tvar apiClients []ApiClient\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/api_clients\", nil, &apiClients)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn apiClients, err\n}"
        ],
        [
            "func (c *Client) ApiClient(identifier string) (*ApiClient, error) {\n\tapiClient := new(ApiClient)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/api_clients/\"+identifier, nil, apiClient)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn apiClient, err\n}"
        ],
        [
            "func (c *Client) ResetSecretForApiClient(identifier string) (*ApiClient, error) {\n\tac := new(ApiClient)\n\t_, err := c.MakeApiRequest(\"POST\", \"/1.0/api_clients/\"+identifier+\"/reset_secret\", nil, &ac)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ac, nil\n}"
        ],
        [
            "func (c *Client) Images() ([]Image, error) {\n\tvar images []Image\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/images\", nil, &images)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn images, err\n}"
        ],
        [
            "func (c *Client) Image(identifier string) (*Image, error) {\n\timage := new(Image)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/images/\"+identifier, nil, image)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn image, err\n}"
        ],
        [
            "func (c *Client) Accounts() ([]Account, error) {\n\tvar accounts []Account\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/accounts?nested=false\", nil, &accounts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn accounts, err\n}"
        ],
        [
            "func (c *Client) Account(identifier string) (*Account, error) {\n\taccount := new(Account)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/accounts/\"+identifier, nil, account)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn account, err\n}"
        ],
        [
            "func (c *Client) CloudIPs() ([]CloudIP, error) {\n\tvar cloudips []CloudIP\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/cloud_ips\", nil, &cloudips)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn cloudips, err\n}"
        ],
        [
            "func (c *Client) CloudIP(identifier string) (*CloudIP, error) {\n\tcloudip := new(CloudIP)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/cloud_ips/\"+identifier, nil, cloudip)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn cloudip, err\n}"
        ],
        [
            "func (c *Client) MapCloudIPtoServer(identifier string, serverid string) error {\n\tserver, err := c.Server(serverid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(server.Interfaces) == 0 {\n\t\treturn fmt.Errorf(\"Server %s has no interfaces to map cloud ip %s to\", server.Id, identifier)\n\t}\n\tdestination := server.Interfaces[0].Id\n\terr = c.MapCloudIP(identifier, destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}"
        ],
        [
            "func setAuthHeader(t *oauth2.Token, r *http.Request) {\n\tr.Header.Set(\"X-Auth-Token\", t.AccessToken)\n}"
        ],
        [
            "func Auth(c *gophercloud.ProviderClient, opts AuthOptsBuilder) (r GetAuthResult) {\n\th := make(map[string]string)\n\n\tif opts != nil {\n\t\theaders, err := opts.ToAuthOptsMap()\n\t\tif err != nil {\n\t\t\tr.Err = err\n\t\t\treturn\n\t\t}\n\n\t\tfor k, v := range headers {\n\t\t\th[k] = v\n\t\t}\n\t}\n\n\tresp, err := c.Request(\"GET\", getURL(c), &gophercloud.RequestOpts{\n\t\tMoreHeaders: h,\n\t\tOkCodes:     []int{200},\n\t})\n\n\tif resp != nil {\n\t\tr.Header = resp.Header\n\t}\n\n\tr.Err = err\n\n\treturn r\n}"
        ],
        [
            "func (c *Client) Collaborations() ([]Collaboration, error) {\n\tvar cl []Collaboration\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/user/collaborations\", nil, &cl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn cl, err\n}"
        ],
        [
            "func (c *Client) Collaboration(identifier string) (*Collaboration, error) {\n\tcol := new(Collaboration)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/user/collaborations/\"+identifier, nil, col)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn col, err\n}"
        ],
        [
            "func (c *Client) DatabaseSnapshots() ([]DatabaseSnapshot, error) {\n\tvar database_snapshot []DatabaseSnapshot\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/database_snapshots\", nil, &database_snapshot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn database_snapshot, err\n}"
        ],
        [
            "func (c *Client) DatabaseSnapshot(identifier string) (*DatabaseSnapshot, error) {\n\tdatabase_snapshot := new(DatabaseSnapshot)\n\t_, err := c.MakeApiRequest(\"GET\", \"/1.0/database_snapshots/\"+identifier, nil, database_snapshot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn database_snapshot, err\n}"
        ],
        [
            "func (d PingScanner) Scan() (aliveIPs []string, err error) {\n\tvar hostsInCidr []string\n\tif hostsInCidr, err = expandCidrIntoIPs(d.CIDR); err != nil {\n\t\treturn nil, err\n\t}\n\tpingChan := make(chan string, d.NumOfConcurrency)\n\tpongChan := make(chan pong, len(hostsInCidr))\n\tdoneChan := make(chan []pong)\n\n\tfor i := 0; i < d.NumOfConcurrency; i++ {\n\t\tgo ping(pingChan, pongChan, d.PingOptions...)\n\t}\n\n\tgo receivePong(len(hostsInCidr), pongChan, doneChan)\n\n\tfor _, ip := range hostsInCidr {\n\t\tpingChan <- ip\n\t}\n\n\talives := <-doneChan\n\tfor _, a := range alives {\n\t\taliveIPs = append(aliveIPs, a.IP)\n\t}\n\tsort.Strings(aliveIPs)\n\treturn\n}"
        ],
        [
            "func ToFile(src, dest string, options FileOptions) error {\n\tu, err := url.Parse(src)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"invalid src URL\")\n\t}\n\n\ttargetDir := filepath.Dir(dest)\n\tif err = createDir(targetDir, options.Mkdirs == nil || *options.Mkdirs); err != nil {\n\t\treturn err\n\t}\n\n\ttargetName := filepath.Base(dest)\n\tf, err := ioutil.TempFile(targetDir, \".tmp-\"+targetName)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to create temp file\")\n\t}\n\n\terr = downloadFile(u, f, options.Options)\n\tif err != nil {\n\t\t_ = f.Close()           // #nosec\n\t\t_ = os.Remove(f.Name()) // #nosec\n\t\treturn errors.Wrap(err, \"failed to download\")\n\t}\n\terr = f.Close()\n\tif err != nil {\n\t\t_ = os.Remove(f.Name()) // #nosec\n\t\treturn errors.Wrap(err, \"failed to close temp file\")\n\t}\n\n\tif err = renameFile(f.Name(), dest); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func ToWriter(src string, w io.Writer, options Options) error {\n\tu, err := url.Parse(src)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"invalid src URL\")\n\t}\n\treturn FromURL(u, w, options)\n}"
        ],
        [
            "func FromURL(src *url.URL, w io.Writer, options Options) error {\n\thttpClient := getHTTPClient(options)\n\tvar (\n\t\terr  error\n\t\tresp *http.Response\n\t)\n\tdownloader := func() error {\n\t\tresp, err = httpClient.Get(src.String())\n\t\tif err != nil {\n\t\t\treturn &retriableError{errors.Wrap(err, \"Temporary download error\")}\n\t\t}\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tdefer func() { _ = resp.Body.Close() }() // #nosec\n\t\t\treturn errors.Errorf(\"received invalid status code: %d (expected %d)\", resp.StatusCode, http.StatusOK)\n\t\t}\n\t\treturn nil\n\t}\n\tretries := options.Retries\n\tif retries == 0 {\n\t\tretries = 5\n\t}\n\tif err = retryAfter(retries, downloader, options.RetryInterval); err != nil {\n\t\treturn errors.Wrap(err, \"download failed\")\n\t}\n\tdefer func() { _ = resp.Body.Close() }() // #nosec\n\n\tvar (\n\t\tvalidator checksumValidator\n\n\t\treader io.Reader = resp.Body\n\t)\n\n\tif options.ProgressBars != nil && resp.ContentLength > 0 {\n\t\tbar := newProgressBar(resp.ContentLength, options.ProgressBars.MaxWidth, options.ProgressBars.Writer)\n\t\tbar.Start()\n\t\treader = bar.NewProxyReader(reader)\n\t\tdefer func() {\n\t\t\t<-time.After(bar.RefreshRate)\n\t\t\tfmt.Println()\n\t\t}()\n\t}\n\n\tvalidator, reader, err = createValidatorReader(reader, options.ChecksumHash, httpClient, options.Checksum, path.Base(src.Path))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = io.Copy(w, reader); err != nil {\n\t\treturn errors.Wrap(err, \"failed to copy contents\")\n\t}\n\n\tif !validator.validate() {\n\t\treturn errors.New(\"checksum validation failed\")\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (totp *TOTP) ForPeriod(period int64) int32 {\n\tdata := int_to_bytestring(period)\n\n\thmacHash := hmac.New(sha1.New, totp.key)\n\thmacHash.Write(data)\n\tdigest := hmacHash.Sum(nil)\n\toffset := int(digest[19] & 0xf)\n\tcode := int32(digest[offset]&0x7f)<<24 |\n\t\tint32(digest[offset+1]&0xff)<<16 |\n\t\tint32(digest[offset+2]&0xff)<<8 |\n\t\tint32(digest[offset+3]&0xff)\n\n\tcode = int32(int64(code) % int64(math.Pow10(totp.Digits)))\n\treturn code\n}"
        ],
        [
            "func (totp *TOTP) QRCodeData(label string) string {\n\t// We need to URL Escape the label, but at the same time, spaces come through\n\t// as +'s, so we need to reverse that encoding...\n\tlabel = url.QueryEscape(label)\n\tlabel = strings.Replace(label, \"+\", \" \", -1)\n\treturn fmt.Sprintf(\"otpauth://totp/%v?secret=%v&Digits=%v&Period=%v\", label, totp.Secret(), totp.Digits, totp.Period)\n}"
        ],
        [
            "func RandomSecret(length int, rnd *rand.Rand) string {\n\tif 0 <= length {\n\t\tlength = 10\n\t}\n\tsecret := make([]byte, length)\n\tfor i, _ := range secret {\n\t\tsecret[i] = byte(rnd.Int31() % 256)\n\t}\n\treturn base32.StdEncoding.EncodeToString(secret)\n}"
        ],
        [
            "func DefaultPeerConfig() *PeerConfig {\n\treturn &PeerConfig{\n\t\tAuthEnc:          true,\n\t\tHandshakeTimeout: 2 * time.Second,\n\t\tDialTimeout:      3 * time.Second,\n\t\tMConfig:          DefaultMConnConfig(),\n\t\tFuzz:             false,\n\t\tFuzzConfig:       DefaultFuzzConnConfig(),\n\t}\n}"
        ],
        [
            "func (p *Peer) PubKey() crypto.PubKeyEd25519 {\n\tif p.config.AuthEnc {\n\t\treturn p.conn.(*SecretConnection).RemotePubKey()\n\t}\n\tif p.NodeInfo == nil {\n\t\tpanic(\"Attempt to get peer's PubKey before calling Handshake\")\n\t}\n\treturn p.PubKey()\n}"
        ],
        [
            "func (p *Peer) OnStart() error {\n\tp.BaseService.OnStart()\n\t_, err := p.mconn.Start()\n\treturn err\n}"
        ],
        [
            "func (p *Peer) Send(chID byte, msg interface{}) bool {\n\tif !p.IsRunning() {\n\t\t// see Switch#Broadcast, where we fetch the list of peers and loop over\n\t\t// them - while we're looping, one peer may be removed and stopped.\n\t\treturn false\n\t}\n\treturn p.mconn.Send(chID, msg)\n}"
        ],
        [
            "func (p *Peer) WriteTo(w io.Writer) (n int64, err error) {\n\tvar n_ int\n\twire.WriteString(p.Key, w, &n_, &err)\n\tn += int64(n_)\n\treturn\n}"
        ],
        [
            "func (p *Peer) Equals(other *Peer) bool {\n\treturn p.Key == other.Key\n}"
        ],
        [
            "func FuzzConnAfter(conn net.Conn, d time.Duration) net.Conn {\n\treturn FuzzConnAfterFromConfig(conn, d, DefaultFuzzConnConfig())\n}"
        ],
        [
            "func NewMConnectionWithConfig(conn net.Conn, chDescs []*ChannelDescriptor, onReceive receiveCbFunc, onError errorCbFunc, config *MConnConfig) *MConnection {\n\tmconn := &MConnection{\n\t\tconn:        conn,\n\t\tbufReader:   bufio.NewReaderSize(conn, minReadBufferSize),\n\t\tbufWriter:   bufio.NewWriterSize(conn, minWriteBufferSize),\n\t\tsendMonitor: flow.New(0, 0),\n\t\trecvMonitor: flow.New(0, 0),\n\t\tsend:        make(chan struct{}, 1),\n\t\tpong:        make(chan struct{}),\n\t\tonReceive:   onReceive,\n\t\tonError:     onError,\n\t\tconfig:      config,\n\n\t\tLocalAddress:  NewNetAddress(conn.LocalAddr()),\n\t\tRemoteAddress: NewNetAddress(conn.RemoteAddr()),\n\t}\n\n\t// Create channels\n\tvar channelsIdx = map[byte]*Channel{}\n\tvar channels = []*Channel{}\n\n\tfor _, desc := range chDescs {\n\t\tdescCopy := *desc // copy the desc else unsafe access across connections\n\t\tchannel := newChannel(mconn, &descCopy)\n\t\tchannelsIdx[channel.id] = channel\n\t\tchannels = append(channels, channel)\n\t}\n\tmconn.channels = channels\n\tmconn.channelsIdx = channelsIdx\n\n\tmconn.BaseService = *cmn.NewBaseService(log, \"MConnection\", mconn)\n\n\treturn mconn\n}"
        ],
        [
            "func (c *MConnection) _recover() {\n\tif r := recover(); r != nil {\n\t\tstack := debug.Stack()\n\t\terr := cmn.StackError{r, stack}\n\t\tc.stopForError(err)\n\t}\n}"
        ],
        [
            "func (c *MConnection) Send(chID byte, msg interface{}) bool {\n\tif !c.IsRunning() {\n\t\treturn false\n\t}\n\n\tlog.Debug(\"Send\", \"channel\", chID, \"conn\", c, \"msg\", msg) //, \"bytes\", wire.BinaryBytes(msg))\n\n\t// Send message to channel.\n\tchannel, ok := c.channelsIdx[chID]\n\tif !ok {\n\t\tlog.Error(cmn.Fmt(\"Cannot send bytes, unknown channel %X\", chID))\n\t\treturn false\n\t}\n\n\tsuccess := channel.sendBytes(wire.BinaryBytes(msg))\n\tif success {\n\t\t// Wake up sendRoutine if necessary\n\t\tselect {\n\t\tcase c.send <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t} else {\n\t\tlog.Warn(\"Send failed\", \"channel\", chID, \"conn\", c, \"msg\", msg)\n\t}\n\treturn success\n}"
        ],
        [
            "func (c *MConnection) TrySend(chID byte, msg interface{}) bool {\n\tif !c.IsRunning() {\n\t\treturn false\n\t}\n\n\tlog.Debug(\"TrySend\", \"channel\", chID, \"conn\", c, \"msg\", msg)\n\n\t// Send message to channel.\n\tchannel, ok := c.channelsIdx[chID]\n\tif !ok {\n\t\tlog.Error(cmn.Fmt(\"Cannot send bytes, unknown channel %X\", chID))\n\t\treturn false\n\t}\n\n\tok = channel.trySendBytes(wire.BinaryBytes(msg))\n\tif ok {\n\t\t// Wake up sendRoutine if necessary\n\t\tselect {\n\t\tcase c.send <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n\n\treturn ok\n}"
        ],
        [
            "func (c *MConnection) CanSend(chID byte) bool {\n\tif !c.IsRunning() {\n\t\treturn false\n\t}\n\n\tchannel, ok := c.channelsIdx[chID]\n\tif !ok {\n\t\tlog.Error(cmn.Fmt(\"Unknown channel %X\", chID))\n\t\treturn false\n\t}\n\treturn channel.canSend()\n}"
        ],
        [
            "func (c *MConnection) sendRoutine() {\n\tdefer c._recover()\n\nFOR_LOOP:\n\tfor {\n\t\tvar n int\n\t\tvar err error\n\t\tselect {\n\t\tcase <-c.flushTimer.Ch:\n\t\t\t// NOTE: flushTimer.Set() must be called every time\n\t\t\t// something is written to .bufWriter.\n\t\t\tc.flush()\n\t\tcase <-c.chStatsTimer.Ch:\n\t\t\tfor _, channel := range c.channels {\n\t\t\t\tchannel.updateStats()\n\t\t\t}\n\t\tcase <-c.pingTimer.Ch:\n\t\t\tlog.Debug(\"Send Ping\")\n\t\t\twire.WriteByte(packetTypePing, c.bufWriter, &n, &err)\n\t\t\tc.sendMonitor.Update(int(n))\n\t\t\tc.flush()\n\t\tcase <-c.pong:\n\t\t\tlog.Debug(\"Send Pong\")\n\t\t\twire.WriteByte(packetTypePong, c.bufWriter, &n, &err)\n\t\t\tc.sendMonitor.Update(int(n))\n\t\t\tc.flush()\n\t\tcase <-c.quit:\n\t\t\tbreak FOR_LOOP\n\t\tcase <-c.send:\n\t\t\t// Send some msgPackets\n\t\t\teof := c.sendSomeMsgPackets()\n\t\t\tif !eof {\n\t\t\t\t// Keep sendRoutine awake.\n\t\t\t\tselect {\n\t\t\t\tcase c.send <- struct{}{}:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !c.IsRunning() {\n\t\t\tbreak FOR_LOOP\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Warn(\"Connection failed @ sendRoutine\", \"conn\", c, \"error\", err)\n\t\t\tc.stopForError(err)\n\t\t\tbreak FOR_LOOP\n\t\t}\n\t}\n\n\t// Cleanup\n}"
        ],
        [
            "func (c *MConnection) sendSomeMsgPackets() bool {\n\t// Block until .sendMonitor says we can write.\n\t// Once we're ready we send more than we asked for,\n\t// but amortized it should even out.\n\tc.sendMonitor.Limit(maxMsgPacketTotalSize, atomic.LoadInt64(&c.config.SendRate), true)\n\n\t// Now send some msgPackets.\n\tfor i := 0; i < numBatchMsgPackets; i++ {\n\t\tif c.sendMsgPacket() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"
        ],
        [
            "func (c *MConnection) sendMsgPacket() bool {\n\t// Choose a channel to create a msgPacket from.\n\t// The chosen channel will be the one whose recentlySent/priority is the least.\n\tvar leastRatio float32 = math.MaxFloat32\n\tvar leastChannel *Channel\n\tfor _, channel := range c.channels {\n\t\t// If nothing to send, skip this channel\n\t\tif !channel.isSendPending() {\n\t\t\tcontinue\n\t\t}\n\t\t// Get ratio, and keep track of lowest ratio.\n\t\tratio := float32(channel.recentlySent) / float32(channel.priority)\n\t\tif ratio < leastRatio {\n\t\t\tleastRatio = ratio\n\t\t\tleastChannel = channel\n\t\t}\n\t}\n\n\t// Nothing to send?\n\tif leastChannel == nil {\n\t\treturn true\n\t} else {\n\t\t// log.Info(\"Found a msgPacket to send\")\n\t}\n\n\t// Make & send a msgPacket from this channel\n\tn, err := leastChannel.writeMsgPacketTo(c.bufWriter)\n\tif err != nil {\n\t\tlog.Warn(\"Failed to write msgPacket\", \"error\", err)\n\t\tc.stopForError(err)\n\t\treturn true\n\t}\n\tc.sendMonitor.Update(int(n))\n\tc.flushTimer.Set()\n\treturn false\n}"
        ],
        [
            "func (ch *Channel) nextMsgPacket() msgPacket {\n\tpacket := msgPacket{}\n\tpacket.ChannelID = byte(ch.id)\n\tpacket.Bytes = ch.sending[:cmn.MinInt(maxMsgPacketPayloadSize, len(ch.sending))]\n\tif len(ch.sending) <= maxMsgPacketPayloadSize {\n\t\tpacket.EOF = byte(0x01)\n\t\tch.sending = nil\n\t\tatomic.AddInt32(&ch.sendQueueSize, -1) // decrement sendQueueSize\n\t} else {\n\t\tpacket.EOF = byte(0x00)\n\t\tch.sending = ch.sending[cmn.MinInt(maxMsgPacketPayloadSize, len(ch.sending)):]\n\t}\n\treturn packet\n}"
        ],
        [
            "func (ch *Channel) writeMsgPacketTo(w io.Writer) (n int, err error) {\n\tpacket := ch.nextMsgPacket()\n\tlog.Debug(\"Write Msg Packet\", \"conn\", ch.conn, \"packet\", packet)\n\twire.WriteByte(packetTypeMsg, w, &n, &err)\n\twire.WriteBinary(packet, w, &n, &err)\n\tif err == nil {\n\t\tch.recentlySent += int64(n)\n\t}\n\treturn\n}"
        ],
        [
            "func (ch *Channel) recvMsgPacket(packet msgPacket) ([]byte, error) {\n\t// log.Debug(\"Read Msg Packet\", \"conn\", ch.conn, \"packet\", packet)\n\tif ch.desc.RecvMessageCapacity < len(ch.recving)+len(packet.Bytes) {\n\t\treturn nil, wire.ErrBinaryReadOverflow\n\t}\n\tch.recving = append(ch.recving, packet.Bytes...)\n\tif packet.EOF == byte(0x01) {\n\t\tmsgBytes := ch.recving\n\t\t// clear the slice without re-allocating.\n\t\t// http://stackoverflow.com/questions/16971741/how-do-you-clear-a-slice-in-go\n\t\t//   suggests this could be a memory leak, but we might as well keep the memory for the channel until it closes,\n\t\t//\tat which point the recving slice stops being used and should be garbage collected\n\t\tch.recving = ch.recving[:0] // make([]byte, 0, ch.desc.RecvBufferCapacity)\n\t\treturn msgBytes, nil\n\t}\n\treturn nil, nil\n}"
        ],
        [
            "func hash24(input []byte) (res *[24]byte) {\n\thasher := ripemd160.New()\n\thasher.Write(input) // does not error\n\tresSlice := hasher.Sum(nil)\n\tres = new([24]byte)\n\tcopy(res[:], resSlice)\n\treturn\n}"
        ],
        [
            "func incrNonce(nonce *[24]byte) {\n\tfor i := 23; 0 <= i; i-- {\n\t\tnonce[i] += 1\n\t\tif nonce[i] != 0 {\n\t\t\treturn\n\t\t}\n\t}\n}"
        ],
        [
            "func (ps *PeerSet) List() []*Peer {\n\tps.mtx.Lock()\n\tdefer ps.mtx.Unlock()\n\treturn ps.list\n}"
        ],
        [
            "func (l *DefaultListener) listenRoutine() {\n\tfor {\n\t\tconn, err := l.listener.Accept()\n\n\t\tif !l.IsRunning() {\n\t\t\tbreak // Go to cleanup\n\t\t}\n\n\t\t// listener wasn't stopped,\n\t\t// yet we encountered an error.\n\t\tif err != nil {\n\t\t\tPanicCrisis(err)\n\t\t}\n\n\t\tl.connections <- conn\n\t}\n\n\t// Cleanup\n\tclose(l.connections)\n\tfor _ = range l.connections {\n\t\t// Drain\n\t}\n}"
        ],
        [
            "func NewAddrBook(filePath string, routabilityStrict bool) *AddrBook {\n\tam := &AddrBook{\n\t\trand:              rand.New(rand.NewSource(time.Now().UnixNano())),\n\t\tourAddrs:          make(map[string]*NetAddress),\n\t\taddrLookup:        make(map[string]*knownAddress),\n\t\tfilePath:          filePath,\n\t\troutabilityStrict: routabilityStrict,\n\t}\n\tam.init()\n\tam.BaseService = *NewBaseService(log, \"AddrBook\", am)\n\treturn am\n}"
        ],
        [
            "func (a *AddrBook) OnStart() error {\n\ta.BaseService.OnStart()\n\ta.loadFromFile(a.filePath)\n\ta.wg.Add(1)\n\tgo a.saveRoutine()\n\treturn nil\n}"
        ],
        [
            "func (a *AddrBook) RemoveAddress(addr *NetAddress) {\n\ta.mtx.Lock()\n\tdefer a.mtx.Unlock()\n\tka := a.addrLookup[addr.String()]\n\tif ka == nil {\n\t\treturn\n\t}\n\tlog.Info(\"Remove address from book\", \"addr\", addr)\n\ta.removeFromAllBuckets(ka)\n}"
        ],
        [
            "func (a *AddrBook) loadFromFile(filePath string) bool {\n\t// If doesn't exist, do nothing.\n\t_, err := os.Stat(filePath)\n\tif os.IsNotExist(err) {\n\t\treturn false\n\t}\n\n\t// Load addrBookJSON{}\n\tr, err := os.Open(filePath)\n\tif err != nil {\n\t\tPanicCrisis(Fmt(\"Error opening file %s: %v\", filePath, err))\n\t}\n\tdefer r.Close()\n\taJSON := &addrBookJSON{}\n\tdec := json.NewDecoder(r)\n\terr = dec.Decode(aJSON)\n\tif err != nil {\n\t\tPanicCrisis(Fmt(\"Error reading file %s: %v\", filePath, err))\n\t}\n\n\t// Restore all the fields...\n\t// Restore the key\n\ta.key = aJSON.Key\n\t// Restore .addrNew & .addrOld\n\tfor _, ka := range aJSON.Addrs {\n\t\tfor _, bucketIndex := range ka.Buckets {\n\t\t\tbucket := a.getBucket(ka.BucketType, bucketIndex)\n\t\t\tbucket[ka.Addr.String()] = ka\n\t\t}\n\t\ta.addrLookup[ka.Addr.String()] = ka\n\t\tif ka.BucketType == bucketTypeNew {\n\t\t\ta.nNew++\n\t\t} else {\n\t\t\ta.nOld++\n\t\t}\n\t}\n\treturn true\n}"
        ],
        [
            "func (a *AddrBook) Save() {\n\tlog.Info(\"Saving AddrBook to file\", \"size\", a.Size())\n\ta.saveToFile(a.filePath)\n}"
        ],
        [
            "func (a *AddrBook) addToOldBucket(ka *knownAddress, bucketIdx int) bool {\n\t// Sanity check\n\tif ka.isNew() {\n\t\tlog.Warn(Fmt(\"Cannot add new address to old bucket: %v\", ka))\n\t\treturn false\n\t}\n\tif len(ka.Buckets) != 0 {\n\t\tlog.Warn(Fmt(\"Cannot add already old address to another old bucket: %v\", ka))\n\t\treturn false\n\t}\n\n\taddrStr := ka.Addr.String()\n\tbucket := a.getBucket(bucketTypeNew, bucketIdx)\n\n\t// Already exists?\n\tif _, ok := bucket[addrStr]; ok {\n\t\treturn true\n\t}\n\n\t// Enforce max addresses.\n\tif len(bucket) > oldBucketSize {\n\t\treturn false\n\t}\n\n\t// Add to bucket.\n\tbucket[addrStr] = ka\n\tif ka.addBucketRef(bucketIdx) == 1 {\n\t\ta.nOld++\n\t}\n\n\t// Ensure in addrLookup\n\ta.addrLookup[addrStr] = ka\n\n\treturn true\n}"
        ],
        [
            "func (a *AddrBook) expireNew(bucketIdx int) {\n\tfor addrStr, ka := range a.addrNew[bucketIdx] {\n\t\t// If an entry is bad, throw it away\n\t\tif ka.isBad() {\n\t\t\tlog.Notice(Fmt(\"expiring bad address %v\", addrStr))\n\t\t\ta.removeFromBucket(ka, bucketTypeNew, bucketIdx)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// If we haven't thrown out a bad entry, throw out the oldest entry\n\toldest := a.pickOldest(bucketTypeNew, bucketIdx)\n\ta.removeFromBucket(oldest, bucketTypeNew, bucketIdx)\n}"
        ],
        [
            "func (sw *Switch) DialSeeds(addrBook *AddrBook, seeds []string) error {\n\n\tnetAddrs, err := NewNetAddressStrings(seeds)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif addrBook != nil {\n\t\t// add seeds to `addrBook`\n\t\tourAddrS := sw.nodeInfo.ListenAddr\n\t\tourAddr, _ := NewNetAddressString(ourAddrS)\n\t\tfor _, netAddr := range netAddrs {\n\t\t\t// do not add ourselves\n\t\t\tif netAddr.Equals(ourAddr) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\taddrBook.AddAddress(netAddr, ourAddr)\n\t\t}\n\t\taddrBook.Save()\n\t}\n\n\t// permute the list, dial them in random order.\n\tperm := rand.Perm(len(netAddrs))\n\tfor i := 0; i < len(perm); i++ {\n\t\tgo func(i int) {\n\t\t\ttime.Sleep(time.Duration(rand.Int63n(3000)) * time.Millisecond)\n\t\t\tj := perm[i]\n\t\t\tsw.dialSeed(netAddrs[j])\n\t\t}(i)\n\t}\n\treturn nil\n}"
        ],
        [
            "func NewNetAddressStrings(addrs []string) ([]*NetAddress, error) {\n\tnetAddrs := make([]*NetAddress, len(addrs))\n\tfor i, addr := range addrs {\n\t\tnetAddr, err := NewNetAddressString(addr)\n\t\tif err != nil {\n\t\t\treturn nil, errors.New(cmn.Fmt(\"Error in address %s: %v\", addr, err))\n\t\t}\n\t\tnetAddrs[i] = netAddr\n\t}\n\treturn netAddrs, nil\n}"
        ],
        [
            "func NewNetAddressIPPort(ip net.IP, port uint16) *NetAddress {\n\tna := &NetAddress{\n\t\tIP:   ip,\n\t\tPort: port,\n\t\tstr: net.JoinHostPort(\n\t\t\tip.String(),\n\t\t\tstrconv.FormatUint(uint64(port), 10),\n\t\t),\n\t}\n\treturn na\n}"
        ],
        [
            "func (na *NetAddress) Equals(other interface{}) bool {\n\tif o, ok := other.(*NetAddress); ok {\n\t\treturn na.String() == o.String()\n\t}\n\n\treturn false\n}"
        ],
        [
            "func (na *NetAddress) Dial() (net.Conn, error) {\n\tconn, err := net.Dial(\"tcp\", na.String())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}"
        ],
        [
            "func (na *NetAddress) Valid() bool {\n\treturn na.IP != nil && !(na.IP.IsUnspecified() || na.RFC3849() ||\n\t\tna.IP.Equal(net.IPv4bcast))\n}"
        ],
        [
            "func (na *NetAddress) ReachabilityTo(o *NetAddress) int {\n\tconst (\n\t\tUnreachable = 0\n\t\tDefault     = iota\n\t\tTeredo\n\t\tIpv6_weak\n\t\tIpv4\n\t\tIpv6_strong\n\t\tPrivate\n\t)\n\tif !na.Routable() {\n\t\treturn Unreachable\n\t} else if na.RFC4380() {\n\t\tif !o.Routable() {\n\t\t\treturn Default\n\t\t} else if o.RFC4380() {\n\t\t\treturn Teredo\n\t\t} else if o.IP.To4() != nil {\n\t\t\treturn Ipv4\n\t\t} else { // ipv6\n\t\t\treturn Ipv6_weak\n\t\t}\n\t} else if na.IP.To4() != nil {\n\t\tif o.Routable() && o.IP.To4() != nil {\n\t\t\treturn Ipv4\n\t\t}\n\t\treturn Default\n\t} else /* ipv6 */ {\n\t\tvar tunnelled bool\n\t\t// Is our v6 is tunnelled?\n\t\tif o.RFC3964() || o.RFC6052() || o.RFC6145() {\n\t\t\ttunnelled = true\n\t\t}\n\t\tif !o.Routable() {\n\t\t\treturn Default\n\t\t} else if o.RFC4380() {\n\t\t\treturn Teredo\n\t\t} else if o.IP.To4() != nil {\n\t\t\treturn Ipv4\n\t\t} else if tunnelled {\n\t\t\t// only prioritise ipv6 if we aren't tunnelling it.\n\t\t\treturn Ipv6_weak\n\t\t}\n\t\treturn Ipv6_strong\n\t}\n}"
        ],
        [
            "func NewPEXReactor(b *AddrBook) *PEXReactor {\n\tr := &PEXReactor{\n\t\tbook:              b,\n\t\tensurePeersPeriod: defaultEnsurePeersPeriod,\n\t\tmsgCountByPeer:    cmn.NewCMap(),\n\t\tmaxMsgCountByPeer: defaultMaxMsgCountByPeer,\n\t}\n\tr.BaseReactor = *NewBaseReactor(log, \"PEXReactor\", r)\n\treturn r\n}"
        ],
        [
            "func (r *PEXReactor) OnStart() error {\n\tr.BaseReactor.OnStart()\n\tr.book.Start()\n\tgo r.ensurePeersRoutine()\n\tgo r.flushMsgCountByPeer()\n\treturn nil\n}"
        ],
        [
            "func (r *PEXReactor) Receive(chID byte, src *Peer, msgBytes []byte) {\n\tsrcAddr := src.Connection().RemoteAddress\n\tsrcAddrStr := srcAddr.String()\n\n\tr.IncrementMsgCountForPeer(srcAddrStr)\n\tif r.ReachedMaxMsgCountForPeer(srcAddrStr) {\n\t\tlog.Warn(\"Maximum number of messages reached for peer\", \"peer\", srcAddrStr)\n\t\t// TODO remove src from peers?\n\t\treturn\n\t}\n\n\t_, msg, err := DecodeMessage(msgBytes)\n\tif err != nil {\n\t\tlog.Warn(\"Error decoding message\", \"error\", err)\n\t\treturn\n\t}\n\tlog.Notice(\"Received message\", \"msg\", msg)\n\n\tswitch msg := msg.(type) {\n\tcase *pexRequestMessage:\n\t\t// src requested some peers.\n\t\tr.SendAddrs(src, r.book.GetSelection())\n\tcase *pexAddrsMessage:\n\t\t// We received some peer addresses from src.\n\t\t// (We don't want to get spammed with bad peers)\n\t\tfor _, addr := range msg.Addrs {\n\t\t\tif addr != nil {\n\t\t\t\tr.book.AddAddress(addr, srcAddr)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tlog.Warn(fmt.Sprintf(\"Unknown message type %v\", reflect.TypeOf(msg)))\n\t}\n}"
        ],
        [
            "func (r *PEXReactor) RequestPEX(p *Peer) {\n\tp.Send(PexChannel, struct{ PexMessage }{&pexRequestMessage{}})\n}"
        ],
        [
            "func (r *PEXReactor) SendAddrs(p *Peer, addrs []*NetAddress) {\n\tp.Send(PexChannel, struct{ PexMessage }{&pexAddrsMessage{Addrs: addrs}})\n}"
        ],
        [
            "func (r *PEXReactor) IncrementMsgCountForPeer(addr string) {\n\tvar count uint16\n\tcountI := r.msgCountByPeer.Get(addr)\n\tif countI != nil {\n\t\tcount = countI.(uint16)\n\t}\n\tcount++\n\tr.msgCountByPeer.Set(addr, count)\n}"
        ],
        [
            "func DecodeMessage(bz []byte) (msgType byte, msg PexMessage, err error) {\n\tmsgType = bz[0]\n\tn := new(int)\n\tr := bytes.NewReader(bz)\n\tmsg = wire.ReadBinary(struct{ PexMessage }{}, r, maxPexMessageSize, n, &err).(struct{ PexMessage }).PexMessage\n\treturn\n}"
        ],
        [
            "func NewReader(r io.Reader) *Reader {\n\treturn &Reader{\n\t\tReader: csv.NewReader(r),\n\t}\n}"
        ],
        [
            "func LogOnPanic(id int64, err interface{}, stacktrace []string, _ *http.Request) {\n\tlogMutex.Lock()\n\tdefer logMutex.Unlock()\n\n\tlog.Printf(\"panic=%016x message=%v\\n\", id, err)\n\tfor _, line := range stacktrace {\n\t\tlog.Printf(\"panic=%016x %s\", id, line)\n\t}\n}"
        ],
        [
            "func Wrap(h http.Handler, onPanic PanicHandler) http.Handler {\n\treturn &recoveryHandler{h: h, p: onPanic}\n}"
        ],
        [
            "func (al *LoggingHandler) Start() {\n\tgo func() {\n\t\tfor s := range al.buffer {\n\t\t\tfmt.Fprint(al.w, s)\n\t\t}\n\t\tclose(al.quit)\n\t}()\n}"
        ],
        [
            "func New(h http.Handler, onPanic recovery.PanicHandler) Service {\n\tl := logging.Wrap(\n\t\trecovery.Wrap(\n\t\t\tdebug.Wrap(\n\t\t\t\tmetrics.Wrap(\n\t\t\t\t\th,\n\t\t\t\t),\n\t\t\t),\n\t\t\tonPanic,\n\t\t),\n\t\tos.Stdout,\n\t)\n\tl.Start()\n\treturn Service{h: l}\n}"
        ],
        [
            "func (v *X509NameVerifier) Wrap(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdn := r.Header.Get(v.HeaderName)\n\n\t\tvar name *pkix.Name\n\t\tif dn != \"\" {\n\t\t\tname = parseDN(dn)\n\t\t}\n\n\t\tif name != nil && v.CheckCertificate(name) {\n\t\t\th.ServeHTTP(w, r)\n\t\t} else if v.InvalidHandler != nil {\n\t\t\tv.InvalidHandler.ServeHTTP(w, r)\n\t\t} else {\n\t\t\tlog.Printf(\"Rejected request with an invalid client certificate: %q\", dn)\n\t\t\tw.WriteHeader(403)\n\t\t}\n\t})\n}"
        ],
        [
            "func (c HubConfig) GetString(key string, defval string) string {\n\tval, ok := c[key]\n\tif ok {\n\t\ts, ok := val.(string)\n\t\tif ok && len(s) > 0 {\n\t\t\treturn s\n\t\t}\n\t\t// TODO only primitive types\n\t\treturn fmt.Sprintf(\"%s\", val)\n\t}\n\treturn defval\n}"
        ],
        [
            "func (c HubConfig) GetInt(key string, defval int) int {\n\tval, ok := c[key]\n\tif ok {\n\t\ti, ok := val.(int)\n\t\tif ok {\n\t\t\treturn i\n\t\t}\n\t\ts := c.GetString(key, \"\")\n\t\tif len(s) > 0 {\n\t\t\ti, err := strconv.Atoi(s)\n\t\t\tif err != nil {\n\t\t\t\t// TODO handling error on app level\n\t\t\t\treturn defval\n\t\t\t}\n\t\t\treturn i\n\t\t}\n\t}\n\treturn defval\n}"
        ],
        [
            "func RegisterDriver(d Driver, knownNames ...string) {\n\tfor _, k := range knownNames {\n\t\tdrivers[strings.ToLower(k)] = d\n\t}\n\tlog.Info(\"registered pubsub driver: %v\", knownNames)\n}"
        ],
        [
            "func Open(URL ...string) (pubsub.Hub, error) {\n\tredisURL := getRedisURL(URL...)\n\tconn, err := redisurl.ConnectToURL(redisURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &hub{\n\t\tconn:     conn,\n\t\tredisURL: redisURL,\n\t\tsubs:     make(map[*sub]struct{}),\n\t}, nil\n}"
        ],
        [
            "func SendEvents(w http.ResponseWriter, r *http.Request, channels []string) {\n\t// make sure that the writer supports flushing\n\tflusher, ok := w.(http.Flusher)\n\n\tif !ok {\n\t\tlog.Error(\"current response %T does not implement http.Flusher, plase check your middlewares that wraps response\", w)\n\t\thttp.Error(w, \"streaming unsupported\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tcloseNotifier, ok := w.(http.CloseNotifier)\n\tif !ok {\n\t\tlog.Error(\"current response %T does not implement http.CloseNotifier, plase check your middlewares that wraps response\", w)\n\t\thttp.Error(w, \"streaming unsupported\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tsub, err := pubsub.Subscribe(channels)\n\tif err != nil {\n\t\tlog.Error(\"subscribe failed: %v\", err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// set the headers related to event streaming\n\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n\tw.Header().Set(\"Cache-Control\", \"no-cache\")\n\tw.Header().Set(\"Connection\", \"keep-alive\")\n\n\t// channel to send data to client\n\tvar send = make(chan []byte)\n\tvar closeConn = closeNotifier.CloseNotify()\n\tvar heartbeatTicker = time.NewTicker(10 * time.Second) // TODO get from config\n\tvar heatbeat = []byte{}\n\n\tvar stop = func() {\n\t\tlog.Info(\"SSE streaming stopped\")\n\t\theartbeatTicker.Stop()\n\t\tsub.Close()\n\t\tclose(send)\n\t}\n\n\t// goroutine to listen all room events\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tlog.Error(\"recovered from panic: %+v\", err)\n\t\t\t\tdebug.PrintStack()\n\t\t\t}\n\t\t}()\n\n\t\tlog.Info(\"SSE streaming started\")\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase msg := <-sub.Read():\n\t\t\t\tvar err error\n\t\t\t\tvar data, ok = msg.([]byte)\n\t\t\t\tif !ok {\n\t\t\t\t\tdata, err = json.Marshal(msg)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// TODO should we ignore error messages?\n\t\t\t\t\t\tlog.Error(\"json.Marshal failed with: %+v\", err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif len(data) == 0 {\n\t\t\t\t\tlog.Warning(\"empty message is not allowed\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsend <- data\n\t\t\t// listen to connection close and un-register message channel\n\t\t\tcase <-sub.CloseNotify():\n\t\t\t\tlog.Info(\"subscription closed\")\n\t\t\t\tstop()\n\t\t\t\treturn\n\t\t\tcase <-closeConn:\n\t\t\t\tstop()\n\t\t\t\treturn\n\t\t\tcase <-heartbeatTicker.C:\n\t\t\t\tsend <- heatbeat\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tvar data, ok = <-send\n\t\tif !ok {\n\t\t\tlog.Info(\"connection closed, stop streaming of %v\", channels)\n\t\t\treturn\n\t\t}\n\n\t\tif len(data) == 0 {\n\t\t\tfmt.Fprint(w, \":heartbeat signal\\n\\n\")\n\t\t} else {\n\t\t\tfmt.Fprintf(w, \"data: %s\\n\\n\", data)\n\t\t}\n\n\t\tflusher.Flush()\n\t}\n}"
        ],
        [
            "func Unmarshal(data []byte) (interface{}, error) {\n\tvar msg map[string]interface{}\n\terr := json.Unmarshal(data, &msg)\n\tif err != nil {\n\t\tlog.Errorf(\"json.Unmarshal failed: %+v\", err)\n\t\treturn nil, err\n\t}\n\treturn msg, nil\n}"
        ],
        [
            "func (hub *hub) Publish(channels []string, msg interface{}) {\n\tfor _, name := range channels {\n\t\tvar cn = hub.getChannel(name)\n\t\tcn.Publish(msg)\n\t}\n}"
        ],
        [
            "func (hub *hub) Subscribe(channels []string) (Channel, error) {\n\tvar chans []*channel\n\tfor _, name := range channels {\n\t\tchans = append(chans, hub.getChannel(name))\n\t}\n\tvar sub = makeSub(chans)\n\tfor _, cn := range chans {\n\t\tcn.Subscribe(sub)\n\t}\n\treturn sub, nil\n}"
        ],
        [
            "func (hub *hub) getChannel(name string) *channel {\n\thub.Lock()\n\tdefer hub.Unlock()\n\tcn, ok := hub.channels[name]\n\tif ok {\n\t\treturn cn\n\t}\n\tcn = makeChannel(hub, name)\n\thub.channels[name] = cn\n\tgo cn.start()\n\treturn cn\n}"
        ],
        [
            "func (hub *hub) remove(cn *channel) {\n\thub.Lock()\n\tdefer hub.Unlock()\n\tcn, ok := hub.channels[cn.name]\n\tif !ok {\n\t\treturn\n\t}\n\tdelete(hub.channels, cn.name)\n\treturn\n}"
        ],
        [
            "func Open(URL ...string) (pubsub.Hub, error) {\n\tif len(URL) == 0 {\n\t\tURL = []string{nats.DefaultURL}\n\t}\n\n\tlog.Info(\"connecting to nats hub: %v\", URL)\n\n\tconn, err := nats.Connect(URL[0])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &hub{\n\t\tconn: conn,\n\t\tsubs: make(map[*sub]struct{}),\n\t}, nil\n}"
        ],
        [
            "func Publish(channels []string, msg interface{}) error {\n\tif hubInstance == nil {\n\t\treturn errorNohub\n\t}\n\tlog.Debug(\"publish to %v\", channels)\n\thubInstance.Publish(channels, msg)\n\treturn nil\n}"
        ],
        [
            "func Subscribe(channels []string) (Channel, error) {\n\tif hubInstance == nil {\n\t\treturn nil, errorNohub\n\t}\n\tr, err := hubInstance.Subscribe(channels)\n\tif err != nil {\n\t\tlog.Errorf(\"pubsub subscribe failed: %+v\", err)\n\t\treturn nil, err\n\t}\n\tlog.Debug(\"subscibe to %v\", channels)\n\treturn r, nil\n}"
        ],
        [
            "func MakeHub(config HubConfig) (Hub, error) {\n\tif config == nil {\n\t\treturn NewHub(), nil\n\t}\n\n\tdriverName := getDriverName(config)\n\tif len(driverName) == 0 {\n\t\treturn nil, fmt.Errorf(\"driver name is not specified\")\n\t}\n\td, ok := drivers[driverName]\n\tif ok {\n\t\th, err := d.Create(config)\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"unable to connect to %s pubsub server: %+v\", driverName, err)\n\t\t\treturn nil, err\n\t\t}\n\t\tlog.Info(\"connected to %s pubsub\", driverName)\n\t\treturn h, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"unknown driver: %s\", driverName)\n}"
        ],
        [
            "func Fib() func() time.Duration {\n\ta, b := 0, 1\n\treturn func() time.Duration {\n\t\ta, b = b, a+b\n\t\treturn time.Duration(a*10) * time.Millisecond\n\t}\n}"
        ],
        [
            "func roundIndex(start, max int) []int {\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tresult := make([]int, max)\n\tfor i := 0; i < max; i++ {\n\t\tif start+i < max {\n\t\t\tresult[i] = start + i\n\t\t} else {\n\t\t\tresult[i] = int(math.Abs(float64(max - (start + i))))\n\t\t}\n\t}\n\treturn result\n}"
        ],
        [
            "func Dir() (string, error) {\n\tcurrentUser, err := user.Current()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif currentUser.HomeDir == \"\" {\n\t\treturn \"\", errors.New(\"cannot find user-specific home dir\")\n\t}\n\n\treturn currentUser.HomeDir, nil\n}"
        ],
        [
            "func (s *Session) Ask(question string) (string, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.Values.Set(\"input\", question)\n\t// Clear previous json, just in case\n\ts.clear()\n\t// Prepare the request.\n\treq, err := http.NewRequest(\"GET\", apiURL+s.Values.Encode(), nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Headers.\n\treq.Header.Set(\"User-Agent\", \"cleverbot-go https://github.com/ugjka/cleverbot-go\")\n\n\t// Make the request\n\tresp, err := s.Client.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\t// Check for errors.\n\tswitch resp.StatusCode {\n\tcase http.StatusUnauthorized:\n\t\tErrKeyNotValid.origin = fmt.Sprintf(\"status code %d\", resp.StatusCode)\n\t\treturn \"\", ErrKeyNotValid\n\tcase http.StatusNotFound:\n\t\tErrAPINotFound.origin = fmt.Sprintf(\"status code %d\", resp.StatusCode)\n\t\treturn \"\", ErrAPINotFound\n\tcase http.StatusRequestEntityTooLarge:\n\t\tErrRequestTooLarge.origin = fmt.Sprintf(\"status code %d\", resp.StatusCode)\n\t\treturn \"\", ErrRequestTooLarge\n\tcase http.StatusBadGateway:\n\t\tErrNoReply.origin = fmt.Sprintf(\"status code %d\", resp.StatusCode)\n\t\treturn \"\", ErrNoReply\n\tcase http.StatusGatewayTimeout:\n\t\tErrNoReply.origin = fmt.Sprintf(\"status code %d\", resp.StatusCode)\n\t\treturn \"\", ErrNoReply\n\tcase http.StatusServiceUnavailable:\n\t\tErrTooManyRequests.origin = fmt.Sprintf(\"status code %d\", resp.StatusCode)\n\t\treturn \"\", ErrTooManyRequests\n\tdefault:\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tErrStatusNotOK.origin = fmt.Sprintf(\"status code %d\", resp.StatusCode)\n\t\t\treturn \"\", ErrStatusNotOK\n\t\t}\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(&s.Decoded); err != nil {\n\t\tErrInvalidJSON.origin = err.Error()\n\t\treturn \"\", ErrInvalidJSON\n\t}\n\tif _, ok := s.Decoded[\"output\"].(string); !ok {\n\t\treturn \"\", fmt.Errorf(\"Cleverbot API: 'output' does not exist or is not a string\")\n\t}\n\tif _, ok := s.Decoded[\"cs\"].(string); !ok {\n\t\treturn \"\", fmt.Errorf(\"Cleverbot API: 'cs' does not exist or is not a string\")\n\t}\n\t// Set session context id.\n\ts.Values.Set(\"cs\", s.Decoded[\"cs\"].(string))\n\n\treturn s.Decoded[\"output\"].(string), nil\n}"
        ],
        [
            "func (s *Session) InteractionCount() int {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif v, ok := s.Decoded[\"interaction_count\"].(string); ok {\n\t\tif count, err := strconv.Atoi(v); err == nil {\n\t\t\treturn count\n\t\t}\n\t}\n\treturn -1\n}"
        ],
        [
            "func (s *Session) TimeElapsed() time.Duration {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif v, ok := s.Decoded[\"time_elapsed\"].(string); ok {\n\t\tif dur, err := time.ParseDuration(v + \"s\"); err == nil {\n\t\t\treturn dur\n\t\t}\n\t}\n\treturn time.Second * -1\n}"
        ],
        [
            "func (s *Session) History() QAPairs {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tvar qa []QAPair\n\tfor i := 1; ; i++ {\n\t\tif v, ok := s.Decoded[fmt.Sprintf(\"interaction_%d_other\", i)].(string); ok && v != \"\" {\n\t\t\tqa = append([]QAPair{{s.Decoded[fmt.Sprintf(\"interaction_%d\", i)].(string),\n\t\t\t\ts.Decoded[fmt.Sprintf(\"interaction_%d_other\", i)].(string)}}, qa...)\n\t\t} else {\n\t\t\treturn qa\n\t\t}\n\t}\n}"
        ],
        [
            "func (f Flags) Bool(name string) bool {\n\treturn f.C.Bool(name)\n}"
        ],
        [
            "func (f Flags) String(name string) string {\n\treturn f.C.String(name)\n}"
        ],
        [
            "func (t *T) Fail() {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.failed = true\n}"
        ],
        [
            "func (t *T) Failed() bool {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn t.failed\n}"
        ],
        [
            "func (t *T) Logf(format string, args ...interface{}) {\n\tfmt.Printf(format, args...)\n}"
        ],
        [
            "func (t *T) Error(args ...interface{}) {\n\tfmt.Fprintln(os.Stderr, args...)\n\tt.Fail()\n}"
        ],
        [
            "func (t *T) Errorf(format string, args ...interface{}) {\n\tfmt.Fprintf(os.Stderr, format, args...)\n\tt.Fail()\n}"
        ],
        [
            "func (c *Client) Init(root, auth string, api Api) {\n\tif api == nil {\n\t\tapi = new(f)\n\t}\n\n\tc.api = api\n\tc.Url = root\n\tc.Auth = auth\n}"
        ],
        [
            "func (c *Client) Value() interface{} {\n\t// if we have not yet performed a look-up, do it so a value is returned\n\tif c.value == nil {\n\t\tvar v interface{}\n\t\tc = c.Child(\"\", nil, v)\n\t}\n\n\tif c == nil {\n\t\treturn nil\n\t}\n\n\treturn c.value\n}"
        ],
        [
            "func (c *Client) Child(path string, params map[string]string, v interface{}) *Client {\n\tu := c.Url + \"/\" + path\n\n\tres, err := c.api.Call(\"GET\", u, c.Auth, nil, params)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\terr = json.Unmarshal(res, &v)\n\tif err != nil {\n\t\tlog.Printf(\"%v\\n\", err)\n\t\treturn nil\n\t}\n\n\tret := &Client{\n\t\tapi:   c.api,\n\t\tAuth:  c.Auth,\n\t\tUrl:   u,\n\t\tvalue: v}\n\n\treturn ret\n}"
        ],
        [
            "func (c *Client) Push(value interface{}, params map[string]string) (*Client, error) {\n\tbody, err := json.Marshal(value)\n\tif err != nil {\n\t\tlog.Printf(\"%v\\n\", err)\n\t\treturn nil, err\n\t}\n\n\tres, err := c.api.Call(\"POST\", c.Url, c.Auth, body, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar r map[string]string\n\n\terr = json.Unmarshal(res, &r)\n\tif err != nil {\n\t\tlog.Printf(\"%v\\n\", err)\n\t\treturn nil, err\n\t}\n\n\tret := &Client{\n\t\tapi:   c.api,\n\t\tAuth:  c.Auth,\n\t\tUrl:   c.Url + \"/\" + r[\"name\"],\n\t\tvalue: value}\n\n\treturn ret, nil\n}"
        ],
        [
            "func (c *Client) Update(path string, value interface{}, params map[string]string) error {\n\tbody, err := json.Marshal(value)\n\tif err != nil {\n\t\tlog.Printf(\"%v\\n\", err)\n\t\treturn err\n\t}\n\n\t_, err = c.api.Call(\"PATCH\", c.Url+\"/\"+path, c.Auth, body, params)\n\n\t// if we've just updated the root node, clear the value so it gets looked up\n\t// again and populated correctly since we just applied a diffgram\n\tif len(path) == 0 {\n\t\tc.value = nil\n\t}\n\n\treturn err\n}"
        ],
        [
            "func (c *Client) Remove(path string, params map[string]string) error {\n\t_, err := c.api.Call(\"DELETE\", c.Url+\"/\"+path, c.Auth, nil, params)\n\n\treturn err\n}"
        ],
        [
            "func (c *Client) Rules(params map[string]string) (Rules, error) {\n\tres, err := c.api.Call(\"GET\", c.Url+\"/.settings/rules\", c.Auth, nil, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar v Rules\n\terr = json.Unmarshal(res, &v)\n\tif err != nil {\n\t\tlog.Printf(\"%v\\n\", err)\n\t\treturn nil, err\n\t}\n\n\treturn v, nil\n}"
        ],
        [
            "func (c *Client) SetRules(rules *Rules, params map[string]string) error {\n\tbody, err := json.Marshal(rules)\n\tif err != nil {\n\t\tlog.Printf(\"%v\\n\", err)\n\t\treturn err\n\t}\n\n\t_, err = c.api.Call(\"PUT\", c.Url+\"/.settings/rules\", c.Auth, body, params)\n\n\treturn err\n}"
        ],
        [
            "func (f *f) Call(method, path, auth string, body []byte, params map[string]string) ([]byte, error) {\n\tif !strings.HasSuffix(path, \"/\") {\n\t\tpath += \"/\"\n\t}\n\n\tpath += suffix\n\tqs := url.Values{}\n\n\t// if the client has an auth, set it as a query string.\n\t// the caller can also override this on a per-call basis\n\t// which will happen via params below\n\tif len(auth) > 0 {\n\t\tqs.Set(\"auth\", auth)\n\t}\n\n\tfor k, v := range params {\n\t\tqs.Set(k, v)\n\t}\n\n\tif len(qs) > 0 {\n\t\tpath += \"?\" + qs.Encode()\n\t}\n\n\treq, err := http.NewRequest(method, path, bytes.NewReader(body))\n\tif err != nil {\n\t\tlog.Printf(\"Cannot create Firebase request: %v\\n\", err)\n\t\treturn nil, err\n\t}\n\n\treq.Close = true\n\tlog.Printf(\"Calling %v %q\\n\", method, path)\n\n\tres, err := httpClient.Do(req)\n\tif err != nil {\n\t\tlog.Printf(\"Request to Firebase failed: %v\\n\", err)\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tret, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tlog.Printf(\"Cannot parse Firebase response: %v\\n\", err)\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode >= 400 {\n\t\terr = errors.New(string(ret))\n\t\tlog.Printf(\"Error encountered from Firebase: %v\\n\", err)\n\t\treturn nil, err\n\t}\n\n\treturn ret, nil\n}"
        ],
        [
            "func (t *trace) SetTraceInfo(traceID uint64, spanID uint64) {\n\tt.trace.SetTraceInfo(traceID, spanID)\n}"
        ],
        [
            "func (t *trace) Finish() {\n\tif t.err {\n\t\tincrError(t)\n\t}\n\tincr(t)\n\tduration(t)\n\tif t.err {\n\t\tincrError(t)\n\t}\n\tt.trace.Finish()\n}"
        ],
        [
            "func ServeMetrics(ctx context.Context, l net.Listener) error {\n\treturn http.Serve(l, promhttp.Handler())\n}"
        ],
        [
            "func DumpMetrics(ctx context.Context, task string) (string, error) {\n\tgatherer := prometheus.DefaultGatherer\n\tmfs, err := gatherer.Gather()\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"gathering metrics\")\n\t}\n\n\tbuf := &bytes.Buffer{}\n\tenc := expfmt.NewEncoder(buf, expfmt.FmtText)\n\n\tfor _, mf := range mfs {\n\t\tif err := enc.Encode(mf); err != nil {\n\t\t\treturn buf.String(), errors.Wrap(err, \"encoding metrics\")\n\t\t}\n\t}\n\treturn buf.String(), nil\n}"
        ],
        [
            "func NewEventLog(family, title string) xtr.EventLog {\n\te := &EventLog{\n\t\tfamily: family,\n\t\ttitle:  title,\n\t\tel:     xtr.NewEventLog(family, title),\n\t}\n\treturn e\n}"
        ],
        [
            "func (e *EventLog) Printf(format string, a ...interface{}) {\n\tnewfmt, newvals := addEvent(e, format, a...)\n\tLog.Printf(newfmt, newvals...)\n\te.el.Printf(format, a...)\n}"
        ],
        [
            "func (e *EventLog) Errorf(format string, a ...interface{}) {\n\tLog.Printf(\"[ERROR] \"+format, a...)\n\te.el.Errorf(format, a...)\n}"
        ],
        [
            "func SetLogger(out io.Writer, prefix string, flag int) {\n\tLog = stdlog.New(out, prefix, flag)\n}"
        ],
        [
            "func (th *timeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tt, _ := trace.NewContext(context.Background(), \"webserver\", \"servehttp\")\n\tdefer t.Finish()\n\n\ttm := time.Now().Format(th.format)\n\t// log to the trace\n\tt.LazyPrintf(\"time %v\", tm)\n\tw.Write([]byte(\"The time is: \" + tm))\n}"
        ],
        [
            "func TitleFromContext(ctx context.Context) string {\n\tid, ok := ctx.Value(TraceIDKey).(string)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn id\n}"
        ],
        [
            "func NewContext(ctx context.Context, family, title string) (xtr.Trace, context.Context) {\n\tsp := parentOrChildFromContext(ctx, family, title)\n\treturn sp, contextWithTrace(ctx, sp)\n}"
        ],
        [
            "func New(apikey string) *Client {\n\tendpoint := Endpoint{URL: EndpointURL}\n\treturn &Client{apikey, http.DefaultClient, endpoint}\n}"
        ],
        [
            "func NewWithClient(apikey string, client *http.Client) *Client {\n\tendpoint := Endpoint{URL: EndpointURL}\n\treturn &Client{apikey, client, endpoint}\n}"
        ],
        [
            "func (c *Client) Devices() ([]*Device, error) {\n\treq := c.buildRequest(\"/devices\", nil)\n\tresp, err := c.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\tvar errjson errorResponse\n\t\tdec := json.NewDecoder(resp.Body)\n\t\terr = dec.Decode(&errjson)\n\t\tif err == nil {\n\t\t\treturn nil, &errjson.ErrResponse\n\t\t}\n\n\t\treturn nil, errors.New(resp.Status)\n\t}\n\n\tvar devResp deviceResponse\n\tdec := json.NewDecoder(resp.Body)\n\terr = dec.Decode(&devResp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := range devResp.Devices {\n\t\tdevResp.Devices[i].Client = c\n\t}\n\tdevices := append(devResp.Devices, devResp.SharedDevices...)\n\treturn devices, nil\n}"
        ],
        [
            "func (c *Client) Device(nickname string) (*Device, error) {\n\tdevices, err := c.Devices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := range devices {\n\t\tif devices[i].Nickname == nickname {\n\t\t\tdevices[i].Client = c\n\t\t\treturn devices[i], nil\n\t\t}\n\t}\n\treturn nil, ErrDeviceNotFound\n}"
        ],
        [
            "func (d *Device) PushNote(title, body string) error {\n\treturn d.Client.PushNote(d.Iden, title, body)\n}"
        ],
        [
            "func (d *Device) PushLink(title, u, body string) error {\n\treturn d.Client.PushLink(d.Iden, title, u, body)\n}"
        ],
        [
            "func (d *Device) PushSMS(deviceIden, phoneNumber, message string) error {\n\treturn d.Client.PushSMS(d.Iden, deviceIden, phoneNumber, message)\n}"
        ],
        [
            "func (c *Client) Me() (*User, error) {\n\treq := c.buildRequest(\"/users/me\", nil)\n\tresp, err := c.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\tvar errjson errorResponse\n\t\tdec := json.NewDecoder(resp.Body)\n\t\terr = dec.Decode(&errjson)\n\t\tif err == nil {\n\t\t\treturn nil, &errjson.ErrResponse\n\t\t}\n\n\t\treturn nil, errors.New(resp.Status)\n\t}\n\n\tvar userResponse User\n\tdec := json.NewDecoder(resp.Body)\n\terr = dec.Decode(&userResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &userResponse, nil\n}"
        ],
        [
            "func (c *Client) Push(endPoint string, data interface{}) error {\n\treq := c.buildRequest(endPoint, data)\n\tresp, err := c.Client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tvar errResponse errorResponse\n\t\tdec := json.NewDecoder(resp.Body)\n\t\terr = dec.Decode(&errResponse)\n\t\tif err == nil {\n\t\t\treturn &errResponse.ErrResponse\n\t\t}\n\n\t\treturn errors.New(resp.Status)\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (c *Client) PushNote(iden string, title, body string) error {\n\tdata := Note{\n\t\tIden:  iden,\n\t\tType:  \"note\",\n\t\tTitle: title,\n\t\tBody:  body,\n\t}\n\treturn c.Push(\"/pushes\", data)\n}"
        ],
        [
            "func (c *Client) PushNoteToChannel(tag string, title, body string) error {\n\tdata := Note{\n\t\tTag:   tag,\n\t\tType:  \"note\",\n\t\tTitle: title,\n\t\tBody:  body,\n\t}\n\treturn c.Push(\"/pushes\", data)\n}"
        ],
        [
            "func (c *Client) PushLink(iden, title, u, body string) error {\n\tdata := Link{\n\t\tIden:  iden,\n\t\tType:  \"link\",\n\t\tTitle: title,\n\t\tURL:   u,\n\t\tBody:  body,\n\t}\n\treturn c.Push(\"/pushes\", data)\n}"
        ],
        [
            "func (c *Client) PushLinkToChannel(tag, title, u, body string) error {\n\tdata := Link{\n\t\tTag:   tag,\n\t\tType:  \"link\",\n\t\tTitle: title,\n\t\tURL:   u,\n\t\tBody:  body,\n\t}\n\treturn c.Push(\"/pushes\", data)\n}"
        ],
        [
            "func (c *Client) PushSMS(userIden, deviceIden, phoneNumber, message string) error {\n\tdata := Ephemeral{\n\t\tType: \"push\",\n\t\tPush: EphemeralPush{\n\t\t\tType:             \"messaging_extension_reply\",\n\t\t\tPackageName:      \"com.pushbullet.android\",\n\t\t\tSourceUserIden:   userIden,\n\t\t\tTargetDeviceIden: deviceIden,\n\t\t\tConversationIden: phoneNumber,\n\t\t\tMessage:          message,\n\t\t},\n\t}\n\treturn c.Push(\"/ephemerals\", data)\n}"
        ],
        [
            "func (c *Client) Subscription(tag string) (*Subscription, error) {\n\tsubs, err := c.Subscriptions()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := range subs {\n\t\tif subs[i].Channel.Tag == tag {\n\t\t\tsubs[i].Client = c\n\t\t\treturn subs[i], nil\n\t\t}\n\t}\n\treturn nil, ErrDeviceNotFound\n}"
        ],
        [
            "func (s *Subscription) PushNote(title, body string) error {\n\treturn s.Client.PushNoteToChannel(s.Channel.Tag, title, body)\n}"
        ],
        [
            "func (s *Subscription) PushLink(title, u, body string) error {\n\treturn s.Client.PushLinkToChannel(s.Channel.Tag, title, u, body)\n}"
        ],
        [
            "func NewCachedLoader(namespace string, consulAddr string) (config.Loader, error) {\n\tconfig := api.DefaultConfig()\n\tconfig.Address = consulAddr\n\tconsul, err := api.NewClient(config)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Could not connect to consul: %v\", err)\n\t}\n\n\treturn &cachedLoader{namespace: namespace, consulKV: consul.KV()}, nil\n}"
        ],
        [
            "func (c *cachedLoader) Import(data []byte) error {\n\tconf := make(map[string]interface{})\n\terr := json.Unmarshal(data, &conf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to parse json data: %v\", err)\n\t}\n\tkvMap, err := c.compileKeyValues(conf, c.namespace)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to complie KVs: %v\", err)\n\t}\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Could not create consul client: %v\", err)\n\t}\n\tfor k, v := range kvMap {\n\t\tp := &api.KVPair{Key: k, Value: v}\n\t\t_, err = c.consulKV.Put(p, nil)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Could not write key to consul (%s | %s) %v\", k, v, err)\n\t\t}\n\t}\n\treturn nil\n}"
        ],
        [
            "func (c *cachedLoader) Initialize() error {\n\tpairs, _, err := c.consulKV.List(c.namespace, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Could not pull config from consul: %v\", err)\n\t}\n\n\t//write lock the cache incase init is called more than once\n\tc.cacheLock.Lock()\n\tdefer c.cacheLock.Unlock()\n\n\tc.cache = make(map[string][]byte)\n\tfor _, kv := range pairs {\n\t\tc.cache[kv.Key] = kv.Value\n\t}\n\treturn nil\n}"
        ],
        [
            "func (c *cachedLoader) Get(key string) ([]byte, error) {\n\tc.cacheLock.RLock()\n\tdefer c.cacheLock.RUnlock()\n\n\tcompiledKey := c.namespace + divider + key\n\tif ret, ok := c.cache[compiledKey]; ok {\n\t\treturn ret, nil\n\t}\n\treturn nil, fmt.Errorf(\"Could not find value for key: %s\", compiledKey)\n}"
        ],
        [
            "func (c *cachedLoader) MustGetString(key string) string {\n\tb, err := c.Get(key)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Could not fetch config (%s) %v\", key, err))\n\t}\n\n\tvar s string\n\terr = json.Unmarshal(b, &s)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Could not unmarshal config (%s) %v\", key, err))\n\t}\n\n\treturn s\n}"
        ],
        [
            "func (c *cachedLoader) MustGetBool(key string) bool {\n\tb, err := c.Get(key)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Could not fetch config (%s) %v\", key, err))\n\t}\n\tvar ret bool\n\terr = json.Unmarshal(b, &ret)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Could not unmarshal config (%s) %v\", key, err))\n\t}\n\treturn ret\n}"
        ],
        [
            "func (c *cachedLoader) MustGetInt(key string) int {\n\tb, err := c.Get(key)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Could not fetch config (%s) %v\", key, err))\n\t}\n\n\tvar ret int\n\terr = json.Unmarshal(b, &ret)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Could not unmarshal config (%s) %v\", key, err))\n\t}\n\treturn ret\n}"
        ],
        [
            "func (c *cachedLoader) MustGetDuration(key string) time.Duration {\n\ts := c.MustGetString(key)\n\tret, err := time.ParseDuration(s)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Could not parse config (%s) into a duration: %v\", key, err))\n\t}\n\treturn ret\n}"
        ],
        [
            "func NewRandomDNSBalancer(environment string, consulAddr string, cacheTTL time.Duration) (balancer.DNS, error) {\n\tconfig := api.DefaultConfig()\n\tconfig.Address = consulAddr\n\tconsul, err := api.NewClient(config)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Could not connect to consul: %v\", err)\n\t}\n\n\tr := randomBalancer{}\n\tr.cache = make(map[string]cachedServiceLocation)\n\tr.environment = environment\n\tr.ttl = cacheTTL\n\tr.consulCatalog = consul.Health()\n\treturn &r, nil\n}"
        ],
        [
            "func (r *randomBalancer) writeServiceToCache(serviceName string) ([]*balancer.ServiceLocation, error) {\n\t//acquire a write lock\n\tr.cacheLock.Lock()\n\tdefer r.cacheLock.Unlock()\n\n\t//check the cache again in case we've fetched since the last check\n\t//(our lock could have been waiting for another call to this function)\n\tif result, ok := r.cache[serviceName]; ok {\n\t\tif time.Now().UTC().Before(result.CachedAt.Add(r.ttl)) {\n\t\t\treturn result.Services, nil\n\t\t}\n\t}\n\n\t//it still isn't in the cache, lets put it there\n\tconsulServices, _, err := r.consulCatalog.Service(serviceName, r.environment, true, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error reaching consul for service lookup %v\", err)\n\t}\n\n\tif len(consulServices) == 0 {\n\t\treturn nil, fmt.Errorf(\"No services found for %s\", serviceName)\n\t}\n\n\t//setup service locations\n\tvar services []*balancer.ServiceLocation\n\tfor _, v := range consulServices {\n\t\ts := &balancer.ServiceLocation{}\n\t\ts.URL = v.Service.Address\n\t\ts.Port = v.Service.Port\n\t\tservices = append(services, s)\n\t}\n\n\t// cache\n\tc := cachedServiceLocation{Services: services, CachedAt: time.Now().UTC()}\n\tr.cache[serviceName] = c\n\treturn services, nil\n}"
        ],
        [
            "func StringToLabels(s string) *mesos.Labels {\n\tlabels := &mesos.Labels{Labels: make([]*mesos.Label, 0)}\n\tif s == \"\" {\n\t\treturn labels\n\t}\n\tpairs := strings.Split(s, \";\")\n\tfor _, pair := range pairs {\n\t\tkv := strings.Split(pair, \"=\")\n\t\tkey, value := kv[0], kv[1]\n\t\tlabel := &mesos.Label{Key: proto.String(key), Value: proto.String(value)}\n\t\tlabels.Labels = append(labels.Labels, label)\n\t}\n\treturn labels\n}"
        ],
        [
            "func SetClockSequence(seq int) {\n\tif seq == -1 {\n\t\tvar b [2]byte\n\t\trandomBits(b[:]) // clock sequence\n\t\tseq = int(b[0])<<8 | int(b[1])\n\t}\n\told_seq := clock_seq\n\tclock_seq = uint16(seq&0x3fff) | 0x8000 // Set our variant\n\tif old_seq != clock_seq {\n\t\tlasttime = 0\n\t}\n}"
        ],
        [
            "func (dl *DefaultLogger) Trace(message string, params ...interface{}) {\n\tdl.logger.Tracef(fmt.Sprintf(\"%s %s\", caller(), message), params...)\n}"
        ],
        [
            "func (dl *DefaultLogger) Debug(message string, params ...interface{}) {\n\tdl.logger.Debugf(fmt.Sprintf(\"%s %s\", caller(), message), params...)\n}"
        ],
        [
            "func (dl *DefaultLogger) Info(message string, params ...interface{}) {\n\tdl.logger.Infof(fmt.Sprintf(\"%s %s\", caller(), message), params...)\n}"
        ],
        [
            "func (dl *DefaultLogger) Warn(message string, params ...interface{}) {\n\tdl.logger.Warnf(fmt.Sprintf(\"%s %s\", caller(), message), params...)\n}"
        ],
        [
            "func (dl *DefaultLogger) Error(message string, params ...interface{}) {\n\tdl.logger.Errorf(fmt.Sprintf(\"%s %s\", caller(), message), params...)\n}"
        ],
        [
            "func (dl *DefaultLogger) Critical(message string, params ...interface{}) {\n\tdl.logger.Criticalf(fmt.Sprintf(\"%s %s\", caller(), message), params...)\n}"
        ],
        [
            "func (api * API) SendPaste(paste Paste) (string, error) {\n\tif paste.UserKey == \"\" && paste.Privacy == \"2\" {\n\t\treturn \"\", PrivacyModError\n\t}\n\tvalues := url.Values{}\n\tvalues.Set(\"api_dev_key\", api.APIKey)\n\tvalues.Set(\"api_user_key\", paste.UserKey)\n\tvalues.Set(\"api_option\", \"paste\")\n\tvalues.Set(\"api_paste_code\", paste.Text)\n\tvalues.Set(\"api_paste_name\", paste.Name)\n\tvalues.Set(\"api_paste_private\", paste.Privacy)\n\tvalues.Set(\"api_paste_expire_date\", paste.ExpireDate)\n\tresponse, err := http.PostForm(\"http://pastebin.com/api/api_post.php\", values)\n\tdefer response.Body.Close()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif response.StatusCode != 200 {\n\t\treturn \"\", PastePostingError\n\t}\n\tbuf := bytes.Buffer{}\n\t_, err = buf.ReadFrom(response.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn buf.String(), nil\n}"
        ],
        [
            "func (api * API) GetPasteTextById(paste_id string) (string, error) {\n\tresponse, err := http.Get(\"http://pastebin.com/raw.php?i=\" + paste_id)\n\tdefer response.Body.Close()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif response.StatusCode != 200 {\n\t\treturn \"\", PasteGetError\n\t}\n\tbuf := bytes.Buffer{}\n\t_, err = buf.ReadFrom(response.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn buf.String(), nil\n}"
        ],
        [
            "func (e *execStreamer) ExecAndWait() error {\n\tcmd, err := e.StartExec()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\te.stdOutAndErrWaitGroup.Wait()\n\n\terr = cmd.Wait()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (e *execStreamerBuilder) ExecutorName(executorName string) ExecStreamerBuilder {\n\te.d.ExecutorName = executorName\n\treturn e\n}"
        ],
        [
            "func (e *execStreamerBuilder) Exe(exe string) ExecStreamerBuilder {\n\te.d.Exe = exe\n\treturn e\n}"
        ],
        [
            "func (e *execStreamerBuilder) Args(args ...string) ExecStreamerBuilder {\n\te.d.Args = args\n\treturn e\n}"
        ],
        [
            "func (e *execStreamerBuilder) Dir(dir string) ExecStreamerBuilder {\n\te.d.Dir = dir\n\treturn e\n}"
        ],
        [
            "func (e *execStreamerBuilder) Env(env ...string) ExecStreamerBuilder {\n\te.d.Env = env\n\treturn e\n}"
        ],
        [
            "func (e *execStreamerBuilder) Writers(writers io.Writer) ExecStreamerBuilder {\n\te.d.StdoutWriter = writers\n\te.d.StderrWriter = writers\n\treturn e\n}"
        ],
        [
            "func (e *execStreamerBuilder) StdoutWriter(writer io.Writer) ExecStreamerBuilder {\n\te.d.StdoutWriter = writer\n\treturn e\n}"
        ],
        [
            "func (e *execStreamerBuilder) StdoutPrefix(prefix string) ExecStreamerBuilder {\n\te.d.StdoutPrefix = prefix\n\treturn e\n}"
        ],
        [
            "func (e *execStreamerBuilder) StderrWriter(writer io.Writer) ExecStreamerBuilder {\n\te.d.StderrWriter = writer\n\treturn e\n}"
        ],
        [
            "func (e *execStreamerBuilder) StderrPrefix(prefix string) ExecStreamerBuilder {\n\te.d.StderrPrefix = prefix\n\treturn e\n}"
        ],
        [
            "func (e *execStreamerBuilder) Build() (ExecStreamer, error) {\n\tif e.d.ExecutorName == \"\" {\n\t\treturn nil, errors.New(\"ExecStreamerBuilder requires ExecutorName to be non-empty\")\n\t}\n\tif e.d.Exe == \"\" {\n\t\treturn nil, errors.New(\"ExecStreamerBuilder requires Exe to be non-empty\")\n\t}\n\tif e.d.StdoutWriter == nil {\n\t\te.d.StdoutWriter = ioutil.Discard\n\t}\n\tif e.d.StderrWriter == nil {\n\t\te.d.StderrWriter = ioutil.Discard\n\t}\n\n\treturn e.d, nil\n}"
        ],
        [
            "func MakeWidget(w *Window, x, y int) Widget {\n\treturn Widget{\n\t\tw: w,\n\t\tx: x,\n\t\ty: y,\n\t}\n}"
        ],
        [
            "func (l *Label) SetText(format string, args ...interface{}) {\n\tl.text = fmt.Sprintf(format, args...)\n}"
        ],
        [
            "func (w *Window) AddLabel(x, y int, format string, args ...interface{}) *Label {\n\t// we can ignore error for builtins\n\tl, _ := w.AddWidget(WidgetLabel, x, y)\n\tlabel := l.(*Label)\n\tlabel.Resize()\n\tlabel.SetAttributes(defaultAttributes())\n\tlabel.SetText(format, args...)\n\n\treturn label\n}"
        ],
        [
            "func (w *Window) printf(x, y int, a Attributes, format string,\n\targs ...interface{}) {\n\tout := fmt.Sprintf(format, args...)\n\txx := 0\n\tc := Cell{}\n\tc.Fg = a.Fg\n\tc.Bg = a.Bg\n\tmx := w.x - x\n\tvar rw int\n\tfor i := 0; i < len(out); i += rw {\n\t\tif x+xx+1 > mx {\n\t\t\tbreak\n\t\t}\n\n\t\tv, width := utf8.DecodeRuneInString(out[i:])\n\t\tif v == '\\x1b' {\n\t\t\t// see if we understand this escape seqeunce\n\t\t\tcc, skip, err := DecodeColor(out[i:])\n\t\t\tif err == nil {\n\t\t\t\tc.Fg = cc.Fg\n\t\t\t\tc.Bg = cc.Bg\n\t\t\t\trw = skip\n\t\t\t\tcontinue\n\n\t\t\t}\n\t\t}\n\n\t\trw = width\n\t\tc.Ch = v\n\t\tw.setCell(x+xx, y, c)\n\t\txx++\n\t}\n}"
        ],
        [
            "func (w *Window) setCell(x, y int, c Cell) {\n\tc.dirty = true\n\tpos := x + (y * w.x)\n\tif pos < len(w.backingStore) {\n\t\tw.backingStore[pos] = c\n\t}\n}"
        ],
        [
            "func (w *Window) resize(x, y int) {\n\tw.x = x\n\tw.y = y\n\tw.backingStore = make([]Cell, x*y)\n\n\t// iterate over widgets\n\tfor _, widget := range w.widgets {\n\t\twidget.Resize()\n\t}\n}"
        ],
        [
            "func (w *Window) render() {\n\tw.mgr.Render(w)\n\n\t// iterate over widgets\n\tfor _, widget := range w.widgets {\n\t\twidget.Render()\n\t}\n\n\t// focus on a widget\n\tw.focusWidget()\n}"
        ],
        [
            "func (w *Window) focusWidget() {\n\tsetCursor(-1, -1) // hide\n\tif w.focus < 0 {\n\t\tfor i, widget := range w.widgets {\n\t\t\tif widget.CanFocus() {\n\t\t\t\tw.focus = i\n\t\t\t\twidget.Focus()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t// nothing to do\n\t\treturn\n\t}\n\n\t// make sure we are in bounds\n\tif w.focus > len(w.widgets) {\n\t\t// this really should not happen\n\t\treturn\n\t}\n\n\tw.widgets[w.focus].Focus()\n}"
        ],
        [
            "func (w *Window) focusPrevious() {\n\t// it is ok to be negative since that'll focus on the first widget\n\tw.focus--\n\tif w.focus < 0 {\n\t\tw.focusWidget()\n\t\treturn\n\t}\n\n\t// find previous widget\n\tfor i := w.focus; i > 0; i-- {\n\t\twidget := w.widgets[i]\n\t\tif !widget.CanFocus() {\n\t\t\tcontinue\n\t\t}\n\t\tsetCursor(-1, -1) // hide\n\t\tw.focus = i\n\t\twidget.Focus()\n\t\treturn\n\t}\n\n\t// if we get here we need to focus on last focusable widget\n\tfor i := len(w.widgets) - 1; i > w.focus; i-- {\n\t\twidget := w.widgets[i]\n\t\tif !widget.CanFocus() {\n\t\t\tcontinue\n\t\t}\n\t\tsetCursor(-1, -1) // hide\n\t\tw.focus = i\n\t\twidget.Focus()\n\t\treturn\n\t}\n\n\t// if we get here it means we found nothing usable and give up\n}"
        ],
        [
            "func (w *Window) keyHandler(ev termbox.Event) (bool, Windower, Widgeter) {\n\tif w.focus < 0 || w.focus > len(w.widgets) {\n\t\treturn false, w.mgr, nil // not used\n\t}\n\treturn w.widgets[w.focus].KeyHandler(ev), w.mgr, w.widgets[w.focus]\n}"
        ],
        [
            "func Color(at, fg, bg int) (string, error) {\n\tvar a, f, b string\n\n\t// can't be all NA\n\tif at == AttrNA && fg == AttrNA && bg == AttrNA {\n\t\treturn \"\", ErrInvalidColor\n\t}\n\n\tswitch at {\n\tcase AttrNA:\n\t\tbreak\n\tcase AttrBold, AttrUnderline, AttrReverse, AttrReset:\n\t\ta = fmt.Sprintf(\"%v;\", at)\n\tdefault:\n\t\treturn \"\", ErrInvalidAttribute\n\t}\n\n\tswitch {\n\tcase fg == AttrNA:\n\t\tbreak\n\tcase fg >= ColorBlack && fg <= ColorWhite:\n\t\tf = fmt.Sprintf(\"%v;\", fg+ANSIFg)\n\tdefault:\n\t\treturn \"\", ErrInvalidForeground\n\t}\n\n\tswitch {\n\tcase bg == AttrNA:\n\t\tbreak\n\tcase bg >= ColorBlack && bg <= ColorWhite:\n\t\tb = fmt.Sprintf(\"%v;\", bg+ANSIBg)\n\tdefault:\n\t\treturn \"\", ErrInvalidBackground\n\t}\n\n\tes := fmt.Sprintf(\"\\x1b[%v%v%v\", a, f, b)\n\n\t// replace last ; with m\n\tes = es[:len(es)-1] + \"m\"\n\n\treturn es, nil\n}"
        ],
        [
            "func EscapedLen(s string) int {\n\tif len(s) == 0 {\n\t\treturn 0\n\t}\n\n\tvar rw, total int\n\tfor i := 0; i < len(s); i += rw {\n\t\tv, width := utf8.DecodeRuneInString(s[i:])\n\t\tif v == '\\x1b' {\n\t\t\t_, skip, err := DecodeColor(s[i:])\n\t\t\tif err == nil {\n\t\t\t\trw = skip\n\t\t\t\ttotal += skip\n\t\t\t\tcontinue\n\n\t\t\t}\n\t\t}\n\t\trw = width\n\t}\n\n\treturn total\n}"
        ],
        [
            "func Unescape(s string) string {\n\tif len(s) == 0 {\n\t\treturn \"\"\n\t}\n\n\tvar ret string\n\tvar rw int\n\tfor i := 0; i < len(s); i += rw {\n\t\tv, width := utf8.DecodeRuneInString(s[i:])\n\t\tif v == '\\x1b' {\n\t\t\t_, skip, err := DecodeColor(s[i:])\n\t\t\tif err == nil {\n\t\t\t\trw = skip\n\t\t\t\tcontinue\n\n\t\t\t}\n\t\t}\n\t\tret += string(v)\n\t\trw = width\n\t}\n\n\treturn ret\n}"
        ],
        [
            "func init() {\n\twork = make(chan func(), 32)\n\tkeyC = make(chan Key, 1024)\n\twindows = make(map[int]*Window)\n\twindower2window = make(map[Windower]*Window)\n\n\t// setup render queue\n\t// we do this song and dance in order to be able to deal with slow\n\t// connections where rendering could take a long time\n\texecute := make(chan bool, 1)\n\tfa := make([]func(), 0, 20)\n\tmtx := sync.Mutex{}\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\twg.Done()\n\t\tfor range execute {\n\t\t\tfor {\n\t\t\t\t// get work off queue\n\t\t\t\tmtx.Lock()\n\t\t\t\tif len(fa) == 0 {\n\t\t\t\t\tmtx.Unlock()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tf := fa[0]\n\t\t\t\tfa[0] = nil // just in case to prevent leak\n\t\t\t\tfa = fa[1:]\n\t\t\t\tmtx.Unlock()\n\n\t\t\t\t// actually do work\n\t\t\t\tf()\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\twg.Done()\n\t\tfor f := range work {\n\t\t\t// queue work\n\t\t\tmtx.Lock()\n\t\t\tfa = append(fa, f)\n\t\t\tmtx.Unlock()\n\n\t\t\t// tell executer there is work\n\t\t\tselect {\n\t\t\tcase execute <- true:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\twg.Wait()\n}"
        ],
        [
            "func initKeyHandler() {\n\tfor {\n\t\tswitch ev := termbox.PollEvent(); ev.Type {\n\t\tcase termbox.EventKey:\n\t\t\te := ev\n\t\t\tQueue(func() {\n\t\t\t\tvar (\n\t\t\t\t\twidget Widgeter\n\t\t\t\t\twindow Windower\n\t\t\t\t)\n\t\t\t\tif focus != nil {\n\t\t\t\t\tvar used bool\n\t\t\t\t\tused, window, widget = focus.keyHandler(e)\n\t\t\t\t\tif used {\n\t\t\t\t\t\tflush()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// forward to global application handler\n\t\t\t\tkeyC <- Key{\n\t\t\t\t\tMod:    e.Mod,\n\t\t\t\t\tKey:    e.Key,\n\t\t\t\t\tCh:     e.Ch,\n\t\t\t\t\tWindow: window,\n\t\t\t\t\tWidget: widget,\n\t\t\t\t}\n\t\t\t\t// XXX this is a terrible workaround!!\n\t\t\t\t// the app is racing this channel\n\t\t\t\t// we need to somehow block here before doing\n\t\t\t\t// anything else\n\t\t\t\t//time.Sleep(25 * time.Millisecond)\n\t\t\t})\n\n\t\tcase termbox.EventResize:\n\t\t\tQueue(func() {\n\t\t\t\tresizeAndRender(focus)\n\t\t\t})\n\t\tcase termbox.EventMouse:\n\t\tcase termbox.EventError:\n\t\t\treturn\n\t\t}\n\t}\n}"
        ],
        [
            "func Init() error {\n\trawMtx.Lock()\n\tdefer rawMtx.Unlock()\n\n\tif termRaw {\n\t\treturn ErrAlreadyInitialized\n\t}\n\n\t// switch mode\n\terr := termbox.Init()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbg = termbox.ColorDefault\n\tfg = termbox.ColorDefault\n\ttermbox.HideCursor()\n\ttermbox.SetInputMode(termbox.InputAlt) // this may need to become variable\n\t_ = termbox.Clear(bg, bg)\n\tmaxX, maxY = termbox.Size()\n\t_ = termbox.Flush()\n\n\t// see if we need to launch the key handler\n\tif !keyHandler {\n\t\tgo initKeyHandler()\n\t\tkeyHandler = true\n\t}\n\n\ttermRaw = true // we are now in raw mode\n\n\treturn nil\n}"
        ],
        [
            "func Deinit() {\n\twait := make(chan interface{})\n\tQueue(func() {\n\t\ttermbox.Close()\n\t\tfocus = nil\n\t\tprevFocus = nil\n\t\twindows = make(map[int]*Window) // toss all windows\n\n\t\trawMtx.Lock()\n\t\ttermRaw = false\n\t\trawMtx.Unlock()\n\n\t\twait <- true\n\t})\n\t<-wait\n}"
        ],
        [
            "func NewWindow(manager Windower) *Window {\n\twc := make(chan *Window)\n\tQueue(func() {\n\t\tw := &Window{\n\t\t\tid:           lastWindowID,\n\t\t\tmgr:          manager,\n\t\t\tx:            maxX,\n\t\t\ty:            maxY,\n\t\t\tfocus:        -1, // no widget focused\n\t\t\tbackingStore: make([]Cell, maxX*maxY),\n\t\t\twidgets:      make([]Widgeter, 0, 16),\n\t\t}\n\t\tlastWindowID++\n\t\twindows[w.id] = w\n\t\twindower2window[manager] = w\n\t\tmanager.Init(w)\n\t\twc <- w\n\t})\n\treturn <-wc\n}"
        ],
        [
            "func flush() {\n\tif focus == nil {\n\t\treturn\n\t}\n\tfor y := 0; y < focus.y; y++ {\n\t\tfor x := 0; x < focus.x; x++ {\n\t\t\tc := focus.getCell(x, y)\n\t\t\tif c == nil {\n\t\t\t\t// out of range, should not happen\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !c.dirty {\n\t\t\t\t// skip unchanged cells\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc.dirty = false\n\n\t\t\t// this shall be the only spot where\n\t\t\t// termbox.SetCell is called!\n\t\t\ttermbox.SetCell(x, y, c.Ch, c.Fg, c.Bg)\n\t\t}\n\t}\n\t_ = termbox.Flush()\n}"
        ],
        [
            "func focusWindow(w *Window) {\n\tif w == nil {\n\t\treturn\n\t}\n\t_, found := windows[w.id]\n\tif !found {\n\t\treturn\n\t}\n\tif focus == w {\n\t\treturn\n\t}\n\tprevFocus = focus\n\tfocus = w\n\n\tresizeAndRender(w)\n}"
        ],
        [
            "func resizeAndRender(w *Window) {\n\t// render window\n\tif w != nil {\n\t\t_ = termbox.Clear(bg, bg)\n\t\tmaxX, maxY = termbox.Size()\n\n\t\tw.resize(maxX, maxY)\n\t\tw.render()\n\n\t\t// display all the things\n\t\tflush()\n\t}\n}"
        ],
        [
            "func Panic(format string, args ...interface{}) {\n\ttermbox.Close()\n\tmsg := fmt.Sprintf(format, args...)\n\tpanic(msg)\n}"
        ],
        [
            "func Exit(format string, args ...interface{}) {\n\ttermbox.Close()\n\tfmt.Fprintf(os.Stderr, format+\"\\n\", args...)\n\tos.Exit(1)\n}"
        ],
        [
            "func (w *Window) AddList(x, y, width, height int) *List {\n\t// we can ignore error for builtins\n\tl, _ := w.AddWidget(WidgetList, x, y)\n\tlist := l.(*List)\n\tlist.width = width\n\tlist.height = height\n\tlist.Resize()\n\tlist.SetAttributes(defaultAttributes())\n\n\tlist.content = make([]string, 0, 1000)\n\treturn list\n}"
        ],
        [
            "func (l *List) Append(format string, args ...interface{}) {\n\ts := fmt.Sprintf(format, args...)\n\tl.content = append(l.content, s)\n\n\t// adjust at if we are not in a paging operation\n\tif l.paging {\n\t\treturn\n\t}\n\tl.at = len(l.content) - l.trueH\n\tif l.at < 0 {\n\t\tl.at = 0\n\t}\n}"
        ],
        [
            "func (e *Edit) Focus() {\n\tif e.cx == -1 || e.cy == -1 {\n\t\t// || is deliberate to handle \"just in case\"\n\t\te.cx = e.trueX\n\t\te.cy = e.trueY\n\t\te.at = 0\n\t}\n\tsetCursor(e.cx, e.cy)\n}"
        ],
        [
            "func (e *Edit) SetText(s *string, end bool) {\n\te.target = s\n\te.display = []rune(*s)\n\te.at = 0\n\n\t// send synthesized key to position cursor and text\n\tev := termbox.Event{}\n\tif end {\n\t\tev.Key = termbox.KeyCtrlE\n\t} else {\n\t\tev.Key = termbox.KeyCtrlA\n\t}\n\te.KeyHandler(ev)\n}"
        ],
        [
            "func (w *Window) AddEdit(x, y, width int, target *string) *Edit {\n\t// we can ignore error for builtins\n\te, _ := w.AddWidget(WidgetEdit, x, y)\n\tedit := e.(*Edit)\n\tedit.width = width\n\n\t// save current sizes to detect actual window resizes\n\tedit.prevX = w.x\n\tedit.prevY = w.y\n\n\tedit.Resize()\n\n\t// cursor\n\tedit.cx = -1\n\tedit.cy = -1\n\n\t// set target string\n\tedit.SetText(target, true)\n\n\t// flip attributes\n\ta := defaultAttributes()\n\ta2 := Attributes{\n\t\tFg: a.Bg,\n\t\tBg: a.Fg,\n\t}\n\tedit.SetAttributes(a2)\n\n\treturn edit\n}"
        ],
        [
            "func (s *Session) makeAuthorizationHeaders() (string, *Error) {\n\n\tif s.Username == \"\" {\n\t\treturn \"\", NewBambouError(\"Invalid Credentials\", \"No username given\")\n\t}\n\n\tif s.root == nil {\n\t\treturn \"\", NewBambouError(\"Invalid Credentials\", \"No root user set\")\n\t}\n\n\tkey := s.root.APIKey()\n\tif s.Password == \"\" && key == \"\" {\n\t\treturn \"\", NewBambouError(\"Invalid Credentials\", \"No password or authentication token given\")\n\t}\n\n\tif key == \"\" {\n\t\tkey = s.Password\n\t}\n\n\treturn \"XREST \" + base64.StdEncoding.EncodeToString([]byte(s.Username+\":\"+key)), nil\n}"
        ],
        [
            "func (s *Session) Start() *Error {\n\n\tcurrentSession = s\n\n\tberr := s.FetchEntity(s.root)\n\n\tif berr != nil {\n\t\treturn berr\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (s *Session) FetchEntity(object Identifiable) *Error {\n\n\turl, berr := s.getPersonalURL(object)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\n\trequest, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn NewBambouError(\"HTTP transaction error\", err.Error())\n\t}\n\n\tresponse, berr := s.send(request, nil)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\tdefer response.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(response.Body)\n\tlog.Debugf(\"Response Body: %s\", string(body))\n\n\tarr := IdentifiablesList{object} // trick for weird api..\n\tif err := json.Unmarshal(body, &arr); err != nil {\n\t\treturn NewBambouError(\"JSON unmarshalling error\", err.Error())\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (s *Session) SaveEntity(object Identifiable) *Error {\n\n\turl, berr := s.getPersonalURL(object)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\n\tbuffer := &bytes.Buffer{}\n\tif err := json.NewEncoder(buffer).Encode(object); err != nil {\n\t\treturn NewBambouError(\"JSON error\", err.Error())\n\t}\n\n\turl = url + \"?responseChoice=1\"\n\trequest, err := http.NewRequest(\"PUT\", url, buffer)\n\tif err != nil {\n\t\treturn NewBambouError(\"HTTP transaction error\", err.Error())\n\t}\n\n\tresponse, berr := s.send(request, nil)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\tdefer response.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(response.Body)\n\tlog.Debugf(\"Response Body: %s\", string(body))\n\n\tdest := IdentifiablesList{object}\n\tif len(body) > 0 {\n\t\tif err := json.Unmarshal(body, &dest); err != nil {\n\t\t\treturn NewBambouError(\"JSON Unmarshaling error\", err.Error())\n\t\t}\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (s *Session) DeleteEntity(object Identifiable) *Error {\n\n\turl, berr := s.getPersonalURL(object)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\n\turl = url + \"?responseChoice=1\"\n\trequest, err := http.NewRequest(\"DELETE\", url, nil)\n\n\tif err != nil {\n\t\treturn NewBambouError(\"HTTP transaction error\", err.Error())\n\t}\n\n\tresponse, berr := s.send(request, nil)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\tdefer response.Body.Close()\n\n\treturn nil\n}"
        ],
        [
            "func (s *Session) FetchChildren(parent Identifiable, identity Identity, dest interface{}, info *FetchingInfo) *Error {\n\n\turl, berr := s.getURLForChildrenIdentity(parent, identity)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\n\trequest, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn NewBambouError(\"HTTP transaction error\", err.Error())\n\t}\n\n\tresponse, berr := s.send(request, info)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\tdefer response.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(response.Body)\n\tlog.Debugf(\"Response Body: %s\", string(body))\n\n\tif response.StatusCode == http.StatusNoContent || response.ContentLength == 0 {\n\t\treturn nil\n\t}\n\n\tif err := json.Unmarshal(body, &dest); err != nil {\n\t\treturn NewBambouError(\"HTTP Unmarshaling error\", err.Error())\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (s *Session) CreateChild(parent Identifiable, child Identifiable) *Error {\n\n\turl, berr := s.getURLForChildrenIdentity(parent, child.Identity())\n\tif berr != nil {\n\t\treturn berr\n\t}\n\n\tbuffer := &bytes.Buffer{}\n\tif err := json.NewEncoder(buffer).Encode(child); err != nil {\n\t\treturn NewBambouError(\"JSON error\", err.Error())\n\t}\n\n\trequest, err := http.NewRequest(\"POST\", url, buffer)\n\tif err != nil {\n\t\treturn NewBambouError(\"HTTP transaction error\", err.Error())\n\t}\n\n\tresponse, berr := s.send(request, nil)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\tdefer response.Body.Close()\n\n\tbody, _ := ioutil.ReadAll(response.Body)\n\tlog.Debugf(\"Response Body: %s\", string(body))\n\n\tdest := IdentifiablesList{child}\n\tif err := json.Unmarshal(body, &dest); err != nil {\n\t\treturn NewBambouError(\"JSON Unmarshaling error\", err.Error())\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (s *Session) AssignChildren(parent Identifiable, children []Identifiable, identity Identity) *Error {\n\n\turl, berr := s.getURLForChildrenIdentity(parent, identity)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\n\tvar ids []string\n\tfor _, c := range children {\n\n\t\tif i := c.Identifier(); i != \"\" {\n\t\t\tids = append(ids, c.Identifier())\n\t\t} else {\n\t\t\treturn NewBambouError(\"VSD Error\", \"One of the object to assign has no ID\")\n\t\t}\n\t}\n\n\tbuffer := &bytes.Buffer{}\n\tjson.NewEncoder(buffer).Encode(ids)\n\n\trequest, err := http.NewRequest(\"PUT\", url, buffer)\n\tif err != nil {\n\t\treturn NewBambouError(\"HTTP transaction error\", err.Error())\n\t}\n\n\tresponse, berr := s.send(request, nil)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\tdefer response.Body.Close()\n\n\treturn nil\n}"
        ],
        [
            "func (s *Session) NextEvent(channel NotificationsChannel, lastEventID string) *Error {\n\n\tcurrentURL := s.URL + \"/events\"\n\tif lastEventID != \"\" {\n\t\tcurrentURL += \"?uuid=\" + lastEventID\n\t}\n\n\trequest, err := http.NewRequest(\"GET\", currentURL, nil)\n\tif err != nil {\n\t\treturn NewBambouError(\"HTTP transaction error\", err.Error())\n\t}\n\n\tresponse, berr := s.send(request, nil)\n\tif berr != nil {\n\t\treturn berr\n\t}\n\tdefer response.Body.Close()\n\n\tnotification := NewNotification()\n\tif err := json.NewDecoder(response.Body).Decode(notification); err != nil {\n\t\treturn NewBambouError(\"JSON error\", err.Error())\n\t}\n\n\tif len(notification.Events) > 0 {\n\t\tchannel <- notification\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (i Identity) String() string {\n\n\treturn fmt.Sprintf(\"<Identity %s|%s>\", i.Name, i.Category)\n}"
        ],
        [
            "func NewPushCenter(session *Session) *PushCenter {\n\n\treturn &PushCenter{\n\t\tChannel:  make(NotificationsChannel),\n\t\tstop:     make(chan bool),\n\t\thandlers: eventHandlers{},\n\t\tsession:  session,\n\t}\n}"
        ],
        [
            "func (p *PushCenter) RegisterHandlerForIdentity(handler EventHandler, identity Identity) {\n\n\tif identity.Name == AllIdentity.Name {\n\t\tp.defaultHander = handler\n\t\treturn\n\t}\n\n\tp.handlers[identity.Name] = handler\n}"
        ],
        [
            "func (p *PushCenter) UnregisterHandlerForIdentity(identity Identity) {\n\n\tif identity.Name == AllIdentity.Name {\n\t\tp.defaultHander = nil\n\t\treturn\n\t}\n\n\tif _, exists := p.handlers[identity.Name]; exists {\n\t\tdelete(p.handlers, identity.Name)\n\t}\n}"
        ],
        [
            "func (p *PushCenter) HasHandlerForIdentity(identity Identity) bool {\n\n\tif identity.Name == AllIdentity.Name {\n\t\treturn p.defaultHander != nil\n\t}\n\t_, exists := p.handlers[identity.Name]\n\treturn exists\n}"
        ],
        [
            "func (p *PushCenter) Start() error {\n\n\tif p.isRunning {\n\t\treturn errors.New(\"the push center is already started\")\n\t}\n\n\tp.isRunning = true\n\n\tgo func() {\n\t\tlastEventID := \"\"\n\t\tfor {\n\t\t\tgo p.session.NextEvent(p.Channel, lastEventID)\n\t\t\tselect {\n\t\t\tcase notification := <-p.Channel:\n\t\t\t\tfor _, event := range notification.Events {\n\n\t\t\t\t\tbuffer := &bytes.Buffer{}\n\t\t\t\t\tif err := json.NewEncoder(buffer).Encode(event.DataMap[0]); err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tevent.Data = buffer.Bytes()\n\n\t\t\t\t\tlastEventID = notification.UUID\n\t\t\t\t\tif p.defaultHander != nil {\n\t\t\t\t\t\tp.defaultHander(event)\n\t\t\t\t\t}\n\n\t\t\t\t\tif handler, exists := p.handlers[event.EntityType]; exists {\n\t\t\t\t\t\thandler(event)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase <-p.stop:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}"
        ],
        [
            "func (p *PushCenter) Stop() error {\n\n\tif !p.isRunning {\n\t\treturn errors.New(\"the push center is not started\")\n\t}\n\n\tp.stop <- true\n\tp.isRunning = false\n\n\treturn nil\n}"
        ],
        [
            "func Logger() *logging.Logger {\n\n\tif defaultLogger == nil {\n\t\tlogger, _ := logging.SimpleLogger(\"bambou\")\n\t\tdefaultLogger = logger\n\t\tlogger.SetLevel(logging.ERROR)\n\t}\n\n\treturn defaultLogger\n}"
        ],
        [
            "func (f *FetchingInfo) String() string {\n\n\treturn fmt.Sprintf(\"<FetchingInfo page: %d, pagesize: %d, totalcount: %d>\", f.Page, f.PageSize, f.TotalCount)\n}"
        ],
        [
            "func NewClient(apiKey string) *Client {\n\treturn &Client{\n\t\tclient: &http.Client{Transport: &http.Transport{\n\t\t\tProxy: http.ProxyFromEnvironment,\n\t\t\tDialContext: (&net.Dialer{\n\t\t\t\tTimeout:   30 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t\tDualStack: true,\n\t\t\t}).DialContext,\n\t\t\tDisableKeepAlives:     true,\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t}},\n\t\tapiKey: apiKey,\n\t\tURL:    DefaultURL,\n\t}\n}"
        ],
        [
            "func (c *Client) Post(metrics []Metric) error {\n\tseries := struct {\n\t\tSeries []Metric `json:\"series,omitempty\"`\n\t}{Series: metrics}\n\n\tbuf := fetchBuffer()\n\tdefer bufferPool.Put(buf)\n\n\tvar dst io.Writer = buf\n\tif !c.DisableCompression {\n\t\tzlw := fetcZlibWriter(buf)\n\t\tdefer zlibWriterPool.Put(zlw)\n\t\tdefer zlw.Close()\n\n\t\tdst = zlw\n\t}\n\n\tif err := json.NewEncoder(dst).Encode(&series); err != nil {\n\t\treturn err\n\t}\n\tif c, ok := dst.(io.Closer); ok {\n\t\tif err := c.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn c.post(buf.Bytes(), 0)\n}"
        ],
        [
            "func MetricID(name string, tags []string) string {\n\tif len(tags) == 0 {\n\t\treturn name\n\t}\n\tsort.Strings(tags)\n\treturn name + \"|\" + strings.Join(tags, \",\")\n}"
        ],
        [
            "func SplitMetricID(metricID string) (name string, tags []string) {\n\tif metricID == \"\" {\n\t\treturn \"\", nil\n\t}\n\n\tpos := strings.LastIndexByte(metricID, '|')\n\tif pos > 0 && pos < len(metricID)-1 {\n\t\treturn metricID[:pos], strings.Split(metricID[pos+1:], \",\")\n\t}\n\treturn metricID, nil\n}"
        ],
        [
            "func NewRateScale(d time.Duration) *Rate {\n\treturn &Rate{\n\t\ttime: time.Now().UnixNano(),\n\t\tunit: d.Seconds(),\n\t}\n}"
        ],
        [
            "func (r *Rate) Snapshot() float64 {\n\tnow := time.Now().UnixNano()\n\tdur := time.Duration(now - atomic.SwapInt64(&r.time, now))\n\treturn r.count.Snapshot() / dur.Seconds() * r.unit\n}"
        ],
        [
            "func NewDeriveScale(v float64, d time.Duration) *Derive {\n\treturn &Derive{\n\t\tvalue: math.Float64bits(v),\n\t\trate: Rate{\n\t\t\ttime: time.Now().UnixNano(),\n\t\t\tunit: d.Seconds(),\n\t\t},\n\t}\n}"
        ],
        [
            "func (d *Derive) Update(v float64) {\n\tp := atomic.SwapUint64(&d.value, math.Float64bits(v))\n\td.rate.Update(v - math.Float64frombits(p))\n}"
        ],
        [
            "func (r *Reservoir) Snapshot() Distribution {\n\th := newHistogram(defaultHistogramSize)\n\tr.m.Lock()\n\th = r.hist.Copy(h)\n\tr.m.Unlock()\n\treturn h\n}"
        ],
        [
            "func (g *Gauge) Update(v float64) {\n\tatomic.StoreUint64(&g.value, math.Float64bits(v))\n}"
        ],
        [
            "func (g *Gauge) Snapshot() float64 {\n\tu := atomic.LoadUint64(&g.value)\n\treturn math.Float64frombits(u)\n}"
        ],
        [
            "func NewUnstarted(prefix string, tags ...string) *Registry {\n\treturn &Registry{\n\t\tinstruments: make(map[string]interface{}),\n\t\tprefix:      prefix,\n\t\ttags:        tags,\n\t}\n}"
        ],
        [
            "func (r *Registry) Subscribe(rep Reporter) {\n\tr.mutex.Lock()\n\tr.reporters = append(r.reporters, rep)\n\tr.mutex.Unlock()\n}"
        ],
        [
            "func (r *Registry) Get(name string, tags []string) interface{} {\n\tkey := MetricID(name, tags)\n\tr.mutex.RLock()\n\tv := r.instruments[key]\n\tr.mutex.RUnlock()\n\treturn v\n}"
        ],
        [
            "func (r *Registry) Register(name string, tags []string, v interface{}) {\n\tswitch v.(type) {\n\tcase Discrete, Sample:\n\t\tkey := MetricID(name, tags)\n\t\tr.mutex.Lock()\n\t\tr.instruments[key] = v\n\t\tr.mutex.Unlock()\n\t}\n}"
        ],
        [
            "func (r *Registry) Fetch(name string, tags []string, factory func() interface{}) interface{} {\n\tkey := MetricID(name, tags)\n\n\tr.mutex.RLock()\n\tv, ok := r.instruments[key]\n\tr.mutex.RUnlock()\n\tif ok {\n\t\treturn v\n\t}\n\n\tr.mutex.Lock()\n\tdefer r.mutex.Unlock()\n\n\tif v, ok = r.instruments[key]; !ok {\n\t\tswitch v = factory(); v.(type) {\n\t\tcase Discrete, Sample:\n\t\t\tr.instruments[key] = v\n\t\t}\n\t}\n\treturn v\n}"
        ],
        [
            "func (r *Registry) Size() int {\n\tr.mutex.RLock()\n\tsize := len(r.instruments)\n\tr.mutex.RUnlock()\n\treturn size\n}"
        ],
        [
            "func (r *Registry) Tags() []string {\n\tr.mutex.RLock()\n\ttags := r.tags\n\tr.mutex.RUnlock()\n\treturn tags\n}"
        ],
        [
            "func (r *Registry) SetTags(tags ...string) {\n\tr.mutex.Lock()\n\tr.tags = tags\n\tr.mutex.Unlock()\n}"
        ],
        [
            "func (r *Registry) AddTags(tags ...string) {\n\tr.mutex.Lock()\n\tr.tags = append(r.tags, tags...)\n\tr.mutex.Unlock()\n}"
        ],
        [
            "func (r *Registry) Close() error {\n\tif r.closing == nil {\n\t\treturn nil\n\t}\n\tclose(r.closing)\n\treturn <-r.closed\n}"
        ],
        [
            "func New(apiKey string) *Reporter {\n\thostname, _ := os.Hostname()\n\n\treturn &Reporter{\n\t\tClient:   NewClient(apiKey),\n\t\tHostname: hostname,\n\t\trefs:     make(map[string]int8),\n\t}\n}"
        ],
        [
            "func (r *Reporter) Metric(name string, tags []string, v float32) {\n\tr.metrics = append(r.metrics, Metric{\n\t\tName:   name,\n\t\tPoints: [][2]interface{}{[2]interface{}{r.timestamp, v}},\n\t\tTags:   tags,\n\t\tHost:   r.Hostname,\n\t})\n}"
        ],
        [
            "func (s RethinkStore) FilterBefore(id string, filter map[string]interface{}, count int, skip int, store string, opts ObjectStoreOptions) (rows ObjectRows, err error) {\n\trootTerm := r.DB(s.Database).Table(store).Between(\n\t\tr.MinVal, id, r.BetweenOpts{RightBound: \"closed\"}).OrderBy(\n\t\tr.OrderByOpts{Index: r.Desc(\"id\")}).Filter(\n\t\ts.transformFilter(nil, filter)).Limit(count)\n\tresult, err := rootTerm.Run(s.Session)\n\tif err != nil {\n\t\treturn\n\t}\n\tif result.Err() != nil {\n\t\treturn nil, result.Err()\n\t}\n\tif result.IsNil() {\n\t\treturn nil, ErrNotFound\n\t}\n\trows = RethinkRows{result}\n\treturn\n}"
        ],
        [
            "func (e *EnvVar) Set(key, value string) {\n\tkeyVal := key + \"=\" + value\n\tfor i, v := range *e {\n\t\tenv := strings.SplitN(v, \"=\", 2)\n\t\tif len(env) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tif env[0] == key {\n\t\t\t(*e)[i] = keyVal\n\t\t\treturn\n\t\t}\n\t}\n\t*e = append(*e, keyVal)\n}"
        ],
        [
            "func (e *EnvVar) SetStr(keyVal string) {\n\ts := strings.SplitN(keyVal, \"=\", 2)\n\tif len(s) == 2 {\n\t\te.Set(s[0], s[1])\n\t}\n}"
        ],
        [
            "func (e EnvVar) Get(key string) string {\n\tfor _, v := range e {\n\t\tenv := strings.SplitN(v, \"=\", 2)\n\t\tif len(env) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tif env[0] == key {\n\t\t\treturn env[1]\n\t\t}\n\t}\n\treturn \"\"\n}"
        ],
        [
            "func (e EnvVar) String() string {\n\tb := bytes.NewBuffer(nil)\n\tfor _, env := range e {\n\t\t// don't include invalid strings\n\t\tif len(strings.SplitN(env, \"=\", 2)) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Fprintln(b, env)\n\t}\n\treturn b.String()\n}"
        ],
        [
            "func (s *Set) Add(value interface{}) {\n\ts.Lock()\n\tdefer s.Unlock()\n\ts.m[value] = struct{}{}\n}"
        ],
        [
            "func (s *Set) AddAll(values ...interface{}) {\n\ts.Lock()\n\tdefer s.Unlock()\n\tfor _, value := range values {\n\t\ts.m[value] = struct{}{}\n\t}\n}"
        ],
        [
            "func (s *Set) Remove(value interface{}) {\n\ts.Lock()\n\tdefer s.Unlock()\n\tdelete(s.m, value)\n}"
        ],
        [
            "func (s *Set) RemoveAll(values ...interface{}) {\n\ts.Lock()\n\tdefer s.Unlock()\n\tfor _, value := range values {\n\t\tdelete(s.m, value)\n\t}\n}"
        ],
        [
            "func (s *Set) Contains(value interface{}) bool {\n\ts.RLock()\n\tdefer s.RUnlock()\n\t_, ok := s.m[value]\n\treturn ok\n}"
        ],
        [
            "func (s *Set) ContainsAll(values ...interface{}) bool {\n\ts.RLock()\n\tdefer s.RUnlock()\n\tfor _, value := range values {\n\t\t_, ok := s.m[value]\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
        ],
        [
            "func (s *Set) ContainsFunc(f func(interface{}) bool) bool {\n\ts.RLock()\n\tdefer s.RUnlock()\n\tfor k := range s.m {\n\t\tif f(k) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"
        ],
        [
            "func (s *Set) Clear() {\n\ts.Lock()\n\tdefer s.Unlock()\n\ts.m = make(map[interface{}]struct{})\n}"
        ],
        [
            "func (s *Set) Iterator() Iterator {\n\ts.RLock()\n\tdefer s.RUnlock()\n\titerChan := make(chan interface{}, len(s.m))\n\tfor k := range s.m {\n\t\titerChan <- k\n\t}\n\tclose(iterChan)\n\treturn IterFunc(func() (interface{}, bool) {\n\t\tvalue, ok := <-iterChan\n\t\treturn value, ok\n\t})\n}"
        ],
        [
            "func (s *Set) Items() []interface{} {\n\ts.RLock()\n\tdefer s.RUnlock()\n\titems := make([]interface{}, len(s.m))\n\ti := 0\n\tfor k := range s.m {\n\t\titems[i] = k\n\t\ti++\n\t}\n\treturn items\n}"
        ],
        [
            "func (s *Set) ItemsFunc(f func(value interface{}) bool) []interface{} {\n\ts.RLock()\n\tdefer s.RUnlock()\n\titems := []interface{}{}\n\tfor k := range s.m {\n\t\tif f(k) {\n\t\t\titems = append(items, k)\n\t\t}\n\t}\n\treturn items\n}"
        ],
        [
            "func (h holidaysUSNational) fixWeekend(in time.Time) time.Time {\n\tswitch in.Weekday() {\n\tcase time.Saturday:\n\t\treturn in.Add(-1 * 24 * time.Hour)\n\tcase time.Sunday:\n\t\treturn in.Add(1 * 24 * time.Hour)\n\tdefault:\n\t\treturn in\n\t}\n}"
        ],
        [
            "func GetHolidays(countryCode string, year int) ([]Holiday, error) {\n\trequiredCodes := []string{countryCode}\n\tresult := []Holiday{}\n\n\tfor len(requiredCodes) > 0 {\n\t\tcc := requiredCodes[0]\n\t\thds, ok := holidayProviders[cc]\n\t\tif !ok {\n\t\t\treturn nil, HolidayDataNotFoundError\n\t\t}\n\n\t\trequiredCodes = append(requiredCodes, hds.GetIncludes()...)\n\t\tresult = append(result, hds.GetHolidays(year)...)\n\n\t\trequiredCodes = requiredCodes[1:]\n\t}\n\n\tsort.Sort(holidays(result))\n\n\treturn result, nil\n}"
        ],
        [
            "func (c GConfig) GetInt(key string) int {\n\ti, _ := strconv.Atoi(c.getStringValue(key))\n\treturn i\n}"
        ],
        [
            "func (c GConfig) GetFloat(key string) float64 {\n\tv, _ := strconv.ParseFloat(c.getStringValue(key), 32)\n\treturn v\n}"
        ],
        [
            "func (c GConfig) GetBool(key string) bool {\n\tb, _ := strconv.ParseBool(c.getStringValue(key))\n\treturn b\n}"
        ],
        [
            "func (c GConfig) Exists(key string) bool {\n\tv := c.getValue(key)\n\tif v != nil {\n\t\treturn true\n\t}\n\treturn false\n}"
        ],
        [
            "func (c GConfig) getValue(key string) interface{} {\n\tv := c.defaultConfig.configs[key]\n\tif c.profileConfig.fileInfo != nil && s.Contains(c.profileConfig.fileInfo.Name(), c.Profile) {\n\t\tv = c.profileConfig.configs[key]\n\t}\n\tif v == nil {\n\t\tv = c.defaultConfig.configs[key]\n\t}\n\n\treturn v\n}"
        ],
        [
            "func Load() (*GConfig, error) {\n\n\tflag.Parse()\n\n\tgc := new(GConfig)\n\tgc.Profile = loadProfile()\n\n\tp, err := loadPath()\n\tif err != nil {\n\t\treturn configError(err, \"Error reading config directory path %s\", p)\n\t}\n\n\tfiles, err := ioutil.ReadDir(p)\n\tif err != nil {\n\t\treturn configError(err, \"Error reading config directory in path %s\", cpath)\n\t}\n\tif len(files) == 0 {\n\t\treturn configError(ErrConfigFileRequired, \"Config file not found in path %s\", cpath)\n\t}\n\n\t//read individual config file\n\tfor _, f := range files {\n\t\tcfpath := filepath.Join(p, f.Name())\n\t\tpf := fmt.Sprintf(\"application-%s.properties\", gc.Profile)\n\t\tif f.Name() == StandardPropFileName || pf == f.Name() {\n\t\t\tcf, err := readPropertyFile(f, cfpath)\n\t\t\tif err != nil {\n\t\t\t\treturn configError(err, \"Error opening config file %s\", f)\n\t\t\t}\n\t\t\tgc.addConfigFile(cf)\n\t\t}\n\t}\n\n\tGcg = gc\n\n\t//do a final check if loaded config has any values\n\tif gc.isEmpty() {\n\t\tlog.Printf(\"Configuration loaded, but empty for profile: '%s'\\n\", Gcg.Profile)\n\t} else {\n\t\tlog.Printf(\"Configuration loaded for profile %s\\n\", Gcg.Profile)\n\t}\n\n\treturn gc, nil\n}"
        ],
        [
            "func loadPath() (string, error) {\n\tpath := \"\"\n\tif len(*cpath) == 0 {\n\t\tpath = os.Getenv(\"GC_PATH\")\n\t} else {\n\t\tpath = *cpath\n\t}\n\n\t//if empty, load default config path\n\tif len(path) == 0 {\n\t\tgp, err := getGoPath()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tpath = gp + \"/config\"\n\t}\n\n\tlog.Printf(\"Loading configuration file from path %s\\n\", path)\n\n\treturn path, nil\n}"
        ],
        [
            "func New(filename string, utf8 bool) *Reader {\n\treturn &Reader{filename, utf8, nil, sync.Mutex{}}\n}"
        ],
        [
            "func readMimetypes(filename string) (map[string]string, error) {\n\tmimetypes := make(map[string]string)\n\t// Read the mimetype file\n\tdata, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// For each line, store extensions and mimetypes in the hash map\n\tfor _, line := range bytes.Split(data, []byte(\"\\n\")) {\n\t\tfields := bytes.Fields(line)\n\t\tif len(fields) > 1 {\n\t\t\tfor _, ext := range fields[1:] {\n\t\t\t\tmimetypes[string(ext)] = string(fields[0])\n\t\t\t}\n\t\t}\n\t}\n\treturn mimetypes, nil\n}"
        ],
        [
            "func (mr *Reader) Get(ext string) string {\n\tvar err error\n\t// No extension\n\tif len(ext) == 0 {\n\t\treturn \"\"\n\t}\n\t// Strip the leading dot\n\tif ext[0] == '.' {\n\t\text = ext[1:]\n\t}\n\tmr.mu.Lock()\n\tdefer mr.mu.Unlock()\n\tif mr.mimetypes == nil {\n\t\tmr.mimetypes, err = readMimetypes(mr.filename)\n\t\tif err != nil {\n\t\t\t// Using the fallback hash map\n\t\t\tif mime, ok := fallback[ext]; ok {\n\t\t\t\treturn mime\n\t\t\t}\n\t\t\t// Unable to find the mime type for the given extension\n\t\t\treturn \"\"\n\t\t}\n\t}\n\t// Use the value from the hash map\n\tif mime, ok := mr.mimetypes[ext]; ok {\n\t\treturn mime\n\t}\n\t// Using the fallback hash map\n\tif mime, ok := fallback[ext]; ok {\n\t\treturn mime\n\t}\n\t// Unable to find the mime type for the given extension\n\treturn \"\"\n}"
        ],
        [
            "func (mr *Reader) SetHeader(w http.ResponseWriter, ext string) {\n\tmimestring := mr.Get(ext)\n\tif mimestring == \"\" {\n\t\t// Default mime type\n\t\tmimestring = \"application/octet-stream\"\n\t}\n\tif mr.utf8 {\n\t\tmimestring += \"; charset=utf-8\"\n\t}\n\tw.Header().Add(\"Content-Type\", mimestring)\n}"
        ],
        [
            "func GetFileSize(filename string) (fileSize int64) {\n\tvar (\n\t\tfileInfo os.FileInfo\n\t\terr      error\n\t\tfile     *os.File\n\t)\n\n\tif file, err = os.Open(filename); err == nil {\n\t\tfileInfo, err = file.Stat()\n\t\tfileSize = fileInfo.Size()\n\n\t} else {\n\t\tfileSize = -1\n\t}\n\treturn\n}"
        ],
        [
            "func (s *Server) ListenAndServe() error {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", websocket.Server{\n\t\tConfig:  s.wsConfig,\n\t\tHandler: s.wsConnHandler,\n\t\tHandshake: func(config *websocket.Config, req *http.Request) error {\n\t\t\ts.wg.Add(1)                                  // todo: this needs to happen inside the gorotune executing the Start method and not the request goroutine or we'll miss some edge connections\n\t\t\tconfig.Origin, _ = url.Parse(req.RemoteAddr) // we're interested in remote address and not origin header text\n\t\t\treturn nil\n\t\t},\n\t})\n\n\tl, err := net.Listen(\"tcp\", s.addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create TLS listener on network address %v with error: %v\", s.addr, err)\n\t}\n\ts.listener = l\n\n\tlog.Printf(\"server: started %v\", s.addr)\n\ts.running.Store(true)\n\terr = http.Serve(l, mux)\n\tif !s.running.Load().(bool) {\n\t\treturn nil\n\t}\n\treturn err\n}"
        ],
        [
            "func (s *Server) SendRequest(connID string, method string, params interface{}, resHandler func(ctx *ResCtx) error) (reqID string, err error) {\n\tif !s.running.Load().(bool) {\n\t\treturn \"\", errors.New(\"use of closed server\")\n\t}\n\n\tif conn, ok := s.conns.GetOk(connID); ok {\n\t\treqID, err = conn.(*Conn).SendRequest(method, params, resHandler)\n\t\t// todo: only log in debug mode?\n\t\tlog.Printf(\"server: send-request: connID: %v, reqID: %v, method: %v, params: %#v, err (if any): %v\", connID, reqID, method, params, err)\n\t\treturn\n\t}\n\n\treturn \"\", fmt.Errorf(\"connection with requested ID: %v does not exist\", connID)\n}"
        ],
        [
            "func (s *Server) SendRequestArr(connID string, method string, resHandler func(ctx *ResCtx) error, params ...interface{}) (reqID string, err error) {\n\treturn s.SendRequest(connID, method, params, resHandler)\n}"
        ],
        [
            "func (s *Server) Close() error {\n\tif !s.running.Load().(bool) {\n\t\treturn nil\n\t}\n\ts.running.Store(false)\n\terr := s.listener.Close()\n\n\t// close all active connections discarding any read/writes that is going on currently\n\ts.conns.Range(func(c interface{}) {\n\t\tc.(*Conn).Close()\n\t})\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"an error occured before or while stopping the server: %v\", err)\n\t}\n\n\ts.wg.Wait()\n\tlog.Printf(\"server: stopped %v\", s.addr)\n\treturn nil\n}"
        ],
        [
            "func (s *Server) wsConnHandler(ws *websocket.Conn) {\n\tc, err := NewConn()\n\tif err != nil {\n\t\tlog.Printf(\"server: error while accepting connection: %v\", err)\n\t\treturn\n\t}\n\tdefer recoverAndLog(c, &s.wg)\n\tc.MiddlewareFunc(s.middleware...)\n\n\tlog.Printf(\"server: client connected %v: %v\", c.ID, ws.RemoteAddr())\n\n\ts.conns.Set(c.ID, c)\n\tconnsCounter.Add(1)\n\tc.setConn(ws)\n\tc.startReceive()\n\ts.conns.Delete(c.ID)\n\tconnsCounter.Add(-1)\n\ts.disconnHandler(c)\n}"
        ],
        [
            "func SafeCreateS3Bucket(domain, bucket, accessKey, secretKey string) (*S3Bucket, error) {\n\ts := &S3Bucket{\n\t\tBucket:    bucket,\n\t\tName:      \"s3\",\n\t\tDomain:    domain,\n\t\tAccessKey: accessKey,\n\t\tSecretKey: secretKey,\n\t}\n\tif s.Bucket == \"\" {\n\t\treturn nil, errors.New(\"bucket name is undefined\")\n\t}\n\tvar k s3gof3r.Keys\n\tvar err error\n\n\tif s.AccessKey == \"\" || s.SecretKey == \"\" {\n\t\tk, err = s3gof3r.EnvKeys() // get S3 keys from environment\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tk = s3gof3r.Keys{\n\t\t\tAccessKey: s.AccessKey,\n\t\t\tSecretKey: s.SecretKey,\n\t\t}\n\t}\n\ts3 := s3gof3r.New(s.Domain, k)\n\ts.bucket = s3.Bucket(s.Bucket)\n\treturn s, nil\n}"
        ],
        [
            "func (s *S3Bucket) NewWriter(path string) (io.WriteCloser, error) {\n\treturn s.bucket.PutWriter(path, nil, nil)\n}"
        ],
        [
            "func (s *S3Bucket) NewReader(path string) (io.ReadCloser, error) {\n\tr, _, err := s.bucket.GetReader(path, nil)\n\treturn r, err\n}"
        ],
        [
            "func (s *S3Bucket) Delete(path string) error {\n\treturn s.bucket.Delete(path)\n}"
        ],
        [
            "func CertAtuh(ctx *neptulon.ReqCtx) error {\n\tif _, ok := ctx.Session.GetOk(\"userid\"); ok {\n\t\treturn ctx.Next()\n\t}\n\n\t// if provided, client certificate is verified by the TLS listener so the peerCerts list in the connection is trusted\n\t// connState, _ := ctx.Conn.ConnectionState()\n\t// certs := connState.PeerCertificates\n\t// if len(certs) == 0 {\n\t// \tlog.Println(\"Invalid client-certificate authentication attempt:\", ctx.Conn.RemoteAddr())\n\t// \tctx.Conn.Close()\n\t// \treturn nil\n\t// }\n\t//\n\t// userID := certs[0].Subject.CommonName\n\t// ctx.Session.Set(\"userid\", userID)\n\t// log.Printf(\"Client authenticated. TLS/IP: %v, User ID: %v, Conn ID: %v\\n\", ctx.Conn.RemoteAddr(), userID, ctx.Conn.ID)\n\treturn ctx.Next()\n}"
        ],
        [
            "func (ctx *ReqCtx) Params(v interface{}) error {\n\tif ctx.params == nil {\n\t\treturn errors.New(\"ctx: request did not have any request parameters\")\n\t}\n\n\tif err := json.Unmarshal(ctx.params, v); err != nil {\n\t\treturn fmt.Errorf(\"ctx: cannot deserialize request params: %v\", err)\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (ctx *ReqCtx) Next() error {\n\tctx.mwIndex++\n\n\t// call next middleware in the stack, if any\n\tif ctx.mwIndex <= len(ctx.mw) {\n\t\treturn ctx.mw[ctx.mwIndex-1](ctx)\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (ctx *ResCtx) Result(v interface{}) error {\n\tif !ctx.Success {\n\t\treturn errors.New(\"ctx: cannot read result data since server returned an error\")\n\t}\n\tif ctx.result == nil {\n\t\treturn errors.New(\"ctx: server did not return any response data\")\n\t}\n\n\tif err := json.Unmarshal(ctx.result, v); err != nil {\n\t\treturn fmt.Errorf(\"ctx: cannot deserialize response result: %v\", err)\n\t}\n\treturn nil\n}"
        ],
        [
            "func (ctx *ResCtx) ErrorData(v interface{}) error {\n\tif ctx.Success {\n\t\treturn errors.New(\"ctx: cannot read error data since server returned a success response\")\n\t}\n\tif ctx.errorData == nil {\n\t\treturn errors.New(\"ctx: server did not return any error data\")\n\t}\n\n\tif err := json.Unmarshal(ctx.errorData, v); err != nil {\n\t\treturn fmt.Errorf(\"ctx: cannot deserialize error data: %v\", err)\n\t}\n\treturn nil\n}"
        ],
        [
            "func MiddlewareList(middlware []Middleware) Middleware {\n\treturn Middleware(func(next Handler) Handler {\n\t\tfor _, m := range middlware {\n\t\t\tnext = m(next)\n\t\t}\n\t\treturn next\n\t})\n}"
        ],
        [
            "func LogFactory(name string, logType LogType, writer io.Writer) Logger {\n\tlog := &logger{Name: name, LogLevel: minLogLevel, Writer: writer}\n\tif logType == Lager {\n\t\treturn NewLager(log)\n\t}\n\treturn NewLager(log)\n}"
        ],
        [
            "func NewRouter() *Router {\n\treturn &Router{routes: make(map[string]func(ctx *neptulon.ReqCtx) error)}\n}"
        ],
        [
            "func (r *Router) Request(route string, handler func(ctx *neptulon.ReqCtx) error) {\n\tr.routes[route] = handler\n}"
        ],
        [
            "func (r *Router) Middleware(ctx *neptulon.ReqCtx) error {\n\tif handler, ok := r.routes[ctx.Method]; ok {\n\t\treturn handler(ctx)\n\t}\n\n\treturn ctx.Next()\n}"
        ],
        [
            "func NotFound(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n\thttp.NotFound(w, r)\n}"
        ],
        [
            "func NewMysqlDump(ip, username, password string) *MysqlDump {\n\tlo.G.Debug(\"setting up a new local mysqldump object\")\n\tm := &MysqlDump{\n\t\tIP:       ip,\n\t\tUsername: username,\n\t\tPassword: password,\n\t\tCaller:   command.NewLocalExecuter(),\n\t}\n\treturn m\n}"
        ],
        [
            "func NewRemoteMysqlDump(username, password string, sshCfg command.SshConfig) (*MysqlDump, error) {\n\treturn NewRemoteMysqlDumpWithPath(username, password, sshCfg, \"\")\n}"
        ],
        [
            "func (s *MysqlDump) Import(lfile io.Reader) (err error) {\n\tif err = s.RemoteOps.UploadFile(lfile); err != nil {\n\t\treturn err\n\t}\n\n\terr = s.restore()\n\tlo.G.Debug(\"mysqldump Import called: \", err)\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = s.RemoteOps.RemoveRemoteFile()\n\n\tlo.G.Debug(\"mysqldump remove remote file called: \", err)\n\treturn\n}"
        ],
        [
            "func (s *MysqlDump) Dump(dest io.Writer) (err error) {\n\terr = s.Caller.Execute(dest, s.getDumpCommand())\n\tlo.G.Debug(\"mysqldump command called\")\n\treturn\n}"
        ],
        [
            "func NewRemoteExecutor(sshCfg SshConfig) (executor Executer, err error) {\n\tclientconfig := &ssh.ClientConfig{\n\t\tUser:            sshCfg.Username,\n\t\tAuth:            sshCfg.GetAuthMethod(),\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n\tremoteExecutor := &DefaultRemoteExecutor{}\n\tremoteExecutor.LazyClientDial = func() {\n\t\tclient, err := ssh.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", sshCfg.Host, sshCfg.Port), clientconfig)\n\t\tif err != nil {\n\t\t\tlo.G.Error(\"ssh connection issue:\", err)\n\t\t\treturn\n\t\t}\n\t\tremoteExecutor.Client = NewClientWrapper(client)\n\t}\n\texecutor = remoteExecutor\n\treturn\n}"
        ],
        [
            "func (executor *DefaultRemoteExecutor) Execute(dest io.Writer, command string) (err error) {\n\tvar session SSHSession\n\tvar stdoutReader io.Reader\n\n\tif executor.once.Do(executor.LazyClientDial); executor.Client != nil {\n\t\tsession, err = executor.Client.NewSession()\n\t\tdefer session.Close()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tstdoutReader, err = session.StdoutPipe()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\terr = session.Start(command)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\t_, err = io.Copy(dest, stdoutReader)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\terr = session.Wait()\n\t} else {\n\t\terr = fmt.Errorf(\"un-initialized client executor\")\n\t\tlo.G.Error(err.Error())\n\t}\n\treturn\n}"
        ],
        [
            "func (h *Hello) World(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"Hello World!\"))\n}"
        ],
        [
            "func (h *Hello) Name(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n\tname := scaffold.GetParam(ctx, \"name\")\n\n\tmsg := fmt.Sprintf(\"Hello %s!\", name)\n\tw.Write([]byte(msg))\n}"
        ],
        [
            "func NewPgDump(ip string, port int, database, username, password string) *PgDump {\n\treturn &PgDump{\n\t\tIP:                ip,\n\t\tPort:              port,\n\t\tDatabase:          database,\n\t\tUsername:          username,\n\t\tPassword:          password,\n\t\tCaller:            command.NewLocalExecuter(),\n\t\tRecreateOnRestore: false,\n\t}\n}"
        ],
        [
            "func NewPgRemoteDump(port int, database, username, password string, sshCfg command.SshConfig) (*PgDump, error) {\n\treturn NewPgRemoteDumpWithPath(port, database, username, password, sshCfg, \"\")\n}"
        ],
        [
            "func (s *PgDump) Import(lfile io.Reader) (err error) {\n\tlo.G.Debug(\"pgdump Import being called\")\n\n\tif err = s.RemoteOps.UploadFile(lfile); err == nil {\n\t\terr = s.restore()\n\t}\n\treturn\n}"
        ],
        [
            "func New(s string) *IrcText {\n\treturn &IrcText{text: s, bgColor: None, fgColor: None}\n}"
        ],
        [
            "func (i *IrcText) SetFg(c int) *IrcText {\n\ti.fgColor = c\n\treturn i\n}"
        ],
        [
            "func (i *IrcText) SetBg(c int) *IrcText {\n\ti.bgColor = c\n\treturn i\n}"
        ],
        [
            "func HandlerBuilder(i interface{}) (scaffold.Handler, error) {\n\tswitch i.(type) {\n\tcase Handler:\n\t\treturn build(i.(Handler)), nil\n\tcase func(context.Context, http.ResponseWriter, *http.Request) error:\n\t\treturn build(HandlerFunc(i.(func(context.Context, http.ResponseWriter, *http.Request) error))), nil\n\t}\n\n\treturn nil, errors.New(\"Invalid type\")\n}"
        ],
        [
            "func LoggerWithPrefix(prefix string) func(ctx *neptulon.ReqCtx) error {\n\tif prefix != \"\" {\n\t\tprefix = prefix + \": \"\n\t}\n\n\treturn func(ctx *neptulon.ReqCtx) error {\n\t\tvar v interface{}\n\t\tctx.Params(&v)\n\n\t\terr := ctx.Next()\n\n\t\tvar res interface{}\n\t\tif res = ctx.Session.Get(CustResLogDataKey); res == nil {\n\t\t\tres = ctx.Res\n\t\t\tif res == nil {\n\t\t\t\tres = ctx.Err\n\t\t\t}\n\t\t}\n\n\t\tlog.Printf(\"%vmw: logger: %v: %v, in: \\\"%v\\\", out: \\\"%#v\\\"\", prefix, ctx.ID, ctx.Method, v, res)\n\n\t\treturn err\n\t}\n}"
        ],
        [
            "func NewEncoder(defaultEncoding Encoding, encodings ...Encoding) *Encoder {\n\tm := make(map[Encoding]*mimeInfo)\n\n\tfor _, e := range append(encodings, defaultEncoding) {\n\t\tinfo := parseMimeInfo(e.Mime())\n\t\tm[e] = info\n\t}\n\n\treturn &Encoder{\n\t\tdefaultEncoding: defaultEncoding,\n\t\tencodings:       m,\n\t}\n}"
        ],
        [
            "func (e *Encoder) Parser(r *http.Request) Parser {\n\tcontentType := r.Header.Get(\"Content-Type\")\n\tinfo := parseMimeInfo(contentType)\n\n\tif info != nil {\n\t\tfor encoding, i := range e.encodings {\n\t\t\tif i.equals(info) {\n\t\t\t\treturn encoding\n\t\t\t}\n\t\t}\n\t}\n\n\treturn e.defaultEncoding\n}"
        ],
        [
            "func (e *Encoder) Responder(r *http.Request) Responder {\n\taccept := r.Header.Get(\"Accept\")\n\tinfoList := parseAcceptHeader(accept)\n\n\tfor _, info := range infoList {\n\t\tfor encoding, i := range e.encodings {\n\t\t\tif i.equals(info) {\n\t\t\t\treturn encoding\n\t\t\t}\n\t\t}\n\t}\n\n\treturn e.Parser(r).(Responder)\n}"
        ],
        [
            "func NewErrorStatus(status int, err string) error {\n\treturn &errStatus{\n\t\terror:  errors.New(err),\n\t\tstatus: status,\n\t}\n}"
        ],
        [
            "func ConvertErrorStatus(status int, err error) error {\n\treturn &errStatus{\n\t\terror:  err,\n\t\tstatus: status,\n\t}\n}"
        ],
        [
            "func (f FileEntry) Read(p []byte) (n int, err error) {\n\tfile := f.pbo.file\n\n\toffset, err := file.Seek(0, os.SEEK_CUR)\n\tif offset >= f.dataOffset+int64(f.DataBlockSize) {\n\t\treturn 0, io.EOF\n\t}\n\n\t// If the offset in the file we're in + length of the buffer is greater than the end of the file,\n\t// then instead read in fileEndOffset - currentOffset bytes\n\tif offset+int64(len(p)) > f.dataOffset+int64(f.DataBlockSize) {\n\t\tremainingBytes := (f.dataOffset + int64(f.DataBlockSize)) - offset\n\n\t\treturn file.Read(p[:remainingBytes])\n\t}\n\n\treturn file.Read(p)\n}"
        ],
        [
            "func (f HeaderExtension) EntrySize() int {\n\t// Length of the name includes a null terminator\n\t// the 4 * 5 is 4 bytes (uint32) for the 5 fields\n\tbaseSize := f.FileEntry.EntrySize()\n\n\tfor key, val := range f.ExtendedFields {\n\t\t// + 2 for the null terminator for each key/val\n\t\tbaseSize += len(key) + len(val) + 2\n\t}\n\n\t// There's a null terminator at the end of the block\n\treturn baseSize + 1\n}"
        ],
        [
            "func NewLager(log *logger) Logger {\n\tvar minLagerLogLevel lager.LogLevel\n\tswitch log.LogLevel {\n\tcase DEBUG:\n\t\tminLagerLogLevel = lager.DEBUG\n\tcase INFO:\n\t\tminLagerLogLevel = lager.INFO\n\tcase ERROR:\n\t\tminLagerLogLevel = lager.ERROR\n\tcase FATAL:\n\t\tminLagerLogLevel = lager.FATAL\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unknown log level: %s\", log.LogLevel))\n\t}\n\n\tlogger := lager.NewLogger(log.Name)\n\tlogger.RegisterSink(lager.NewWriterSink(log.Writer, minLagerLogLevel))\n\tlog.Logger = logger\n\n\treturn log\n}"
        ],
        [
            "func URLParts(ctx context.Context, r *http.Request) (context.Context, []string) {\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\n\tif parts, ok := ctx.Value(\"scaffold_url_parts\").([]string); ok {\n\t\treturn ctx, parts\n\t}\n\n\tparts := pathSplit(r.URL.Path)\n\n\tctx = context.WithValue(ctx, \"scaffold_url_parts\", parts)\n\treturn URLParts(ctx, r)\n}"
        ],
        [
            "func URLPart(ctx context.Context, r *http.Request, i int) (context.Context, string, bool) {\n\tctx, parts := URLParts(ctx, r)\n\tif len(parts) > i && i >= 0 {\n\t\treturn ctx, parts[i], true\n\t}\n\treturn ctx, \"\", false\n}"
        ],
        [
            "func StoreParam(ctx context.Context, name string, value string) context.Context {\n\tn := paramName(name)\n\treturn context.WithValue(ctx, n, Param(value))\n}"
        ],
        [
            "func GetParam(ctx context.Context, name string) Param {\n\tn := paramName(name)\n\tif p, ok := ctx.Value(n).(Param); ok {\n\t\treturn p\n\t}\n\treturn \"\"\n}"
        ],
        [
            "func (p Param) Int32() (int32, error) {\n\ti, err := strconv.ParseInt(string(p), 10, 32)\n\treturn int32(i), err\n}"
        ],
        [
            "func (p Param) UInt() (uint, error) {\n\ti, err := strconv.ParseUint(string(p), 10, strconv.IntSize)\n\treturn uint(i), err\n}"
        ],
        [
            "func (p Param) UInt32() (uint32, error) {\n\ti, err := strconv.ParseUint(string(p), 10, 32)\n\treturn uint32(i), err\n}"
        ],
        [
            "func (p Param) Float32() (float32, error) {\n\tf, err := strconv.ParseFloat(string(p), 32)\n\treturn float32(f), err\n}"
        ],
        [
            "func (s *RemoteOperations) UploadFile(lfile io.Reader) (err error) {\n\tvar rfile io.WriteCloser\n\n\tif rfile, err = s.GetRemoteFile(); err == nil {\n\t\tdefer rfile.Close()\n\t\t_, err = io.Copy(rfile, lfile)\n\t}\n\treturn\n}"
        ],
        [
            "func (s *RemoteOperations) RemoveRemoteFile() (err error) {\n\tvar sftpclient SFTPClient\n\tsftpclient, err = s.getClient()\n\n\tif err == nil {\n\t\terr = SafeRemoveSSH(sftpclient, s.remotePath)\n\t}\n\n\treturn\n}"
        ],
        [
            "func (s *RemoteOperations) GetRemoteFile() (rfile io.WriteCloser, err error) {\n\tvar sftpclient SFTPClient\n\tsftpclient, err = s.getClient()\n\n\tif err == nil {\n\t\trfile, err = SafeCreateSSH(sftpclient, s.remotePath)\n\t}\n\n\treturn\n}"
        ],
        [
            "func NewConn() (*Conn, error) {\n\tid, err := shortid.UUID()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := &Conn{\n\t\tID:             id,\n\t\tSession:        cmap.New(),\n\t\tresRoutes:      cmap.New(),\n\t\tdeadline:       time.Second * time.Duration(300),\n\t\tdisconnHandler: func(c *Conn) {},\n\t}\n\tc.connected.Store(false)\n\treturn c, nil\n}"
        ],
        [
            "func (c *Conn) RemoteAddr() net.Addr {\n\tws := c.ws.Load().(*websocket.Conn)\n\tif ws == nil {\n\t\treturn nil\n\t}\n\n\treturn ws.RemoteAddr()\n}"
        ],
        [
            "func (c *Conn) SendRequest(method string, params interface{}, resHandler func(res *ResCtx) error) (reqID string, err error) {\n\tid, err := shortid.UUID()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treq := request{ID: id, Method: method, Params: params}\n\tif err = c.send(req); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tc.resRoutes.Set(req.ID, resHandler)\n\treturn id, nil\n}"
        ],
        [
            "func (c *Conn) SendRequestArr(method string, resHandler func(res *ResCtx) error, params ...interface{}) (reqID string, err error) {\n\treturn c.SendRequest(method, params, resHandler)\n}"
        ],
        [
            "func (c *Conn) Close() error {\n\tc.connected.Store(false)\n\tws := c.ws.Load().(*websocket.Conn)\n\tif ws != nil {\n\t\tws.Close()\n\t}\n\treturn nil\n}"
        ],
        [
            "func (c *Conn) sendResponse(id string, result interface{}, err *ResError) error {\n\treturn c.send(response{ID: id, Result: result, Error: err})\n}"
        ],
        [
            "func (c *Conn) send(msg interface{}) error {\n\tif !c.connected.Load().(bool) {\n\t\treturn errors.New(\"use of closed connection\")\n\t}\n\n\treturn websocket.JSON.Send(c.ws.Load().(*websocket.Conn), msg)\n}"
        ],
        [
            "func (c *Conn) receive(msg *message) error {\n\tif !c.connected.Load().(bool) {\n\t\treturn errors.New(\"use of closed connection\")\n\t}\n\n\treturn websocket.JSON.Receive(c.ws.Load().(*websocket.Conn), &msg)\n}"
        ],
        [
            "func (c *Conn) setConn(ws *websocket.Conn) error {\n\tc.ws.Store(ws)\n\tc.connected.Store(true)\n\tif err := ws.SetDeadline(time.Now().Add(c.deadline)); err != nil {\n\t\treturn fmt.Errorf(\"conn: error while setting websocket connection deadline: %v\", err)\n\t}\n\treturn nil\n}"
        ],
        [
            "func (c *Conn) startReceive() {\n\trecvCounter.Add(1)\n\tdefer func() {\n\t\tc.Close()\n\t\tc.disconnHandler(c)\n\t\trecvCounter.Add(-1)\n\t}()\n\n\tfor {\n\t\tvar m message\n\t\terr := c.receive(&m)\n\t\tif err != nil {\n\t\t\t// if we closed the connection\n\t\t\tif !c.connected.Load().(bool) {\n\t\t\t\tlog.Printf(\"conn: closed %v: %v\", c.ID, c.RemoteAddr())\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// if peer closed the connection\n\t\t\tif err == io.EOF {\n\t\t\t\tlog.Printf(\"conn: peer disconnected %v: %v\", c.ID, c.RemoteAddr())\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tlog.Printf(\"conn: error while receiving message: %v\", err)\n\t\t\tbreak\n\t\t}\n\n\t\t// if the message is a request\n\t\tif m.Method != \"\" {\n\t\t\treqCounter.Add(1)\n\t\t\tc.wg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer reqCounter.Add(-1)\n\t\t\t\tdefer recoverAndLog(c, &c.wg)\n\t\t\t\tctx := newReqCtx(c, m.ID, m.Method, m.Params, c.middleware)\n\t\t\t\tif err := ctx.Next(); err != nil {\n\t\t\t\t\tlog.Printf(\"ctx: request middleware returned error: %v\", err)\n\t\t\t\t\tc.Close()\n\t\t\t\t}\n\t\t\t\tif ctx.Res != nil || ctx.Err != nil {\n\t\t\t\t\tif err := ctx.Conn.sendResponse(ctx.ID, ctx.Res, ctx.Err); err != nil {\n\t\t\t\t\t\tlog.Printf(\"ctx: error sending response: %v\", err)\n\t\t\t\t\t\tc.Close()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// if the message is not a JSON-RPC message\n\t\tif m.ID == \"\" || (m.Result == nil && m.Error == nil) {\n\t\t\tlog.Printf(\"conn: received an unknown message %v: %v, %v\", c.ID, c.RemoteAddr(), m)\n\t\t\tbreak\n\t\t}\n\n\t\t// if the message is a response\n\t\tif resHandler, ok := c.resRoutes.GetOk(m.ID); ok {\n\t\t\tresCounter.Add(1)\n\t\t\tc.wg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer resCounter.Add(-1)\n\t\t\t\tdefer recoverAndLog(c, &c.wg)\n\t\t\t\terr := resHandler.(func(ctx *ResCtx) error)(newResCtx(c, m.ID, m.Result, m.Error))\n\t\t\t\tc.resRoutes.Delete(m.ID)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"conn: error while handling response: %v\", err)\n\t\t\t\t\tc.Close()\n\t\t\t\t}\n\t\t\t}()\n\t\t} else {\n\t\t\tlog.Printf(\"conn: error while handling response: got response to a request with unknown ID: %v\", m.ID)\n\t\t\tbreak\n\t\t}\n\t}\n}"
        ],
        [
            "func NewPbo(path string) (*Pbo, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpbo := Pbo{\n\t\tfile: file,\n\t}\n\n\t// Create a new buffered reader\n\treader := bufio.NewReader(file)\n\n\tfor {\n\t\tentry := readEntry(reader)\n\t\tif entry.Flag == ProductEntry {\n\t\t\textension := HeaderExtension{\n\t\t\t\tFileEntry: entry,\n\t\t\t}\n\n\t\t\textension.ReadExtendedFields(reader)\n\t\t\tpbo.HeaderExtension = &extension\n\n\t\t\tpbo.dataOffset += int64(extension.EntrySize())\n\n\t\t\tcontinue\n\t\t}\n\n\t\tpbo.dataOffset += int64(entry.EntrySize())\n\n\t\tif entry.IsNull() {\n\t\t\tbreak\n\t\t}\n\n\t\tentry.pbo = &pbo\n\t\tpbo.Entries = append(pbo.Entries, entry)\n\t}\n\n\t// Loop through all of our entries and set their data offset\n\tbaseOffset := pbo.dataOffset\n\tfor i := range pbo.Entries {\n\t\tentry := &pbo.Entries[i]\n\t\t// If the block is compressed, use the compressed size. If it's not, use the actual size\n\t\tentry.dataOffset = baseOffset\n\t\tbaseOffset += int64(entry.DataBlockSize)\n\t}\n\n\treturn &pbo, nil\n}"
        ],
        [
            "func NewReadWriteCloser(readErr, writeErr, closeErr error) *MockReadWriteCloser {\n\treturn &MockReadWriteCloser{\n\t\tReadErr:  readErr,\n\t\tWriteErr: writeErr,\n\t\tCloseErr: closeErr,\n\t}\n}"
        ],
        [
            "func (r *MockReadWriteCloser) Read(p []byte) (n int, err error) {\n\n\tif err = r.ReadErr; err == nil {\n\t\tr.BytesRead = p\n\t\tn = len(p)\n\t}\n\treturn\n}"
        ],
        [
            "func (r *MockReadWriteCloser) Write(p []byte) (n int, err error) {\n\n\tif err = r.WriteErr; err != nil {\n\t\tr.BytesWritten = p\n\t\tn = len(p)\n\t}\n\treturn\n}"
        ],
        [
            "func SafeRemoveSSH(client SFTPClient, filePath string) (err error) {\n\tssh := sshClientBucket{\n\t\tclient: client,\n\t}\n\tlo.G.Debug(\"Preparing to remove %s\", filePath)\n\tif !ssh.exists(filePath) {\n\t\tlo.G.Debug(\"Removing %s\", filePath)\n\t\terr = client.Remove(filePath)\n\t}\n\treturn\n}"
        ],
        [
            "func SafeCreateSSH(client SFTPClient, name ...string) (file *sftp.File, err error) {\n\tssh := sshClientBucket{\n\t\tclient: client,\n\t}\n\tfpath := path.Join(name...)\n\tbasepath := filepath.Dir(fpath)\n\n\tif err = ssh.remoteSafeMkdirAll(basepath); err == nil {\n\t\tfile, err = client.Create(fpath)\n\t}\n\treturn\n}"
        ],
        [
            "func SafeCreate(name ...string) (file *os.File, err error) {\n\tp, e := ensurePath(path.Join(name...))\n\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\treturn os.Create(p)\n}"
        ],
        [
            "func HMAC(password string) func(ctx *neptulon.ReqCtx) error {\n\tpass := []byte(password)\n\n\treturn func(ctx *neptulon.ReqCtx) error {\n\t\t// if user is already authenticated\n\t\tif _, ok := ctx.Conn.Session.GetOk(\"userid\"); ok {\n\t\t\treturn ctx.Next()\n\t\t}\n\n\t\t// if user is not authenticated.. check the JWT token\n\t\tvar t token\n\t\tif err := ctx.Params(&t); err != nil {\n\t\t\tctx.Conn.Close()\n\t\t\treturn err\n\t\t}\n\n\t\tjt, err := jwt.Parse(t.Token, func(token *jwt.Token) (interface{}, error) {\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"mw: jwt: unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t\t}\n\t\t\treturn pass, nil\n\t\t})\n\n\t\tif err != nil || !jt.Valid {\n\t\t\tctx.Conn.Close()\n\t\t\treturn fmt.Errorf(\"mw: jwt: invalid JWT authentication attempt: %v: %v: %v\", err, ctx.Conn.RemoteAddr(), t.Token)\n\t\t}\n\n\t\tuserID := jt.Claims[\"userid\"].(string)\n\t\tctx.Conn.Session.Set(\"userid\", userID)\n\t\tlog.Printf(\"mw: jwt: client authenticated, user: %v, conn: %v, ip: %v\", userID, ctx.Conn.ID, ctx.Conn.RemoteAddr())\n\t\treturn ctx.Next()\n\t}\n}"
        ],
        [
            "func Scaffold(d Dispatcher, platform Platform) Handler {\n\trouter := New(d)\n\tplatform.Routes(router)\n\treturn router.dispatcher\n}"
        ],
        [
            "func (r *Router) Route(pattern string) *Router {\n\tc := r.pattern(pattern)\n\treturn r.clone(c)\n}"
        ],
        [
            "func (r *Router) Group(pattern string, group func(*Router)) {\n\tc := r.pattern(pattern)\n\tgroup(r.clone(c))\n}"
        ],
        [
            "func (r *Router) Platform(pattern string, platform Platform) {\n\tc := r.pattern(pattern)\n\tplatform.Routes(r.clone(c))\n}"
        ],
        [
            "func (r *Router) Handle(pattern string, handlers ...interface{}) *Router {\n\tc := r.pattern(pattern)\n\tclone := r.clone(c)\n\tclone.handle(handlers)\n\treturn clone\n}"
        ],
        [
            "func (r *Router) Options(pattern string, handlers ...interface{}) *Router {\n\tc := r.pattern(pattern)\n\tc.Method = \"OPTIONS\"\n\tclone := r.clone(c)\n\tclone.handle(handlers)\n\treturn clone\n}"
        ],
        [
            "func (r *Router) Use(middleware ...interface{}) {\n\tr.dispatcher.Middleware(r.route, r.buildMiddlewares(middleware)...)\n}"
        ],
        [
            "func (r *Router) NotFound(i interface{}) {\n\thandler := r.buildHandler(i)\n\tr.dispatcher.NotFoundHandler(r.route, handler)\n}"
        ],
        [
            "func (r *Router) AddHandlerBuilder(builder func(interface{}) (Handler, error)) {\n\tr.builders = append(r.builders, &builder)\n}"
        ],
        [
            "func (e ErrorHandlerFunc) ServeErrorPage(ctx context.Context, w http.ResponseWriter, r *http.Request, status int, err error) {\n\te(ctx, w, r, status, err)\n}"
        ],
        [
            "func GetErrorHandler(ctx context.Context, status int) ErrorHandler {\n\tkey := fmt.Sprintf(\"error_handler_%d\", status)\n\tif h, ok := ctx.Value(key).(ErrorHandler); ok {\n\t\treturn h\n\t}\n\n\tkey = fmt.Sprintf(\"error_handler_%d\", AllStatusCodes)\n\tif h, ok := ctx.Value(key).(ErrorHandler); ok {\n\t\treturn h\n\t}\n\n\treturn DefaultErrorHandler\n}"
        ],
        [
            "func SetErrorHandler(status int, handler ErrorHandler) scaffold.Middleware {\n\treturn scaffold.Middleware(func(next scaffold.Handler) scaffold.Handler {\n\t\treturn scaffold.HandlerFunc(func(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n\t\t\tkey := fmt.Sprintf(\"error_handler_%d\", status)\n\t\t\tctx = context.WithValue(ctx, key, handler)\n\n\t\t\tnext.CtxServeHTTP(ctx, w, r)\n\t\t})\n\t})\n}"
        ],
        [
            "func SetErrorHandlerFunc(status int, handler func(ctx context.Context, w http.ResponseWriter, r *http.Request, status int, err error)) scaffold.Middleware {\n\treturn SetErrorHandler(status, ErrorHandlerFunc(handler))\n}"
        ],
        [
            "func Echo(ctx *neptulon.ReqCtx) error {\n\t// unmarshall incoming message into response directly\n\tif err := ctx.Params(&ctx.Res); err != nil {\n\t\treturn err\n\t}\n\treturn ctx.Next()\n}"
        ],
        [
            "func (c *ConfigArg) UnmarshalBinary(b []byte) error {\n\t// Must contain minimum length for argument\n\tif len(b) < configArgLen {\n\t\treturn io.ErrUnexpectedEOF\n\t}\n\n\t// Retrieve basic data\n\tc.BufferCount = binary.BigEndian.Uint16(b[0:2])\n\tc.FirmwareVersion = binary.BigEndian.Uint16(b[2:4])\n\tc.SectorCount = b[4]\n\n\t// Version is most significant 4 bits\n\tc.Version = uint8(b[5] >> 4)\n\n\t// Command is least significant 4 bits of byte 5\n\tc.Command = ConfigCommand(b[5] & 0x0f)\n\n\t// StringLength cannot be larger than the number of bytes remaining\n\t// in the buffer\n\tc.StringLength = binary.BigEndian.Uint16(b[6:8])\n\tif len(b[8:]) < int(c.StringLength) {\n\t\treturn io.ErrUnexpectedEOF\n\t}\n\t// StringLength must not be greater than 1024, per AoEr11, Section 3.2.\n\tif c.StringLength > 1024 {\n\t\treturn ErrorBadArgumentParameter\n\t}\n\n\t// Copy config string for use\n\td := make([]byte, c.StringLength)\n\tcopy(d, b[8:])\n\tc.String = d\n\n\treturn nil\n}"
        ],
        [
            "func ataIdentify(r *ATAArg, rs io.ReadSeeker) (*ATAArg, error) {\n\t// Only ATA device identify allowed here\n\tif r.CmdStatus != ATACmdStatusIdentify {\n\t\treturn nil, errATAAbort\n\t}\n\n\t// Request must be for 1 sector (512 bytes)\n\tif r.SectorCount != 1 {\n\t\treturn nil, errATAAbort\n\t}\n\n\t// If rs is an Identifier, request its identity directly\n\tident, ok := rs.(Identifier)\n\tif !ok {\n\t\t// Currently no generic Identify implementation, as is done in\n\t\t// vblade.\n\t\t// TODO(mdlayher): add generic Identify implementation\n\t\treturn nil, ErrNotImplemented\n\t}\n\n\t// Retrieve device identity information\n\tid, err := ident.Identify()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &ATAArg{\n\t\tCmdStatus: ATACmdStatusReadyStatus,\n\t\tData:      id[:],\n\t}, nil\n}"
        ],
        [
            "func ataRead(r *ATAArg, rs io.ReadSeeker) (*ATAArg, error) {\n\t// Only ATA reads allowed here\n\tif r.CmdStatus != ATACmdStatusRead28Bit && r.CmdStatus != ATACmdStatusRead48Bit {\n\t\treturn nil, errATAAbort\n\t}\n\n\t// Read must not be flagged as a write\n\tif r.FlagWrite {\n\t\treturn nil, errATAAbort\n\t}\n\n\t// Convert LBA to byte offset and seek to correct location\n\toffset := calculateLBA(r.LBA, r.FlagLBA48Extended) * sectorSize\n\tif _, err := rs.Seek(offset, os.SEEK_SET); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Allocate buffer and read exact (sector count * sector size) bytes from\n\t// stream\n\t//\n\t// TODO(mdlayher): use r.Data instead of allocating?\n\tb := make([]byte, int(r.SectorCount)*sectorSize)\n\tn, err := rs.Read(b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Verify sector count\n\tif sectors := n / sectorSize; sectors != int(r.SectorCount) {\n\t\treturn nil, errATAAbort\n\t}\n\n\treturn &ATAArg{\n\t\tCmdStatus: ATACmdStatusReadyStatus,\n\t\tData:      b,\n\t}, nil\n}"
        ],
        [
            "func ataWrite(r *ATAArg, rs io.ReadSeeker) (*ATAArg, error) {\n\t// Only ATA writes allowed here\n\tif r.CmdStatus != ATACmdStatusWrite28Bit && r.CmdStatus != ATACmdStatusWrite48Bit {\n\t\treturn nil, errATAAbort\n\t}\n\n\t// Write must be flagged as a write\n\tif !r.FlagWrite {\n\t\treturn nil, errATAAbort\n\t}\n\n\t// Verify that request data and sector count match up\n\tif sectors := len(r.Data) / sectorSize; sectors != int(r.SectorCount) {\n\t\treturn nil, errATAAbort\n\t}\n\n\t// Determine if io.ReadSeeker is also an io.Writer, and if a write is\n\t// requested\n\trws, ok := rs.(io.ReadWriteSeeker)\n\tif !ok {\n\t\t// A write was requested, but the io.ReadSeeker is not an io.Writer\n\t\treturn nil, errATAAbort\n\t}\n\n\t// TODO(mdlayher): implement asynchronous writes\n\n\t// Convert LBA to byte offset and seek to correct location\n\toffset := calculateLBA(r.LBA, r.FlagLBA48Extended) * sectorSize\n\tif _, err := rs.Seek(offset, os.SEEK_SET); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Write data to stream\n\tn, err := rws.Write(r.Data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Verify full sectors written to disk using sector count\n\tif sectors := n / sectorSize; sectors != int(r.SectorCount) {\n\t\treturn nil, errATAAbort\n\t}\n\n\treturn &ATAArg{\n\t\tCmdStatus: ATACmdStatusReadyStatus,\n\t}, nil\n}"
        ],
        [
            "func calculateLBA(rlba [6]uint8, is48Bit bool) int64 {\n\t// Pad two bytes at the end to parse as uint64\n\tb := []byte{\n\t\trlba[0],\n\t\trlba[1],\n\t\trlba[2],\n\t\trlba[3],\n\t\trlba[4],\n\t\trlba[5],\n\t\t0,\n\t\t0,\n\t}\n\tlba := binary.LittleEndian.Uint64(b)\n\n\t// Mask off high bits to limit size to either 48 bit or 28 bit,\n\t// depending on is48Bit's value.\n\tif is48Bit {\n\t\t// 48-bit\n\t\tlba &= 0x0000ffffffffffff\n\t} else {\n\t\t// 28-bit\n\t\tlba &= 0x0fffffff\n\t}\n\n\treturn int64(lba)\n}"
        ],
        [
            "func (r *ReserveReleaseArg) MarshalBinary() ([]byte, error) {\n\t// Must indicate correct number of hardware addresses\n\tif int(r.NMACs) != len(r.MACs) {\n\t\treturn nil, ErrorBadArgumentParameter\n\t}\n\n\t// Allocate byte slice for argument and hardware addresses\n\tb := make([]byte, reserveReleaseArgLen+(r.NMACs*6))\n\n\tb[0] = uint8(r.Command)\n\tb[1] = uint8(r.NMACs)\n\n\t// Copy each hardware address into byte slice, after verifying exactly\n\t// 6 bytes in length\n\tn := 2\n\tfor _, m := range r.MACs {\n\t\tif len(m) != 6 {\n\t\t\treturn nil, ErrorBadArgumentParameter\n\t\t}\n\n\t\tcopy(b[n:n+6], m)\n\t\tn += 6\n\t}\n\n\treturn b, nil\n}"
        ],
        [
            "func (r *ReserveReleaseArg) UnmarshalBinary(b []byte) error {\n\t// Must contain minimum length for argument\n\tif len(b) < reserveReleaseArgLen {\n\t\treturn io.ErrUnexpectedEOF\n\t}\n\n\tr.Command = ReserveReleaseCommand(b[0])\n\tr.NMACs = b[1]\n\n\t// Must have exact number of bytes for hardware addresses with\n\t// this count\n\tif len(b[2:]) != (6 * int(r.NMACs)) {\n\t\treturn io.ErrUnexpectedEOF\n\t}\n\n\t// Copy each hardware address into slice\n\tr.MACs = make([]net.HardwareAddr, r.NMACs)\n\tfor i := 0; i < int(r.NMACs); i++ {\n\t\tm := make(net.HardwareAddr, 6)\n\t\tcopy(m, b[2+(i*6):2+(i*6)+6])\n\t\tr.MACs[i] = m\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (a *ATAArg) MarshalBinary() ([]byte, error) {\n\t// Allocate correct number of bytes for argument and data\n\tb := make([]byte, ataArgLen+len(a.Data))\n\n\t// Add bit flags at appropriate positions\n\t//\n\t// 0101 0011\n\t//  | |   ||\n\t//  | |   |+-- write flag\n\t//  | |   +--- asynchronous flag\n\t//  | +------- device/head register flag\n\t//  +--------- extended LBA48 flag\n\tvar flags uint8\n\tif a.FlagLBA48Extended {\n\t\tflags |= (1 << 6)\n\t}\n\tif a.FlagATADeviceHeadRegister {\n\t\tflags |= (1 << 4)\n\t}\n\tif a.FlagAsynchronous {\n\t\tflags |= (1 << 1)\n\t}\n\tif a.FlagWrite {\n\t\tflags |= 1\n\t}\n\tb[0] = flags\n\n\t// Set other ATA data\n\tb[1] = a.ErrFeature\n\tb[2] = a.SectorCount\n\tb[3] = uint8(a.CmdStatus)\n\tb[4] = a.LBA[0]\n\tb[5] = a.LBA[1]\n\tb[6] = a.LBA[2]\n\tb[7] = a.LBA[3]\n\tb[8] = a.LBA[4]\n\tb[9] = a.LBA[5]\n\n\t// 2 bytes reserved space\n\n\t// Copy raw data after argument header\n\tcopy(b[12:], a.Data)\n\n\treturn b, nil\n}"
        ],
        [
            "func New(db *sql.DB, tables Tables) Fixture {\n\tfixture := Fixture{db: db, Tables: tables}\n\treturn fixture\n}"
        ],
        [
            "func FromYAML(db *sql.DB, yamlIn []byte) (Fixture, error) {\n\tvar tables Tables\n\terr := yaml.Unmarshal(yamlIn, &tables)\n\treturn New(db, tables), err\n}"
        ],
        [
            "func FromJSON(db *sql.DB, jsonIn []byte) (Fixture, error) {\n\tvar tables Tables\n\terr := json.Unmarshal(jsonIn, &tables)\n\treturn New(db, tables), err\n}"
        ],
        [
            "func (d *Directive) MarshalBinary() ([]byte, error) {\n\t// Ethernet hardware addresses must be 6 bytes in length\n\tif len(d.MAC) != 6 {\n\t\treturn nil, ErrorBadArgumentParameter\n\t}\n\n\t// Allocate fixed-length byte structure\n\tb := make([]byte, directiveLen)\n\n\t// 1 byte reserved\n\n\t// Add command copy hardware address into Directive\n\tb[1] = uint8(d.Command)\n\tcopy(b[2:], d.MAC)\n\n\treturn b, nil\n}"
        ],
        [
            "func (m *MACMaskArg) MarshalBinary() ([]byte, error) {\n\t// Must indicate correct number of directives\n\tif int(m.DirCount) != len(m.Directives) {\n\t\treturn nil, ErrorBadArgumentParameter\n\t}\n\n\t// Allocate byte slice for argument and all directives\n\tb := make([]byte, macMaskArgLen+(directiveLen*m.DirCount))\n\n\t// 1 byte reserved\n\n\tb[1] = uint8(m.Command)\n\tb[2] = uint8(m.Error)\n\tb[3] = m.DirCount\n\n\t// Marshal each directive into binary and copy into byte slice\n\t// after argument\n\tn := 4\n\tfor _, d := range m.Directives {\n\t\tdb, err := d.MarshalBinary()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcopy(b[n:n+directiveLen], db)\n\t\tn += directiveLen\n\t}\n\n\treturn b, nil\n}"
        ],
        [
            "func NewSendToLogger(logger *golog.Logger) LogBackend {\n\tif logger == nil {\n\t\treturn &SendToLogger{\n\t\t\tLogger: golog.New(os.Stderr, \"\", golog.LstdFlags),\n\t\t}\n\t}\n\treturn &SendToLogger{\n\t\tLogger: logger,\n\t}\n}"
        ],
        [
            "func NewMulti(vals ...interface{}) LogBackend {\n\tif len(vals)%2 != 0 {\n\t\tFail(e.New(\"parameters must be in pair of LogBackend and Formatter\"))\n\t\treturn nil\n\t}\n\tl := len(vals) / 2\n\tmp := make([]LogBackend, 0, l)\n\tfor i := 0; i < len(vals); i += 2 {\n\t\tbak, ok := vals[i].(LogBackend)\n\t\tif !ok {\n\t\t\tFail(e.New(\"not a LogBackend\"))\n\t\t\treturn nil\n\t\t}\n\t\tf, ok := vals[i+1].(Formatter)\n\t\tif !ok {\n\t\t\tFail(e.New(\"not a Formatter\"))\n\t\t\treturn nil\n\t\t}\n\t\tbak.F(f)\n\t\tmp = append(mp, bak)\n\t}\n\treturn &MultiLog{\n\t\tmp: mp,\n\t}\n}"
        ],
        [
            "func (mp *MultiLog) OuterLog(level Level, tags ...string) io.Writer {\n\tif mp.chouter != nil {\n\t\treturn &outer{\n\t\t\tch:  mp.chouter,\n\t\t\tbuf: make([]byte, 0),\n\t\t}\n\t}\n\tmp.chclose = make(chan chan struct{})\n\tmp.chouter = make(chan []byte)\n\tif len(mp.mp) < 2 {\n\t\treturn nil\n\t}\n\tf := mp.mp[0].GetF()\n\tlogger := f.NewEntry(mp).Tag(\"outer\").EntryLevel(level)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase buf := <-mp.chouter:\n\t\t\t\tlogger.Tag(tags...).Println(string(buf))\n\t\t\tcase ch := <-mp.chclose:\n\t\t\t\tch <- struct{}{}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn &outer{\n\t\tch:  mp.chouter,\n\t\tbuf: make([]byte, 0),\n\t}\n}"
        ],
        [
            "func (s *RunConfig) PublishPort(hostPort, containerPort uint16) {\n\ts.Options = append(s.Options, \"-p\",\n\t\tfmt.Sprintf(\"%d:%d\", hostPort, containerPort))\n}"
        ],
        [
            "func (s *RunConfig) Name(name string) {\n\ts.Options = append(s.Options, \"--name\", name)\n}"
        ],
        [
            "func (s *RunConfig) AddArgs(args ...string) {\n\ts.Args = append(s.Args, args...)\n}"
        ],
        [
            "func NewCORSHandler() *CORSHandler {\n\treturn &CORSHandler{\n\t\tPredicateOrigin: raiqub.TrueForAll,\n\t\tHeaders: []string{\n\t\t\t\"Origin\", \"X-Requested-With\", \"Content-Type\",\n\t\t\t\"Accept\", \"Authorization\",\n\t\t},\n\t\tExposedHeaders: make([]string, 0),\n\t}\n}"
        ],
        [
            "func (s *CORSHandler) CreatePreflight(routes Routes) Routes {\n\tlist := make(Routes, 0, len(routes))\n\thList := make(map[string]*CORSPreflight, len(routes))\n\tfor _, v := range routes {\n\t\tpreflight, ok := hList[v.Path]\n\t\tif !ok {\n\t\t\tpreflight = &CORSPreflight{\n\t\t\t\t*s,\n\t\t\t\tmake([]string, 0, 1),\n\t\t\t\tv.MustAuth,\n\t\t\t}\n\t\t\thList[v.Path] = preflight\n\t\t}\n\n\t\tpreflight.Methods = append(preflight.Methods, v.Method)\n\t\tif v.MustAuth {\n\t\t\tpreflight.UseCredentials = true\n\t\t}\n\t}\n\n\tfor k, v := range hList {\n\t\tlist = append(list, Route{\n\t\t\tName:       \"\",\n\t\t\tMethod:     DEFAULT_CORS_PREFLIGHT_METHOD,\n\t\t\tPath:       k,\n\t\t\tMustAuth:   v.UseCredentials,\n\t\t\tActionFunc: v.ServeHTTP,\n\t\t})\n\t}\n\treturn list\n}"
        ],
        [
            "func (s *CORSPreflight) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\torigin := HttpHeader_Origin().GetReader(r.Header)\n\tstatus := http.StatusBadRequest\n\tmsg := \"\"\n\tdefer func() {\n\t\tw.WriteHeader(status)\n\t\tw.Write([]byte(msg))\n\t}()\n\n\tif origin.Value != \"\" {\n\t\tif !s.PredicateOrigin(origin.Value) {\n\t\t\tstatus = http.StatusForbidden\n\t\t\treturn\n\t\t}\n\n\t\tmethod := HttpHeader_AccessControlRequestMethod().\n\t\t\tGetReader(r.Header).Value\n\t\theader := strings.Split(\n\t\t\tHttpHeader_AccessControlRequestHeaders().\n\t\t\t\tGetReader(r.Header).Value, \", \")\n\t\tif len(header) == 1 && header[0] == \"\" {\n\t\t\theader = []string{}\n\t\t}\n\n\t\tif !raiqub.StringSlice(s.Methods).Exists(method) {\n\t\t\tmsg = \"Method not allowed\"\n\t\t\treturn\n\t\t}\n\n\t\tif len(s.Headers) == 0 {\n\t\t\tHttpHeader_AccessControlAllowHeaders().\n\t\t\t\tSetWriter(w.Header())\n\t\t} else {\n\t\t\tif len(header) > 0 &&\n\t\t\t\t!raiqub.StringSlice(s.Headers).ExistsAllIgnoreCase(header) {\n\t\t\t\tmsg = \"Header not allowed\"\n\t\t\t\treturn\n\t\t\t}\n\t\t\tHttpHeader_AccessControlAllowHeaders().\n\t\t\t\tSetValue(strings.Join(s.Headers, \", \")).\n\t\t\t\tSetWriter(w.Header())\n\t\t}\n\n\t\tHttpHeader_AccessControlAllowMethods().\n\t\t\tSetValue(strings.Join(s.Methods, \", \")).\n\t\t\tSetWriter(w.Header())\n\t\tHttpHeader_AccessControlAllowOrigin().\n\t\t\tSetValue(origin.Value).\n\t\t\tSetWriter(w.Header())\n\t\tHttpHeader_AccessControlAllowCredentials().\n\t\t\tSetValue(strconv.FormatBool(s.UseCredentials)).\n\t\t\tSetWriter(w.Header())\n\t\t// Optional\n\t\tHttpHeader_AccessControlMaxAge().\n\t\t\tSetValue(strconv.Itoa(int(DEFAULT_CORS_MAX_AGE))).\n\t\t\tSetWriter(w.Header())\n\t\tstatus = http.StatusOK\n\t} else {\n\t\tstatus = http.StatusNotFound\n\t}\n}"
        ],
        [
            "func (s *CORSMiddleware) Handle(next http.Handler) http.Handler {\n\tfn := func(w http.ResponseWriter, r *http.Request) {\n\t\torigin := HttpHeader_Origin().GetReader(r.Header)\n\t\tif r.Method != DEFAULT_CORS_PREFLIGHT_METHOD && origin.Value != \"\" {\n\t\t\tif !s.PredicateOrigin(origin.Value) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tHttpHeader_AccessControlAllowOrigin().\n\t\t\t\tSetValue(origin.Value).\n\t\t\t\tSetWriter(w.Header())\n\t\t\tHttpHeader_AccessControlAllowCredentials().\n\t\t\t\tSetValue(strconv.FormatBool(s.UseCredentials)).\n\t\t\t\tSetWriter(w.Header())\n\t\t\tif len(s.Headers) > 0 {\n\t\t\t\tHttpHeader_AccessControlAllowHeaders().\n\t\t\t\t\tSetValue(strings.Join(s.Headers, \", \")).\n\t\t\t\t\tSetWriter(w.Header())\n\t\t\t} else {\n\t\t\t\tHttpHeader_AccessControlAllowHeaders().\n\t\t\t\t\tSetWriter(w.Header())\n\t\t\t}\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n\n\treturn http.HandlerFunc(fn)\n}"
        ],
        [
            "func NewRandomSourceListSecure() RandomSourceList {\n\treturn RandomSourceList{\n\t\tRandomSource{\n\t\t\tReader: rand.Reader,\n\t\t\tWeight: DEFAULT_SYS_RAND_SIZE,\n\t\t},\n\t\tRandomSource{\n\t\t\tReader: NewRandom(),\n\t\t\tWeight: DEFAULT_RAIQUB_RAND_SIZE,\n\t\t},\n\t}\n}"
        ],
        [
            "func (handler *SyslogHandler) Handle(record *Record) error {\n\n\tif handler.writter == nil {\n\t\twritter, err := syslog.Dial(\n\t\t\thandler.Network,\n\t\t\thandler.Address,\n\t\t\thandler.Facility|handler.Severity,\n\t\t\thandler.Tag,\n\t\t)\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thandler.writter = writter\n\t}\n\n\tmsg := handler.Formatter.Format(record)\n\n\tswitch record.Level {\n\tcase EMERGENCY:\n\t\treturn handler.writter.Emerg(msg)\n\tcase ALERT:\n\t\treturn handler.writter.Alert(msg)\n\tcase CRITICAL:\n\t\treturn handler.writter.Crit(msg)\n\tcase ERROR:\n\t\treturn handler.writter.Err(msg)\n\tcase WARNING:\n\t\treturn handler.writter.Warning(msg)\n\tcase NOTICE:\n\t\treturn handler.writter.Notice(msg)\n\tcase INFO:\n\t\treturn handler.writter.Info(msg)\n\tdefault:\n\t\treturn handler.writter.Debug(msg)\n\t}\n}"
        ],
        [
            "func (handler *SyslogHandler) Close() error {\n\tif handler.writter == nil {\n\t\treturn nil\n\t}\n\treturn handler.writter.Close()\n}"
        ],
        [
            "func hasDatePrefix(s string) bool {\n\tif len(s) < 10 {\n\t\treturn false\n\t}\n\tvar count int\n\tfor i, r := range s {\n\t\tif count != i {\n\t\t\treturn false\n\t\t}\n\t\tswitch i {\n\t\tcase 4, 7:\n\t\t\tif r != '-' {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\tif !isDigit(r) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tif i == 9 {\n\t\t\t// month\n\t\t\tif s[5] == '1' {\n\t\t\t\tif s[6] > '2' {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t} else if s[5] == '0' {\n\t\t\t\tif s[6] == '0' {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\t// day\n\t\t\tif s[8] == '0' {\n\t\t\t\tif s[9] == '0' {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t} else if s[8] == '3' {\n\t\t\t\tif s[9] > '1' {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t} else if s[8] != '1' && s[8] != '2' {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\treturn true\n\t\t}\n\t\tcount += 1\n\t}\n\n\treturn true\n}"
        ],
        [
            "func (f RuneMatcherFunc) Match(str string) (offset int, matchStr string) {\n\toffset = -1\n\tlength := len(str)\n\tif length == 0 {\n\t\treturn\n\t}\n\n\tfor i, r := range str {\n\t\tif f(r) {\n\t\t\tcontinue\n\t\t}\n\t\tif i != 0 {\n\t\t\toffset = i\n\t\t\tmatchStr = str[:i]\n\t\t\treturn\n\t\t}\n\t\treturn\n\t}\n\n\toffset = length\n\tmatchStr = str\n\treturn\n}"
        ],
        [
            "func (m *SuffixMatcher) Match(str string) (offset int, matchStr string) {\n\toffset = -1\n\n\t// at least 1 character is required to match suffix and matcher\n\td := len(str) - len(m.suffix)\n\tif d < 1 {\n\t\treturn\n\t}\n\n\tfor i, r := range str {\n\t\tif i > d {\n\t\t\treturn\n\t\t}\n\n\t\t// peek string to match to suffix pattern\n\t\tif i != 0 && m.suffix == str[i:i+len(m.suffix)] {\n\t\t\toffset = i + len(m.suffix)\n\t\t\tmatchStr = str[:i]\n\t\t\treturn\n\t\t}\n\n\t\tif !m.matcher.MatchRune(r) {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}"
        ],
        [
            "func (m *SuffixMatcher) MatchRune(r rune) bool {\n\treturn m.matcher.MatchRune(r)\n}"
        ],
        [
            "func (m *FixedLengthMatcher) Match(s string) (offset int, matchStr string) {\n\tif len(s) < m.length || !m.match(s) {\n\t\toffset = -1\n\t\treturn\n\t}\n\treturn m.length, s[:m.length]\n}"
        ],
        [
            "func (b *RefCountBox) Alloc() (DB, error) {\n\tb.Lock()\n\tdefer b.Unlock()\n\n\tif b.db.DB == nil {\n\t\tif b.DataPath == nil {\n\t\t\treturn DB{}, errorsp.WithStacks(ErrBoxDataPathNotSpecified)\n\t\t}\n\t\tvar db DB\n\t\tvar err error\n\t\tif b.OpenFunc == nil {\n\t\t\tdb, err = Open(b.DataPath(), 0644, nil)\n\t\t} else {\n\t\t\tdb, err = b.OpenFunc(b.DataPath())\n\t\t}\n\t\tif err != nil {\n\t\t\treturn DB{}, errorsp.WithStacks(err)\n\t\t}\n\t\tb.db, b.count = db, 0\n\t}\n\tb.count++\n\treturn b.db, nil\n}"
        ],
        [
            "func (b *RefCountBox) Free() {\n\tb.Lock()\n\tdefer b.Unlock()\n\n\tb.count--\n\tif b.count == 0 {\n\t\tb.db.Close()\n\t\tb.db = DB{}\n\t}\n}"
        ],
        [
            "func (g GRPCLoggerV2) Infof(format string, args ...interface{}) {\n\tg.l.Infof(format, args...)\n}"
        ],
        [
            "func (g GRPCLoggerV2) Warningf(format string, args ...interface{}) {\n\tg.l.Warningf(format, args...)\n}"
        ],
        [
            "func (g GRPCLoggerV2) Errorf(format string, args ...interface{}) {\n\tg.l.Errorf(format, args...)\n}"
        ],
        [
            "func (g GRPCLoggerV2) Fatalf(format string, args ...interface{}) {\n\tg.l.Criticalf(format, args...)\n}"
        ],
        [
            "func ToPhone(theString, delimiter string) (string, error) {\n\tf := New(theString)\n\tf.removeNonDigits()\n\n\tif f.length < 10 {\n\t\treturn \"\", errors.New(lengthError)\n\t}\n\n\tvar buffer bytes.Buffer\n\tcount := 0\n\tswitch f.length {\n\tcase 10:\n\t\tbuffer.WriteString(\"(\")\n\t\tfor _, i := range f.theString {\n\t\t\tcount++\n\t\t\tbuffer.WriteString(string(i))\n\t\t\tswitch count {\n\t\t\tcase 3:\n\t\t\t\tbuffer.WriteString(\") \")\n\t\t\tcase 6:\n\t\t\t\tbuffer.WriteString(fmt.Sprintf(\"%s\", delimiter))\n\t\t\t}\n\t\t}\n\tcase 11:\n\t\tfor _, i := range f.theString {\n\t\t\tcount++\n\t\t\tbuffer.WriteString(string(i))\n\t\t\tswitch count {\n\t\t\tcase 1:\n\t\t\t\tbuffer.WriteString(\" (\")\n\t\t\tcase 4:\n\t\t\t\tbuffer.WriteString(\") \")\n\t\t\tcase 7:\n\t\t\t\tbuffer.WriteString(fmt.Sprintf(\"%s\", delimiter))\n\t\t\t}\n\t\t}\n\tdefault:\n\t\treturn \"\", errors.New(\"non US number given\")\n\t}\n\treturn buffer.String(), nil\n}"
        ],
        [
            "func ToURL(theString, subdomain string, secure bool) (string, error) {\n\tf := New(theString)\n\n\tif f.length < 4 {\n\t\treturn \"\", errors.New(lengthError)\n\t}\n\n\tf.makeLower()\n\n\tif secure {\n\t\tif len(subdomain) > 0 {\n\t\t\treturn fmt.Sprintf(\"https://%s.%s\", subdomain, f.theString), nil\n\t\t}\n\t\treturn fmt.Sprintf(\"https://%s\", f.theString), nil\n\t}\n\n\tif len(subdomain) > 0 {\n\t\treturn fmt.Sprintf(\"http://%s.%s\", subdomain, f.theString), nil\n\t}\n\treturn fmt.Sprintf(\"http://%s\", f.theString), nil\n}"
        ],
        [
            "func ToSSN(theString, delimiter string) (string, error) {\n\tf := New(theString)\n\tf.removeNonDigits()\n\n\tif f.length != 9 {\n\t\treturn \"\", errors.New(\"string needs to be 9 digits for Social Security Numbers\")\n\t}\n\n\tvar buffer bytes.Buffer\n\tcount := 0\n\n\tfor _, i := range f.theString {\n\t\tcount++\n\n\t\tbuffer.WriteString(string(i))\n\n\t\tif count == 3 || count == 5 {\n\t\t\tbuffer.WriteString(delimiter)\n\t\t}\n\t}\n\treturn buffer.String(), nil\n}"
        ],
        [
            "func ToMorseCode(theString string) (string, error) {\n\tf := New(theString)\n\n\tif f.length < 1 {\n\t\treturn \"\", errors.New(lengthError)\n\t}\n\n\tf.makeLower()\n\n\tvar buffer bytes.Buffer\n\n\tfor _, i := range f.theString {\n\t\tkey := string(i)\n\t\tif _, ok := morse[key]; ok {\n\t\t\tbuffer.WriteString(morse[key])\n\t\t} else if key == \" \" {\n\t\t\tbuffer.WriteString(\" \")\n\t\t}\n\t}\n\treturn buffer.String(), nil\n}"
        ],
        [
            "func ToPirateSpeak(theString string) (string, error) {\n\tf := New(theString)\n\n\tif f.length < 1 {\n\t\treturn \"\", errors.New(lengthError)\n\t}\n\n\tf.urlEncodeSpaces()\n\n\tresponse, err := http.Get(fmt.Sprintf(pirateLink, f.theString))\n\tif err != nil {\n\t\treturn \"\", errors.New(\"unable to convert\")\n\t}\n\tdefer response.Body.Close()\n\n\tcontents, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(contents), nil\n}"
        ],
        [
            "func ToIRSA(theString string) (string, error) {\n\tf := New(theString)\n\n\tif f.length < 1 {\n\t\treturn \"\", errors.New(lengthError)\n\t}\n\n\tf.makeLower()\n\n\tvar buffer bytes.Buffer\n\n\tfor _, i := range f.theString {\n\t\tkey := strings.ToLower(string(i))\n\t\tif _, ok := irsa[key]; ok {\n\t\t\tbuffer.WriteString(irsa[key] + \" \")\n\t\t}\n\t}\n\treturn buffer.String(), nil\n}"
        ],
        [
            "func newDefaultLogger() *Logger {\n\treturn NewLogger(\"default\", DEBUG, []Handler{\n\t\t&WriteHandler{\n\t\t\tLevel:     DEBUG,\n\t\t\tFormatter: &StandardFormatter{TimeFormat: StandardTimeFormat},\n\t\t\tWriter:    os.Stderr,\n\t\t},\n\t}, 0)\n}"
        ],
        [
            "func Logf(level Level, format string, a ...interface{}) {\n\tgetDefaultLogger().log(level, format, a...)\n}"
        ],
        [
            "func (c *Config) Sections() []string {\n\tvar sections []string\n\tfor _, sect := range c.sections {\n\t\tsections = append(sections, sect.name)\n\t}\n\treturn sections\n}"
        ],
        [
            "func (c *Config) Options(section string) []string {\n\tvar options []string\n\tfor _, sect := range c.sections {\n\t\tif sect.name == section {\n\t\t\tfor _, opt := range sect.options {\n\t\t\t\toptions = append(options, opt.name)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn options\n}"
        ],
        [
            "func (c *Config) OptionMap(section string) map[string]string {\n\toptions := make(map[string]string)\n\tfor _, sect := range c.sections {\n\t\tif sect.name == section {\n\t\t\tfor _, opt := range sect.options {\n\t\t\t\toptions[opt.name] = opt.value\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn options\n}"
        ],
        [
            "func (c *Config) Comments(section string) []string {\n\tif section == \"\" {\n\t\treturn c.comments\n\t}\n\tfor _, sect := range c.sections {\n\t\tif sect.name == section {\n\t\t\treturn sect.comments\n\t\t}\n\t}\n\treturn nil\n}"
        ],
        [
            "func (c *Config) AddComment(sect, comment string) {\n\tif sect == \"\" {\n\t\tc.comments = append(c.comments, comment)\n\t\treturn\n\t}\n\n\tfor i, s := range c.sections {\n\t\tif s.name == sect {\n\t\t\tc.sections[i].comments = append(s.comments, comment)\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.sections = append(c.sections, section{\n\t\tname:     sect,\n\t\tcomments: []string{comment},\n\t})\n}"
        ],
        [
            "func Parse(stream io.Reader) Config {\n\tvar cfg Config\n\tvar curSection string\n\n\tscanner := bufio.NewScanner(bufio.NewReader(stream))\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tif strings.HasPrefix(line, \"#\") || strings.HasPrefix(line, \";\") {\n\t\t\tcomment := strings.TrimLeft(line, \";# \")\n\t\t\tcfg.AddComment(curSection, comment)\n\t\t} else if len(line) > 0 {\n\t\t\tif m := iniSectionRe.FindStringSubmatch(line); len(m) > 0 {\n\t\t\t\tcurSection = m[1]\n\t\t\t} else if m := iniOptionRe.FindStringSubmatch(line); len(m) > 0 {\n\t\t\t\tkey := m[1]\n\t\t\t\tval := m[2]\n\t\t\t\tif !strings.Contains(val, \"\\\"\") {\n\t\t\t\t\t// If val does not contain any quote characers, we can make it\n\t\t\t\t\t// a quoted string and safely let strconv.Unquote sort out any\n\t\t\t\t\t// escapes\n\t\t\t\t\tval = \"\\\"\" + val + \"\\\"\"\n\t\t\t\t}\n\t\t\t\tif val[0] == '\"' {\n\t\t\t\t\tval, _ = strconv.Unquote(val)\n\t\t\t\t}\n\n\t\t\t\tcfg.Set(curSection, key, val)\n\t\t\t}\n\t\t}\n\t}\n\treturn cfg\n}"
        ],
        [
            "func (c *Config) Write(out io.Writer) error {\n\tfor _, cmt := range c.comments {\n\t\tfmt.Fprintln(out, \"; \"+cmt)\n\t}\n\tif len(c.comments) > 0 {\n\t\tfmt.Fprintln(out)\n\t}\n\n\tfor _, sect := range c.sections {\n\t\tfmt.Fprintf(out, \"[%s]\\n\", sect.name)\n\t\tfor _, cmt := range sect.comments {\n\t\t\tfmt.Fprintln(out, \"; \"+cmt)\n\t\t}\n\t\tfor _, opt := range sect.options {\n\t\t\tval := opt.value\n\t\t\tif len(val) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Quote the string if it begins or ends with space\n\t\t\tneedsQuoting := val[0] == ' ' || val[len(val)-1] == ' '\n\n\t\t\tif !needsQuoting {\n\t\t\t\t// Quote the string if it contains any unprintable characters\n\t\t\t\tfor _, r := range val {\n\t\t\t\t\tif !strconv.IsPrint(r) {\n\t\t\t\t\t\tneedsQuoting = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif needsQuoting {\n\t\t\t\tval = strconv.Quote(val)\n\t\t\t}\n\n\t\t\tfmt.Fprintf(out, \"%s=%s\\n\", opt.name, val)\n\t\t}\n\t\tfmt.Fprintln(out)\n\t}\n\treturn nil\n}"
        ],
        [
            "func (c *Config) Get(section, key string) string {\n\tfor _, sect := range c.sections {\n\t\tif sect.name == section {\n\t\t\tfor _, opt := range sect.options {\n\t\t\t\tif opt.name == key {\n\t\t\t\t\treturn opt.value\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"\"\n\t\t}\n\t}\n\treturn \"\"\n}"
        ],
        [
            "func (c *Config) Set(sectionName, key, value string) {\n\tfor i, sect := range c.sections {\n\t\tif sect.name == sectionName {\n\t\t\tfor j, opt := range sect.options {\n\t\t\t\tif opt.name == key {\n\t\t\t\t\tc.sections[i].options[j].value = value\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.sections[i].options = append(sect.options, option{key, value})\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.sections = append(c.sections, section{\n\t\tname:    sectionName,\n\t\toptions: []option{{key, value}},\n\t})\n}"
        ],
        [
            "func (c *Config) Delete(section, key string) {\n\tfor sn, sect := range c.sections {\n\t\tif sect.name == section {\n\t\t\tfor i, opt := range sect.options {\n\t\t\t\tif opt.name == key {\n\t\t\t\t\tc.sections[sn].options = append(sect.options[:i], sect.options[i+1:]...)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}"
        ],
        [
            "func Convert(val interface{}, targetType reflect.Type) reflect.Value {\n\tvalue := reflect.ValueOf(val)\n\tif !value.IsValid() {\n\t\treturn reflect.Zero(targetType)\n\t}\n\n\tvalType := value.Type()\n\tif valType.ConvertibleTo(targetType) {\n\t\treturn value.Convert(targetType)\n\t}\n\n\t//fmt.Printf(\"Value type is %v, emptyInterfaceType is %v, equals %v\\n\", valType, emptyInterfaceType, valType == emptyInterfaceType)\n\tinterfaceVal := value.Interface()\n\n\tswitch realVal := interfaceVal.(type) {\n\tcase float64:\n\t\treturn reflect.ValueOf(realVal).Convert(targetType)\n\tcase []interface{}:\n\t\t// val is of type []interface{}, try to convert to typ\n\t\tsliceSize := len(realVal)\n\t\ttargetSlice := reflect.MakeSlice(targetType, 0, sliceSize)\n\t\telemType := targetType.Elem()\n\t\tfor i := 0; i < sliceSize; i++ {\n\t\t\ttargetSlice = reflect.Append(targetSlice, Convert(value.Index(i), elemType))\n\t\t}\n\t\treturn targetSlice\n\t}\n\n\tpanic(fmt.Errorf(\"convert from type %v to %v failed: %v\", valType, targetType, value))\n}"
        ],
        [
            "func (i *cacheItem) Postpone() {\n\ti.expireAt = time.Now().Add(i.lifetime)\n}"
        ],
        [
            "func Filter(l LogBackend, r Ruler) LogBackend {\n\treturn &filter{\n\t\tLogBackend: l,\n\t\tr:          r,\n\t}\n}"
        ],
        [
            "func Op(o Operation, field string, vleft ...interface{}) Ruler {\n\tif len(vleft) > 1 {\n\t\tpanic(\"Op accept only zero or one val\")\n\t}\n\tvar val reflect.Value\n\tif len(vleft) == 1 {\n\t\tval = reflect.Indirect(reflect.ValueOf(vleft[0]))\n\t\tif val.IsValid() && val.Kind() == reflect.Interface {\n\t\t\tval = val.Elem()\n\t\t}\n\t}\n\treturn &op{\n\t\tfield:  field,\n\t\tvright: val,\n\t\top:     o,\n\t}\n}"
        ],
        [
            "func ApplyRuleIf(condition, rule Ruler) Ruler {\n\treturn &apply{\n\t\tcondition: condition,\n\t\trule:      rule,\n\t}\n}"
        ],
        [
            "func ApplyRuleIfElse(condition, rule, el Ruler) Ruler {\n\treturn &applyelse{\n\t\tcondition: condition,\n\t\trule:      rule,\n\t\tel:        el,\n\t}\n}"
        ],
        [
            "func (self HttpBasicAuthenticator) AuthHandler(next http.Handler) http.Handler {\n\tif self.HttpAuthenticable == nil {\n\t\tpanic(\"HttpAuthenticable cannot be nil\")\n\t}\n\n\tf := func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, secret := self.parseAuthHeader(r.Header.Get(\"Authorization\"))\n\t\tif len(user) > 0 &&\n\t\t\tlen(secret) > 0 &&\n\t\t\tself.TryAuthentication(r, user, secret) {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tHttpHeader_WwwAuthenticate().\n\t\t\tSetValue(BASIC_REALM).\n\t\t\tSetWriter(w.Header())\n\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized),\n\t\t\thttp.StatusUnauthorized)\n\t}\n\n\treturn http.HandlerFunc(f)\n}"
        ],
        [
            "func (s *Docker) HasBin() bool {\n\t_, err := exec.LookPath(s.binCmd)\n\treturn err == nil\n}"
        ],
        [
            "func (s *Docker) Run(cmd string, args ...string) (string, error) {\n\tcmdArgs := make([]string, 0, len(args)+1)\n\tcmdArgs = append(cmdArgs, cmd)\n\tcmdArgs = append(cmdArgs, args...)\n\n\texe := exec.Command(s.binCmd, cmdArgs...)\n\tvar stdout, stderr bytes.Buffer\n\texe.Stdout, exe.Stderr = &stdout, &stderr\n\n\tif err := exe.Run(); err != nil {\n\t\treturn stdout.String(), ExternalCmdError{\n\t\t\terr, stderr.String(), stdout.String()}\n\t}\n\treturn stdout.String(), nil\n}"
        ],
        [
            "func (s *HttpHeader) GetReader(h http.Header) *HttpHeader {\n\ts.Value = h.Get(s.Name)\n\treturn s\n}"
        ],
        [
            "func (s *HttpHeader) SetName(name string) *HttpHeader {\n\ts.Name = name\n\treturn s\n}"
        ],
        [
            "func (s *HttpHeader) SetValue(value string) *HttpHeader {\n\ts.Value = value\n\treturn s\n}"
        ],
        [
            "func (s *HttpHeader) SetWriter(h http.Header) *HttpHeader {\n\th.Set(s.Name, s.Value)\n\treturn s\n}"
        ],
        [
            "func (e *Entity) encryptionKey(now time.Time) (Key, bool) {\n\tcandidateSubkey := -1\n\n\tfor i, subkey := range e.Subkeys {\n\t\tif subkey.Sig.FlagsValid &&\n\t\t\tsubkey.Sig.FlagEncryptCommunications &&\n\t\t\tsubkey.PublicKey.PubKeyAlgo.CanEncrypt() &&\n\t\t\t!subkey.Sig.KeyExpired(now) {\n\t\t\tcandidateSubkey = i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif candidateSubkey != -1 {\n\t\tsubkey := e.Subkeys[candidateSubkey]\n\t\treturn Key{e, subkey.PublicKey, subkey.PrivateKey, subkey.Sig}, true\n\t}\n\n\t// If we don't have any candidate subkeys for encryption and\n\t// the primary key doesn't have any usage metadata then we\n\t// assume that the primary key is ok. Or, if the primary key is\n\t// marked as ok to encrypt to, then we can obviously use it.\n\ti := e.primaryIdentity()\n\tif !i.SelfSignature.FlagsValid || i.SelfSignature.FlagEncryptCommunications &&\n\t\te.PrimaryKey.PubKeyAlgo.CanEncrypt() &&\n\t\t!i.SelfSignature.KeyExpired(now) {\n\t\treturn Key{e, e.PrimaryKey, e.PrivateKey, i.SelfSignature}, true\n\t}\n\n\t// This Entity appears to be signing only.\n\treturn Key{}, false\n}"
        ],
        [
            "func NewContentNegotiator(defaultEncoder Encoder, responseWriter http.ResponseWriter) *ContentNegotiator {\n\tresult := &ContentNegotiator{}\n\tresult.DefaultEncoder = defaultEncoder\n\tresult.ResponseWriter = responseWriter\n\treturn result\n}"
        ],
        [
            "func NewJsonXmlContentNegotiator(defaultEncoder Encoder, responseWriter http.ResponseWriter, prettyPrint bool) *ContentNegotiator {\n\tresult := NewContentNegotiator(defaultEncoder, responseWriter)\n\tresult.AddEncoder(MimeJSON, JsonEncoder{prettyPrint})\n\tresult.AddEncoder(MimeXML, XmlEncoder{prettyPrint})\n\treturn result\n}"
        ],
        [
            "func (cn *ContentNegotiator) Negotiate(req *http.Request, data interface{}) ([]byte, error) {\n\tif len(cn.encoderMap) <= 0 {\n\t\tpanic(\"No Encoders present. Please add them using ContentNegotiator.AddEncoder()\")\n\t}\n\tvar e = cn.getEncoder(req)\n\tcn.ResponseWriter.Header().Set(\"Content-Type\", e.ContentType())\n\treturn e.Encode(data)\n}"
        ],
        [
            "func (cn *ContentNegotiator) AddEncoder(mimeType string, enc Encoder) {\n\tif cn.encoderMap == nil {\n\t\tcn.encoderMap = make(map[string]Encoder)\n\t}\n\tcn.encoderMap[mimeType] = enc\n}"
        ],
        [
            "func (cn *ContentNegotiator) getEncoder(req *http.Request) Encoder {\n\tvar result = cn.DefaultEncoder\n\taccept := req.Header.Get(\"Accept\")\n\n\tfor k, v := range cn.encoderMap {\n\t\tif strings.Contains(accept, k) {\n\t\t\tresult = v\n\t\t\tbreak\n\t\t}\n\t}\n\treturn result\n}"
        ],
        [
            "func (pka PublicKeyAlgorithm) CanSign() bool {\n\tswitch pka {\n\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoDSA:\n\t\treturn true\n\t}\n\treturn false\n}"
        ],
        [
            "func (s PlayerStandings) ByWinnings(oldTieBreak bool) {\n\tif oldTieBreak {\n\t\tsort.Sort(sort.Reverse(ByWinningsOld{s}))\n\t} else {\n\t\tsort.Sort(sort.Reverse(ByWinnings{s}))\n\t}\n}"
        ],
        [
            "func WaitFunc(interval, timeout time.Duration, f func() bool) bool {\n\tafter := time.After(timeout)\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(interval):\n\t\t\tif f() {\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase <-after:\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn false\n}"
        ],
        [
            "func (s NetworkNode) FormatDialAddress() string {\n\treturn fmt.Sprintf(\"%s:%d\", s.IpAddress, s.Port)\n}"
        ],
        [
            "func (s *NetworkNode) SetFromDocker(port string) error {\n\tsplit := strings.Split(port, \"/\")\n\tiPort, err := strconv.ParseUint(split[0], 10, 16)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.Port, s.Protocol = uint16(iPort), split[1]\n\treturn nil\n}"
        ],
        [
            "func (s *Random) Read(b []byte) (n int, err error) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\tfor i, _ := range b {\n\t\tb[i] = s.readByte()\n\t}\n\n\treturn len(b), nil\n}"
        ],
        [
            "func (s *Random) readByte() byte {\n\tbefore := time.Now()\n\trndDuration := time.Duration(getUInt16FromBytes(s.val))\n\n\ttime.Sleep(DEFAULT_SLEEP_TIME + rndDuration)\n\tdiff := time.Now().Sub(before)\n\tn := byte(diff.Nanoseconds())\n\n\ts.val[s.index] = n\n\ts.index ^= 1\n\n\treturn n\n}"
        ],
        [
            "func RecoverHandlerJson(next http.Handler) http.Handler {\n\tfn := func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tjerr := NewJsonErrorFromError(\n\t\t\t\t\thttp.StatusInternalServerError, fmt.Errorf(\"panic: %+v\", err))\n\t\t\t\tJsonWrite(w, jerr.Status, jerr)\n\t\t\t}\n\t\t}()\n\n\t\tnext.ServeHTTP(w, r)\n\t}\n\n\treturn http.HandlerFunc(fn)\n}"
        ],
        [
            "func DefaultServiceConfig() ServiceConfig {\n\treturn ServiceConfig{\n\t\t// Dependencies.\n\t\tBackoffFactory: func() Backoff {\n\t\t\treturn &backoff.StopBackOff{}\n\t\t},\n\t\tRandFactory: rand.Int,\n\n\t\t// Settings.\n\t\tRandReader: rand.Reader,\n\t\tTimeout:    1 * time.Second,\n\t}\n}"
        ],
        [
            "func NewService(config ServiceConfig) (Service, error) {\n\t// Dependencies.\n\tif config.BackoffFactory == nil {\n\t\treturn nil, maskAnyf(invalidConfigError, \"backoff factory must not be empty\")\n\t}\n\tif config.RandFactory == nil {\n\t\treturn nil, maskAnyf(invalidConfigError, \"rand factory must not be empty\")\n\t}\n\n\t// Settings.\n\tif config.RandReader == nil {\n\t\treturn nil, maskAnyf(invalidConfigError, \"rand reader must not be empty\")\n\t}\n\n\tnewService := &service{\n\t\t// Dependencies.\n\t\tbackoffFactory: config.BackoffFactory,\n\t\trandFactory:    config.RandFactory,\n\n\t\t// Settings.\n\t\trandReader: config.RandReader,\n\t\ttimeout:    config.Timeout,\n\t}\n\n\treturn newService, nil\n}"
        ],
        [
            "func (s *ImageMongoDB) RunLight(cfg *RunConfig) (*Container, error) {\n\tcfg.AddArgs(\"--smallfiles\", \"--nojournal\")\n\treturn s.Image.Run(cfg)\n}"
        ],
        [
            "func initConfig() {\n\tif cfgFile != \"\" { // enable ability to specify config file via flag\n\t\tviper.SetConfigFile(cfgFile)\n\t}\n\n\tviper.SetConfigName(\".fstack\") // name of config file (without extension)\n\tviper.AddConfigPath(\"$HOME\")   // adding home directory as first search path\n\tviper.AutomaticEnv()           // read in environment variables that match\n\n\t// If a config file is found, read it in.\n\tif err := viper.ReadInConfig(); err == nil {\n\t\tfmt.Println(\"Using config file:\", viper.ConfigFileUsed())\n\t}\n\n\tfs, err := fstack.OpenStack(stackFile)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tstack = fs\n}"
        ],
        [
            "func (s *Container) HasExposedPorts() bool {\n\tnodes, err := s.NetworkNodes()\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tfor _, v := range nodes {\n\t\tif v.Port > 0 || len(v.Protocol) > 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}"
        ],
        [
            "func (s *Container) Inspect() ([]Inspect, error) {\n\tout, err := s.docker.Run(\"inspect\", s.id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar list []Inspect\n\terr = json.NewDecoder(strings.NewReader(out)).Decode(&list)\n\tif err != nil {\n\t\treturn nil, UnexpectedOutputError(fmt.Sprintf(\n\t\t\t\"Error parsing output when inspecting container: %v\", err))\n\t}\n\tif len(list) == 0 {\n\t\treturn nil, UnexpectedOutputError(\n\t\t\t\"Empty output when inspecting container\")\n\t}\n\n\treturn list, nil\n}"
        ],
        [
            "func (s *Container) Kill() error {\n\terr := exec.Command(s.docker.binCmd, \"kill\", s.id).Run()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstopped := raiqub.WaitFunc(\n\t\t250*time.Millisecond, 30*time.Second, func() bool {\n\t\t\tinspect, err := s.Inspect()\n\t\t\tif err != nil || len(inspect) == 0 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif !inspect[0].State.Running {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\treturn false\n\t\t})\n\tif !stopped {\n\t\terr = fmt.Errorf(\"Timeout waiting '%s' container to stop\", s.id)\n\t}\n\n\treturn err\n}"
        ],
        [
            "func (s *Container) NetworkNodes() ([]NetworkNode, error) {\n\tinspect, err := s.Inspect()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(inspect) == 0 {\n\t\treturn nil, fmt.Errorf(\"Container inspect is empty\")\n\t}\n\n\tnodes := make([]NetworkNode, 0)\n\tfor _, i := range inspect {\n\t\tip := i.NetworkSettings.IPAddress\n\t\tif ip == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(i.NetworkSettings.Ports) == 0 {\n\t\t\tnodes = append(nodes, NetworkNode{\n\t\t\t\tIpAddress: ip,\n\t\t\t})\n\t\t} else {\n\t\t\tfor k, _ := range i.NetworkSettings.Ports {\n\t\t\t\tnode := NetworkNode{}\n\t\t\t\tnode.IpAddress = ip\n\t\t\t\tnode.SetFromDocker(k)\n\t\t\t\tnodes = append(nodes, node)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nodes, nil\n}"
        ],
        [
            "func (s *Container) Remove() error {\n\treturn exec.Command(s.docker.binCmd, \"rm\", s.id).Run()\n}"
        ],
        [
            "func (s *Container) WaitStartup(timeout time.Duration) error {\n\tnodes, err := s.NetworkNodes()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Error getting network nodes: %v\", err)\n\t}\n\n\tif !s.HasExposedPorts() {\n\t\treturn fmt.Errorf(\"Current container has no exposed ports\")\n\t}\n\n\tok := raiqub.WaitPeerListening(\n\t\tnodes[0].Protocol, nodes[0].FormatDialAddress(), timeout)\n\tif !ok {\n\t\terr = fmt.Errorf(\"%s unreachable for %v\",\n\t\t\tnodes[0].FormatDialAddress(), timeout)\n\t}\n\n\treturn err\n}"
        ],
        [
            "func NewHandler(counter *Counter, level logging.Level) (h *Handler) {\n\treturn &Handler{\n\t\tCounter: counter,\n\t\tLevel:   level,\n\t}\n}"
        ],
        [
            "func (h *Handler) Handle(record *logging.Record) error {\n\tswitch record.Level {\n\tcase logging.EMERGENCY:\n\t\th.Counter.emergencyCounter.Inc()\n\tcase logging.ALERT:\n\t\th.Counter.alertCounter.Inc()\n\tcase logging.CRITICAL:\n\t\th.Counter.criticalCounter.Inc()\n\tcase logging.ERROR:\n\t\th.Counter.errorCounter.Inc()\n\tcase logging.WARNING:\n\t\th.Counter.warningCounter.Inc()\n\tcase logging.NOTICE:\n\t\th.Counter.noticeCounter.Inc()\n\tcase logging.INFO:\n\t\th.Counter.infoCounter.Inc()\n\tcase logging.DEBUG:\n\t\th.Counter.debugCounter.Inc()\n\t}\n\treturn nil\n}"
        ],
        [
            "func NewCounter(options *CounterOptions) (c *Counter) {\n\tif options == nil {\n\t\toptions = new(CounterOptions)\n\t}\n\tif options.Name == \"\" {\n\t\toptions.Name = \"logging_messages_total\"\n\t}\n\tif options.Help == \"\" {\n\t\toptions.Help = \"Number of log messages processed, partitioned by log level.\"\n\t}\n\tvector := prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: options.Name,\n\t\t\tHelp: options.Help,\n\t\t},\n\t\t[]string{\"level\"},\n\t)\n\treturn &Counter{\n\t\tvector:           vector,\n\t\temergencyCounter: vector.WithLabelValues(\"emergency\"),\n\t\talertCounter:     vector.WithLabelValues(\"alert\"),\n\t\tcriticalCounter:  vector.WithLabelValues(\"critical\"),\n\t\terrorCounter:     vector.WithLabelValues(\"error\"),\n\t\twarningCounter:   vector.WithLabelValues(\"warning\"),\n\t\tnoticeCounter:    vector.WithLabelValues(\"notice\"),\n\t\tinfoCounter:      vector.WithLabelValues(\"info\"),\n\t\tdebugCounter:     vector.WithLabelValues(\"debug\"),\n\t}\n}"
        ],
        [
            "func (c *Counter) Metrics() (cs []prometheus.Collector) {\n\treturn []prometheus.Collector{c.vector}\n}"
        ],
        [
            "func Retrieve(sources []*Source) (http.FileSystem, error) {\n\tfiles := make(mfs.Files)\n\n\tfor i, source := range sources {\n\t\tlog.Printf(\"Processing asset source (%d/%d): %s ...\", i+1, len(sources), source.Location)\n\n\t\t// Retrieve the file or files\n\t\tretFiles, err := retrieve(source.Location)\n\t\tif err != nil {\n\t\t\treturn nil, &RetrieveError{source.Location, err}\n\t\t}\n\n\t\t// If multiple files are returned store them and finish processing.\n\t\t// Chekcsum and archive not supported for multiple files.\n\t\tif len(retFiles) > 1 {\n\t\t\tfor _, file := range retFiles {\n\t\t\t\tpath := strings.TrimSuffix(source.Path, \"/\") + \"/\" + file.path\n\t\t\t\tlog.Printf(\"Created asset: %s ...\", path)\n\t\t\t\tfiles[path] = &mfs.File{file.data, file.modTime}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Process the single returned file\n\t\tfile := retFiles[0]\n\n\t\t// Verify the file checksum if requested\n\t\tif source.Checksum != nil {\n\t\t\terr = verifyChecksum(source.Checksum, file.data)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, &ChecksumError{source.Location, err}\n\t\t\t}\n\t\t}\n\n\t\t// If the file is not an archive store it and finish processing.\n\t\tif source.Archive == nil {\n\t\t\tlog.Printf(\"Created asset: %s ...\", source.Path)\n\t\t\tfiles[source.Path] = &mfs.File{file.data, file.modTime}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Extract files from the archive and store them.\n\t\tarchFiles, err := processArchive(source.Archive, file.data)\n\t\tif err != nil {\n\t\t\treturn nil, &ArchiveError{source.Location, err}\n\t\t}\n\n\t\tfor _, file := range archFiles {\n\t\t\tlog.Printf(\"Created asset: %s ...\", file.path)\n\t\t\tfiles[file.path] = &mfs.File{file.data, file.modTime}\n\t\t}\n\n\t}\n\n\tfs, err := mfs.New(files)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn httpfs.New(fs), nil\n}"
        ],
        [
            "func Compile(sources []*Source, filePath string, pkgName string, varName string, opts *Opts) error {\n\n\tfs, err := Retrieve(sources)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif opts == nil {\n\t\topts = &Opts{}\n\t}\n\n\tif opts.VariableComment == \"\" {\n\t\topts.VariableComment = fmt.Sprintf(\"%s implements a http.FileSystem.\", varName)\n\t}\n\n\terr = vfsgen.Generate(fs, vfsgen.Options{\n\t\tFilename:        filePath,\n\t\tPackageName:     pkgName,\n\t\tBuildTags:       opts.BuildTags,\n\t\tVariableName:    varName,\n\t\tVariableComment: opts.VariableComment,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func readBlockAt(reader io.ReadSeeker, offset int64) (fileBlock, error) {\n\tvar block fileBlock\n\t_, err := reader.Seek(offset, os.SEEK_SET)\n\tif err != nil {\n\t\treturn block, err\n\t}\n\treturn block, binary.Read(reader, binary.LittleEndian, &block)\n}"
        ],
        [
            "func (fb *fileBlock) writeTo(writer io.WriteSeeker, offset int64) error {\n\t_, err := writer.Seek(offset, os.SEEK_SET)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn binary.Write(writer, binary.LittleEndian, *fb)\n}"
        ],
        [
            "func (s *Stack) Push(header, data []byte) (depth int, err error) {\n\ts.guard.Lock()\n\tdefer s.guard.Unlock()\n\ts.lastAccess = time.Now()\n\tfile, err := s.getFile()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\t// Seek to place for next block\n\tcurrentOffset, err := file.Seek(s.currentBlock.NextBlockPoint(), os.SEEK_SET)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\t// Get place for payload\n\tbodyOffset := currentOffset + fileBlockDefineSize\n\tblock := fileBlock{\n\t\tPrevBlock:   uint64(s.currentBlockPos),\n\t\tHeaderPoint: uint64(bodyOffset),\n\t\tHeaderSize:  uint64(len(header)),\n\t\tDataPoint:   uint64(bodyOffset) + uint64(len(header)),\n\t\tDataSize:    uint64(len(data)),\n\t}\n\t// Write block meta-info\n\terr = binary.Write(file, binary.LittleEndian, block)\n\tif err != nil {\n\t\tfile.Seek(currentOffset, os.SEEK_SET)\n\t\treturn -1, err\n\t}\n\t// Write header\n\t_, err = file.Write(header)\n\tif err != nil {\n\t\tfile.Seek(currentOffset, os.SEEK_SET)\n\t\treturn -1, err\n\t}\n\t// Write data\n\t_, err = file.Write(data)\n\tif err != nil {\n\t\tfile.Seek(currentOffset, os.SEEK_SET)\n\t\treturn -1, err\n\t}\n\ts.depth++\n\ts.currentBlockPos = currentOffset\n\ts.currentBlock = block\n\treturn s.depth, nil\n}"
        ],
        [
            "func (s *Stack) Pop() (header, data []byte, err error) {\n\tif s.depth == 0 {\n\t\treturn nil, nil, nil\n\t}\n\ts.guard.Lock()\n\tdefer s.guard.Unlock()\n\ts.lastAccess = time.Now()\n\tfile, err := s.getFile()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdata = make([]byte, s.currentBlock.DataSize)\n\theader = make([]byte, s.currentBlock.HeaderSize)\n\t// Read header\n\t_, err = file.ReadAt(header, int64(s.currentBlock.HeaderPoint))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\t// Read data\n\t_, err = file.ReadAt(data, int64(s.currentBlock.DataPoint))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\t// Read new block if current block is not head\n\tvar newBlock fileBlock\n\tif s.currentBlockPos != 0 {\n\t\tnewBlock, err = readBlockAt(file, int64(s.currentBlock.PrevBlock))\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\t// Remove tail\n\terr = file.Truncate(int64(s.currentBlockPos))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\ts.depth--\n\ts.currentBlockPos = int64(s.currentBlock.PrevBlock)\n\ts.currentBlock = newBlock\n\n\treturn header, data, nil\n}"
        ],
        [
            "func (s *Stack) Peak() (header, data []byte, err error) {\n\tif s.depth == 0 {\n\t\treturn nil, nil, nil\n\t}\n\ts.guard.Lock()\n\tdefer s.guard.Unlock()\n\ts.lastAccess = time.Now()\n\tfile, err := s.getFile()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdata = make([]byte, s.currentBlock.DataSize)\n\theader = make([]byte, s.currentBlock.HeaderSize)\n\t// Read header\n\t_, err = file.ReadAt(header, int64(s.currentBlock.HeaderPoint))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\t// Read data\n\t_, err = file.ReadAt(data, int64(s.currentBlock.DataPoint))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn header, data, nil\n}"
        ],
        [
            "func (s *Stack) PeakHeader() (header []byte, err error) {\n\tif s.depth == 0 {\n\t\treturn nil, nil\n\t}\n\ts.guard.Lock()\n\tdefer s.guard.Unlock()\n\ts.lastAccess = time.Now()\n\tfile, err := s.getFile()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\theader = make([]byte, s.currentBlock.HeaderSize)\n\t// Read header\n\t_, err = file.ReadAt(header, int64(s.currentBlock.HeaderPoint))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn header, nil\n}"
        ],
        [
            "func (s *Stack) IterateBackward(handler func(depth int, header io.Reader, body io.Reader) bool) error {\n\ts.guard.Lock()\n\tdefer s.guard.Unlock()\n\tif s.depth == 0 {\n\t\treturn nil\n\t}\n\tfile, err := s.getFile()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Seek(0, os.SEEK_END)\n\tvar (\n\t\tcurrentBlock       fileBlock // Current block description\n\t\tcurrentBlockOffset uint64    // Current block offset from begining of file\n\t)\n\tcurrentBlock = s.currentBlock\n\tcurrentBlockOffset = uint64(s.currentBlockPos)\n\tdepth := s.depth\n\tfor {\n\t\tbody := io.NewSectionReader(file, int64(currentBlock.DataPoint), int64(currentBlock.DataSize))\n\t\theader := io.NewSectionReader(file, int64(currentBlock.HeaderPoint), int64(currentBlock.HeaderSize))\n\t\t// invoke block processor\n\t\tif handler != nil && !handler(depth, header, body) {\n\t\t\treturn nil\n\t\t}\n\t\tif currentBlock.PrevBlock > currentBlockOffset {\n\t\t\tlog.Printf(\"Danger back-ref link: prev block %v has greater index then current %v\", currentBlock.PrevBlock, currentBlockOffset)\n\t\t}\n\n\t\tdepth--\n\t\tif currentBlock.PrevBlock == currentBlockOffset {\n\t\t\t// First block has prev block = 0\n\t\t\tbreak\n\t\t}\n\t\tcurrentBlockOffset = currentBlock.PrevBlock\n\t\tcurrentBlock, err = readBlockAt(file, int64(currentBlock.PrevBlock))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif depth != 0 {\n\t\tlog.Println(\"Broker back path detected at\", depth, \"depth index\")\n\t}\n\treturn nil\n}"
        ],
        [
            "func (s *Stack) IterateForward(handler func(depth int, header io.Reader, body io.Reader) bool) error {\n\t// This operation does not relies on depth counter, so can be used for repare\n\ts.guard.Lock()\n\tdefer s.guard.Unlock()\n\ts.lastAccess = time.Now()\n\tfile, err := s.getFile()\n\tif err != nil {\n\t\treturn err\n\t}\n\t//Get file size\n\tfileSize, err := file.Seek(0, os.SEEK_END)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = file.Seek(0, os.SEEK_SET)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Seek(0, os.SEEK_END)\n\tvar (\n\t\tcurrentBlock       fileBlock // Current block description\n\t\tcurrentBlockOffset uint64    // Current block offset from begining of file\n\t)\n\tvar depth int\n\tfor currentBlock.NextBlockPoint() < fileSize {\n\t\tnewPos := currentBlock.NextBlockPoint()\n\t\tif newPos > fileSize {\n\t\t\tlog.Println(\"Bad reference to next block at\", currentBlockOffset, \"!trunc!\")\n\t\t\tfile.Truncate(int64(currentBlockOffset))\n\t\t\tbreak\n\t\t}\n\t\tblock, err := readBlockAt(file, newPos)\n\t\t// Non-full meta-info?\n\t\tif err == io.EOF {\n\t\t\tlog.Println(\"Broken meta info at\", newPos, \"!trunc!\")\n\t\t\tfile.Truncate(newPos)\n\t\t\tbreak\n\t\t}\n\t\t// I/O error\n\t\tif err != nil {\n\t\t\tlog.Println(\"Can't read block at\", newPos)\n\t\t\treturn err\n\t\t}\n\t\t// Check back-ref\n\t\tif block.PrevBlock != currentBlockOffset {\n\t\t\tlog.Println(\"Bad back reference\", block.PrevBlock, \"!=\", currentBlockOffset, \"!upd!\")\n\t\t\tblock.PrevBlock = currentBlockOffset\n\t\t\tblock.writeTo(file, newPos)\n\t\t}\n\t\t// Update current state\n\t\tcurrentBlockOffset = uint64(newPos)\n\t\tcurrentBlock = block\n\t\tbody := io.NewSectionReader(file, int64(currentBlock.DataPoint), int64(currentBlock.DataSize))\n\t\theader := io.NewSectionReader(file, int64(currentBlock.HeaderPoint), int64(currentBlock.HeaderSize))\n\t\t// invoke block processor\n\t\tif handler != nil && !handler(depth, header, body) {\n\t\t\treturn nil\n\t\t}\n\t\tdepth++\n\t}\n\ts.depth = depth\n\ts.currentBlock = currentBlock\n\ts.currentBlockPos = int64(currentBlockOffset)\n\treturn nil\n}"
        ],
        [
            "func (s *Stack) Close() error {\n\ts.guard.Lock()\n\tdefer s.guard.Unlock()\n\tif s.file != nil {\n\t\terr := s.file.Close()\n\t\ts.file = nil\n\t\treturn err\n\t}\n\treturn nil\n}"
        ],
        [
            "func OpenStack(filename string) (*Stack, error) {\n\tfile, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR, 0755)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewStack(file)\n}"
        ],
        [
            "func NewStack(file *os.File) (*Stack, error) {\n\tstack := &Stack{file: file, fileName: file.Name()}\n\terr := stack.Repare()\n\tif err != nil {\n\t\tstack.Close()\n\t\treturn nil, err\n\t}\n\treturn stack, nil\n}"
        ],
        [
            "func NewSessionCache(d time.Duration, salt string) *SessionCache {\n\treturn &SessionCache{\n\t\tcache: data.NewCache(d),\n\t\tsalter: crypt.NewSalter(\n\t\t\tcrypt.NewRandomSourceListSecure(), []byte(salt)),\n\t}\n}"
        ],
        [
            "func (s *SessionCache) getInvalidTokenError(token string) error {\n\treturn errors.New(fmt.Sprintf(\n\t\t\"The requested token '%s' is invalid or is expired\", token))\n}"
        ],
        [
            "func (s *SessionCache) Get(token string) (interface{}, error) {\n\tv, err := s.cache.Get(token)\n\tif err != nil {\n\t\treturn nil, s.getInvalidTokenError(token)\n\t}\n\treturn v, err\n}"
        ],
        [
            "func (s *SessionCache) Add() string {\n\tstrSum := s.salter.DefaultToken()\n\n\terr := s.cache.Add(strSum, nil)\n\tif err != nil {\n\t\tpanic(\"Something is seriously wrong, a duplicated token was generated\")\n\t}\n\n\treturn strSum\n}"
        ],
        [
            "func (s *SessionCache) Delete(token string) error {\n\terr := s.cache.Delete(token)\n\tif err != nil {\n\t\treturn s.getInvalidTokenError(token)\n\t}\n\treturn nil\n}"
        ],
        [
            "func (s *SessionCache) Set(token string, value interface{}) error {\n\terr := s.cache.Set(token, value)\n\tif err != nil {\n\t\treturn s.getInvalidTokenError(token)\n\t}\n\treturn nil\n}"
        ],
        [
            "func NewClient(nick, serverHost string, serverPort uint16) *Client {\n\treturn &Client{\n\t\tnick:       nick,\n\t\tserverHost: serverHost,\n\t\tserverPort: serverPort,\n\n\t\twriteTimeout: 30 * time.Second,\n\t\treadTimeout:  100 * time.Millisecond,\n\n\t\tchannels: map[string]struct{}{},\n\t\tmutex:    &sync.Mutex{},\n\t}\n}"
        ],
        [
            "func (c *Client) connect() error {\n\tdialer := &net.Dialer{\n\t\tTimeout:   30 * time.Second,\n\t\tKeepAlive: 30 * time.Second,\n\t}\n\n\tconn, err := dialer.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", c.serverHost,\n\t\tc.serverPort))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error dialing: %s\", err)\n\t}\n\n\tc.conn = conn\n\tc.rw = bufio.NewReadWriter(bufio.NewReader(c.conn), bufio.NewWriter(c.conn))\n\treturn nil\n}"
        ],
        [
            "func (c Client) writeMessage(m irc.Message) error {\n\tbuf, err := m.Encode()\n\tif err != nil && err != irc.ErrTruncated {\n\t\treturn fmt.Errorf(\"unable to encode message: %s\", err)\n\t}\n\n\tif err := c.conn.SetWriteDeadline(time.Now().Add(\n\t\tc.writeTimeout)); err != nil {\n\t\treturn fmt.Errorf(\"unable to set deadline: %s\", err)\n\t}\n\n\tsz, err := c.rw.WriteString(buf)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif sz != len(buf) {\n\t\treturn fmt.Errorf(\"short write\")\n\t}\n\n\tif err := c.rw.Flush(); err != nil {\n\t\treturn fmt.Errorf(\"flush error: %s\", err)\n\t}\n\n\tlog.Printf(\"client %s: sent: %s\", c.nick, strings.TrimRight(buf, \"\\r\\n\"))\n\treturn nil\n}"
        ],
        [
            "func (c Client) readMessage() (irc.Message, error) {\n\tif err := c.conn.SetReadDeadline(time.Now().Add(c.readTimeout)); err != nil {\n\t\treturn irc.Message{}, fmt.Errorf(\"unable to set deadline: %s\", err)\n\t}\n\n\tline, err := c.rw.ReadString('\\n')\n\tif err != nil {\n\t\treturn irc.Message{}, err\n\t}\n\n\tlog.Printf(\"client %s: read: %s\", c.nick, strings.TrimRight(line, \"\\r\\n\"))\n\n\tm, err := irc.ParseMessage(line)\n\tif err != nil && err != irc.ErrTruncated {\n\t\treturn irc.Message{}, fmt.Errorf(\"unable to parse message: %s: %s\", line,\n\t\t\terr)\n\t}\n\n\treturn m, nil\n}"
        ],
        [
            "func (c *Client) Stop() {\n\t// Tell reader and writer to end.\n\tclose(c.doneChan)\n\n\t// We won't be sending anything further to writer. Let it clean up.\n\tclose(c.sendChan)\n\n\t// Wait for reader and writer to end.\n\tc.wg.Wait()\n\n\t// We know the reader and writer won't be sending on the error channel any\n\t// more.\n\tclose(c.errChan)\n\n\t_ = c.conn.Close()\n\n\tfor range c.recvChan {\n\t}\n\tfor range c.errChan {\n\t}\n}"
        ],
        [
            "func (c Client) GetChannels() []string {\n\tvar channels []string\n\tc.mutex.Lock()\n\tfor k := range c.channels {\n\t\tchannels = append(channels, k)\n\t}\n\tc.mutex.Unlock()\n\treturn channels\n}"
        ],
        [
            "func JsonWrite(w http.ResponseWriter, status int, content interface{}) {\n\tHttpHeader_ContentType_Json().SetWriter(w.Header())\n\tw.WriteHeader(status)\n\tif content != nil {\n\t\tjson.NewEncoder(w).Encode(content)\n\t}\n}"
        ],
        [
            "func JsonRead(body io.ReadCloser, obj interface{}, w http.ResponseWriter) bool {\n\tcontent, err := ioutil.ReadAll(io.LimitReader(body, HTTP_BODY_MAX_LENGTH))\n\tif err != nil {\n\t\tjerr := NewJsonErrorFromError(http.StatusInternalServerError, err)\n\t\tJsonWrite(w, jerr.Status, jerr)\n\t\treturn false\n\t}\n\n\tif err := body.Close(); err != nil {\n\t\tjerr := NewJsonErrorFromError(http.StatusInternalServerError, err)\n\t\tJsonWrite(w, jerr.Status, jerr)\n\t\treturn false\n\t}\n\n\tif err := json.Unmarshal(content, obj); err != nil {\n\t\tjerr := NewJsonErrorFromError(StatusUnprocessableEntity, err)\n\t\tJsonWrite(w, jerr.Status, jerr)\n\t\treturn false\n\t}\n\n\treturn true\n}"
        ],
        [
            "func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) (err error) {\n\th, err := keySignatureHash(pk, signed, sig.Hash)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pk.VerifySignature(h, sig)\n}"
        ],
        [
            "func NewUser(player uuid.UUID, userdata *User) (*User, error) {\n\tp, err := storage.Load(player)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp.User = *userdata\n\t//fmt.Println(\"Creating user:\")\n\t//fmt.Printf(\"%v\", p.User)\n\terr = storage.Store(p)\n\tif err != nil {\n\t\treturn nil,\n\t\t\terrors.New(err.Error() + \" - Could not write user to storage\")\n\t}\n\treturn &p.User, nil\n}"
        ],
        [
            "func (c *Context) Next(w http.ResponseWriter, r *http.Request) {\n\tif c.route == nil {\n\t\treturn\n\t}\n\n\tif next := c.route.next; next != nil {\n\t\tc.route = next\n\t\tnext.ServeHTTPContext(w, r, c)\n\t} else {\n\t\tc.holdUp = true\n\t}\n}"
        ],
        [
            "func (route *Route) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tc := &Context{route: route}\n\troute.ServeHTTPContext(w, r, c)\n}"
        ],
        [
            "func (r *Route) UseHandler(h Handler) {\n\tif r.f == nil {\n\t\tr.f = h\n\t\treturn\n\t}\n\n\troute := r.getLeaf()\n\troute.next = &Route{f: h}\n}"
        ],
        [
            "func (r *Route) HandleMethod(pat, method string, f ...HandlerFunc) {\n\tentry := r.addPattern(pat)\n\tbatch := batchRoute(f)\n\tif err := entry.SetMethodHandler(method, batch); err != nil {\n\t\tpanic(err)\n\t}\n}"
        ],
        [
            "func (r *Route) Handle(pat string, f ...HandlerFunc) {\n\tentry := r.addPattern(pat)\n\tbatch := batchRoute(f)\n\tif err := entry.SetHandler(batch); err != nil {\n\t\tpanic(err)\n\t}\n}"
        ],
        [
            "func (r *Route) Get(pat string, f ...HandlerFunc) {\n\tr.HandleMethod(pat, \"GET\", f...)\n\tr.HandleMethod(pat, \"HEAD\", f...)\n}"
        ],
        [
            "func (r *Route) Post(pat string, f ...HandlerFunc) {\n\tr.HandleMethod(pat, \"POST\", f...)\n}"
        ],
        [
            "func (r *Route) Put(pat string, f ...HandlerFunc) {\n\tr.HandleMethod(pat, \"PUT\", f...)\n}"
        ],
        [
            "func (r *Route) Patch(pat string, f ...HandlerFunc) {\n\tr.HandleMethod(pat, \"PATCH\", f...)\n}"
        ],
        [
            "func (r *Route) Delete(pat string, f ...HandlerFunc) {\n\tr.HandleMethod(pat, \"DELETE\", f...)\n}"
        ],
        [
            "func (r *Route) Options(pat string, f ...HandlerFunc) {\n\tr.HandleMethod(pat, \"OPTIONS\", f...)\n}"
        ],
        [
            "func NewSalter(sources RandomSourceList, input []byte) *Salter {\n\tif input == nil {\n\t\tinput = []byte(\"\")\n\t}\n\n\thash := sha256.New()\n\thash.Write(input)\n\n\tsum := 0\n\tfor _, v := range sources {\n\t\tsum += v.Weight\n\t}\n\n\treturn &Salter{\n\t\tsalt:       hash.Sum(nil),\n\t\trndSources: sources,\n\t\tsumWeight:  sum,\n\t}\n}"
        ],
        [
            "func (self *Salter) BToken(size int) []byte {\n\tmac := hmac.New(sha256.New, self.salt)\n\n\tfor _, v := range self.rndSources {\n\t\titemSize := float32(size) * (float32(v.Weight) / float32(self.sumWeight))\n\t\tmac.Write(getRandomBytes(v.Reader, int(itemSize)))\n\t}\n\tmacSum := mac.Sum(nil)\n\n\tself.salt = macSum\n\treturn macSum\n}"
        ],
        [
            "func (self *Salter) Token(size int) string {\n\treturn base64.URLEncoding.EncodeToString(self.BToken(size))\n}"
        ],
        [
            "func getRandomBytes(r io.Reader, n int) []byte {\n\tb := make([]byte, n)\n\t_, err := r.Read(b)\n\tif err != nil {\n\t\tpanic(\"Could not access secure random generator\")\n\t}\n\n\treturn b\n}"
        ],
        [
            "func NewNewsItem(itemdata NewsItem, author uuid.UUID) (*NewsItem, error) {\n\tc := new(NewsItem)\n\tif err := mergo.MergeWithOverwrite(c, itemdata); err != nil {\n\t\treturn nil, errors.New(err.Error() + \" - Could not set initial NewsItem data\")\n\t}\n\tc.UUID, _ = uuid.V4()\n\tc.Author = author\n\tc.Created = time.Now()\n\tif err := storage.Store(c); err != nil {\n\t\treturn nil, errors.New(err.Error() + \" - Could not write NewsItem to storage\")\n\t}\n\teventqueue.Publish(utils.CKPTEvent{\n\t\tType:    utils.NEWS_EVENT,\n\t\tSubject: \"Nytt bidrag lagt ut\",\n\t\tMessage: \"Det er lagt ut et nytt bidrag p\u00e5 ckpt.no!\"})\n\treturn c, nil\n}"
        ],
        [
            "func (lw DebugLogWriter) Write(p []byte) (int, error) {\n\tlw.Debug(string(bytes.TrimRightFunc(p, unicode.IsSpace)))\n\treturn len(p), nil\n}"
        ],
        [
            "func (lw InfoLogWriter) Write(p []byte) (int, error) {\n\tlw.Info(string(bytes.TrimRightFunc(p, unicode.IsSpace)))\n\treturn len(p), nil\n}"
        ],
        [
            "func (lw WarningLogWriter) Write(p []byte) (int, error) {\n\tlw.Warning(string(bytes.TrimRightFunc(p, unicode.IsSpace)))\n\treturn len(p), nil\n}"
        ],
        [
            "func (lw ErrorLogWriter) Write(p []byte) (int, error) {\n\tlw.Error(string(bytes.TrimRightFunc(p, unicode.IsSpace)))\n\treturn len(p), nil\n}"
        ],
        [
            "func GetLogger(name string) (*Logger, error) {\n\tif name == \"default\" {\n\t\treturn getDefaultLogger(), nil\n\t}\n\tlock.RLock()\n\tlogger, ok := loggers[name]\n\tlock.RUnlock()\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"unknown logger %s\", name)\n\t}\n\treturn logger, nil\n}"
        ],
        [
            "func RemoveLogger(name string) {\n\tlock.Lock()\n\tdelete(loggers, name)\n\tif name == \"default\" {\n\t\tdefaultLogger = nil\n\t}\n\tlock.Unlock()\n}"
        ],
        [
            "func WaitForAllUnprocessedRecords() {\n\tlock.Lock()\n\tvar wg sync.WaitGroup\n\tfor _, logger := range loggers {\n\t\twg.Add(1)\n\t\tgo func(logger *Logger) {\n\t\t\tlogger.WaitForUnprocessedRecords()\n\t\t\twg.Done()\n\t\t}(logger)\n\t}\n\twg.Wait()\n\tlock.Unlock()\n}"
        ],
        [
            "func (logger *Logger) run() {\n\tdefer func() {\n\t\tlogger.WaitForUnprocessedRecords()\n\t\tlogger.closeHandlers()\n\t}()\nrecordLoop:\n\tfor {\n\t\tselect {\n\t\tcase record := <-logger.recordChannel:\n\t\t\trecord.process(logger)\n\t\tcase state := <-logger.stateChannel:\n\t\t\tswitch state {\n\t\t\tcase stopped:\n\t\t\t\tbreak recordLoop\n\t\t\tcase paused:\n\t\t\tstateLoop:\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase state := <-logger.stateChannel:\n\t\t\t\t\t\tswitch state {\n\t\t\t\t\t\tcase stopped:\n\t\t\t\t\t\t\tbreak recordLoop\n\t\t\t\t\t\tcase running:\n\t\t\t\t\t\t\tbreak stateLoop\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
        ],
        [
            "func (logger *Logger) WaitForUnprocessedRecords() {\n\truntime.Gosched()\n\tvar (\n\t\tdiff     uint64\n\t\tdiffPrev uint64\n\t\ti        uint8\n\t)\n\tfor {\n\t\tdiff = atomic.LoadUint64(&logger.countIn) - atomic.LoadUint64(&logger.countOut)\n\t\tif diff == diffPrev {\n\t\t\ti++\n\t\t}\n\t\tif i >= 100 {\n\t\t\treturn\n\t\t}\n\t\tif diff > 0 {\n\t\t\tdiffPrev = diff\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}"
        ],
        [
            "func (logger *Logger) SetBufferLength(length int) {\n\tlogger.lock.Lock()\n\n\tif length == 0 {\n\t\tlogger.buffer = nil\n\t} else if length != logger.buffer.Len() {\n\t\tlogger.buffer = ring.New(length)\n\t}\n\n\tlogger.lock.Unlock()\n}"
        ],
        [
            "func (logger *Logger) AddHandler(handler Handler) {\n\tlogger.lock.Lock()\n\tlogger.Handlers = append(logger.Handlers, handler)\n\tlogger.flushBuffer()\n\tlogger.lock.Unlock()\n}"
        ],
        [
            "func (logger *Logger) ClearHandlers() {\n\tlogger.lock.Lock()\n\tlogger.closeHandlers()\n\tlogger.Handlers = make([]Handler, 0)\n\tlogger.flushBuffer()\n\tlogger.lock.Unlock()\n}"
        ],
        [
            "func (logger *Logger) SetLevel(level Level) {\n\tlogger.lock.Lock()\n\tlogger.Level = level\n\tlogger.flushBuffer()\n\tlogger.lock.Unlock()\n}"
        ],
        [
            "func (logger *Logger) log(level Level, format string, a ...interface{}) {\n\tvar message string\n\tif format == \"\" {\n\t\tmessage = fmt.Sprint(a...)\n\t} else {\n\t\tmessage = fmt.Sprintf(format, a...)\n\t}\n\n\tatomic.AddUint64(&logger.countIn, 1)\n\tlogger.recordChannel <- &Record{\n\t\tLevel:   level,\n\t\tMessage: message,\n\t\tTime:    time.Now(),\n\t}\n}"
        ],
        [
            "func (logger *Logger) Logf(level Level, format string, a ...interface{}) {\n\tlogger.log(level, format, a...)\n}"
        ],
        [
            "func (logger *Logger) Log(level Level, a ...interface{}) {\n\tlogger.log(level, \"\", a...)\n}"
        ],
        [
            "func (logger *Logger) Emergencyf(format string, a ...interface{}) {\n\tlogger.log(EMERGENCY, format, a...)\n}"
        ],
        [
            "func (logger *Logger) Alertf(format string, a ...interface{}) {\n\tlogger.log(ALERT, format, a...)\n}"
        ],
        [
            "func (logger *Logger) Criticalf(format string, a ...interface{}) {\n\tlogger.log(CRITICAL, format, a...)\n}"
        ],
        [
            "func (logger *Logger) Errorf(format string, a ...interface{}) {\n\tlogger.log(ERROR, format, a...)\n}"
        ],
        [
            "func (logger *Logger) Warningf(format string, a ...interface{}) {\n\tlogger.log(WARNING, format, a...)\n}"
        ],
        [
            "func (logger *Logger) Noticef(format string, a ...interface{}) {\n\tlogger.log(NOTICE, format, a...)\n}"
        ],
        [
            "func (logger *Logger) Infof(format string, a ...interface{}) {\n\tlogger.log(INFO, format, a...)\n}"
        ],
        [
            "func (logger *Logger) Debugf(format string, a ...interface{}) {\n\tlogger.log(DEBUG, format, a...)\n}"
        ],
        [
            "func (e *Entry) SetHandler(h *Route) error {\n\tif e.handler != nil {\n\t\treturn errors.New(\"Duplicate Route registration\")\n\t}\n\te.handler = h\n\treturn nil\n}"
        ],
        [
            "func (e *Entry) SetMethodHandler(method string, h *Route) error {\n\tif e.GetHandler(method) != nil {\n\t\treturn errors.New(\"Duplicate Route registration\")\n\t}\n\te.handlers[method] = h\n\treturn nil\n}"
        ],
        [
            "func (e *Entry) GetHandler(method string) *Route {\n\thandler := e.handlers[method]\n\tif handler == nil {\n\t\thandler = e.handler\n\t}\n\treturn handler\n}"
        ],
        [
            "func (e *Entry) getChildEntry(pat string) *Entry {\n\tfor _, entry := range e.entries {\n\t\tif pat == entry.Pattern() {\n\t\t\treturn entry\n\t\t}\n\t}\n\treturn nil\n}"
        ],
        [
            "func (e *Entry) MergePatterns(patterns []string) *Entry {\n\tpat, size := PeekNextPattern(patterns)\n\tif child := e.getChildEntry(pat); child != nil {\n\t\tif len(patterns) == size {\n\t\t\treturn child\n\t\t}\n\t\treturn child.MergePatterns(patterns[size:])\n\t}\n\treturn e.addPatterns(patterns)\n}"
        ],
        [
            "func (e *Entry) AddEntry(child *Entry) {\n\tlength := len(e.entries)\n\tif length == 0 {\n\t\te.entries = append(e.entries, child)\n\t\treturn\n\t}\n\n\tindex := sort.Search(length, func(i int) bool {\n\t\treturn child.weight > e.entries[i].weight\n\t})\n\n\tif index == length {\n\t\te.entries = append(e.entries, child)\n\t\treturn\n\t}\n\n\te.entries = append(e.entries, nil)\n\tcopy(e.entries[index+1:], e.entries[index:])\n\te.entries[index] = child\n}"
        ],
        [
            "func (e *Entry) addPatterns(patterns []string) *Entry {\n\tvar currentNode *Entry = e\n\n\tfor len(patterns) > 0 {\n\t\tvar entry *Entry\n\t\tpat, size := PeekNextPattern(patterns)\n\n\t\t// suffix entry\n\t\tif size == 2 {\n\t\t\tmatcher, name := parseMatcher(patterns[0])\n\t\t\tsuffixMatcher := &SuffixMatcher{patterns[1], matcher}\n\t\t\tentry = newSuffixMatchEntry(pat, name, suffixMatcher)\n\t\t} else if isMatchPattern(pat) {\n\t\t\tentry = newMatchEntry(pat)\n\t\t} else {\n\t\t\tentry = newStaticEntry(pat)\n\t\t}\n\n\t\tcurrentNode.AddEntry(entry)\n\t\tcurrentNode = entry\n\t\tpatterns = patterns[size:]\n\t}\n\n\treturn currentNode\n}"
        ],
        [
            "func (e *Entry) execPrefix(method, urlStr string) (*Route, []string) {\n\tif !strings.HasPrefix(urlStr, e.pattern) {\n\t\treturn nil, nil\n\t}\n\tif len(urlStr) == len(e.pattern) {\n\t\treturn e.GetHandler(method), nil\n\t}\n\treturn e.traverse(method, urlStr[len(e.pattern):])\n}"
        ],
        [
            "func (e *Entry) traverse(method, urlStr string) (*Route, []string) {\n\tfor _, entry := range e.entries {\n\t\tif h, params := entry.exec(method, urlStr); h != nil {\n\t\t\treturn h, params\n\t\t}\n\t}\n\treturn nil, nil\n}"
        ],
        [
            "func (e *Entry) getExecMatch(name string, matcher Matcher) ExecFunc {\n\treturn func(method, urlStr string) (*Route, []string) {\n\t\toffset, matchStr := matcher.Match(urlStr)\n\t\tif offset == -1 {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\t// finish parsing\n\t\tif len(urlStr) == offset {\n\t\t\tif h := e.GetHandler(method); h != nil {\n\t\t\t\treturn h, []string{name, matchStr}\n\t\t\t}\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tfor _, entry := range e.entries {\n\t\t\tif h, params := entry.exec(method, urlStr[offset:]); h != nil {\n\t\t\t\tparams = append(params, name, matchStr)\n\t\t\t\treturn h, params\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n}"
        ],
        [
            "func MergeRoutes(r ...Routable) Routes {\n\troutes := make(Routes, 0)\n\tfor _, v := range r {\n\t\troutes = append(routes, v.Routes()...)\n\t}\n\treturn routes\n}"
        ],
        [
            "func (l *logger) Debugln(vals ...interface{}) {\n\tl.mut.Lock()\n\tdefer l.mut.Unlock()\n\ts := fmt.Sprintln(vals...)\n\tl.logger.Output(2, \"DEBUG: \"+s)\n\tl.callHandlers(LevelDebug, s)\n}"
        ],
        [
            "func (l *logger) Debugf(format string, vals ...interface{}) {\n\tl.mut.Lock()\n\tdefer l.mut.Unlock()\n\ts := fmt.Sprintf(format, vals...)\n\tl.logger.Output(2, \"DEBUG: \"+s)\n\tl.callHandlers(LevelDebug, s)\n}"
        ],
        [
            "func (l *logger) Verbosef(format string, vals ...interface{}) {\n\tl.mut.Lock()\n\tdefer l.mut.Unlock()\n\ts := fmt.Sprintf(format, vals...)\n\tl.logger.Output(2, \"VERBOSE: \"+s)\n\tl.callHandlers(LevelVerbose, s)\n}"
        ],
        [
            "func (l *logger) Infoln(vals ...interface{}) {\n\tl.mut.Lock()\n\tdefer l.mut.Unlock()\n\ts := fmt.Sprintln(vals...)\n\tl.logger.Output(2, \"INFO: \"+s)\n\tl.callHandlers(LevelInfo, s)\n}"
        ],
        [
            "func (l *logger) Infof(format string, vals ...interface{}) {\n\tl.mut.Lock()\n\tdefer l.mut.Unlock()\n\ts := fmt.Sprintf(format, vals...)\n\tl.logger.Output(2, \"INFO: \"+s)\n\tl.callHandlers(LevelInfo, s)\n}"
        ],
        [
            "func (l *logger) Okln(vals ...interface{}) {\n\tl.mut.Lock()\n\tdefer l.mut.Unlock()\n\ts := fmt.Sprintln(vals...)\n\tl.logger.Output(2, \"OK: \"+s)\n\tl.callHandlers(LevelOK, s)\n}"
        ],
        [
            "func (l *logger) Okf(format string, vals ...interface{}) {\n\tl.mut.Lock()\n\tdefer l.mut.Unlock()\n\ts := fmt.Sprintf(format, vals...)\n\tl.logger.Output(2, \"OK: \"+s)\n\tl.callHandlers(LevelOK, s)\n}"
        ],
        [
            "func (l *logger) Fatalln(vals ...interface{}) {\n\tl.mut.Lock()\n\tdefer l.mut.Unlock()\n\ts := fmt.Sprintln(vals...)\n\tl.logger.Output(2, \"FATAL: \"+s)\n\tl.callHandlers(LevelFatal, s)\n\tos.Exit(1)\n}"
        ],
        [
            "func (l *logger) Fatalf(format string, vals ...interface{}) {\n\tl.mut.Lock()\n\tdefer l.mut.Unlock()\n\ts := fmt.Sprintf(format, vals...)\n\tl.logger.Output(2, \"FATAL: \"+s)\n\tl.callHandlers(LevelFatal, s)\n\tos.Exit(1)\n}"
        ],
        [
            "func (l *logger) ShouldDebug(facility string) bool {\n\tl.mut.Lock()\n\tres := l.debug[facility]\n\tl.mut.Unlock()\n\treturn res\n}"
        ],
        [
            "func (l *logger) SetDebug(facility string, enabled bool) {\n\tl.mut.Lock()\n\tl.debug[facility] = enabled\n\tl.mut.Unlock()\n}"
        ],
        [
            "func (l *logger) Facilities() (enabled, disabled []string) {\n\tl.mut.Lock()\n\tfor facility, isEnabled := range l.debug {\n\t\tif isEnabled {\n\t\t\tenabled = append(enabled, facility)\n\t\t} else {\n\t\t\tdisabled = append(disabled, facility)\n\t\t}\n\t}\n\tl.mut.Unlock()\n\treturn\n}"
        ],
        [
            "func (l *logger) NewFacility(facility string) Logger {\n\tl.mut.Lock()\n\tif l.debug == nil {\n\t\tl.debug = make(map[string]bool)\n\t}\n\tl.debug[facility] = false\n\tl.mut.Unlock()\n\n\treturn &facilityLogger{\n\t\tlogger:   l,\n\t\tfacility: facility,\n\t}\n}"
        ],
        [
            "func (f *formatifier) removeNonDigits() {\n\trp := regexp.MustCompile(`\\D`)\n\tf.theString = rp.ReplaceAllString(f.theString, \"\")\n}"
        ],
        [
            "func (f *formatifier) removeNonWordChars() {\n\tif len(f.theString) > 0 {\n\t\trp := regexp.MustCompile(`\\W|\\s|_`)\n\t\tf.theString = rp.ReplaceAllString(f.theString, \"\")\n\t}\n}"
        ],
        [
            "func (f *formatifier) urlEncodeSpaces() {\n\trp := regexp.MustCompile(`\\s`)\n\tf.theString = rp.ReplaceAllString(f.theString, \"%20\")\n}"
        ],
        [
            "func randomSelect(a []int) int {\n\tvar tmpIndex int\n\tlength := len(a)\n\trandBytes := make([]byte, length)\n\tif _, err := rand.Read(randBytes); err == nil {\n\t\ttmpIndex = int(randBytes[0]) % length\n\t}\n\treturn a[tmpIndex]\n}"
        ],
        [
            "func NewStdFormatter(delim, tmpl string, entry Entry, values map[string]interface{}, timeformat string) (Formatter, error) {\n\tif delim == \"\" {\n\t\treturn nil, e.New(\"invalid delimitator\")\n\t}\n\tif tmpl == \"\" {\n\t\treturn nil, e.New(\"invalid template\")\n\t}\n\tif entry == nil {\n\t\treturn nil, e.New(\"invalid entry\")\n\t}\n\tif values == nil {\n\t\treturn nil, e.New(\"invalid values\")\n\t}\n\tif timeformat == \"\" {\n\t\ttimeformat = TimeDateFormat\n\t}\n\treturn &StdFormatter{\n\t\tDelim:      []byte(delim),\n\t\tTmpl:       []byte(tmpl),\n\t\tE:          entry,\n\t\tMap:        values,\n\t\tIdx:        mkindex(entry),\n\t\tTimeFormat: timeformat,\n\t}, nil\n}"
        ],
        [
            "func (s Chain) Get(handler http.Handler) http.Handler {\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\thandler = s[i](handler)\n\t}\n\treturn handler\n}"
        ],
        [
            "func parseMatcher(pat string) (matcher Matcher, name string) {\n\tif !isMatchPattern(pat) {\n\t\tpanic(\"pattern \\\"\" + pat + \"\\\" is not a matcher pattern\")\n\t}\n\n\ts := pat[1 : len(pat)-1]\n\tss := strings.Split(s, \":\")\n\tvar matchType string\n\tif len(ss) == 1 {\n\t\tname = ss[0]\n\t} else {\n\t\tmatchType = ss[0]\n\t\tname = ss[1]\n\t}\n\tif matchType == \"\" {\n\t\tmatchType = \"default\"\n\t}\n\n\tmatcher = MatcherMap[matchType]\n\tif matcher == nil {\n\t\tpanic(errors.New(\"no such match type: \" + matchType))\n\t}\n\n\treturn matcher, name\n}"
        ],
        [
            "func isMatchPattern(s string) bool {\n\treturn len(s) > 2 && s[0] == '<' && s[len(s)-1] == '>'\n}"
        ],
        [
            "func routeSplitFunc(data []byte, atEOF bool) (int, []byte, error) {\n\tif atEOF || data == nil {\n\t\treturn 0, nil, io.EOF\n\t}\n\n\tr, _ := utf8.DecodeRune(data)\n\n\t// matcher\n\tif r == '<' {\n\t\ti := bytes.IndexRune(data, '>')\n\t\tif i == -1 {\n\t\t\treturn 0, nil, NoClosingBracket\n\t\t}\n\t\treturn (i + 1), data[:(i + 1)], nil\n\t}\n\n\t// one char\n\tif len(data) == 1 {\n\t\treturn 1, data, nil\n\t}\n\n\t// should ignore first '/'\n\tslashIndex := bytes.IndexRune(data[1:], '/')\n\tif slashIndex != -1 {\n\t\tslashIndex++\n\t}\n\n\tmatchIndex := bytes.IndexRune(data, '<')\n\n\t// remaining string would be a static entry\n\tif slashIndex == -1 && matchIndex == -1 {\n\t\treturn len(data), data, nil\n\t}\n\n\t// split by '<'\n\t// return data before '<'\n\tif matchIndex != -1 && (slashIndex == -1 || slashIndex > matchIndex) {\n\t\treturn matchIndex, data[:matchIndex], nil\n\t}\n\n\t// split by '/'\n\t// return data before '/' including '/'\n\treturn slashIndex + 1, data[:(slashIndex + 1)], nil\n}"
        ],
        [
            "func SplitPath(pat string) (routes []string, err error) {\n\tscanner := bufio.NewScanner(strings.NewReader(pat))\n\tscanner.Split(routeSplitFunc)\n\tfor scanner.Scan() {\n\t\troutes = append(routes, scanner.Text())\n\t}\n\terr = scanner.Err()\n\treturn\n}"
        ],
        [
            "func isNextSuffixPattern(p []string) bool {\n\tif len(p) >= 2 && isMatchPattern(p[0]) && !isMatchPattern(p[1]) {\n\t\tmatcher, _ := parseMatcher(p[0])\n\t\tif _, ok := matcher.(*FixedLengthMatcher); ok {\n\t\t\treturn false\n\t\t}\n\t\tr, _ := utf8.DecodeRuneInString(p[1])\n\t\treturn matcher.MatchRune(r)\n\t}\n\treturn false\n}"
        ],
        [
            "func PeekNextPattern(p []string) (pat string, size int) {\n\tif isNextSuffixPattern(p) {\n\t\tpat, size = (p[0] + p[1]), 2\n\t} else {\n\t\tpat, size = p[0], 1\n\t}\n\treturn\n}"
        ],
        [
            "func NewPlayer(nick string, profile Profile) (*Player, error) {\n\tp := new(Player)\n\tnewUUID, err := uuid.V4()\n\tif err != nil {\n\t\t// FIXME: Handle error\n\t}\n\tp.UUID = newUUID\n\tp.Nick = nick\n\tp.Profile = profile\n\terr = storage.Store(p)\n\tif err != nil {\n\t\treturn nil, errors.New(err.Error() + \" - Could not write player to storage\")\n\t}\n\treturn p, nil\n}"
        ],
        [
            "func (r *Reader) Push(reader io.Reader) {\n\tr.readers = append(r.readers, reader)\n}"
        ],
        [
            "func NewCatering(tournament uuid.UUID, ci Info) (*Catering, error) {\n\tc := new(Catering)\n\tc.UUID, _ = uuid.V4()\n\tc.Tournament = tournament\n\tif err := mergo.MergeWithOverwrite(&c.Info, ci); err != nil {\n\t\treturn nil, errors.New(err.Error() + \" - Could not set initial catering info\")\n\t}\n\tif err := storage.Store(c); err != nil {\n\t\treturn nil, errors.New(err.Error() + \" - Could not write catering to storage\")\n\t}\n\treturn c, nil\n}"
        ],
        [
            "func (t Tournaments) GroupByMonths(season int) map[time.Month]Tournaments {\n\tbyMonth := make(map[time.Month]Tournaments)\n\n\tfor _, entry := range t {\n\t\ty, m := entry.Info.Scheduled.Year(), entry.Info.Scheduled.Month()\n\t\tif y == season {\n\t\t\tbyMonth[m] = append(byMonth[m], entry)\n\t\t}\n\t}\n\n\treturn byMonth\n}"
        ],
        [
            "func validateTournamentInfo(info Info) error {\n\tif info.Scheduled.IsZero() {\n\t\treturn errors.New(\"Tournament needs scheduled date\")\n\t}\n\tif info.Stake == 0 {\n\t\treturn errors.New(\"Tournament needs a stake\")\n\t}\n\tif info.Season == 0 {\n\t\treturn errors.New(\"Tournament needs a season\")\n\t}\n\treturn nil\n}"
        ],
        [
            "func NewTournament(tdata Info) (*Tournament, error) {\n\tif err := validateTournamentInfo(tdata); err != nil {\n\t\treturn nil, errors.New(err.Error() + \" - Could not create tournament\")\n\t}\n\n\tt := new(Tournament)\n\tt.UUID, _ = uuid.V4()\n\tif err := mergo.MergeWithOverwrite(&t.Info, tdata); err != nil {\n\t\treturn nil, errors.New(err.Error() + \" - Could not set initial tournament data\")\n\t}\n\t// Merge seems to not handle time.Time for some reason, thus fixup\n\tfixupTournamentInfo(&t.Info, tdata)\n\tif err := storage.Store(t); err != nil {\n\t\treturn nil, errors.New(err.Error() + \" - Could not write tournament to storage\")\n\t}\n\treturn t, nil\n}"
        ],
        [
            "func (s StringSlice) IndexOf(str string) int {\n\tfor i, v := range s {\n\t\tif str == v {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}"
        ],
        [
            "func (s StringSlice) IndexOfIgnoreCase(str string) int {\n\tstr = strings.ToLower(str)\n\tfor i, v := range s {\n\t\tif str == strings.ToLower(v) {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}"
        ],
        [
            "func NewCache(d time.Duration) *Cache {\n\treturn &Cache{\n\t\tvalues:   make(map[string]*cacheItem),\n\t\tlifetime: d,\n\t}\n}"
        ],
        [
            "func (s *Cache) Count() int {\n\tif s.removeExpired() == raiqub.WriteLocked {\n\t\tdefer s.Unlock()\n\t} else {\n\t\tdefer s.RUnlock()\n\t}\n\n\treturn len(s.values)\n}"
        ],
        [
            "func (s *Cache) Flush() {\n\ts.Lock()\n\tdefer s.Unlock()\n\n\ts.values = make(map[string]*cacheItem)\n}"
        ],
        [
            "func (s *Cache) removeExpired() raiqub.LockStatus {\n\twriteLocked := false\n\ts.RLock()\n\tfor i := range s.values {\n\t\tif s.values[i].IsExpired() {\n\t\t\tif !writeLocked {\n\t\t\t\ts.RUnlock()\n\t\t\t\ts.Lock()\n\t\t\t\twriteLocked = true\n\t\t\t}\n\t\t\tdelete(s.values, i)\n\t\t}\n\t}\n\n\tif writeLocked {\n\t\treturn raiqub.WriteLocked\n\t} else {\n\t\treturn raiqub.ReadLocked\n\t}\n}"
        ],
        [
            "func NewImage(d *Docker, name string) *Image {\n\treturn &Image{\n\t\tdocker: d,\n\t\tname:   name,\n\t}\n}"
        ],
        [
            "func (s *Image) Exists() bool {\n\tout, err := s.docker.Run(\"images\", \"--no-trunc\")\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn strings.Contains(out, s.name)\n}"
        ],
        [
            "func (s *Image) Pull() error {\n\t_, err := s.docker.Run(\"pull\", s.name)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func (s *Image) Run(cfg *RunConfig) (*Container, error) {\n\targs := make([]string, 0, len(cfg.Options)+len(cfg.Args)+1)\n\targs = append(args, cfg.Options...)\n\targs = append(args, s.name)\n\targs = append(args, cfg.Args...)\n\n\tout, err := s.docker.Run(\"run\", args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcontainer := &Container{\n\t\tdocker: s.docker,\n\t\tid:     strings.TrimSpace(out),\n\t}\n\tif container.id == \"\" {\n\t\treturn nil, UnexpectedOutputError(\n\t\t\t\"Unexpected empty output when running docker container\")\n\t}\n\n\treturn container, nil\n}"
        ],
        [
            "func (s *Image) Setup() error {\n\tif !s.docker.HasBin() {\n\t\treturn DockerBinNotFound(s.docker.binCmd)\n\t}\n\n\tif !s.Exists() {\n\t\tif err := s.Pull(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}"
        ],
        [
            "func NewLocation(host uuid.UUID, lp Profile) (*Location, error) {\n\tl := new(Location)\n\tl.UUID, _ = uuid.V4()\n\tl.Active = true\n\tl.Host = host\n\tif err := mergo.MergeWithOverwrite(&l.Profile, lp); err != nil {\n\t\treturn nil, errors.New(err.Error() + \" - Could not set initial location profile\")\n\t}\n\tif err := storage.Store(l); err != nil {\n\t\treturn nil, errors.New(err.Error() + \" - Could not write location to storage\")\n\t}\n\treturn l, nil\n}"
        ],
        [
            "func (s NetworkSettings) PortAt(index int) (string, *HostPublish) {\n\tcounter := 0\n\tfor k, v := range s.Ports {\n\t\tif counter != index {\n\t\t\tcounter++\n\t\t\tcontinue\n\t\t}\n\n\t\treturn k, v\n\t}\n\n\treturn \"\", nil\n}"
        ],
        [
            "func (s NetworkSettings) SplitPort(index int) (uint16, string) {\n\tptProt, _ := s.PortAt(index)\n\tvect := strings.Split(ptProt, \"/\")\n\tport, _ := strconv.ParseUint(vect[0], 10, 16)\n\treturn uint16(port), vect[1]\n}"
        ],
        [
            "func (s SyslogFacility) Priority() syslog.Priority {\n\treturn syslogPriorities[strings.ToLower(s.String())]\n}"
        ],
        [
            "func (s SyslogFacility) OK() (ok bool) {\n\t_, ok = syslogPriorities[strings.ToLower(s.String())]\n\treturn\n}"
        ],
        [
            "func (formatter *JSONFormatter) Format(record *Record) string {\n\tdata, _ := json.Marshal(record)\n\treturn string(data)\n}"
        ],
        [
            "func Open(path string, mode os.FileMode, options *bolt.Options) (DB, error) {\n\tdb, err := bolt.Open(path, mode, options)\n\treturn DB{db}, errorsp.WithStacks(err)\n}"
        ],
        [
            "func (db DB) Begin(writable bool) (Tx, error) {\n\ttx, err := db.DB.Begin(writable)\n\treturn Tx{tx}, errorsp.WithStacks(err)\n}"
        ],
        [
            "func (db DB) View(f func(Tx) error) error {\n\treturn errorsp.WithStacks(db.DB.View(func(tx *bolt.Tx) error {\n\t\treturn errorsp.WithStacks(f(Tx{tx}))\n\t}))\n}"
        ],
        [
            "func (tx Tx) CopyFile(path string, mode os.FileMode) error {\n\treturn errorsp.WithStacks(tx.Tx.CopyFile(path, mode))\n}"
        ],
        [
            "func (tx Tx) CreateBucketIfNotExists(folders [][]byte) (Bucket, error) {\n\tb, err := tx.Tx.CreateBucketIfNotExists(folders[0])\n\tif err != nil {\n\t\treturn Bucket{}, nil\n\t}\n\tif len(folders) == 1 {\n\t\treturn Bucket{b}, nil\n\t}\n\treturn Bucket{b}.CreateBucketIfNotExists(folders[1:])\n}"
        ],
        [
            "func (tx Tx) Delete(k [][]byte) error {\n\tif len(k) == 1 {\n\t\treturn errorsp.WithStacks(tx.Tx.DeleteBucket(k[0]))\n\t}\n\treturn tx.Bucket(k[:len(k)-1], func(b Bucket) error {\n\t\treturn errorsp.WithStacks(b.Bucket.Delete(k[len(k)-1]))\n\t})\n}"
        ],
        [
            "func (tx Tx) ForEach(folders [][]byte, f func(Bucket, bytesp.Slice, bytesp.Slice) error) error {\n\treturn tx.Bucket(folders, func(b Bucket) error {\n\t\treturn errorsp.WithStacks(b.Bucket.ForEach(func(k, v []byte) error {\n\t\t\treturn errorsp.WithStacks(f(b, bytesp.Slice(k), bytesp.Slice(v)))\n\t\t}))\n\t})\n}"
        ],
        [
            "func (tx Tx) ForEachGob(folders [][]byte, f func(Bucket, bytesp.Slice, interface{}) error) error {\n\treturn tx.ForEach(folders, func(b Bucket, k, bs bytesp.Slice) error {\n\t\tvar v interface{}\n\t\tif err := gob.NewDecoder(&bs).Decode(&v); err != nil {\n\t\t\treturn errorsp.WithStacksAndMessage(err, \"decoding %d bytes value for key %q failed\", len(bs), string(k))\n\t\t}\n\t\treturn errorsp.WithStacks(f(b, k, v))\n\t})\n}"
        ],
        [
            "func (tx Tx) Put(k [][]byte, v []byte) error {\n\tb, err := tx.CreateBucketIfNotExists(k[:len(k)-1])\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn errorsp.WithStacks(b.Bucket.Put(k[len(k)-1], v))\n}"
        ],
        [
            "func (tx Tx) Value(k [][]byte, f func(v bytesp.Slice) error) error {\n\treturn tx.Bucket(k[:len(k)-1], func(b Bucket) error {\n\t\tv := b.Bucket.Get(k[len(k)-1])\n\t\tif v == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn errorsp.WithStacks(f(bytesp.Slice(v)))\n\t})\n}"
        ],
        [
            "func (tx Tx) Update(k [][]byte, f func(bytesp.Slice) (bytesp.Slice, error)) error {\n\tb, err := tx.CreateBucketIfNotExists(k[:len(k)-1])\n\tif err != nil {\n\t\treturn err\n\t}\n\tv, err := f(b.Bucket.Get(k[len(k)-1]))\n\tif err != nil {\n\t\treturn errorsp.WithStacks(err)\n\t}\n\tif v == nil {\n\t\treturn errorsp.WithStacks(b.Bucket.Delete(k[len(k)-1]))\n\t}\n\treturn errorsp.WithStacks(b.Bucket.Put(k[len(k)-1], v))\n}"
        ],
        [
            "func (b Bucket) OpenBucket(folders [][]byte, f func(Bucket) error) error {\n\tbb := b.Bucket\n\tfor _, fld := range folders {\n\t\tbb = bb.Bucket(fld)\n\t\tif bb == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errorsp.WithStacks(f(Bucket{bb}))\n}"
        ],
        [
            "func (b Bucket) CreateBucketIfNotExists(folders [][]byte) (Bucket, error) {\n\tbb := b.Bucket\n\tfor _, fld := range folders {\n\t\tvar err error\n\t\tif bb, err = bb.CreateBucketIfNotExists(fld); err != nil {\n\t\t\treturn Bucket{}, errorsp.WithStacks(err)\n\t\t}\n\t}\n\treturn Bucket{bb}, nil\n}"
        ],
        [
            "func (b Bucket) Delete(k [][]byte) error {\n\treturn b.OpenBucket(k[:len(k)-1], func(b Bucket) error {\n\t\treturn errorsp.WithStacks(b.Bucket.Delete(k[len(k)-1]))\n\t})\n}"
        ],
        [
            "func (b Bucket) GobValue(k [][]byte, f func(interface{}) error) error {\n\treturn b.Value(k, func(bs bytesp.Slice) error {\n\t\tvar v interface{}\n\t\tif err := gob.NewDecoder(&bs).Decode(&v); err != nil {\n\t\t\treturn errorsp.WithStacksAndMessage(err, \"decoding %d bytes buffer failed\", len(bs))\n\t\t}\n\t\treturn f(v)\n\t})\n}"
        ],
        [
            "func (b Bucket) NextSequence() (uint64, error) {\n\ts, err := b.Bucket.NextSequence()\n\treturn s, errorsp.WithStacks(err)\n}"
        ],
        [
            "func (b Bucket) Put(k [][]byte, v []byte) error {\n\tbb, err := b.CreateBucketIfNotExists(k[:len(k)-1])\n\tif err != nil {\n\t\treturn errorsp.WithStacksAndMessage(err, \"CreateBucketIfNotExists %q failed\", string(bytes.Join(k[:len(k)-1], []byte(\" \"))))\n\t}\n\treturn errorsp.WithStacks(bb.Bucket.Put(k[len(k)-1], v))\n}"
        ],
        [
            "func (b Bucket) PutGob(k [][]byte, v interface{}) error {\n\tvar bs bytesp.Slice\n\tif err := gob.NewEncoder(&bs).Encode(&v); err != nil {\n\t\treturn errorsp.WithStacksAndMessage(err, \"encoding %+v failed\", v)\n\t}\n\treturn b.Put(k, bs)\n}"
        ],
        [
            "func (m *MongoDb) Drop() error {\n\terr := m.db.DropDatabase()\n\tif err != nil {\n\t\treturn e.New(err)\n\t}\n\tm.db = m.session.DB(m.dbname)\n\tm.c = m.db.C(m.collection)\n\treturn nil\n}"
        ],
        [
            "func (handler *NullHandler) HandleError(err error) error {\n\tos.Stderr.WriteString(fmt.Sprintf(\"%s %s\\n\", time.Now(), err.Error()))\n\treturn nil\n}"
        ],
        [
            "func (handler *WriteHandler) Handle(record *Record) error {\n\t_, err := handler.Writer.Write([]byte(handler.Formatter.Format(record) + \"\\n\"))\n\treturn err\n}"
        ],
        [
            "func (handler *MemoryHandler) Handle(record *Record) error {\n\thandler.lock.Lock()\n\thandler.Messages = append(handler.Messages, handler.Formatter.Format(record))\n\thandler.lock.Unlock()\n\treturn nil\n}"
        ],
        [
            "func WaitPeerListening(network, address string, timeout time.Duration) bool {\n\treturn WaitFunc(100*time.Millisecond, timeout, func() bool {\n\t\tc, err := net.Dial(network, address)\n\t\tif err == nil {\n\t\t\tc.Close()\n\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t})\n}"
        ],
        [
            "func NewEvent(name string, body interface{}) Event {\n\treturn Event{\n\t\tname:        name,\n\t\tbody:        body,\n\t\toccuredTime: time.Now(),\n\t}\n}"
        ],
        [
            "func (b *Bus) Subscribe(h Handler) bool {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\tfor _, v := range b.handlers {\n\t\tif v == h {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tb.handlers = append(b.handlers, h)\n\treturn true\n}"
        ],
        [
            "func (b *Bus) Unsubscribe(h Handler) bool {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\tfor i, v := range b.handlers {\n\t\tif v == h {\n\t\t\tb.handlers = append(b.handlers[:i], b.handlers[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}"
        ],
        [
            "func (b *Bus) Publish(eventName string, eventBody interface{}) {\n\te := NewEvent(eventName, eventBody)\n\n\tb.mu.RLock()\n\tdefer b.mu.RUnlock()\n\tfor _, h := range b.handlers {\n\t\th.Handle(e)\n\t}\n}"
        ],
        [
            "func HandleOnly(h Handler, names ...string) Handler {\n\treturn HandlerFunc(func(e Event) {\n\t\tfor _, name := range names {\n\t\t\tif e.Name() == name {\n\t\t\t\th.Handle(e)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t})\n}"
        ],
        [
            "func ContextWithPublisher(ctx context.Context, pub Publisher) context.Context {\n\treturn context.WithValue(ctx, KeyPublisher, pub)\n}"
        ],
        [
            "func PublisherContext(ctx context.Context) Publisher {\n\tpub, ok := ctx.Value(KeyPublisher).(Publisher)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\treturn pub\n}"
        ],
        [
            "func PublishNamedEvent(pub Publisher, eventBody interface{}) {\n\tname := reflect.TypeOf(eventBody).Name()\n\tpub.Publish(name, eventBody)\n}"
        ],
        [
            "func PublishEventContext(ctx context.Context, eventName string, eventBody interface{}) {\n\tpub := PublisherContext(ctx)\n\tif pub == nil {\n\t\treturn\n\t}\n\n\tpub.Publish(eventName, eventBody)\n}"
        ],
        [
            "func PublishNamedEventContext(ctx context.Context, eventBody interface{}) {\n\tname := reflect.TypeOf(eventBody).Name()\n\tPublishEventContext(ctx, name, eventBody)\n}"
        ],
        [
            "func (level Level) String() string {\n\tswitch level {\n\tcase EMERGENCY:\n\t\treturn \"EMERGENCY\"\n\tcase ALERT:\n\t\treturn \"ALERT\"\n\tcase CRITICAL:\n\t\treturn \"CRITICAL\"\n\tcase ERROR:\n\t\treturn \"ERROR\"\n\tcase WARNING:\n\t\treturn \"WARNING\"\n\tcase NOTICE:\n\t\treturn \"NOTICE\"\n\tcase INFO:\n\t\treturn \"INFO\"\n\tdefault:\n\t\treturn \"DEBUG\"\n\t}\n}"
        ],
        [
            "func (level *Level) UnmarshalJSON(data []byte) error {\n\tswitch string(bytes.ToUpper(data)) {\n\tcase `\"EMERGENCY\"`, \"0\":\n\t\t*level = EMERGENCY\n\tcase `\"ALERT\"`, \"1\":\n\t\t*level = ALERT\n\tcase `\"CRITICAL\"`, \"2\":\n\t\t*level = CRITICAL\n\tcase `\"ERROR\"`, \"3\":\n\t\t*level = ERROR\n\tcase `\"WARNING\"`, \"4\":\n\t\t*level = WARNING\n\tcase `\"NOTICE\"`, \"5\":\n\t\t*level = NOTICE\n\tcase `\"INFO\"`, \"6\":\n\t\t*level = INFO\n\tcase `\"DEBUG\"`, \"7\":\n\t\t*level = DEBUG\n\tdefault:\n\t\treturn ErrInvalidLevel\n\t}\n\treturn nil\n}"
        ]
    ]
}