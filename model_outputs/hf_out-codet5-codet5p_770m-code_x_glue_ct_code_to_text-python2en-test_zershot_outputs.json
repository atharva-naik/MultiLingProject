{
    "accuracy": 0,
    "bleu": {
        "bleu": 0.07171629222003208,
        "precisions": [
            0.09690193797802218,
            0.07024196708613321,
            0.06434132859691163,
            0.06040211698787437
        ],
        "brevity_penalty": 1.0,
        "length_ratio": 5.688288692918283,
        "translation_length": 658573,
        "reference_length": 115777
    },
    "codebleu": 0,
    "preds": [
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.",
        "\n        elif event.is_directory:\n            self._on_directory_moved(event)\n\n        elif event.is_file:\n            self._on_file_moved(event)\n\n        elif event.is_symlink:\n            self._on_symlink_moved(event)\n\n        elif event.is_symlink_to:\n            self._on_symlink_to_moved(event)\n\n        elif event.is_symlink_from:\n            self._on_symlink_from_moved(event)\n\n        elif event.is_symlink_to_symlink:\n            self._on_symlink_to_symlink_moved(event)\n\n        elif event.is_symlink_from_symlink:\n            self._on_symlink_from_symlink_moved(event)\n\n        elif event.is_symlink_to_symlink_from:\n            self._on_symlink_to_symlink_from_moved(event)\n\n        elif event.is_symlink_to_symlink_from_symlink:\n            self._on_symlink_to_symlink_from_moved(event)\n\n        elif event.is_symlink_to_symlink_from_symlink:\n            self._on_symlink_to_symlink_from_moved(event)\n\n        elif event.",
        "\n\ndef get_temp_directory(self):\n        \"\"\"\n        Returns the directory where the test files will be stored.\n        \"\"\"\n        return tempfile.mkdtemp()\n\ndef get_temp_file(self):\n        \"\"\"\n        Returns the file where the test files will be stored.\n        \"\"\"\n        return tempfile.mktemp()\n\ndef get_temp_file_path(self):\n        \"\"\"\n        Returns the path where the test files will be stored.\n        \"\"\"\n        return os.path.join(get_temp_directory(), 'test.txt')\n\ndef get_temp_file_path_with_extension(self, extension):\n        \"\"\"\n        Returns the path where the test files will be stored.\n        \"\"\"\n        return os.path.join(get_temp_directory(), 'test.%s.txt' % extension)\n\ndef get_temp_file_path_with_extension_with_extension(self, extension, extension2):\n        \"\"\"\n        Returns the path where the test files will be stored.\n        \"\"\"\n        return os.path.join(get_temp_directory(), 'test.%s.%s.txt' % (extension, extension2))\n\ndef get_temp_file_path_with_extension_with_extension_with_extension(self, extension, extension2, extension",
        "(self.exists() and overwrite is True):\n            return True\n\ndef is_not_exist_or_allow_delete(self, delete=False):\n        \"\"\"\n        Test whether a file target is not exists or it exists but allow\n        delete.\n        \"\"\"\n        if self.exists() and delete is False:\n            return False\n        else:  # pragma: no cover\n            return True\n\ndef is_not_exist_or_allow_move(self, move=False):\n        \"\"\"\n        Test whether a file target is not exists or it exists but allow\n        move.\n        \"\"\"\n        if self.exists() and move is False:\n            return False\n        else:  # pragma: no cover\n            return True\n\ndef is_not_exist_or_allow_copy(self, copy=False):\n        \"\"\"\n        Test whether a file target is not exists or it exists but allow\n        copy.\n        \"\"\"\n        if self.exists() and copy is False:\n            return False\n        else:  # pragma: no cover\n            return True\n\ndef is_not_exist_or_allow_move_or_copy(self, move=False, copy=False):\n        \"\"\"\n        Test whether a file target is not exists or it exists but allow\n        move or copy.\n        \"\"\"\n",
        "\n\ndef copy(self,\n         new_abspath=None,\n         new_dirpath=None,\n         new_dirname=None,\n         new_basename=None,\n         new_fname=None,\n         new_ext=None,\n         overwrite=False,\n         makedirs=False):\n    \"\"\"\n    Copy this file to other place.\n    \"\"\"\n    self.assert_exists()\n\n    p = self.change(\n        new_abspath=new_abspath,\n        new_dirpath=new_dirpath,\n        new_dirname=new_dirname,\n        new_basename=new_basename,\n        new_fname=new_fname,\n        new_ext=new_ext,\n    )\n\n    if p.is_not_exist_or_allow_overwrite(overwrite=overwrite):\n        # \u5982\u679c\u4e24\u4e2a\u8def\u5f84\u4e0d\u540c, \u624d\u8fdb\u884ccopy\n        if self.abspath != p.abspath:\n            try:\n                shutil.copy(self.abspath, p.abspath)\n            except IOError as e:\n                if makedirs:\n                    os.makedirs(p.parent.abspath)\n                    shutil.copy(self.abs",
        "\n\n\ndef _create_client(base_url: str, tls: bool = False) -> APIClient:\n    \"\"\"\n    Creates a Docker client.\n\n    :param base_url: the Docker daemon's location\n    :param tls: whether to use TLS\n    :return: the Docker client\n    \"\"\"\n    if tls:\n        return APIClient(base_url, tls=tls)\n    else:\n        return APIClient(base_url)\n\n\ndef kwargs_from_env(assert_hostname: bool = False) -> Dict[str, Any]:\n    \"\"\"\n    Returns a dictionary of environment variables.\n\n    :param assert_hostname: whether to assert that the hostname is correct\n    :return: a dictionary of environment variables\n    \"\"\"\n    docker_environment = os.environ.copy()\n    docker_environment.update(\n        {\n            \"DOCKER_HOST\": os.environ.get(\"DOCKER_HOST\", \"localhost\"),\n            \"DOCKER_X\": os.environ.get(\"DOCKER_X\", \"docker\"),\n            \"DOCKER_X_TLS\": os.environ.get(\"DOCKER_X_TLS\", \"1\"),\n        }\n    )\n    if assert_hostname:\n        docker_environment[\"DOCKER_HOST\"] = os",
        "\n    return wrapper\n\n\ndef load_repository(path):\n    \"\"\"Load repository from path.\"\"\"\n    return Repository(path)\n\n\ndef create_repository(path):\n    \"\"\"Create repository from path.\"\"\"\n    return Repository(path)\n",
        "\n\ndef __clean_before_after_recursive(self, stateBefore, stateAfter, keepNoneEmptyDirectory=True):\n        \"\"\"clean repository given before and after states\"\"\"\n        # prepare after for faster search\n        errors    = []\n        afterDict = {}\n        [afterDict.setdefault(list(aitem)[0],[]).append(aitem) for aitem in stateAfter]\n        # loop before\n        for bitem in reversed(stateBefore):\n            relaPath = list(bitem)[0]\n            basename = os.path.basename(relaPath)\n            btype    = bitem[relaPath]['type']\n            alist    = afterDict.get(relaPath, [])\n            aitem    = [a for a in alist if a[relaPath]['type']==btype]\n            if len(aitem)>1:\n                errors.append(\"Multiple '%s' of type '%s' where found in '%s', this should never had happened. Please report issue\"%(basename,btype,relaPath))\n                continue\n            if not len(aitem):\n                removeDirs  = []\n                removeFiles = []\n                if btype == 'dir':\n                    if not len(relaPath):\n                        errors.append(\"Removing main repository directory is not allowed\")",
        "\n\ndef get_repository_state(self):\n        \"\"\"\n        Get repository state\n\n        :Returns:\n            #. repositoryState (dict): Repository state\n        \"\"\"\n        if self.__path is None:\n            return {}\n        try:\n            fdict = self.__path.get_repository_state()\n        except Exception as e:\n            raise Exception('Error getting repository state: %s' % e)\n        return fdict\n\ndef get_repository_state_dict(self):\n        \"\"\"\n        Get repository state dict\n\n        :Returns:\n            #. repositoryState (dict): Repository state\n        \"\"\"\n        if self.__path is None:\n            return {}\n        try:\n            fdict = self.__path.get_repository_state_dict()\n        except Exception as e:\n            raise Exception('Error getting repository state dict: %s' % e)\n        return fdict\n\ndef get_repository_state_dict_dict(self):\n        \"\"\"\n        Get repository state dict dict\n\n        :Returns:\n            #. repositoryState (dict): Repository state dict\n        \"\"\"\n        if self.__path is None:\n            return {}\n        try:\n            fdict = self.__path.get_repository_state_dict_dict()\n        except Exception as e:\n            raise Exception('Error",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef save_repository(self, path, verbose=True, ntrials=3):\n        \"\"\"\n        Save repository to a directory path and update the current instance.\n        First, new repository still will be saved. If failed, then old\n        style repository save will be tried.\n\n        :Parameters:\n            #. path (string): The path of the directory to save\n               the repository to. If '.' or an empty string is passed,\n               the current working directory will be used.\n            #. verbose (boolean): Whether to be verbose about abnormalities\n               when saving.\n            #. ntrials (int): After aquiring all locks, ntrials is the maximum\n               number of trials allowed before failing.\n               In rare cases, when multiple processes\n               are accessing the same repository components, different processes\n               can alter repository components between successive lock releases\n               of some other process. Bigger number of trials lowers the\n               likelyhood of failure due to multiple processes same time\n               alteration.\n\n        :Returns:\n             #. repository (pyrep.Repository): returns self repository with saved data.\n        \"\"\"\n        assert isinstance(ntrials, int), \"ntrials must be integer\"\n        ntrials>0, \"ntrials must be >0\"\n        repo = None\n        for _",
        "\n        if os.path.isfile(os.path.join(repo.path,self.__repoClass)):\n            os.remove(os.path.join(repo.path,self.__repoClass))\n        if os.path.isfile(os.path.join(repo.path,self.__repoInfo)):\n            os.remove(os.path.join(repo.path,self.__repoInfo))\n        if os.path.isfile(os.path.join(repo.path,self.__repoLock)):\n            os.remove(os.path.join(repo.path,self.__repoLock))\n        if os.path.isfile(os.path.join(repo.path,self.__repoClass)):\n            os.remove(os.path.join(repo.path,self.__repoClass))\n        if os.path.isfile(os.path.join(repo.path,self.__repoInfo)):\n            os.remove(os.path.join(repo.path,self.__repoInfo))\n        if os.path.isfile(os.path.join(repo.path,self.__repoLock)):\n            os.remove(os.path.join(repo.path,self.__repoLock))\n        if os.path.isfile(os.path.join(repo",
        "\n\ndef is_name_allowed_recursive(self, path):\n        \"\"\"\n        Get whether creating a file or a directory from the basenane of the given\n        path is allowed recursively\n\n        :Parameters:\n            #. path (str): The absolute or relative path or simply the file\n               or directory name.\n\n        :Returns:\n            #. allowed (bool): Whether name is allowed.\n            #. message (None, str): Reason for the name to be forbidden.\n        \"\"\"\n        assert isinstance(path, basestring), \"given path must be a string\"\n        name = os.path.basename(path)\n        if not len(name):\n            return False, \"empty name is not allowed\"\n        # exact match\n        for em in [self.__repoLock,self.__repoFile,self.__dirInfo,self.__dirLock]:\n            if name == em:\n                return False, \"name '%s' is reserved for pyrep internal usage\"%em\n        # pattern match\n        for pm in [self.__fileInfo,self.__fileLock]:#,self.__objectDir]:\n            if name == pm or (name.endswith(pm[3:]) and name.startswith('.')):\n                return False, \"name pattern '%s' is not allowed as result may be reserved for pyrep internal usage\"%pm\n",
        "\n\ndef to_repo_path(self, path):\n        \"\"\"\n        Given a path, return path as a string\n\n        :Parameters:\n            #. path (str): Path as a string\n\n        :Returns:\n            #. path (str): Path as a string\n        \"\"\"\n        path = os.path.normpath(path)\n        if path == '.':\n            path = ''\n        path = path.split(self.__path)[-1].strip(os.sep)\n        return path\n\ndef to_repo_path_with_path(self, path):\n        \"\"\"\n        Given a path, return path as a string\n\n        :Parameters:\n            #. path (str): Path as a string\n\n        :Returns:\n            #. path (str): Path as a string\n        \"\"\"\n        path = os.path.normpath(path)\n        if path == '.':\n            path = ''\n        path = path.split(self.__path)[-1].strip(os.sep)\n        return path\n\ndef to_repo_path_without_path(self, path):\n        \"\"\"\n        Given a path, return path as a string\n\n        :Parameters:\n            #. path (str): Path as a string\n\n        :Returns:\n            #. path (str):",
        "\n\ndef get_repository_info(self, relaPath=None):\n        \"\"\"\n        Get a list representation of repository info along with useful\n        information. List state is ordered relativeley to directories level\n\n        :Parameters:\n            #. relaPath (None, str): relative directory path from where to\n               start. If None all repository information is returned.\n\n        :Returns:\n            #. state (list): List representation of the repository.\n               List items are all dictionaries. Every dictionary has a single\n               key which is the file or the directory name and the value is a\n               dictionary of information including:\n\n                   * 'type': the type of the tracked whether it's file, dir, or objectdir\n                   * 'exists': whether file or directory actually exists on disk\n                   * 'pyrepfileinfo': In case of a file or an objectdir whether .%s_pyrepfileinfo exists\n                   * 'pyrepdirinfo': In case of a directory whether .pyrepdirinfo exists\n        \"\"\"\n        state = []\n        def _walk_dir(relaPath, dirList):\n            dirDict = {'type':'dir',\n                       'exists':os.path.isdir(os.path.join(self.__path,relaPath)),\n                       'pyrepdirinfo':os.path.isfile",
        "\n\ndef get_file_class(self, relativePath):\n        \"\"\"\n        Get file class from the repository given its relative path.\n\n        :Parameters:\n            #. relativePath (string): The relative to the repository path of\n               the file.\n\n        :Returns:\n            #. class (string): The file class.\n               If None, it means an error has occurred.\n        \"\"\"\n        relativePath = self.to_repo_relative_path(path=relativePath, split=False)\n        isRepoFile,fileOnDisk, infoOnDisk, classOnDisk = self.is_repository_file(relativePath)\n        if not isRepoFile:\n            return None, \"file is not a registered repository file.\"\n        if not classOnDisk:\n            return None, \"file is a registered repository file but class file missing\"\n        classPath = os.path.join(self.__path,os.path.dirname(relativePath),self.__class%os.path.basename(relativePath))\n        try:\n            with open(classPath, 'rb') as fd:\n                class = pickle.load(fd)\n        except Exception as err:\n            return None, \"Unable to read file class from disk (%s)\"%str(err)\n        return class, ''\n\ndef get_file_path(self, relativePath):\n        \"\"\"\n",
        "\n\ndef is_repository_file_info(self, relativePath):\n        \"\"\"\n        Check whether a given relative path is a repository file path\n\n        :Parameters:\n            #. relativePath (string): File relative path\n\n        :Returns:\n            #. isRepoFile (boolean): Whether file is a repository file.\n            #. isFileOnDisk (boolean): Whether file is found on disk.\n            #. isFileInfoOnDisk (boolean): Whether file info is found on disk.\n            #. isFileClassOnDisk (boolean): Whether file class is found on disk.\n        \"\"\"\n        relativePath  = self.to_repo_relative_path(path=relativePath, split=False)\n        if relativePath == '':\n            return False, False, False, False\n        relaDir, name = os.path.split(relativePath)\n        fileOnDisk    = os.path.isfile(os.path.join(self.__path, relativePath))\n        infoOnDisk    = os.path.isfile(os.path.join(self.__path, os.path.dirname(relativePath), self.__fileInfo%name))\n        classOnDisk   = os.path.isfile(os.path.join(self.__path, os.path.dirname(relativePath), self.__fileClass%name))\n        cDir          = self.__repo['walk_",
        "\n        return tarfilePath\n\ndef create_package_from_file(self, path=None, name=None, mode=None):\n        \"\"\"\n        Create a tar file package of all the repository files and directories.\n        Only files and directories that are tracked in the repository\n        are stored in the package tar file.\n\n        **N.B. On some systems packaging requires root permissions.**\n\n        :Parameters:\n            #. path (None, string): The real absolute path where to create the\n               package. If None, it will be created in the same directory as\n               the repository. If '.' or an empty string is passed, the current\n               working directory will be used.\n            #. name (None, string): The name to give to the package file\n               If None, the package directory name will be used with the\n               appropriate extension added.\n            #. mode (None, string): The writing mode of the tarfile.\n               If None, automatically the best compression mode will be chose.\n               Available modes are ('w', 'w:', 'w:gz', 'w:bz2')\n        \"\"\"\n        # check mode\n        assert mode in (None, 'w', 'w:', 'w:gz', 'w:bz2'), 'unkown archive mode %s'%str(mode)\n        if mode is None:",
        "\n\n        self._key_locks[key] = self._key_locks[new_key]\n        self._key_locks[new_key] = None\n\n        self._data[key] = self[new_key]\n        del self._data[new_key]\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Renames an item in this collection as a transaction.\n\n        Will override if new key name already exists.\n        :param key: the current name of the item\n        :param value: the new name that the item should have\n        \"\"\"\n        if new_key == key:\n            return\n\n        required_locks = [self._key_locks[key], self._key_locks[new_key]]\n        ordered_required_locks = sorted(required_locks, key=lambda x: id(x))\n        for lock in ordered_required_locks:\n            lock.acquire()\n\n        try:\n            if key not in self._data:\n                raise KeyError(\"Attribute to rename \\\"%s\\\" does not exist\" % key)\n            self._data[new_key] = self[key]\n            del self._data[key]\n        finally:\n            for lock in required_locks:\n                lock.release()\n\n        self._key_locks[",
        "\n\n\ndef get_text_fingerprint_with_encoding(text, hash_meth, encoding=\"utf-8\"):  # pragma: no cover\n    \"\"\"\n    Use default hash method to return hash value of a piece of string\n    default setting use 'utf-8' encoding.\n    \"\"\"\n    m = hash_meth()\n    m.update(text.encode(encoding))\n    return m.hexdigest()\n\n\ndef get_text_fingerprint_with_encoding_and_hash_method(text, hash_meth, encoding=\"utf-8\"):  # pragma: no cover\n    \"\"\"\n    Use default hash method to return hash value of a piece of string\n    default setting use 'utf-8' encoding.\n    \"\"\"\n    m = hash_meth()\n    m.update(text.encode(encoding))\n    return m.hexdigest()\n\n\ndef get_text_fingerprint_with_encoding_and_hash_method_and_encoding(text, hash_meth, encoding=\"utf-8\"):  # pragma: no cover\n    \"\"\"\n    Use default hash method to return hash value of a piece of string\n    default setting use 'utf-8' encoding.\n    \"\"\"\n    m = hash_meth()\n    m.update(text.encode(encoding))\n    return m.hexdigest()\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef auto_complete_choices_with_case_sensitive(self, case_sensitive=False):\n        \"\"\"\n        A command line auto complete similar behavior. Find all item with same\n        prefix of this one.\n\n        :param case_sensitive: toggle if it is case sensitive.\n        :return: list of :class:`pathlib_mate.pathlib2.Path`.\n        \"\"\"\n        self_basename = self.basename\n        self_basename_lower = self.basename.lower()\n        if case_sensitive:  # pragma: no cover\n            def match(basename):\n                return basename.startswith(self_basename)\n        else:\n            def match(basename):\n                return basename.lower().startswith(self_basename_lower)\n\n        choices = list()\n        if self.is_dir():\n            for p in self.sort_by_abspath(self.select(recursive=False)):\n                if match(p.basename):\n                    choices.append(p)\n        else:\n            p_parent = self.parent\n            if p_parent.is_dir():\n                for p in self.sort_by_abspath(p_parent.select(recursive=False)):\n                    if match(p.basename):\n                        choices.append(p)\n            else:  #",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n        # \u521b\u5efa\u4e00\u4e2a\u76ee\u5f55\u7684\u955c\u50cf\u62f7\u8d1d, \u4e0e\u62f7\u8d1d\u64cd\u4f5c\u4e0d\u540c\u7684\u662f, \u6587\u4ef6\u7684\u526f\u672c\u53ea\u662f\u5728\u6587\u4ef6\u540d\u4e0a\n        # \u4e0e\u539f\u4ef6\u4e00\u81f4, \u4f46\u662f\u662f\u7a7a\u6587\u4ef6, \u5b8c\u5168\u6ca1\u6709\u5185\u5bb9, \u6587\u4ef6\u5927\u5c0f\u4e3a0\u3002\n        # \u5982\u679c\u6587\u4ef6\u540d\u5b58\u5728, \u5219\u521b\u5efa\u4e00\u4e2a\u76ee\u5f55\u7684\u955c\u50cf\u62f7\u8d1d, \u4e0e\u62f7\u8d1d\u64cd\u4f5c\u4e0d\u540c\u7684\u662f, \u6587\u4ef6\u7684\u526f\u672c\u53ea\ufffd",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\ndef trail_space_with_comment(self, filters=lambda p: p.ext == \".py\"):  # pragma: no cover\n        \"\"\"\n        Trail white space at end of each line for every ``.py`` file.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u5c06\u76ee\u5f55\u4e0b\u7684\u6240\u6709\u88ab\u9009\u62e9\u7684\u6587\u4ef6\u4e2d\u884c\u672b\u7684\u7a7a\u683c\u5220\u9664\u3002\n        \"\"\"\n        self.assert_is_dir_and_exists()\n\n        for p in self.select_file(filters):\n            try:\n                with open(p.abspath, \"rb\") as f:\n                    lines = list()\n                    for line in f:\n                        lines.append(line.decode(\"utf-8\").rstrip())\n\n                with open(p.abspath, \"wb\") as f:\n                    f.write(\"\\n\".join(lines).encode(\"utf-8\"))\n\n            except Exception as e:  # pragma: no cover\n                raise e\n\n\ndef trail_space_with_comment_and_comment(self, filters=lambda p",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef mtime(self):\n        \"\"\"\n        File last modified time in seconds.\n        \"\"\"\n        try:\n            return self._stat.st_mtime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self.mtime()\n\ndef uid(self):\n        \"\"\"\n        File owner ID in integer.\n        \"\"\"\n        try:\n            return self._stat.st_uid\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self.uid()\n\ndef gid(self):\n        \"\"\"\n        File group ID in integer.\n        \"\"\"\n        try:\n            return self._stat.st_gid\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self.gid()\n\ndef mode(self):\n        \"\"\"\n        File mode in integer.\n        \"\"\"\n        try:\n            return self._stat.st_mode\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self.mode()\n\ndef uid_gid(self):\n        \"\"\"\n        File owner and group ID in integer.\n        \"\"\"\n        try:\n            return self._stat.st_uid, self._stat.st_gid\n        except:",
        "\n\ndef mtime_in_seconds(self):\n        \"\"\"\n        Get most recent modify time in seconds.\n        \"\"\"\n        try:\n            return self._stat.st_mtime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self._stat.st_mtime\n\ndef mtime_in_days(self):\n        \"\"\"\n        Get most recent modify time in days.\n        \"\"\"\n        try:\n            return self._stat.st_mtime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self._stat.st_mtime\n\ndef mtime_in_hours(self):\n        \"\"\"\n        Get most recent modify time in hours.\n        \"\"\"\n        try:\n            return self._stat.st_mtime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self._stat.st_mtime\n\ndef mtime_in_minutes(self):\n        \"\"\"\n        Get most recent modify time in minutes.\n        \"\"\"\n        try:\n            return self._stat.st_mtime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self._stat.st_mtime\n\ndef mtime_in_seconds_in_days(self):",
        "\n\ndef mtime(self):\n        \"\"\"\n        Get most recent modification time in timestamp.\n        \"\"\"\n        try:\n            return self._stat.st_mtime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self.mtime()\n\ndef mtime(self):\n        \"\"\"\n        Get most recent modification time in timestamp.\n        \"\"\"\n        try:\n            return self._stat.st_mtime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self.mtime()\n\ndef mtime_r(self):\n        \"\"\"\n        Get most recent modification time in timestamp.\n        \"\"\"\n        try:\n            return self._stat.st_mtime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self.mtime_r()\n\ndef mtime_r(self):\n        \"\"\"\n        Get most recent modification time in timestamp.\n        \"\"\"\n        try:\n            return self._stat.st_mtime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self.mtime_r()\n\ndef mtime_t(self):\n        \"\"\"\n        Get most recent modification time in timestamp.\n        \"\"\"\n        try:\n            return self._stat",
        "\n\ndef mtime(self):\n        \"\"\"\n        Get most recent modification time in timestamp.\n        \"\"\"\n        try:\n            return self._stat.st_mtime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self._stat.st_mtime\n\ndef atime(self):\n        \"\"\"\n        Get most recent access time in timestamp.\n        \"\"\"\n        try:\n            return self._stat.st_atime\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self._stat.st_atime\n\ndef mtime_r(self):\n        \"\"\"\n        Get most recent modification time in timestamp.\n        \"\"\"\n        try:\n            return self._stat.st_mtime_r\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self._stat.st_mtime_r\n\ndef atime_r(self):\n        \"\"\"\n        Get most recent access time in timestamp.\n        \"\"\"\n        try:\n            return self._stat.st_atime_r\n        except:  # pragma: no cover\n            self._stat = self.stat()\n            return self._stat.st_atime_r\n\ndef size(self):\n        \"\"\"\n        Get",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n            block.addline(line)\n            block.endblock()\n        return self.untagged\n\ndef parse_file(file):\n    \"\"\"Parse text blocks from a file.\"\"\"\n    return parse(file)\n\ndef parse_string(string):\n    \"\"\"Parse text blocks from a string.\"\"\"\n    return parse(string)\n\ndef parse_file_with_decommenter(file, decommenter):\n    \"\"\"Parse text blocks from a file and a decommenter.\"\"\"\n    return parse(file, decommenter)\n\ndef parse_string_with_decommenter(string, decommenter):\n    \"\"\"Parse text blocks from a string and a decommenter.\"\"\"\n    return parse(string, decommenter)\n\ndef parse_file_with_labelled_classes(file, labelled_classes):\n    \"\"\"Parse text blocks from a file and a labelled_classes.\"\"\"\n    return parse(file, labelled_classes)\n\ndef parse_string_with_labelled_classes(string, labelled_classes):\n    \"\"\"Parse text blocks from a string and a labelled_classes.\"\"\"\n    return parse(string, labelled_classes)\n\ndef parse_file_with_labelled_classes_and_decommenter(file, labelled_classes, decommenter):\n    \"\"\"Parse text",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef get_format(self, i):\n        \"\"\"Return the format that preceding format i, or '' for i == 0.\"\"\"\n        return i and self.format[min(i - 1, len(self.format) - 1)] or ''\n\ndef get_format_list(self, i):\n        \"\"\"Return the format list that preceding format i, or [] for i == 0.\"\"\"\n        return i and self.format_list[min(i - 1, len(self.format_list) - 1)] or []\n\ndef get_format_list_by_format(self, i):\n        \"\"\"Return the format list that preceding format i, or [] for i == 0.\"\"\"\n        return i and self.format_list_by_format[min(i - 1, len(self.format_list_by_format) - 1)] or []\n\ndef get_format_list_by_format_list(self, i):\n        \"\"\"Return the format list that preceding format i, or [] for i == 0.\"\"\"\n        return i and self.format_list_by_format_list[min(i - 1, len(self.format_list_by_format_list) - 1)] or []\n\ndef get_format_list_by_format_list_by_format(self, i):\n        \"\"\"Return the",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef release(self, *args, **kwargs):\n        \"\"\" Wraps Lock.release \"\"\"\n        with self._stat_lock:\n            self._waiting -= 1\n\n        self.lock.release(*args, **kwargs)\n\n        with self._stat_lock:\n            self._locked = False\n\ndef wait(self, *args, **kwargs):\n        \"\"\" Wraps Lock.wait \"\"\"\n        with self._stat_lock:\n            self._waiting += 1\n\n        self.lock.wait(*args, **kwargs)\n\n        with self._stat_lock:\n            self._locked = False\n            self._waiting -= 1\n\ndef try_acquire(self, *args, **kwargs):\n        \"\"\" Wraps Lock.try_acquire \"\"\"\n        with self._stat_lock:\n            self._waiting += 1\n\n        self.lock.try_acquire(*args, **kwargs)\n\n        with self._stat_lock:\n            self._locked = False\n            self._waiting -= 1\n\ndef try_release(self, *args, **kwargs):\n        \"\"\" Wraps Lock.try_release \"\"\"\n        with self._stat_lock:\n            self._waiting += 1\n\n        self.lock.try_release(*args, **kwargs)\n\n        with self._stat_lock:\n",
        "\n\ndef acquire(self):\n        \"\"\" Wraps Lock.acquire \"\"\"\n        self._lock.acquire()\n\n        with self._stat_lock:\n            self._locked = True\n            self._last_acquired = datetime.now()\n\ndef acquire_write(self):\n        \"\"\" Wraps Lock.acquire_write \"\"\"\n        self._lock.acquire_write()\n\n        with self._stat_lock:\n            self._locked = True\n            self._last_acquired = datetime.now()\n\ndef acquire_read(self):\n        \"\"\" Wraps Lock.acquire_read \"\"\"\n        self._lock.acquire_read()\n\n        with self._stat_lock:\n            self._locked = True\n            self._last_acquired = datetime.now()\n\ndef acquire_write_read(self):\n        \"\"\" Wraps Lock.acquire_write_read \"\"\"\n        self._lock.acquire_write_read()\n\n        with self._stat_lock:\n            self._locked = True\n            self._last_acquired = datetime.now()\n\ndef acquire_read_write(self):\n        \"\"\" Wraps Lock.acquire_read_write \"\"\"\n        self._lock.acquire_read_write()\n\n        with self._stat_lock:\n            self",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _prompt_for_values_with_default(d):\n    \"\"\"Update the descriptive metadata interactively.\n\n    Uses values entered by the user. Note that the function keeps recursing\n    whenever a value is another ``CommentedMap`` or a ``list``. The\n    function works as passing dictionaries and lists into a function edits\n    the values in place.\n    \"\"\"\n    for key, value in d.items():\n        if isinstance(value, CommentedMap):\n            _prompt_for_values_with_default(value)\n        elif isinstance(value, list):\n            for item in value:\n                _prompt_for_values_with_default(item)\n        else:\n            typ = type(value)\n\n            if isinstance(value, ScalarFloat):  # Deal with ruamel.yaml floats.\n                typ = float\n\n            new_value = click.prompt(key, type=typ, default=value)\n            d[key] = new_value\n    return d\n\ndef _prompt_for_values_with_default_with_default(d):\n    \"\"\"Update the descriptive metadata interactively.\n\n    Uses values entered by the user. Note that the function keeps recursing\n    whenever a value is another ``CommentedMap`` or a ``list``. The\n    function works as",
        "\n        step = step + 1\n\n        click.secho(\n            \"{}. Convert the proto dataset into a dataset: \".format(step)\n        )\n        click.secho(\"   dtool freeze {}\".format(proto_dataset.uri), fg=\"cyan\")\n        step = step + 1\n\n        click.secho(\n            \"{}. Convert the proto dataset into a dataset: \".format(step)\n        )\n        click.secho(\"   dtool freeze {}\".format(proto_dataset.uri), fg=\"cyan\")\n        step = step + 1\n\n        click.secho(\n            \"{}. Convert the proto dataset into a dataset: \".format(step)\n        )\n        click.secho(\"   dtool freeze {}\".format(proto_dataset.uri), fg=\"cyan\")\n        step = step + 1\n\n        click.secho(\n            \"{}. Convert the proto dataset into a dataset: \".format(step)\n        )\n        click.secho(\"   dtool freeze {}\".format(proto_dataset.uri), fg=\"cyan\")\n        step = step + 1\n\n        click.secho(\n            \"{}. Convert the proto dataset into a dataset: \".format(step)\n        )\n        click.secho(\"   dtool freeze {}\".format(proto_dataset.uri), fg=\"cyan",
        "\n\n\ndef _prompt_for_values(descriptive_metadata):\n    \"\"\"Prompt for values in the descriptive metadata.\"\"\"\n    for key, value in descriptive_metadata.items():\n        if isinstance(value, list):\n            value = '\\n'.join(value)\n        elif isinstance(value, dict):\n            value = '\\n'.join(\n                [\n                    _prompt_for_values(v)\n                    for v in value.items()\n                ])\n        else:\n            value = str(value)\n        descriptive_metadata[key] = value\n    return descriptive_metadata\n\n\ndef _get_readme_template():\n    \"\"\"Get the readme template for the dtool readme.\"\"\"\n    readme_template = \"\"\"\n    # This is a template for the dtool readme.\n    #\n    # This is a template for the dtool readme.\n    #\n    # This is a template for the dtool readme.\n    #\n    # This is a template for the dtool readme.\n    #\n    # This is a template for the dtool readme.\n    #\n    # This is a template for the dtool readme.\n    #\n    # This is a template for the dtool readme.\n    #\n    # This is a template for the dtool readme.\n    #\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef main():\n    \"\"\"Show the descriptive metadata in the readme.\"\"\"\n    dataset_uri = click.prompt(\"Dataset URI:\")\n    show(dataset_uri)\n\nif __name__ == \"__main__\":\n    main()\n",
        "\n\ndef _validate_and_put_readme(proto_dataset, readme):\n    \"\"\"Validate and put the readme in the given dataset.\n\n    Args:\n        proto_dataset (dtoolcore.ProtoDataSet): The dataset to validate and put the readme in.\n        readme (str): The readme to validate and put in the dataset.\n    \"\"\"\n    _validate_readme(proto_dataset, readme)\n    proto_dataset.put_readme(readme)\n\n\ndef _validate_readme(proto_dataset, readme):\n    \"\"\"Validate the readme in the given dataset.\n\n    Args:\n        proto_dataset (dtoolcore.ProtoDataSet): The dataset to validate and put the readme in.\n        readme (str): The readme to validate and put in the dataset.\n    \"\"\"\n    if not readme:\n        raise ValueError(\"Readme must be specified.\")\n    if not readme.startswith(\"desc:\"):\n        raise ValueError(\"Readme must start with 'desc:'.\")\n    if not readme.endswith(\":')\"):\n        raise ValueError(\"Readme must end with ':'.\")\n    if not readme.startswith(\"desc:\"):\n        raise ValueError(\"Readme must start with 'desc:'.\")\n    if not readme.endswith(\":')\"):\n        raise ValueError(\"Readme must",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ",\n                key=key,\n                value=value)\n\ndef metadata_from_file(proto_dataset_uri, relpath_in_dataset, key, value):\n    \"\"\"Add metadata to a file in the proto dataset.\"\"\"\n    proto_dataset = dtoolcore.ProtoDataSet.from_uri(\n        uri=proto_dataset_uri,\n        config_path=CONFIG_PATH)\n    proto_dataset.add_item_metadata(\n        handle=relpath_in_dataset,\n        key=key,\n        value=value)\n\ndef metadata_from_dataset(proto_dataset_uri, relpath_in_dataset, key, value):\n    \"\"\"Add metadata to a file in the proto dataset.\"\"\"\n    proto_dataset = dtoolcore.ProtoDataSet.from_uri(\n        uri=proto_dataset_uri,\n        config_path=CONFIG_PATH)\n    proto_dataset.add_item_metadata(\n        handle=relpath_in_dataset,\n        key=key,\n        value=value)\n\ndef metadata_from_dataset_with_key(proto_dataset_uri, relpath_in_dataset, key, value):\n    \"\"\"Add metadata to a file in the proto dataset.\"\"\"\n    proto_dataset = dtoolcore.ProtoDataSet.from_uri(\n        uri=proto_dataset",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ", dataset_uri, dest_base_uri)\n\ndef _copy(resume, quiet, dataset_uri, dest_base_uri):\n    \"\"\"Copy a dataset to a different location.\"\"\"\n    if not dataset_uri:\n        raise ValueError(\"Dataset URI must be specified.\")\n    if not dest_base_uri:\n        raise ValueError(\"Destination base URI must be specified.\")\n    if not dataset_uri.startswith(dest_base_uri):\n        raise ValueError(\"Dataset URI must start with destination base URI.\")\n    if not dataset_uri.endswith(dest_base_uri):\n        raise ValueError(\"Dataset URI must end with destination base URI.\")\n    if not dataset_uri.startswith(dest_base_uri + \"/\"):\n        raise ValueError(\"Dataset URI must start with destination base URI.\")\n    if not dataset_uri.endswith(dest_base_uri + \"/\"):\n        raise ValueError(\"Dataset URI must end with destination base URI.\")\n    if not dataset_uri.startswith(dest_base_uri + \"/\" + dataset_uri):\n        raise ValueError(\"Dataset URI must start with destination base URI.\")\n    if not dataset_uri.endswith(dest_base_uri + \"/\" + dataset_uri):\n        raise ValueError(\"Dataset URI must end with destination base URI.\")\n    if not dataset_",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "\n        return -1\n\ndef find_probable_month_index(self, tokens):\n        \"\"\"\n        attempt to deduce if a pre 100 month was lost\n         due to padded zeros being taken off\n        \"\"\"\n        for index, token in enumerate(self):\n            potential_month_tokens = _ymd.find_potential_month_tokens(\n                token, tokens)\n            if len(potential_month_tokens) == 1 and len(potential_month_tokens[0]) > 2:\n                return index\n        return -1\n\ndef find_probable_day_index(self, tokens):\n        \"\"\"\n        attempt to deduce if a pre 100 day was lost\n         due to padded zeros being taken off\n        \"\"\"\n        for index, token in enumerate(self):\n            potential_day_tokens = _ymd.find_potential_day_tokens(\n                token, tokens)\n            if len(potential_day_tokens) == 1 and len(potential_day_tokens[0]) > 2:\n                return index\n        return -1\n\ndef find_probable_year_index_and_month_index(self, tokens):\n        \"\"\"\n        attempt to deduce if a pre 100 year was lost\n         due to padded zeros being taken off\n        \"\"\"\n        for index, token in enumerate(self",
        "\n\ndef tzname_in_python3(namefunc):\n    \"\"\"Change unicode output into bytestrings in Python 3\n\n    tzname() API changed in Python 2. It used to return bytes, but was changed\n    to unicode strings\n    \"\"\"\n    def adjust_encoding(*args, **kwargs):\n        name = namefunc(*args, **kwargs)\n        if name is not None and not PY2:\n            name = name.decode()\n\n        return name\n\n    return adjust_encoding\n\ndef tzname_in_python2_with_unicode(namefunc):\n    \"\"\"Change unicode output into bytestrings in Python 2\n\n    tzname() API changed in Python 3. It used to return bytes, but was changed\n    to unicode strings\n    \"\"\"\n    def adjust_encoding(*args, **kwargs):\n        name = namefunc(*args, **kwargs)\n        if name is not None and not PY3:\n            name = name.encode()\n\n        return name\n\n    return adjust_encoding\n\ndef tzname_in_python3_with_unicode(namefunc):\n    \"\"\"Change unicode output into bytestrings in Python 3\n\n    tzname() API changed in Python 2. It used to return bytes, but was changed\n    to unicode strings\n    \"\"\"\n    def adjust_encoding(*args, **kwargs",
        "\n\n\ndef _validate_toutc_inputs(f):\n    \"\"\"\n    The CPython version of ``toutc`` checks that the input is a ``datetime``\n    object and that ``self`` is attached as its ``tzinfo``.\n    \"\"\"\n    @wraps(f)\n    def toutc(self, dt):\n        if not isinstance(dt, datetime):\n            raise TypeError(\"toutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        return f(self, dt)\n\n    return toutc\n\n\ndef _validate_tolocal_inputs(f):\n    \"\"\"\n    The CPython version of ``tolocal`` checks that the input is a ``datetime``\n    object and that ``self`` is attached as its ``tzinfo``.\n    \"\"\"\n    @wraps(f)\n    def tolocal(self, dt):\n        if not isinstance(dt, datetime):\n            raise TypeError(\"tolocal() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        return f(self, dt)\n\n    return tolocal\n\n\ndef _validate_toutc_inputs(f):\n    \"\"\"\n    The CPython version",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ".strip()\n\n\ndef strip_comment_line_with_symbol(string, start=None):\n    \"\"\"Strip a line comment with a given symbol.\n\n    :param string: A string containing json with comments started by comment_symbols.\n    :param start: The symbol that starts a line comment (default # or //).\n    :return: The string with the comments removed.\n    \"\"\"\n    lines = string.splitlines()\n    for k in range(len(lines)):\n        if start is not None and start in lines[k]:\n            lines[k] = lines[k][start:]\n    return '\\n'.join(lines)\n\n\ndef strip_comment_line_with_symbol_with_comment(string, start=None, comment=None):\n    \"\"\"Strip a line comment with a given symbol and a comment.\n\n    :param string: A string containing json with comments started by comment_symbols.\n    :param start: The symbol that starts a line comment (default # or //).\n    :param comment: The comment to remove.\n    :return: The string with the comments removed.\n    \"\"\"\n    lines = string.splitlines()\n    for k in range(len(lines)):\n        if start is not None and start in lines[k]:\n            lines[k] = lines[k][",
        "\n\ndef pickweekday(year, month, dayofweek, hour, minute, whichweek):\n    \"\"\" dayofweek == 0 means Sunday, whichweek 5 means last instance \"\"\"\n    first = datetime.datetime(year, month, 1, hour, minute)\n\n    # This will work if dayofweek is ISO weekday (1-7) or Microsoft-style (0-6),\n    # Because 7 % 7 = 0\n    weekdayone = first.replace(day=((dayofweek - first.isoweekday()) % 7) + 1)\n    wd = weekdayone + ((whichweek - 1) * ONEWEEK)\n    if (wd.month != month):\n        wd -= ONEWEEK\n\n    return wd\n\ndef pickweekday_from_date(date):\n    \"\"\" date is a datetime object \"\"\"\n    return pickweekday(date.year, date.month, date.day, date.hour, date.minute, date.weekday())\n\ndef pickweekday_from_time(time):\n    \"\"\" time is a datetime object \"\"\"\n    return pickweekday(time.year, time.month, time.day, time.hour, time.minute, time.weekday())\n\ndef pickweekday_from_datetime(datetime):\n    \"\"\" datetime is a datetime object \"\"\"\n    return pickweekday",
        "\n\ndef tzres():\n    \"\"\"Return the name of the tzres DLL.\"\"\"\n    return 'tzres'\n\ndef tzres_name_from_string(name):\n    \"\"\"Return the name of the tzres DLL, or None if it's not found.\"\"\"\n    try:\n        return winreg.QueryInfoKey(name)[0]\n    except:\n        return None\n\ndef get_registry_value(key, value):\n    \"\"\"Return the registry value for a given registry key.\"\"\"\n    return valuestodict(key)[value]\n\ndef get_registry_value_int(key, value):\n    \"\"\"Return the registry value for a given registry key, or None if it's not found.\"\"\"\n    return get_registry_value(key, value)\n\ndef get_registry_value_float(key, value):\n    \"\"\"Return the registry value for a given registry key, or None if it's not found.\"\"\"\n    return get_registry_value(key, value)\n\ndef get_registry_value_bool(key, value):\n    \"\"\"Return the registry value for a given registry key, or None if it's not found.\"\"\"\n    return get_registry_value(key, value)\n\ndef get_registry_value_string(key, value):\n    \"\"\"Return the registry value for a given registry key",
        "\n\ndef load_name(offset):\n    \"\"\"\n    Load a timezone name from the registry.\n\n    :param offset:\n        The offset of the timezone name in the registry.\n\n    :return:\n        The localized timezone name from tzres.dll if the offset is valid,\n        else returns the input string.\n    \"\"\"\n    try:\n        return self.registry.GetValue('tzres.dll', offset)\n    except:\n        return offset\n\ndef load_names(registry):\n    \"\"\"\n    Load all timezone names from the registry.\n\n    :param registry:\n        The registry to load the names from.\n\n    :return:\n        A list of localized timezone names from tzres.dll.\n    \"\"\"\n    return [name_from_string(registry) for name in self.registry.GetValue('tzres.dll', 0)]\n\ndef load_names_from_file(filename):\n    \"\"\"\n    Load all timezone names from a file.\n\n    :param filename:\n        The file to load the names from.\n\n    :return:\n        A list of localized timezone names from tzres.dll.\n    \"\"\"\n    return [name_from_string(filename) for name in self.registry.GetValue('tzres.dll', 0)]\n\ndef load_names_from_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef gettz_db_metadata_by_name(name):\n    \"\"\" Get the zonefile metadata by name\n\n    See `zonefile_metadata`_\n\n    :param name:\n        The name of the zoneinfo file to get the metadata for\n\n    :returns:\n        A dictionary with the database metadata\n\n    .. deprecated:: 2.6\n        See deprecation warning in :func:`zoneinfo.gettz`. To get metadata,\n        query the attribute ``zoneinfo.ZoneInfoFile.metadata``.\n    \"\"\"\n    warnings.warn(\"zoneinfo.gettz_db_metadata_by_name() will be removed in future \"\n                  \"versions, to use the dateutil-provided zoneinfo files, \"\n                  \"ZoneInfoFile object and query the 'metadata' attribute \"\n                  \"instead. See the documentation for details.\",\n                  DeprecationWarning)\n\n    if len(_CLASS_ZONE_INSTANCE) == 0:\n        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))\n    return _CLASS_ZONE_INSTANCE[0].metadata.get(name, {})\n\ndef gettz_db_metadata_by_name_by_name(name, name_by_name):\n    \"\"\" Get the zonefile metadata by name by name\n\n    See `zonefile_metadata`_",
        "\n\ndef get_config_for_jid(jid):\n    \"\"\"Get the configuration for the given JID based on XMPP_HTTP_UPLOAD_ACCESS.\n\n    If the JID does not match any rule, ``False`` is returned.\n    \"\"\"\n\n    acls = getattr(settings, 'XMPP_HTTP_UPLOAD_ACCESS', (('.*', False), ))\n\n    for regex, config in acls:\n        if isinstance(regex, six.string_types):\n            regex = [regex]\n\n        for subex in regex:\n            if re.search(subex, jid):\n                return config\n\n    return False\n\ndef get_config_for_jid_and_user(jid, user):\n    \"\"\"Get the configuration for the given JID and user based on XMPP_HTTP_UPLOAD_ACCESS.\n\n    If the JID does not match any rule, ``False`` is returned.\n    \"\"\"\n\n    acls = getattr(settings, 'XMPP_HTTP_UPLOAD_ACCESS', (('.*', False), ))\n\n    for regex, config in acls:\n        if isinstance(regex, six.string_types):\n            regex = [regex]\n\n        for subex in regex:\n            if re.search(subex, jid) and re.search(subex, user):\n                return config\n\n",
        "\n\n\ndef tzutc():\n    \"\"\"\n    Returns a :class:`datetime.tzinfo` with support for the ``fold`` attribute.\n    \"\"\"\n    return datetime.tzinfo(timezone='UTC')\n\n\ndef tzlocal():\n    \"\"\"\n    Returns a :class:`datetime.tzinfo` with support for the ``fold`` attribute.\n    \"\"\"\n    return datetime.tzinfo(timezone='Local')\n\n\ndef tzlocal_utc():\n    \"\"\"\n    Returns a :class:`datetime.tzinfo` with support for the ``fold`` attribute.\n    \"\"\"\n    return datetime.tzinfo(timezone='Local UTC')\n\n\ndef tzlocal_local():\n    \"\"\"\n    Returns a :class:`datetime.tzinfo` with support for the ``fold`` attribute.\n    \"\"\"\n    return datetime.tzinfo(timezone='Local Local')\n\n\ndef tzlocal_local_utc():\n    \"\"\"\n    Returns a :class:`datetime.tzinfo` with support for the ``fold`` attribute.\n    \"\"\"\n    return datetime.tzinfo(timezone='Local Local UTC')\n\n\ndef tzlocal_local_local():\n    \"\"\"\n    Returns a :class:`datetime.tzinfo` with support for the ``fold`` attribute.\n    \"\"\"\n    return datetime.tzinfo(timezone='Local Local Local')\n\n\ndef tz",
        "(self, attr))\n\nclass _tzfile(object):\n    \"\"\" A class that encapsulates the time zone data of a _tzfile object \"\"\"\n    def __init__(self, filename):\n        \"\"\" Create a new _tzfile object from a filename \"\"\"\n        self.filename = filename\n        self.attrs = []\n        self.data = None\n\n    def __getitem__(self, attr):\n        \"\"\" Get the attribute value of this object from a _tzfile object \"\"\"\n        if attr in self.attrs:\n            return getattr(self, attr)\n        else:\n            raise KeyError(attr)\n\n    def __setitem__(self, attr, value):\n        \"\"\" Set the attribute value of this object from a _tzfile object \"\"\"\n        if attr in self.attrs:\n            setattr(self, attr, value)\n        else:\n            raise KeyError(attr)\n\n    def __delitem__(self, attr):\n        \"\"\" Delete the attribute value of this object from a _tzfile object \"\"\"\n        if attr in self.attrs:\n            delattr(self, attr)\n        else:\n            raise KeyError(attr)\n\n    def __iter__(self):\n        \"\"\" Return an iterator over all the attributes of this object \"\"\"\n        return iter(self.attrs)\n\n    def __len__(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _hmac(secret: bytes, data: bytes, alg: str) -> bytes:\n    \"\"\"\n    Create a new HMAC hash.\n\n    :param secret: The secret used when hashing data.\n    :type secret: bytes\n    :param data: The data to hash.\n    :type data: bytes\n    :param alg: The algorithm to use when hashing `data`.\n    :type alg: str\n    :return: New HMAC hash.\n    :rtype: bytes\n    \"\"\"\n    algorithm = get_algorithm(alg)\n    return hmac \\\n        .new(secret, msg=data, digestmod=algorithm) \\\n        .digest()\n\ndef get_algorithm(alg: str) -> str:\n    \"\"\"\n    Get the algorithm to use when hashing `data`.\n\n    :param alg: The algorithm to use when hashing `data`.\n    :type alg: str\n    :return: The algorithm to use when hashing `data`.\n    :rtype: str\n    \"\"\"\n    if alg == 'sha1':\n        return 'sha1'\n    elif alg == 'sha256':\n        return 'sha256'\n    elif alg == 'sha384':\n        return 'sha384'\n    elif alg == 'sha512':\n        return 'sha512'\n    else:\n        raise ValueError('Unknown",
        "\n\n\ndef encode(secret: Union[str, bytes], token: Union[str, bytes],\n           alg: str = default_alg) -> Tuple[str, bytes]:\n    \"\"\"\n    Encodes the given token's header and payload and validates the signature.\n\n    :param secret: The secret used to encode the token. Must match the\n        secret used when creating the token.\n    :type secret: Union[str, bytes]\n    :param token: The token to encode.\n    :type token: Union[str, bytes]\n    :param alg: The algorithm used to encode the token. Must match the\n        algorithm used when creating the token.\n    :type alg: str\n    :return: The encoded header and payload.\n    :rtype: Tuple[str, bytes]\n    \"\"\"\n    secret = util.to_bytes(secret)\n    token = util.to_bytes(token)\n    pre_signature, signature_segment = token.rsplit(b'.', 1)\n    header_b64, payload_b64 = pre_signature.split(b'.')\n    signature = util.b64_encode(signature_segment)\n    calculated_signature = _hash(secret, pre_signature, alg)\n\n    if not compare_signature(signature, calculated_signature):\n        raise InvalidSignatureError",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "\n\n    def __str__(self) -> str:\n        \"\"\"\n        Returns a string representation of the token.\n        \"\"\"\n        return self.token\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Returns a string representation of the token.\n        \"\"\"\n        return self.__str__()\n\n    def __eq__(self, other):\n        \"\"\"\n        Returns true if the two tokens are equal.\n        \"\"\"\n        return self.token == other.token\n\n    def __ne__(self, other):\n        \"\"\"\n        Returns true if the two tokens are not equal.\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        \"\"\"\n        Returns true if the two tokens are less than.\n        \"\"\"\n        return self.token < other.token\n\n    def __le__(self, other):\n        \"\"\"\n        Returns true if the two tokens are less than or equal to.\n        \"\"\"\n        return self.token <= other.token\n\n    def __gt__(self, other):\n        \"\"\"\n        Returns true if the two tokens are greater than.\n        \"\"\"\n        return self.token > other.token\n\n    def __ge__(self, other):\n        \"\"\"\n        Returns true if the two tokens are",
        "\n\n    def _pop_claims_from_payload_with_extant_claims(self):\n        \"\"\"\n        Check for registered claims in the payload and move them to the\n        registered_claims property, overwriting any extant claims.\n        \"\"\"\n        claims_in_payload = [k for k in self.payload.keys() if\n                             k in registered_claims.values()]\n        for name in claims_in_payload:\n            self.registered_claims[name] = self.payload.pop(name, None)\n\n    def _pop_claims_from_payload_with_extant_claims_and_payload(self):\n        \"\"\"\n        Check for registered claims in the payload and move them to the\n        registered_claims property, overwriting any extant claims and\n        payload.\n        \"\"\"\n        claims_in_payload = [k for k in self.payload.keys() if\n                             k in registered_claims.values()]\n        for name in claims_in_payload:\n            self.registered_claims[name] = self.payload.pop(name, None)\n            self.payload[name] = self.payload.pop(name, None)\n\n    def _pop_claims_from_payload_with_extant_claims_and_payload_with_extant_claims(self):\n        \"\"\"",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef encode(token: 'Jwt', alg: str = default_alg) -> bytes:\n        \"\"\"\n        Encodes the given token into a byte string.\n\n        :param token: The token to encode.\n        :type token: `Jwt`\n        :param alg: The algorithm used to encode the token. Must match the\n            algorithm used when creating the token.\n        :type alg: str\n        :return: The encoded token.\n        :rtype: bytes\n        \"\"\"\n        return encode(token, alg)\n\n\ndef decode(secret: Union[str, bytes], token: Union[str, bytes],\n           alg: str = default_alg) -> Tuple[str, bytes]:\n        \"\"\"\n        Decodes the given token into a tuple of (header, payload).\n\n        :param secret: The secret used to decode the token. Must match the\n            secret used when creating the token.\n        :type secret: Union[str, bytes]\n        :param token: The token to decode.\n        :type token: Union[str, bytes]\n        :param alg: The algorithm used to decode the token. Must match the\n            algorithm used when creating the token.\n        :type alg: str\n        :return: The decoded token.\n        :rtype: Tuple[str, bytes]\n        \"\"\"\n        return decode",
        "\n\ndef generate(self, algorithm: str = 'HS256', payload: str = 'JWT', header: str = 'JWT',\n              secret: str = 'secret', alg: str = 'HS256', payload_alg: str = 'HS256',\n              header_alg: str = 'HS256', payload_alg: str = 'HS256', header_alg: str = 'HS256',\n              payload_alg: str = 'HS256', header_alg: str = 'HS256',\n              header_alg: str = 'HS256', payload_alg: str = 'HS256', header_alg: str = 'HS256',\n              header_alg: str = 'HS256', payload_alg: str = 'HS256', header_alg: str = 'HS256',\n              header_alg: str = 'HS256', payload_alg: str = 'HS256', header_alg: str = 'HS256',\n              header_alg: str = 'HS256', payload_alg: str = 'HS256', header_alg: str = 'HS256',\n              header_alg: str = 'HS256', payload_alg: str = 'HS256', header_alg: str = 'HS256',\n              header_alg: str = 'HS256', payload_alg: str = 'HS256', header_alg: str = '",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input",
        "\n\n\ndef is_compressed_js_file(abspath):\n    \"\"\"Test a file is a valid js file.\n\n    - *.js: uncompressed, utf-8 encode js file\n    - *.json: uncompressed, utf-8 encode js file\n    \"\"\"\n    abspath = abspath.lower()\n    fname, ext = os.path.splitext(abspath)\n    if ext in [\".js\", \".json\"]:\n        is_compressed = False\n    elif ext == \".json\":\n        is_compressed = True\n    else:\n        raise ValueError(\n            \"'%s' is not a valid js file. \"\n            \"extension has to be '.js' or '.json' for uncompressed, '.json' \"\n            \"for compressed.\" % abspath)\n    return is_compressed\n\n\ndef is_compressed_css_file(abspath):\n    \"\"\"Test a file is a valid css file.\n\n    - *.css: uncompressed, utf-8 encode css file\n    - *.js: uncompressed, utf-8 encode css file\n    \"\"\"\n    abspath = abspath.lower()\n    fname, ext = os.path.splitext(abspath)\n    if ext in [\".css\", \".js\"]:\n        is_compressed = False\n    elif ext == \".css\":\n        is_compressed = True\n",
        "(item) for item in obj]}\n\ndef set_class_name(self, obj):\n        \"\"\"\n        ``set`` dumper.\n        \"\"\"\n        return self._json_convert(obj)\n\ndef set_class_name_with_prefix(self, obj, prefix):\n        \"\"\"\n        ``set`` dumper.\n        \"\"\"\n        return self._json_convert(obj, prefix=prefix)\n\ndef dump_list(self, obj, class_name=list_class_name):\n        \"\"\"\n        ``list`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: [self._json_convert(item) for item in obj]}\n\ndef list_class_name(self, obj):\n        \"\"\"\n        ``list`` dumper.\n        \"\"\"\n        return self._json_convert(obj)\n\ndef list_class_name_with_prefix(self, obj, prefix):\n        \"\"\"\n        ``list`` dumper.\n        \"\"\"\n        return self._json_convert(obj, prefix=prefix)\n\ndef dump_dict(self, obj, class_name=dict_class_name):\n        \"\"\"\n        ``dict`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: {self._json_convert(key): self._json_convert(value) for key, value",
        ".popleft()]\n\ndef dump_list(self, obj, class_name=\"collections.list\"):\n        \"\"\"\n        ``collections.list`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: [self._json_convert(item) for item in obj]}\n\ndef dump_set(self, obj, class_name=\"collections.set\"):\n        \"\"\"\n        ``collections.set`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: [self._json_convert(item) for item in obj]}\n\ndef dump_dict(self, obj, class_name=\"collections.dict\"):\n        \"\"\"\n        ``collections.dict`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: [self._json_convert(item) for item in obj]}\n\ndef dump_tuple(self, obj, class_name=\"collections.tuple\"):\n        \"\"\"\n        ``collections.tuple`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: [self._json_convert(item) for item in obj]}\n\ndef dump_tuple_list(self, obj, class_name=\"collections.tuple_list\"):\n        \"\"\"\n        ``collections.tuple_list`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: [self._json_convert(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\n\ndef rruleset(f):\n    \"\"\"\n    Decorator for rruleset methods which may invalidate the cached length.\n    \"\"\"\n\n    def inner_func(self, *args, **kwargs):\n        rv = f(self, *args, **kwargs)\n        self._invalidate_cache()\n        return rv\n\n    return inner_func\n\n\ndef _invalidates_cache_with_timeout(f):\n    \"\"\"\n    Decorator for rruleset methods which may invalidate the cached length\n    with a timeout.\n    \"\"\"\n\n    def inner_func(self, *args, **kwargs):\n        rv = f(self, *args, **kwargs)\n        self._invalidate_cache_with_timeout()\n        return rv\n\n    return inner_func\n\n\ndef rruleset_with_timeout(f):\n    \"\"\"\n    Decorator for rruleset methods which may invalidate the cached length\n    with a timeout.\n    \"\"\"\n\n    def inner_func(self, *args, **kwargs):\n        rv = f(self, *args, **kwargs)\n        self._invalidate_cache_with_timeout()\n        return rv\n\n    return inner_func\n\n\ndef _invalidates_cache_with_timeout_with_timeout(f):\n    \"\"\"\n   ",
        "\n\ndef after(self, dt, inc=False):\n        \"\"\" Returns the last recurrence after the given datetime instance. The\n            inc keyword defines what happens if dt is an occurrence. With\n            inc=True, if dt itself is an occurrence, it will be returned. \"\"\"\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n        last = None\n        if inc:\n            for i in gen:\n                if i < dt:\n                    break\n                last = i\n        else:\n            for i in gen:\n                if i > dt:\n                    break\n                last = i\n        return last\n\ndef after_or_before(self, dt, inc=False):\n        \"\"\" Returns the last recurrence after or before the given datetime\n            instance. The inc keyword defines what happens if dt is an\n            occurrence. With inc=True, if dt itself is an occurrence, it\n            will be returned. \"\"\"\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n        last = None\n        if inc:\n            for i in gen:\n                if i > dt:\n                    break\n                last = i\n        else:\n            for i in gen:\n                if i >= dt:\n                    break\n                last = i\n",
        "\n\ndef before(self, dt, inc=False):\n        \"\"\" Returns the first recurrence before the given datetime instance. The\n            inc keyword defines what happens if dt is an occurrence. With\n            inc=True, if dt itself is an occurrence, it will be returned.  \"\"\"\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n        if inc:\n            for i in gen:\n                if i < dt:\n                    return i\n        else:\n            for i in gen:\n                if i > dt:\n                    return i\n        return None\n\ndef after_or_before(self, dt, inc=False):\n        \"\"\" Returns the first recurrence after or before the given datetime\n            instance. The inc keyword defines what happens if dt is an\n            occurrence. With inc=True, if dt itself is an occurrence, it\n            will be returned.  \"\"\"\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n        if inc:\n            for i in gen:\n                if i >= dt:\n                    return i\n        else:\n            for i in gen:\n                if i > dt:\n                    return i\n        return None\n\ndef before_or_after(self, dt, inc=False):\n        \"\"\" Returns",
        "\n                if inc:\n                    yield dt\n\n        if inc:\n            yield dt\n\ndef xbefore(self, dt, count=None, inc=False):\n        \"\"\"\n        Generator which yields up to `count` recurrences before the given\n        datetime instance, equivalent to `before`.\n\n        :param dt:\n            The datetime at which to start generating recurrences.\n\n        :param count:\n            The maximum number of recurrences to generate. If `None` (default),\n            dates are generated until the recurrence rule is exhausted.\n\n        :param inc:\n            If `dt` is an instance of the rule and `inc` is `True`, it is\n            included in the output.\n\n        :yields: Yields a sequence of `datetime` objects.\n        \"\"\"\n\n        if self._cache_complete:\n            gen = self._cache\n        else:\n            gen = self\n\n        # Select the comparison function\n        if inc:\n            def comp(dc, dtc): return dc >= dtc\n        else:\n            def comp(dc, dtc): return dc > dtc\n\n        # Generate dates\n        n = 0\n        for d in gen:\n            if comp(d, dt):\n                if count is not None:\n                    n += 1\n                    if n > count:\n                       ",
        "(**new_kwargs)\n\ndef rrule(self, **kwargs):\n        \"\"\"Return a new rrule with same attributes except for those attributes given new values by whichever keyword arguments are specified.\"\"\"\n        new_kwargs = {\"interval\": self._interval,\n                      \"count\": self._count,\n                      \"dtstart\": self._dtstart,\n                      \"freq\": self._freq,\n                      \"until\": self._until,\n                      \"wkst\": self._wkst,\n                      \"cache\": False if self._cache is None else True}\n        new_kwargs.update(self._original_rule)\n        new_kwargs.update(kwargs)\n        return rrule(**new_kwargs)\n\ndef rrule_from_dict(rule_dict):\n    \"\"\"Return a new rrule with same attributes except for those attributes given new values by whichever keyword arguments are specified.\"\"\"\n    new_kwargs = {\"interval\": rule_dict[\"interval\"],\n                  \"count\": rule_dict[\"count\"],\n                  \"dtstart\": rule_dict[\"dtstart\"],\n                  \"freq\": rule_dict[\"freq\"],\n                  \"until\": rule_dict[\"until\"],\n                  \"wkst\": rule_dict[\"wkst\"],\n                  \"cache\": False if rule_dict[\"cache\"] is None else True}\n   ",
        "\n\nif __name__ == '__main__':\n    run_excel_to_html()\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef translate_val(self, language, val):\n        \"\"\"\n        Translates a value to a string in the specified language.\n        Used to translate or convert a value into a string in another language.\n        Currently supports, PHP, Python, Javascript, and JSON. \n\n        Args:\n            language: a string representing the desired output format for the value.\n\n            val: a string representing the desired output format for the value.\n\n        Returns:\n            None but prints a string to the console if retdata is \n            False, otherwise returns a string.\n            \"\"\"\n        language = language.lower()\n        assert self.is_built_in(language) or language in self.outer_templates, \\\n            \"Sorry, \" + language + \" is not a supported language.\"\n\n        # Serialized data converted to a python data structure (list of tuples)\n        data = phpserialize.loads(bytes(val, 'utf-8'), array_hook=list, decode_strings=True)\n\n        # If language conversion is supported by python avoid recursion entirely\n        # and use a built in library\n        if self.is_built_in(language):\n            self.get_built_in(language, level, data) \n            print(self)\n            return self.data_structure if retdata else None\n\n        # The language is",
        "\n\ndef set(config):\n    \"\"\" Only API function for the config module.\n\n    :param config: {dict}     validated configuration.\n    \"\"\"\n    _validate(config)\n    _complete_config(config)\n    _save_config(config)\n\n\ndef _load_config():\n    \"\"\" Loads the configuration from the file.\n\n    :return: {dict}     loaded validated configuration.\n    \"\"\"\n    with open(CONFIG_FILE) as f:\n        return yaml.load(f)\n\n\ndef _create_default_config():\n    \"\"\" Creates the default configuration.\n\n    :return: {dict}     loaded validated configuration.\n    \"\"\"\n    with open(DEFAULT_CONFIG_FILE) as f:\n        return yaml.load(f)\n\n\ndef _validate(config):\n    \"\"\" Validates the configuration.\n\n    :param config: {dict}     validated configuration.\n    \"\"\"\n    for key, value in config.items():\n        if key not in VALID_KEYS:\n            raise ConfigError(_MANDATORY_KEY_ERROR.format(key))\n        if not isinstance(value, dict):\n            raise ConfigError(_INVALID_VALUE_ERROR.format(key))\n\n\ndef _complete_config(config):\n    \"\"\" Completes the configuration.\n\n    :",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_line_count_from_file(fname):\n    \"\"\"Counts the number of lines in a file.\n\n    Args:\n        fname: string, name of the file.\n\n    Returns:\n        integer, the number of lines in the file.\n\n    \"\"\"\n    i = 0\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\n    return i + 1\n\ndef get_line_count_from_file_with_header(fname):\n    \"\"\"Counts the number of lines in a file.\n\n    Args:\n        fname: string, name of the file.\n\n    Returns:\n        integer, the number of lines in the file.\n\n    \"\"\"\n    i = 0\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\n    return i + 1\n\ndef get_line_count_from_file_with_header_and_footer(fname):\n    \"\"\"Counts the number of lines in a file.\n\n    Args:\n        fname: string, name of the file.\n\n    Returns:\n        integer, the number of lines in the file.\n\n    \"\"\"\n    i = 0\n    with open(fname) as f:\n        for i, l in enumerate(f",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef clean_numbers(iterable):\n    \"\"\"\n    Take a list of numbers and clear whitespace \n    on each one. If a value in the list is not a \n    number pass it through untouched.\n\n    Args:\n        iterable: mixed list\n\n    Returns: \n        mixed list\n    \"\"\"\n    retval = []\n    for val in iterable:\n        try:\n            retval.append(float(val.strip()))\n        except(AttributeError):\n            retval.append(val)\n    return retval\n\ndef clean_dates(iterable):\n    \"\"\"\n    Take a list of dates and clear whitespace \n    on each one. If a value in the list is not a \n    date pass it through untouched.\n\n    Args:\n        iterable: mixed list\n\n    Returns: \n        mixed list\n    \"\"\"\n    retval = []\n    for val in iterable:\n        try:\n            retval.append(val.strip())\n        except(AttributeError):\n            retval.append(val)\n    return retval\n\ndef clean_dates_and_numbers(iterable):\n    \"\"\"\n    Take a list of dates and numbers and clear whitespace \n    on each one. If a value in the list is not a \n    date pass it through untouched.\n\n    Args:\n        iterable: mixed list\n\n",
        "\n",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "\n\n    else:\n        return ordered[0]\n\n\ndef median_of_list(data):\n    \"\"\"\n    Calculates the median of a list of integers or floating point numbers.\n\n    Args:\n        data: A list of integers or floating point numbers\n\n    Returns:\n        The median of the list.\n    \"\"\"\n    return median(data)\n\n\ndef median_of_list_of_ints(data):\n    \"\"\"\n    Calculates the median of a list of integers or floating point numbers.\n\n    Args:\n        data: A list of integers or floating point numbers\n\n    Returns:\n        The median of the list.\n    \"\"\"\n    return median(data)\n\n\ndef median_of_list_of_floats(data):\n    \"\"\"\n    Calculates the median of a list of integers or floating point numbers.\n\n    Args:\n        data: A list of integers or floating point numbers\n\n    Returns:\n        The median of the list.\n    \"\"\"\n    return median(data)\n\n\ndef median_of_list_of_ints_and_floats(data):\n    \"\"\"\n    Calculates the median of a list of integers or floating point numbers.\n\n    Args:\n        data: A list of integers or floating point numbers\n\n    Returns:\n        The median of the list",
        "\n\ndef median(numbers, numtype='float'):\n    \"\"\"\n    Calculates the median of a list of numbers\n\n    Args:\n        numbers: a list of integers or floating point numbers.\n\n        numtype: string, 'decimal' or 'float'; the type of number to return.\n\n    Returns:\n        The median (mean) of the numbers as a floating point number\n        or a Decimal object.\n\n    Requires:\n        The math module\n    \"\"\"\n    if type == 'decimal':\n        return Decimal(median(numbers)) / len(numbers)\n    else:\n        return float(median(numbers)) / len(numbers)\n\ndef median_of_list(numbers, numtype='float'):\n    \"\"\"\n    Calculates the median of a list of numbers\n\n    Args:\n        numbers: a list of integers or floating point numbers.\n\n        numtype: string, 'decimal' or 'float'; the type of number to return.\n\n    Returns:\n        The median (mean) of the numbers as a floating point number\n        or a Decimal object.\n\n    Requires:\n        The math module\n    \"\"\"\n    if type == 'decimal':\n        return Decimal(median_of_list(numbers)) / len(numbers)\n    else:\n        return float(median_of_list(numbers))",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "\n",
        "\ndef get_datetime_from_string(datetime_string):\n        '''\n        Get datetime object from datetime string\n\n        :param str datetime_string: datetime string\n        :return: datetime object\n        :rtype: datetime\n        '''\n\n        if datetime_string:\n            dft = DTFormat()\n            return dft.parse(datetime_string)\n\n        return None\n\ndef get_datetime_from_date(date_obj):\n        '''\n        Get datetime object from date object\n\n        :param date date_obj: date object\n        :return: datetime object\n        :rtype: datetime\n        '''\n\n        if isinstance(date_obj, datetime):\n            dft = DTFormat()\n            return date_obj.strftime(dft.date_format)\n\n        return None\n\ndef get_datetime_from_time(time_obj):\n        '''\n        Get datetime object from time object\n\n        :param time time_obj: time object\n        :return: datetime object\n        :rtype: datetime\n        '''\n\n        if isinstance(time_obj, datetime):\n            dft = DTFormat()\n            return time_obj.strftime(dft.time_format)\n\n        return None\n\ndef get_datetime_from_datetime(datetime_obj):\n        '''",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _get_attr_value(obj, attr_name):\n    \"\"\"getattr pipe can extract attribute values of object.\n\n    If attr_name is a list and its item is not a valid attribute of\n    prev's object. It will be excluded from yielded dict.\n\n    :param obj: The previous iterator of pipe.\n    :type obj: Pipe\n    :param attr_name: The list of attribute names\n    :type attr_name: str of list\n    :returns: generator\n    \"\"\"\n    for name in attr_name:\n        if hasattr(obj, name):\n            yield getattr(obj, name)\n\ndef _get_attr_values(obj, attr_names):\n    \"\"\"getattr pipe can extract attribute values of object.\n\n    If attr_names is a list and its item is not a valid attribute of\n    prev's object. It will be excluded from yielded dict.\n\n    :param obj: The previous iterator of pipe.\n    :type obj: Pipe\n    :param attr_names: The list of attribute names\n    :type attr_names: str of list\n    :returns: generator\n    \"\"\"\n    for name in attr_names:\n        if hasattr(obj, name):\n            yield getattr(obj, name)\n\ndef _get_attr_values_list(obj, attr",
        "\n\ndef attrdict_with_default(prev, attr_names, default=None):\n    \"\"\"attrdict pipe can extract attribute values of object into a dict.\n\n    The argument attr_names can be a list or a dict.\n\n    If attr_names is a list and its item is not a valid attribute of\n    prev's object. It will be excluded from yielded dict.\n\n    If attr_names is dict and the key doesn't exist in prev's object.\n    the value of corresponding attr_names key will be copy to yielded dict.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param attr_names: The list or dict of attribute names\n    :type attr_names: str of list or dict\n    :param default: The default value of attribute of prev's object\n    :type default: str\n    :returns: generator\n    \"\"\"\n    if isinstance(attr_names, dict):\n        for obj in prev:\n            attr_values = dict()\n            for name in attr_names.keys():\n                if hasattr(obj, name):\n                    attr_values[name] = getattr(obj, name)\n                else:\n                    attr_values[name] = default\n            yield attr_values\n    else:\n        for obj in prev:\n            attr_values =",
        "\n\n    return prev\n\n\ndef flatten_pipe(prev, depth=sys.maxsize):\n    \"\"\"flatten pipe extracts nested item from previous pipe.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param depth: The deepest nested level to be extracted. 0 means no extraction.\n    :type depth: integer\n    :returns: generator\n    \"\"\"\n    def inner_flatten(iterable, curr_level, max_levels):\n        for i in iterable:\n            if hasattr(i, '__iter__') and curr_level < max_levels:\n                for j in inner_flatten(i, curr_level + 1, max_levels):\n                    yield j\n            else:\n                yield i\n\n    for d in prev:\n        if hasattr(d, '__iter__') and depth > 0:\n            for inner_d in inner_flatten(d, 1, depth):\n                yield inner_d\n        else:\n            yield d\n\n    return flatten(prev, depth)\n\n\ndef flatten_pipe_with_depth(prev, depth=sys.maxsize):\n    \"\"\"flatten pipe extracts nested item from previous pipe.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param depth: The deepest nested level to be extracted",
        "]\n\n\ndef values_with_kwargs(prev, *keys, **kw):\n    \"\"\"values pipe extract value from previous pipe.\n\n    If previous pipe send a dictionary to values pipe, keys should contains\n    the key of dictionary which you want to get. If previous pipe send list or\n    tuple,\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param keys: The keys of dictionary which you want to get.\n    :type keys: list or tuple\n    :param kw: The keyword arguments of dictionary which you want to get.\n    :type kw: dict\n    :returns: generator\n    \"\"\"\n    d = next(prev)\n    if isinstance(d, dict):\n        yield [d[k] for k in keys if k in d]\n        for d in prev:\n            yield [d[k] for k in keys if k in d]\n    else:\n        yield [d[i] for i in keys if 0 <= i < len(d)]\n        for d in prev:\n            yield [d[i] for i in keys if 0 <= i < len(d)]\n\n\ndef values_with_kwargs_with_kwargs(prev, *keys, **kw):\n    \"\"\"values pipe extract value from previous pipe.\n\n    If previous pipe send a dictionary",
        "\n        items = []\n    return items\n",
        "\n\n\ndef grep_all(prev, pattern, *args, **kw):\n    \"\"\"The pipe greps all the data passed from previous generator according to\n    given regular expression.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param pattern: The pattern which used to filter out data.\n    :type pattern: str|unicode|re pattern object\n    :param inv: If true, invert the match condition.\n    :type inv: boolean\n    :param kw:\n    :type kw: dict\n    :returns: generator\n    \"\"\"\n    inv = False if 'inv' not in kw else kw.pop('inv')\n    pattern_obj = re.compile(pattern, *args, **kw)\n\n    for data in prev:\n        if bool(inv) ^ bool(pattern_obj.match(data)):\n            yield data\n\n\ndef grep_any(prev, pattern, *args, **kw):\n    \"\"\"The pipe greps all the data passed from previous generator according to\n    given regular expression.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param pattern: The pattern which used to filter out data.\n    :type pattern: str|unicode|re pattern object\n    :param inv: If true, invert the match",
        "\n",
        "\n\ndef split(prev, pattern, *args, **kw):\n    \"\"\"The split pipe split previous pipe input by regular expression.\n\n    Use 'maxsplit' keyword argument to limit the number of split.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param pattern: The pattern which used to split string.\n    :type pattern: str|unicode\n    \"\"\"\n    maxsplit = 0 if 'maxsplit' not in kw else kw.pop('maxsplit')\n    pattern_obj = re.compile(pattern, *args, **kw)\n    for s in prev:\n        yield pattern_obj.split(s, maxsplit=maxsplit)\n\ndef split_by_regex(prev, pattern, *args, **kw):\n    \"\"\"The split_by_regex pipe split previous pipe input by regular expression.\n\n    Use 'maxsplit' keyword argument to limit the number of split.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param pattern: The pattern which used to split string.\n    :type pattern: str|unicode\n    \"\"\"\n    maxsplit = 0 if 'maxsplit' not in kw else kw.pop('maxsplit')\n    pattern_obj = re.compile(pattern, *args, **kw)\n    for",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n",
        "\n        else:\n            yield i\n\ndef stderr(prev, endl='\\n', thru=False):\n    \"\"\"This pipe read data from previous iterator and write it to stderr.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param endl: The end-of-line symbol for each output.\n    :type endl: str\n    :param thru: If true, data will passed to next generator. If false, data\n                 will be dropped.\n    :type thru: bool\n    :returns: generator\n    \"\"\"\n    for i in prev:\n        sys.stderr.write(str(i) + endl)\n        if thru:\n            yield i\n        else:\n            yield i\n\ndef pipe(prev, endl='\\n', thru=False):\n    \"\"\"This pipe read data from previous iterator and write it to stdout.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param endl: The end-of-line symbol for each output.\n    :type endl: str\n    :param thru: If true, data will passed to next generator. If false, data\n                 will be dropped.\n    :type thru: bool\n    :returns: generator\n    \"\"\"\n   ",
        "\n\n\ndef is_str_type(obj):\n    \"\"\"Check if the object is a string or unicode type.\n\n    :param obj: The object to check.\n    :type obj: object\n    :returns: boolean\n    \"\"\"\n    return isinstance(obj, str) or isinstance(obj, unicode)\n\n\ndef is_list_type(obj):\n    \"\"\"Check if the object is a list or tuple type.\n\n    :param obj: The object to check.\n    :type obj: object\n    :returns: boolean\n    \"\"\"\n    return isinstance(obj, list) or isinstance(obj, tuple)\n\n\ndef is_tuple_type(obj):\n    \"\"\"Check if the object is a tuple type.\n\n    :param obj: The object to check.\n    :type obj: object\n    :returns: boolean\n    \"\"\"\n    return isinstance(obj, tuple)\n\n\ndef is_file_type(obj):\n    \"\"\"Check if the object is a file type.\n\n    :param obj: The object to check.\n    :type obj: object\n    :returns: boolean\n    \"\"\"\n    return isinstance(obj, file)\n\n\ndef is_pipe_type(obj):\n    \"\"\"Check if the object is a pipe type.\n\n    :param obj: The object to check.\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ", *args, **kw)\n\ndef join_with_separator(prev, sep, *args, **kw):\n    '''alias of str.join'''\n    return sep.join(prev, *args, **kw)\n\ndef join_with_separator_and_separator(prev, sep, *args, **kw):\n    '''alias of str.join'''\n    return sep.join(prev, *args, **kw)\n\ndef join_with_separator_and_separator_and_separator(prev, sep, *args, **kw):\n    '''alias of str.join'''\n    return sep.join(prev, *args, **kw)\n\ndef join_with_separator_and_separator_and_separator(prev, sep, *args, **kw):\n    '''alias of str.join'''\n    return sep.join(prev, *args, **kw)\n\ndef join_with_separator_and_separator_and_separator_and_separator(prev, sep, *args, **kw):\n    '''alias of str.join'''\n    return sep.join(prev, *args, **kw)\n\ndef join_with_separator_and_separator_and_separator_and_separator(prev, sep, *args, **kw):\n    '''alias of str.join'''\n    return sep.",
        "\n\ndef substitute_all(prev, *args, **kw):\n    '''alias of string.Template.substitute_all'''\n    template_obj = string.Template(*args, **kw)\n    for data in prev:\n        yield template_obj.substitute_all(data)\n\ndef substitute_all_with_context(prev, *args, **kw):\n    '''alias of string.Template.substitute_all_with_context'''\n    template_obj = string.Template(*args, **kw)\n    for data in prev:\n        yield template_obj.substitute_all_with_context(data)\n\ndef substitute_all_with_context_with_context(prev, *args, **kw):\n    '''alias of string.Template.substitute_all_with_context_with_context'''\n    template_obj = string.Template(*args, **kw)\n    for data in prev:\n        yield template_obj.substitute_all_with_context_with_context(data)\n\ndef substitute_all_with_context_with_context_with_context(prev, *args, **kw):\n    '''alias of string.Template.substitute_all_with_context_with_context_with_context'''\n    template_obj = string.Template(*args, **kw)",
        "\n\ndef safe_substitute_with_context(prev, *args, **kw):\n    '''alias of string.Template.safe_substitute_with_context'''\n    template_obj = string.Template(*args, **kw)\n    for data in prev:\n        yield template_obj.safe_substitute_with_context(data)\n\ndef safe_substitute_with_context_with_context(prev, *args, **kw):\n    '''alias of string.Template.safe_substitute_with_context_with_context'''\n    template_obj = string.Template(*args, **kw)\n    for data in prev:\n        yield template_obj.safe_substitute_with_context_with_context(data)\n\ndef safe_substitute_with_context_with_context_with_context(prev, *args, **kw):\n    '''alias of string.Template.safe_substitute_with_context_with_context_with_context'''\n    template_obj = string.Template(*args, **kw)\n    for data in prev:\n        yield template_obj.safe_substitute_with_context_with_context_with_context(data)\n\ndef safe_substitute_with_context_with_context_with_context(prev, *args, **kw):\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        register_type(set, seq)\n        register_type(list, seq)\n        register_type(tuple, seq)\n        register_type(list, pipe.map)\n        register_type(tuple, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type(list, pipe.map)\n        register_type",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\n\n    # Check if the PID is running\n    try:\n        pid = int(os.getpid())\n        if check_pid(pid, debug):\n            return True\n    except:\n        pass\n\n    # PID is not running, remove the PID file\n    os.unlink(pidfile)\n    return False\n\ndef check_pid(pid, debug):\n    \"\"\"Check that a process is not running more than once, using PID\"\"\"\n    # Check if the PID is running\n    try:\n        pid = int(pid)\n        if pid == os.getpid():\n            return True\n    except:\n        pass\n\n    # PID is not running, remove the PID file\n    os.unlink(pidfile)\n    return False\n\ndef check_pidfile_exists(pidfile, debug):\n    \"\"\"Check that a process is not running more than once, using PIDFILE\"\"\"\n    # Check PID exists and see if the PID is running\n    if os.path.isfile(pidfile):\n        pidfile_handle = open(pidfile, 'r')\n        # try and read the PID file. If no luck, remove it\n        try:\n            pid = int(pidfile_handle.read())\n            pidfile_handle.close()\n            if check_pid(pid, debug):\n               ",
        " False\n\ndef check_pid_file(pid, debug):\n    \"\"\"This function will check whether a PID is currently running\"\"\"\n    try:\n        # A Kill of 0 is to check if the PID is active. It won't kill the process\n        os.kill(pid, 0)\n        if debug > 1:\n            print(\"Script has a PIDFILE where the process is still running\")\n        return True\n    except OSError:\n        if debug > 1:\n            print(\"Script does not appear to be running\")\n        return False\n\ndef check_pid_file_and_file(pid, debug):\n    \"\"\"This function will check whether a PID is currently running\"\"\"\n    try:\n        # A Kill of 0 is to check if the PID is active. It won't kill the process\n        os.kill(pid, 0)\n        if debug > 1:\n            print(\"Script has a PIDFILE where the process is still running\")\n        return True\n    except OSError:\n        if debug > 1:\n            print(\"Script does not appear to be running\")\n        return False\n\ndef check_pid_file_and_file_and_file(pid, debug):\n    \"\"\"This function will check whether a PID is currently running\"\"\"\n    try:\n        # A Kill of 0 is to check if the PID is active. It won't",
        "\n\ndef run_program(prog_list, debug, run_as_root):\n    \"\"\"This function will run a program, and return the exit code\"\"\"\n    # Run the program\n    try:\n        proc = subprocess.Popen(prog_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\n        proc.wait()\n        if debug >= 1:\n            print(\"Program run: \", prog_list)\n        return proc.returncode\n    except OSError as e:\n        if debug >= 1:\n            print(\"Program failed: \", e)\n        return e.errno\n\ndef main():\n    \"\"\"This function will run the Ardexa service\"\"\"\n    # Get the current PID\n    pid = os.getpid()\n    cgroup_file = \"/proc/\" + str(pid) + \"/cgroup\"\n    try:\n        infile = open(cgroup_file, \"r\")\n    except IOError:\n        print(\"Could not open cgroup file: \", cgroup_file)\n        return\n\n    # Read each line\n    for line in infile:\n        # Check if the line contains \"ardexa.service\"\n        if line.find(\"ardexa.service\") == -1:\n            continue\n\n        # if the lines contains \"name=\", replace it with nothing\n       ",
        "\n\ndef run_program_with_debug(prog_list, debug, shell):\n    \"\"\"Run a  program and check program return code Note that some commands don't work\n    well with Popen.  So if this function is specifically called with 'shell=True',\n    then it will run the old 'os.system'. In which case, there is no program output\n    \"\"\"\n    try:\n        if not shell:\n            process = Popen(prog_list, stdout=PIPE, stderr=PIPE)\n            stdout, stderr = process.communicate()\n            retcode = process.returncode\n            if debug >= 1:\n                print(\"Program : \", \" \".join(prog_list))\n                print(\"Return Code: \", retcode)\n                print(\"Stdout: \", stdout)\n                print(\"Stderr: \", stderr)\n            return bool(retcode)\n        else:\n            command = \" \".join(prog_list)\n            os.system(command)\n            return True\n    except:\n        return False\n\ndef run_program_with_shell(prog_list, shell):\n    \"\"\"Run a  program and check program return code Note that some commands don't work\n    well with Popen.  So if this function is specifically called with 'shell=True',\n    then it will run the old 'os.system'. In which case, there is",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\nclass Pipe(object):\n    \"\"\"Base class for all Pipe objects.\n\n    :param name: name of the object\n    :param next: next object in the chain\n    :param next_name: name of the next object in the chain\n    :param next_next: next object in the chain\n    :param next_next_name: name of the next object in the chain\n    :param next_next_next: next object in the chain\n    :param next_next_next_name: name of the next object in the chain\n    :param next_next_next_next: next object in the chain\n    :param next_next_next_next_name: name of the next object in the chain\n    :param next_next_next_next_next: next object in the chain\n    :param next_next_next_next_next: next object in the chain\n    :param next_next_next_next_next: next object in the chain\n    :param next_next_next_next_next: next object in the chain\n    :param next_next_next_next_next: next object in the chain\n    :param next_next_next_next_next: next object in the chain\n    :param next_next_next_next_next: next object in the chain\n    :param next_",
        "\n        return next\n\ndef prepend(self, next):\n        \"\"\"Prepend next object to pipe head.\n\n        :param next: The Pipe object to be prepended to head.\n        :type next: Pipe object.\n        \"\"\"\n        next.chained = True\n        if self.prev:\n            self.prev.prepend(next)\n        else:\n            self.prev = next\n        return next\n\ndef append_tail(self, next):\n        \"\"\"Append next object to pipe tail.\n\n        :param next: The Pipe object to be appended to tail.\n        :type next: Pipe object.\n        \"\"\"\n        next.chained = True\n        if self.next:\n            self.next.append_tail(next)\n        else:\n            self.next = next\n        return next\n\ndef prepend_tail(self, next):\n        \"\"\"Prepend next object to pipe head.\n\n        :param next: The Pipe object to be prepended to head.\n        :type next: Pipe object.\n        \"\"\"\n        next.chained = True\n        if self.prev:\n            self.prev.prepend_tail(next)\n        else:\n            self.prev = next\n        return next\n\ndef append_tail_chained(self, next):\n        \"\"\"Append next object to pipe tail.\n\n",
        "\n\ndef pipe(self, *args, **kwargs):\n        \"\"\"Return a Pipe object.\n\n        :param args: Arguments to pass to the function.\n        :param kwargs: Keyword arguments to pass to the function.\n        :returns: A Pipe object.\n        \"\"\"\n\n        return Pipe(self.func, *args, **kwargs)\n\ndef pipe_with_next(self, *args, **kwargs):\n        \"\"\"Return a Pipe object with a next Pipe object.\n\n        :param args: Arguments to pass to the function.\n        :param kwargs: Keyword arguments to pass to the function.\n        :returns: A Pipe object with a next Pipe object.\n        \"\"\"\n\n        return Pipe(self.func, *args, **kwargs, next=self.next)\n\ndef pipe_with_prev(self, *args, **kwargs):\n        \"\"\"Return a Pipe object with a previous Pipe object.\n\n        :param args: Arguments to pass to the function.\n        :param kwargs: Keyword arguments to pass to the function.\n        :returns: A Pipe object with a previous Pipe object.\n        \"\"\"\n\n        return Pipe(self.func, *args, **kwargs, prev=self.prev)\n\ndef pipe_with_prev_and_next(self, *args, **kwargs):\n        \"\"\"Return a Pipe object",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _list_networks_with_auto_start(auto_start=True):\n    \"\"\"Return a dictionary of network name to active status bools.\n\n        Sample virsh net-list output::\n\n    Name                 State      Autostart\n    -----------------------------------------\n    default              active     yes\n    juju-test            inactive   no\n    foobar               inactive   no\n\n    Parsing the above would return::\n\n    {\"default\": True, \"juju-test\": False, \"foobar\": False}\n\n    See: http://goo.gl/kXwfC\n    \"\"\"\n    output = core.run(\"virsh net-list --all --auto-start\")\n    networks = {}\n\n    # Take the header off and normalize whitespace.\n    net_lines = [n.strip() for n in output.splitlines()[2:]]\n    for line in net_lines:\n        if not line:\n            continue\n        name, state, auto = line.split()\n        networks[name] = state == \"active\"\n    return networks\n\ndef _list_networks_with_auto_start_and_auto_stop(auto_start=True, auto_stop=True):\n    \"\"\"Return a dictionary of network name to active status bools.\n\n        Sample virsh net-list output",
        "\n\ndef print_line(self, line):\n        \"\"\"print the line to stdout\"\"\"\n        self.flush(line)\n        sys.stdout.write(line)\n        sys.stdout.flush()\n\ndef print_error(self, line):\n        \"\"\"print the error to stderr\"\"\"\n        self.flush(line)\n        sys.stderr.write(line)\n        sys.stderr.flush()\n\ndef print_info(self, line):\n        \"\"\"print the info to stderr\"\"\"\n        self.flush(line)\n        sys.stderr.write(line)\n        sys.stderr.flush()\n\ndef print_success(self, line):\n        \"\"\"print the success to stderr\"\"\"\n        self.flush(line)\n        sys.stderr.write(line)\n        sys.stderr.flush()\n\ndef print_warning(self, line):\n        \"\"\"print the warning to stderr\"\"\"\n        self.flush(line)\n        sys.stderr.write(line)\n        sys.stderr.flush()\n\ndef print_error_and_exit(self, line):\n        \"\"\"print the error and exit to stderr\"\"\"\n        self.flush(line)\n        sys.stderr.write(line)\n        sys.stderr.flush()\n        sys.exit(1)\n\ndef print_success_and_",
        "\n                process.stderr.close()\n\n\nclass Command(object):\n    \"\"\"\n    A class that represents a command that can be executed\n    \"\"\"\n    def __init__(self, cmd_prefix, script, args, kwargs):\n        self.cmd_prefix = cmd_prefix\n        self.script = script\n        self.args = args\n        self.kwargs = kwargs\n        self.output = ''\n        self.bufsize = 1024\n        self.encoding = 'utf-8'\n\n    def __str__(self):\n        return self.cmd_prefix + self.script + ' ' + self.args + ' ' + self.kwargs\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __eq__(self, other):\n        return self.cmd_prefix == other.cmd_prefix and self.script == other.script and self.args == other.args and self.kwargs == other.kwargs\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        return self.cmd_prefix < other.cmd_prefix\n\n    def __le__(self, other):\n        return not self.__lt__(other)\n\n    def __gt__(self, other):",
        "\n\ndef get_response_subfields(root):\n    \"\"\"Build a basic 035 subfield with basic information from the OAI-PMH response.\n\n    :param root: ElementTree root node\n\n    :return: list of subfield tuples [(..),(..)]\n    \"\"\"\n    responsedate = root.find('responseDate')\n\n    subs = [(\"9\", responsedate.text),\n            (\"h\", responsedate.attrib[\"metadataPrefix\"])]\n    return subs\n\ndef get_metadata_subfields(root):\n    \"\"\"Build a basic 035 subfield with basic information from the OAI-PMH metadata.\n\n    :param root: ElementTree root node\n\n    :return: list of subfield tuples [(..),(..)]\n    \"\"\"\n    metadata = root.find('metadata')\n\n    subs = [(\"9\", metadata.text),\n            (\"h\", metadata.attrib[\"metadataPrefix\"])]\n    return subs\n\ndef get_metadata_subfields_with_metadata_prefix(root):\n    \"\"\"Build a basic 035 subfield with basic information from the OAI-PMH metadata.\n\n    :param root: ElementTree root node\n\n    :return: list of subfield tuples [(..),(..)]\n    \"\"\"\n    metadata = root.find('metadata')\n\n    subs = [(\"9",
        "\n    return root\n",
        "\n\ndef save_dict(self, target, namespace=''):\n        \"\"\" Save values to a dictionary structure. Nesting can be used to\n            represent namespaces.\n\n            >>> c = ConfigDict()\n            >>> c.save_dict({'some': {'namespace': {'key': 'value'} } })\n            {'some.namespace.key': 'value'}\n        \"\"\"\n        for key, value in target.items():\n            if isinstance(key, str):\n                nskey = (namespace + '.' + key).strip('.')\n                if isinstance(value, dict):\n                    self.save_dict(value, namespace=nskey)\n                else:\n                    self[nskey] = value\n            else:\n                raise TypeError('Key has type %r (not a string)' % type(key))\n        return self\n\ndef load_file(self, filename, namespace=''):\n        \"\"\" Load values from a file. Nesting can be used to represent\n            namespaces.\n\n            >>> c = ConfigDict()\n            >>> c.load_file('some.config')\n            {'some.namespace.key': 'value'}\n        \"\"\"\n        with open(filename, 'r') as f:\n            return load_dict(self, f.read())\n\ndef save_file(self, filename, namespace='",
        "\n\ndef oembed(request, *args, **kwargs):\n    \"\"\"\n    The oembed endpoint, or the url to which requests for metadata are passed.\n    Third parties will want to access this view with URLs for your site's\n    content and be returned OEmbed metadata.\n    \"\"\"\n    # coerce to dictionary\n    params = dict(request.GET.items())\n    \n    callback = params.pop('callback', None)\n    url = params.pop('url', None)\n    \n    if not url:\n        return HttpResponseBadRequest('Required parameter missing: URL')\n    \n    try:\n        provider = oembed.site.provider_for_url(url)\n        if not provider.provides:\n            raise OEmbedMissingEndpoint()\n    except OEmbedMissingEndpoint:\n        raise Http404('No provider found for %s' % url)\n    \n    query = dict([(smart_str(k), smart_str(v)) for k, v in params.items() if v])\n    \n    try:\n        resource = oembed.site.embed(url, **query)\n    except OEmbedException, e:\n        raise Http404('Error embedding %s: %s' % (url, str(e)))\n\n    response = HttpResponse(mimetype='application/json')\n    json = resource.",
        "\ndef consume_xml(request):\n    \"\"\"\n    Extract and return oembed content for given urls.\n\n    Required GET params:\n        urls - list of urls to consume\n\n    Optional GET params:\n        width - maxwidth attribute for oembed content\n        height - maxheight attribute for oembed content\n        template_dir - template_dir to use when rendering oembed\n\n    Returns:\n        list of dictionaries with oembed metadata and renderings, xml encoded\n    \"\"\"\n    client = OEmbedConsumer()\n    \n    urls = request.GET.getlist('urls')\n    width = request.GET.get('width')\n    height = request.GET.get('height')\n    template_dir = request.GET.get('template_dir')\n\n    output = {}\n    ctx = RequestContext(request)\n\n    for url in urls:\n        try:\n            provider = oembed.site.provider_for_url(url)\n        except OEmbedMissingEndpoint:\n            oembeds = None\n            rendered = None\n        else:\n            oembeds = url\n            rendered = client.parse_xml(url, width, height, context=ctx, template_dir=template_dir)\n\n        output[url] = {\n            'oembeds': oembeds,\n            'rendered': rendered,\n",
        "\n\ndef oembed_json(request):\n    \"\"\"\n    A JSON representation of the current site's oembeds.\n    \"\"\"\n    response = HttpResponse(mimetype='application/json')\n    response.write(simplejson.dumps(oembed.site.get_oembeds()))\n    return response\n",
        "\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n",
        "\n\ndef make_request_data_from_json(self, json_data):\n        \"\"\" Make the request params given location data \"\"\"\n        data = {'key': self.api_key,\n                'postalcode': json_data['postalcode'],\n                'city': json_data['city'],\n                'state': json_data['state']\n        }\n        data = ZipTaxClient._clean_request_data(data)\n        return data\n\ndef make_request_data_from_file(self, file_path):\n        \"\"\" Make the request params given location data \"\"\"\n        data = {'key': self.api_key,\n                'postalcode': file_path,\n                'city': 'New York',\n                'state': 'NY'\n        }\n        data = ZipTaxClient._clean_request_data(data)\n        return data\n\ndef make_request_data_from_file_with_json(self, file_path, json_data):\n        \"\"\" Make the request params given location data \"\"\"\n        data = {'key': self.api_key,\n                'postalcode': file_path,\n                'city': 'New York',\n                'state': 'NY'\n        }\n        data = ZipTaxClient._clean_request_data(data)",
        "\n\n",
        "\n\n\nclass ZipTax(object):\n    \"\"\"\n    A class that provides a way to get taxes from a zip code\n    \"\"\"\n    def __init__(self, zip_code, multiple_rates=False):\n        \"\"\"\n        Create a new instance of the class\n        \"\"\"\n        self.zip_code = zip_code\n        self.multiple_rates = multiple_rates\n\n    def get_taxes(self, multiple_rates=False):\n        \"\"\"\n        Get the taxes for a zip code\n        \"\"\"\n        return self._get_taxes(multiple_rates)\n\n    def _get_taxes(self, multiple_rates=False):\n        \"\"\"\n        Get the taxes for a zip code\n        \"\"\"\n        url = 'http://api.zipcode.com/v1/taxes/get?zipCode=%s' % self.zip_code\n        if multiple_rates:\n            url += '&multipleRates=true'\n        resp = self.get_json(url)\n        _check_for_exceptions(resp, multiple_rates)\n        return resp['results']\n\n    def get_tax_by_id(self, tax_id):\n        \"\"\"\n        Get a tax by id\n        \"\"\"\n        url = 'http://api.zipcode.com/v1",
        "\n\ndef get_all_attributes(node):\n    \"\"\"Recursively extract all attributes from node.\"\"\"\n    if node.nodeType == node.ELEMENT_NODE:\n        return node.attributes\n    else:\n        attributes = {}\n        for child_node in node.childNodes:\n            attributes[child_node.nodeName] = get_all_attributes(child_node)\n        return attributes\n\ndef get_all_children(node):\n    \"\"\"Recursively extract all children from node.\"\"\"\n    if node.nodeType == node.ELEMENT_NODE:\n        return node.childNodes\n    else:\n        children = []\n        for child_node in node.childNodes:\n            children.append(get_all_children(child_node))\n        return children\n\ndef get_all_children_with_text(node):\n    \"\"\"Recursively extract all children with text from node.\"\"\"\n    if node.nodeType == node.ELEMENT_NODE:\n        return node.childNodes\n    else:\n        children = []\n        for child_node in node.childNodes:\n            children.append(get_all_children_with_text(child_node))\n        return children\n\ndef get_all_children_with_attributes(node):\n    \"\"\"Recursively extract all children with attributes from node.\"\"\"\n    if node.nodeType ==",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_regexes(self):\n        \"\"\"\n        Return a dictionary of regexes for all registered providers\n        \"\"\"\n        return self._registry\n\ndef get_regexes_for_provider(self, provider_class):\n        \"\"\"\n        Return a dictionary of regexes for a given provider class\n        \"\"\"\n        return self._registry[provider_class()]\n\ndef get_regexes_for_provider_class(self, provider_class):\n        \"\"\"\n        Return a dictionary of regexes for a given provider class\n        \"\"\"\n        return self._registry[provider_class()]\n\ndef get_regexes_for_provider_class_and_name(self, provider_class, name):\n        \"\"\"\n        Return a dictionary of regexes for a given provider class and name\n        \"\"\"\n        return self._registry[provider_class()][name]\n\ndef get_regexes_for_provider_class_and_name_and_regex(self, provider_class, name, regex):\n        \"\"\"\n        Return a dictionary of regexes for a given provider class and name and regex\n        \"\"\"\n        return self._registry[provider_class()][name][regex]\n\ndef get_regexes_for_provider_class_and_name_and_regex_and_regex(self, provider_class, name",
        ".format(url=url))\n\ndef get_registry():\n        \"\"\"\n        Return a dictionary of providers to regexps\n        \"\"\"\n        return {\n            'twitter': r'https?://twitter.com/(?P<username>[^/]+)',\n            'facebook': r'https?://www.facebook.com/(?P<username>[^/]+)',\n            'google': r'https?://www.google.com/search?q=(?P<q>[^/]+)',\n            'linkedin': r'https?://www.linkedin.com/search?q=(?P<q>[^/]+)',\n            'yahoo': r'https?://www.yahoo.com/search?q=(?P<q>[^/]+)',\n            'yahoo.com': r'https?://www.yahoo.com/search?q=(?P<q>[^/]+)',\n            'yahoo.com.cn': r'https?://www.yahoo.com/search?q=(?P<q>[^/]+)',\n            'yahoo.com.cn.cn': r'https?://www.yahoo.com/search?q=(?P<q>[^/]+)',\n            'yahoo.com.cn.cn.",
        "\n\ndef get_stored_oembeds(self, sender, instance, created, **kwargs):\n        \"\"\"\n        A hook for django-based oembed providers to get a list of stored oembeds\n        \"\"\"\n        ctype = ContentType.objects.get_for_model(instance)\n        return StoredOEmbed.objects.filter(\n            object_id=instance.pk,\n            content_type=ctype).order_by('-created')\n\ndef get_stored_oembeds_for_object(self, sender, instance, created, **kwargs):\n        \"\"\"\n        A hook for django-based oembed providers to get a list of stored oembeds\n        \"\"\"\n        ctype = ContentType.objects.get_for_model(instance)\n        return StoredOEmbed.objects.filter(\n            object_id=instance.pk,\n            content_type=ctype).order_by('-created')\n\ndef get_stored_oembeds_for_object_id(self, sender, instance, created, **kwargs):\n        \"\"\"\n        A hook for django-based oembed providers to get a list of stored oembeds\n        \"\"\"\n        ctype = ContentType.objects.get_for_model(instance)\n        return StoredOEmbed.objects.filter(\n            object_id=instance.pk,\n            content_",
        "\n            except IndexError:\n                # query the endpoint and cache response in db\n                params = dict([(k, v) for k, v in kwargs.items() if v])\n                \n                # request an oembed resource for the url\n                resource = provider.request_resource(url, **params)\n                \n                # save the resource\n                resource.save()\n                return resource\n        else:\n            raise OEmbedMissingEndpoint\n\ndef provider_for_url(self, url):\n    \"\"\"\n    Look up the provider for the given url\n    \"\"\"\n    try:\n        provider = self.providers[url]\n    except KeyError:\n        raise OEmbedMissingEndpoint\n    else:\n        return provider\n\ndef get_provider_for_url(self, url):\n    \"\"\"\n    Look up the provider for the given url\n    \"\"\"\n    try:\n        provider = self.providers[url]\n    except KeyError:\n        raise OEmbedMissingEndpoint\n    else:\n        return provider\n\ndef get_provider_for_url_or_none(self, url):\n    \"\"\"\n    Look up the provider for the given url\n    \"\"\"\n    try:\n        provider = self.providers[url]\n    except KeyError:\n        return None\n    else:\n        return provider\n\ndef get_provider_for_",
        ".get('provider_data', {})\n        else:\n            return self.store_providers(self.get_providers())\n\n    def store_providers(self, provider_data):\n        \"\"\"\n        Store a list of StoredProviders in the database\n        \"\"\"\n        self.db.session.add_all(provider_data)\n        self.db.session.commit()\n        return provider_data\n\n    def get_providers(self):\n        \"\"\"\n        Return a list of StoredProviders\n        \"\"\"\n        return self.db.session.query(StoredProvider).all()\n\n    def get_provider(self, provider_id):\n        \"\"\"\n        Return a StoredProvider by id\n        \"\"\"\n        return self.db.session.query(StoredProvider).filter_by(id=provider_id).first()\n\n    def delete_provider(self, provider_id):\n        \"\"\"\n        Delete a StoredProvider by id\n        \"\"\"\n        self.db.session.delete(self.get_provider(provider_id))\n        self.db.session.commit()\n\n    def delete_provider_by_id(self, provider_id):\n        \"\"\"\n        Delete a StoredProvider by id\n        \"\"\"\n        self.db.session.delete(self.get_provider(provider_id))\n        self.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        return mapping\n\ndef map_attr_list(self, mapping, attr, obj):\n        \"\"\"\n        A kind of cheesy method that allows for callables or attributes to\n        be used interchangably\n        \"\"\"\n        if attr not in mapping and hasattr(self, attr):\n            if not callable(getattr(self, attr)):\n                mapping[attr] = getattr(self, attr)\n            else:\n                mapping[attr] = getattr(self, attr)(obj)\n        return mapping\n\ndef map_attr_dict(self, mapping, attr, obj):\n        \"\"\"\n        A kind of cheesy method that allows for callables or attributes to\n        be used interchangably\n        \"\"\"\n        if attr not in mapping and hasattr(self, attr):\n            if not callable(getattr(self, attr)):\n                mapping[attr] = getattr(self, attr)\n            else:\n                mapping[attr] = getattr(self, attr)(obj)\n        return mapping\n\ndef map_attr_list_dict(self, mapping, attr, obj):\n        \"\"\"\n        A kind of cheesy method that allows for callables or attributes to\n        be used interchangably\n        \"\"\"\n        if attr not in mapping and hasattr(self, attr):\n            if not callable(getattr(self",
        ".image\n        else:\n            return getattr(obj, self.image_field)\n\n    def get_image_url(self, obj):\n        \"\"\"\n        Return an ImageFileField instance\n        \"\"\"\n        if self.image_field:\n            return getattr(obj, self.image_field).url\n        else:\n            return getattr(obj, self.url_field)\n\n    def get_image_width(self, obj):\n        \"\"\"\n        Return an ImageFileField instance\n        \"\"\"\n        if self.image_field:\n            return getattr(obj, self.image_field).width\n        else:\n            return getattr(obj, self.width_field)\n\n    def get_image_height(self, obj):\n        \"\"\"\n        Return an ImageFileField instance\n        \"\"\"\n        if self.image_field:\n            return getattr(obj, self.image_field).height\n        else:\n            return getattr(obj, self.height_field)\n\n    def get_image_alt(self, obj):\n        \"\"\"\n        Return an ImageFileField instance\n        \"\"\"\n        if self.image_field:\n            return getattr(obj, self.image_field).alt\n        else:\n            return getattr(obj, self.alt_field)\n\n    def get_image_",
        "\n\ndef map_to_url(self, url, obj, **kwargs):\n        \"\"\"\n        Build a URL for the requested object.\n        \"\"\"\n        provider_url, provider_name = self.provider_from_url(url)\n        \n        mapping = {\n            'version': '1.0',\n            'url': url,\n            'provider_name': provider_name,\n            'provider_url': provider_url\n        }\n        \n        # a hook\n        self.preprocess(obj, mapping, **kwargs)\n        \n        # resize image if we have a photo, otherwise use the given maximums\n        if self.resource_type == 'photo' and self.get_image(obj):\n            self.resize_photo(obj, mapping, kwargs.get('maxwidth', None), kwargs.get('maxheight', None))\n        elif self.resource_type in ('video', 'rich', 'photo'):\n            width, height = size_to_nearest(\n                kwargs.get('maxwidth', None),\n                kwargs.get('maxheight', None),\n                self._meta.valid_sizes,\n                self._meta.force_fit\n            )\n            mapping.update(width=width, height=height)\n        \n        # a hook\n        self.postprocess(obj, mapping,",
        "\n\ndef get_params(self, url):\n        \"\"\"\n        Parses the url and returns the parameters.\n        \"\"\"\n        params = {}\n        for param in url.split('?'):\n            key, value = param.split('=', 1)\n            params[key] = value\n        return params\n\nclass OEmbedException(Exception):\n    \"\"\"\n    Raised when an error occurs while parsing an OEmbed URL.\n    \"\"\"\n    pass\n",
        "\n\n\ndef get_record_id(self):\n        \"\"\"Override the base.\"\"\"\n        return self.get_recid()\n\n\ndef get_record_type(self):\n        \"\"\"Override the base.\"\"\"\n        return \"INSPIRE\"\n\n\ndef get_record_title(self):\n        \"\"\"Override the base.\"\"\"\n        return \"Inspire\"\n\n\ndef get_record_author(self):\n        \"\"\"Override the base.\"\"\"\n        return \"Inspire\"\n\n\ndef get_record_publisher(self):\n        \"\"\"Override the base.\"\"\"\n        return \"Inspire\"\n\n\ndef get_record_publisher_name(self):\n        \"\"\"Override the base.\"\"\"\n        return \"Inspire\"\n\n\ndef get_record_publisher_url(self):\n        \"\"\"Override the base.\"\"\"\n        return \"http://www.inspire.fr\"\n\n\ndef get_record_publisher_email(self):\n        \"\"\"Override the base.\"\"\"\n        return \"inspire@inspire.fr\"\n\n\ndef get_record_publisher_phone(self):\n        \"\"\"Override the base.\"\"\"\n        return \"909-541-961\"\n\n\ndef get_record_publisher_website(self):\n        \"\"\"Override the base.\"\"\"\n        return \"http://www.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef update_cnum_subfields(self):\n        \"\"\"Check if we shall add cnum in 035.\"\"\"\n        if \"ConferencePaper\" not in self.collections:\n            cnums = record_get_field_values(self.record, '773', code=\"w\")\n            for cnum in cnums:\n                cnum_subs = [\n                    (\"9\", \"INSPIRE-CNUM\"),\n                    (\"a\", cnum)\n                ]\n                record_add_field(self.record, \"035\", subfields=cnum_subs)\n\ndef update_cnum_subfields_with_cnum(self):\n        \"\"\"Check if we shall add cnum in 035.\"\"\"\n        if \"ConferencePaper\" not in self.collections:\n            cnums = record_get_field_values(self.record, '773', code=\"w\")\n            for cnum in cnums:\n                cnum_subs = [\n                    (\"9\", \"INSPIRE-CNUM\"),\n                    (\"a\", cnum)\n                ]\n                record_add_field(self.record, \"035\", subfields=cnum_subs, cnum=cnum)\n\ndef update_cnum_subfields_with_cnum_and_cnum_subfields(self):",
        "\n\ndef update_hidden_notes_for_record(self, record):\n        \"\"\"Remove hidden notes and tag a CERN if detected.\"\"\"\n        if not self.tag_as_cern:\n            notes = record_get_field_instances(record,\n                                               tag=\"595\")\n            for field in notes:\n                for dummy, value in field[0]:\n                    if value == \"CDS\":\n                        self.tag_as_cern = True\n        record_delete_fields(record, tag=\"595\")\n\ndef update_hidden_notes_for_record_with_id(self, record_id):\n        \"\"\"Remove hidden notes and tag a CERN if detected.\"\"\"\n        if not self.tag_as_cern:\n            notes = record_get_field_instances(record_id,\n                                               tag=\"595\")\n            for field in notes:\n                for dummy, value in field[0]:\n                    if value == \"CDS\":\n                        self.tag_as_cern = True\n        record_delete_fields(record_id, tag=\"595\")\n\ndef update_hidden_notes_for_record_with_name(self, record_name):\n        \"\"\"Remove hidden notes and tag a CERN if detected.\"\"\"\n        if not self.tag_as_cern:\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        report_038_fields = record_get_field_instances(self.record, '038')\n        for field in report_038_fields:\n            subs = field_get_subfields(field)\n            for val in subs.get(\"a\", []):\n                if \"arXiv\" not in val:\n                    record_delete_field(self.record,\n                                        tag=\"038\",\n                                        field_position_global=field[4])\n                    new_subs = [(code, val[0]) for code, val in subs.items()]\n                    record_add_field(self.record, \"088\", subfields=new_subs)\n                    break\n        report_039_fields = record_get_field_instances(self.record, '039')\n        for field in report_039_fields:\n            subs = field_get_subfields(field)\n            for val in subs.get(\"a\", []):\n                if \"arXiv\" not in val:\n                    record_delete_field(self.record,\n                                        tag=\"039\",\n                                        field_position_global=field[4])\n                    new_subs = [(code, val[0]) for code, val in subs.items()]\n                    record_add_field(self",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        for key, value in all_dois.items():\n            record_delete_field(self.record, tag='024', ind1='7', field_position_global=value[4])\n\ndef update_dois_with_bib_id(self, bib_id):\n        \"\"\"Remove duplicate BibMatch DOIs with a specific BibID.\"\"\"\n        dois = record_get_field_instances(self.record, '024', ind1=\"7\")\n        all_dois = {}\n        for field in dois:\n            subs = field_get_subfield_instances(field)\n            subs_dict = dict(subs)\n            if subs_dict.get('a'):\n                if subs_dict['a'] in all_dois:\n                    record_delete_field(self.record, tag='024', ind1='7', field_position_global=field[4], bib_id=bib_id)\n                    continue\n                all_dois[subs_dict['a']] = field\n\ndef update_dois_with_bib_id_and_title(self, bib_id, title):\n        \"\"\"Remove duplicate BibMatch DOIs with a specific BibID and title.\"\"\"\n        dois = record_get_field_instances(self.",
        "\n\ndef update_date_month(self):\n        \"\"\"260 Date normalization.\"\"\"\n        dates = record_get_field_instances(self.record, '260')\n        for field in dates:\n            for idx, (key, value) in enumerate(field[0]):\n                if key == 'c':\n                    field[0][idx] = ('c', value[:2])\n                elif key == 't':\n                    del field[0][idx]\n        if not dates:\n            published_months = record_get_field_values(self.record, \"773\", code=\"y\")\n            if published_months:\n                record_add_field(\n                    self.record, \"260\", subfields=[(\"c\", published_months[0][:2])])\n            else:\n                other_months = record_get_field_values(self.record, \"269\", code=\"c\")\n                if other_months:\n                    record_add_field(\n                        self.record, \"260\", subfields=[(\"c\", other_months[0][:2])])\n\ndef update_date_day(self):\n        \"\"\"260 Date normalization.\"\"\"\n        dates = record_get_field_instances(self.record, '260')\n        for field in dates:\n            for idx",
        "\n        \"\"\"042 Language.\"\"\"\n        language_fields = record_get_field_instances(self.record, '042')\n        language = \"eng\"\n        record_delete_fields(self.record, \"042\")\n        for field in language_fields:\n            subs = field_get_subfields(field)\n            if 'a' in subs:\n                language = self.get_config_item(subs['a'][0], \"languages\")\n                break\n        new_subs = [('a', language)]\n        record_add_field(self.record, \"042\", subfields=new_subs)\n\ndef update_languages_with_subfields(self):\n        \"\"\"041 Language with subfields.\"\"\"\n        language_fields = record_get_field_instances(self.record, '041')\n        language = \"eng\"\n        record_delete_fields(self.record, \"041\")\n        for field in language_fields:\n            subs = field_get_subfields(field)\n            if 'a' in subs:\n                language = self.get_config_item(subs['a'][0], \"languages\")\n                break\n        new_subs = [('a', language)]\n        record_add_field(self.record, \"041\", subfields=",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef collapse_initials(lastname):\n    \"\"\" Removes initials from lastname. \"\"\"\n    lastnames = lastname.split()\n    if len(lastname) == 1:\n        if '-' in lastname:\n            names = lastname.split('-')\n            names = map(lambda a: a[0] + a[1:].lower(), names)\n            lastname = '-'.join(names)\n        else:\n            lastname = lastname[0] + lastname[1:].lower()\n    else:\n        names = []\n        for name in lastnames:\n            if re.search(r'[A-Z]\\.', name):\n                names.append(name)\n            else:\n                names.append(name[0] + name[1:].lower())\n        lastname = ' '.join(names)\n    return lastname\n\ndef get_name_from_name(name):\n    \"\"\" Returns the name from the given name. \"\"\"\n    name = name.lower()\n    if name.startswith(' '):\n        name = name[1:]\n    return name\n\ndef get_name_from_name_with_suffix(name, suffix):\n    \"\"\" Returns the name from the given name with the given suffix. \"\"\"\n    name = name.lower()\n    if",
        "\n\ndef text_parser():\n        \"\"\"\n        Parses text into a list of urls\n        \"\"\"\n        parser = text_parser_factory()\n        return parser.extract_urls(text)\n\ndef text_parser_factory():\n        \"\"\"\n        Factory for text parser\n        \"\"\"\n        parser = TextParser()\n        return parser\n\nclass TextParser(object):\n        \"\"\"\n        Parses text into a list of urls\n        \"\"\"\n        def __init__(self):\n                self.urls = []\n\n        def extract_urls(self, text):\n                \"\"\"\n                Scans a block of text and extracts oembed data on any urls,\n                returning it in a list of dictionaries\n                \"\"\"\n                parser = text_parser()\n                urls = parser.extract_urls(text)\n                return urls\n\nclass TextParser_factory(object):\n        \"\"\"\n        Factory for text parser\n        \"\"\"\n        def __init__(self):\n                self.urls = []\n\n        def extract_urls(self, text):\n                \"\"\"\n                Scans a block of text and extracts oembed data on any urls,\n                returning it in a list of dictionaries\n                \"\"\"\n                parser = text_parser()\n                urls = parser.extract_urls(text)\n                return urls\n\nclass TextParser_factory_factory",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef main():\n    \"\"\" main function \"\"\"\n    options = [\n        ('-h', '--help', 'show this help'),\n        ('-v', '--version', 'show version'),\n        ('-q', '--quiet', 'quiet'),\n        ('-v', '--verbose', 'verbose'),\n        ('-q', '--quiet', 'quiet'),\n        ('-v', '--verbose', 'verbose'),\n        ('-q', '--quiet', 'quiet'),\n        ('-v', '--verbose', 'verbose'),\n        ('-q', '--quiet', 'quiet'),\n        ('-v', '--verbose', 'verbose'),\n        ('-q', '--quiet', 'quiet'),\n        ('-v', '--verbose', 'verbose'),\n        ('-q', '--quiet', 'quiet'),\n        ('-v', '--verbose', 'verbose'),\n        ('-q', '--quiet', 'quiet'),\n        ('-v', '--verbose', 'verbose'),\n        ('-q', '--quiet', 'quiet'),\n        ('-v', '--verbose', 'verbose'),\n        ('-q', '--quiet', 'quiet'),\n        ('-v', '--verbose', 'verbose'),\n        ('-q', '--quiet', 'quiet'),\n        ('-v', '--verbose', 'verbose'),\n        ('-q', '--quiet', 'quiet'),\n        ('-",
        "\n\ndef call_package(settings):\n    '''\n    Call the package\n    '''\n\n    package_name = settings.selected_subparser.args[0]\n    path = settings.selected_subparser.args[1]\n    CONSYN = settings.selected_subparser.args[2]\n    update_credentials = settings.selected_subparser.args[3]\n    extract_nations = settings.selected_subparser.args[4]\n\n    if CONSYN:\n        package_name = package_name.replace('.py', '.pyc')\n\n    if update_credentials:\n        package_name = package_name.replace('.pyc', '.py')\n\n    if extract_nations:\n        package_name = package_name.replace('.py', '.pyc')\n\n    if package_name.endswith('.pyc'):\n        package_name = package_name[:-3]\n\n    if package_name.endswith('.py'):\n        package_name = package_name[:-2]\n\n    if package_name.endswith('.pyc'):\n        package_name = package_name[:-1]\n\n    if package_name.endswith('.py'):\n        package_name = package_name[:-",
        "\n\ndef create_record():\n        \"\"\" Creates a bibrecord object \"\"\"\n        rec = create_record()\n        rec.identifier = self.document.get('identifier')\n        rec.title = self.document.get('title')\n        rec.publisher = self.document.get('publisher')\n        rec.date = self.document.get('date')\n        rec.language = self.document.get('language')\n        rec.subject = self.document.get('subject')\n        rec.copyright = self.document.get('copyright')\n        rec.authors = self.document.get('authors')\n        rec.identifier = rec.identifier.replace(' ', '')\n        rec.conference = rec.identifier.split(':')[2]\n        rec.conference = rec.conference.replace(' ', '')\n        rec.contribution = rec.identifier.split(':')[2]\n        rec.contribution = rec.contribution.replace(' ', '')\n        rec.identifier = rec.identifier.replace(' ', '')\n        rec.identifier = rec.identifier.replace(' ', '')\n        rec.identifier = rec.identifier.replace(' ', '')\n        rec.identifier = rec.identifier.replace(' ', '')\n        rec.identifier = rec.identifier.replace(' ', '')\n        rec.identifier = rec.identifier.replace(' ',",
        "\n\ndef progress_class(**kwargs):\n    \"\"\"display a progress that can update in place\n\n    example -- \n        total_length = 1000\n        with echo.progress(total_length) as p:\n            for x in range(total_length):\n                # do something crazy\n                p.update(x)\n\n    length -- int -- the total size of what you will be updating progress on\n    \"\"\"\n    progress_class = kwargs.pop(\"progress_class\", Progress)\n    kwargs[\"write_method\"] = istdout.info\n    kwargs[\"width\"] = kwargs.get(\"width\", globals()[\"WIDTH\"])\n    kwargs[\"length\"] = kwargs.get(\"length\", globals()[\"LENGTH\"])\n    pbar = progress_class(**kwargs)\n    pbar.update(0)\n    yield pbar\n    pbar.update(length)\n    br()\n\ndef progress_bar(length, **kwargs):\n    \"\"\"display a progress bar that can update in place\n\n    example -- \n        total_length = 1000\n        with echo.progress_bar(total_length) as p:\n            for x in range(total_length):\n                # do something crazy\n                p.update(x)\n\n    length -- int -- the total size of what you will be updating progress on\n    \"\"\"\n   ",
        ")\n\ndef warn(format_msg, *args, **kwargs):\n    '''print format_msg to stderr'''\n    exc_info = kwargs.pop(\"exc_info\", False)\n    stderr.warning(str(format_msg).format(*args, **kwargs), exc_info=exc_info)\n\ndef info(format_msg, *args, **kwargs):\n    '''print format_msg to stderr'''\n    exc_info = kwargs.pop(\"exc_info\", False)\n    stderr.info(str(format_msg).format(*args, **kwargs), exc_info=exc_info)\n\ndef debug(format_msg, *args, **kwargs):\n    '''print format_msg to stderr'''\n    exc_info = kwargs.pop(\"exc_info\", False)\n    stderr.debug(str(format_msg).format(*args, **kwargs), exc_info=exc_info)\n\ndef debug_print(format_msg, *args, **kwargs):\n    '''print format_msg to stderr'''\n    exc_info = kwargs.pop(\"exc_info\", False)\n    stderr.debug(str(format_msg).format(*args, **kwargs), exc_info=exc_info)\n\ndef debug_print_exc(format_msg, *args, **kwargs):\n    '''print format",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.security.permission.ActionConstants;\nimport com.hazelcast.security.permission.MapPermission",
        "\n\ndef ask(question, choices=None):\n    \"\"\"echo a prompt to the user and wait for an answer\n\n    question -- string -- the prompt for the user\n    choices -- list -- if given, only exit when prompt matches one of the choices\n    return -- string -- the answer that was given by the user\n    \"\"\"\n\n    if not re.match(\"\\s$\", question):\n        question = \"{}: \".format(question)\n\n    while True:\n        if sys.version_info[0] > 2:\n            answer = input(question)\n\n        else:\n            answer = raw_input(question)\n\n        if not choices or answer in choices:\n            break\n\n    return answer\n\ndef ask_yes_no(question, choices=None):\n    \"\"\"echo a yes/no prompt to the user and wait for an answer\n\n    question -- string -- the prompt for the user\n    choices -- list -- if given, only exit when prompt matches one of the choices\n    return -- string -- the answer that was given by the user\n    \"\"\"\n\n    if not re.match(\"\\s$\", question):\n        question = \"{}: \".format(question)\n\n    while True:\n        if sys.version_info[0] > 2:\n            answer = input(question)\n\n        else:\n            answer = raw",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        _LOGGER.debug(\"Authenticated\")\n\n\ndef get_user_data(self):\n        \"\"\"\n        Get the user data from the NuHeat API\n        \"\"\"\n        data = self.request(config.USER_DATA_URL, method=\"GET\")\n        return data\n\n\ndef get_user_data_by_id(self, user_id):\n        \"\"\"\n        Get the user data from the NuHeat API\n        \"\"\"\n        data = self.request(config.USER_DATA_URL, method=\"GET\", data={\"UserId\": user_id})\n        return data\n\n\ndef get_user_data_by_name(self, user_name):\n        \"\"\"\n        Get the user data from the NuHeat API\n        \"\"\"\n        data = self.request(config.USER_DATA_URL, method=\"GET\", data={\"UserName\": user_name})\n        return data\n\n\ndef get_user_data_by_email(self, user_email):\n        \"\"\"\n        Get the user data from the NuHeat API\n        \"\"\"\n        data = self.request(config.USER_DATA_URL, method=\"GET\", data={\"Email\": user_email})\n        return data\n\n\ndef get_user_data_by_phone(self, user_phone):\n        \"\"\"",
        ".json()\n\n\ndef authenticate():\n        \"\"\"\n        Authenticate the NuHeat API\n        \"\"\"\n        self._session_id = config.SESSION_ID\n        self.request(\"https://api.nuheat.com/v1/login\", method=\"POST\", data=config.SESSION_ID, params=config.SESSION_ID_PARAMS)\n\n\ndef get_user_info():\n        \"\"\"\n        Get the user info from the NuHeat API\n        \"\"\"\n        self.request(\"https://api.nuheat.com/v1/user/info\", method=\"GET\", data=None, params=None)\n\n\ndef get_user_info_by_id(user_id):\n        \"\"\"\n        Get the user info from the NuHeat API\n        \"\"\"\n        self.request(\"https://api.nuheat.com/v1/user/info/{0}\".format(user_id), method=\"GET\", data=None, params=None)\n\n\ndef get_user_info_by_name(user_name):\n        \"\"\"\n        Get the user info from the NuHeat API\n        \"\"\"\n        self.request(\"https://api.nuheat.com/v1/user/info/{0}\".format(user_name), method=\"GET\", data=None, params",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ":\n            self.fed.append(\"</{0}>\".format(tag))\n        else:\n            self.fed.append(\"</{0}>\".format(tag))\n\ndef handle_mathml_element(self, tag):\n        \"\"\"Return representation of html mathml element.\"\"\"\n        if tag in self.mathml_elements:\n            self.fed.append(\"<{0}>\".format(tag))\n        else:\n            self.fed.append(\"<{0}>\".format(tag))\n\ndef handle_mathml_text(self, text):\n        \"\"\"Return representation of html mathml text.\"\"\"\n        if text in self.mathml_elements:\n            self.fed.append(\"<{0}>\".format(text))\n        else:\n            self.fed.append(\"<{0}>\".format(text))\n\ndef handle_mathml_comment(self, text):\n        \"\"\"Return representation of html mathml comment.\"\"\"\n        if text in self.mathml_elements:\n            self.fed.append(\"<{0}>\".format(text))\n        else:\n            self.fed.append(\"<{0}>\".format(text))\n\ndef handle_mathml_text_end(self):\n        \"\"\"Return representation of html mathml text end.\"\"\"\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef is_class(self):\n        \"\"\"return True if callback is a class\"\"\"\n        ret = False\n        val = self.callback\n        if isinstance(val, types.ClassType):\n            ret = True\n        return ret\n\ndef is_callable(self):\n        \"\"\"return True if callback is a callable\"\"\"\n        ret = False\n        val = self.callback\n        if isinstance(val, types.CallableType):\n            ret = True\n        return ret\n\ndef is_method(self):\n        \"\"\"return True if callback is a method\"\"\"\n        ret = False\n        val = self.callback\n        if isinstance(val, types.MethodType):\n            ret = True\n        return ret\n\ndef is_function(self):\n        \"\"\"return True if callback is a function\"\"\"\n        ret = False\n        val = self.callback\n        if isinstance(val, types.FunctionType):\n            ret = True\n        return ret\n\ndef is_class_method(self):\n        \"\"\"return True if callback is a class method\"\"\"\n        ret = False\n        val = self.callback\n        if isinstance(val, types.MethodType):\n            ret = True\n        return ret\n\ndef is_class_function(self):\n        \"\"\"return True if callback is a class function\"\"\"\n        ret = False\n        val = self.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef merge_from_dict(self, dict_args):\n        \"\"\"find any matching parser_args from dict_args and merge them into this\n        instance\n\n        dict_args -- dict -- an array of (args, kwargs) tuples\n        \"\"\"\n        def xs(name, parser_args, dict_args):\n            \"\"\"build the generator of matching dict_args\"\"\"\n            for args, kwargs in dict_args:\n                if len(set(args) & parser_args) > 0:\n                    yield args, kwargs\n\n                else:\n                    if 'dest' in kwargs:\n                        if kwargs['dest'] == name:\n                            yield args, kwargs\n\n        for args, kwargs in xs(self.name, self.parser_args, dict_args):\n            self.merge_args(args)\n            self.merge_kwargs(kwargs)\n\n\ndef merge_from_file(self, file_args):\n        \"\"\"find any matching parser_args from file_args and merge them into this\n        instance\n\n        file_args -- list -- an array of (args, kwargs) tuples\n        \"\"\"\n        def xs(name, parser_args, file_args):\n            \"\"\"build the generator of matching file_args\"\"\"\n            for args, kwargs in file_args:\n                if len(set(args) & parser",
        "\n\ndef _fill_text_with_indent(self, text, width, indent):\n        \"\"\"Overridden to get rid of newlines\n\n        https://github.com/python/cpython/blob/2.7/Lib/argparse.py#L620\"\"\"\n        lines = []\n        for line in text.splitlines(False):\n            if line:\n                # https://docs.python.org/2/library/textwrap.html\n                lines.extend(textwrap.wrap(\n                    line.strip(),\n                    width,\n                    initial_indent=indent,\n                    subsequent_indent=indent\n                ))\n\n            else:\n                lines.append(line)\n\n        text = \"\\n\".join(lines)\n        return text\n\ndef _fill_text_with_indent_and_width(self, text, width, indent):\n        \"\"\"Overridden to get rid of newlines\n\n        https://github.com/python/cpython/blob/2.7/Lib/argparse.py#L620\"\"\"\n        lines = []\n        for line in text.splitlines(False):\n            if line:\n                # https://docs.python.org/2/library/textwrap.html\n                lines.extend(textwrap.wrap(\n                    line.strip(),\n                    width,\n                   ",
        "\n\ndef make_user_agent_with_component(component=None):\n    \"\"\" create string suitable for HTTP User-Agent header with component \"\"\"\n    useragent = make_user_agent(component)\n    return useragent\n\ndef make_user_agent_with_component_and_version(component=None, version=None):\n    \"\"\" create string suitable for HTTP User-Agent header with component and version \"\"\"\n    useragent = make_user_agent(component, version)\n    return useragent\n\ndef make_user_agent_with_component_and_version_and_component(component=None, version=None, component=None):\n    \"\"\" create string suitable for HTTP User-Agent header with component and version and component \"\"\"\n    useragent = make_user_agent(component, version, component)\n    return useragent\n\ndef make_user_agent_with_component_and_version_and_component_and_version(component=None, version=None, component=None, version=None):\n    \"\"\" create string suitable for HTTP User-Agent header with component and version and component and version and component \"\"\"\n    useragent = make_user_agent(component, version, component, version)\n    return useragent\n\ndef make_user_agent_with_component_and_version_and_component_and_version(component=None, version=None,",
        "\n\ndef record_add_field_list(rec, tag, ind1='', ind2='', subfields=[],\n                         controlfield_value=''):\n    \"\"\"Add a MARCXML datafield as a new child to a XML document.\"\"\"\n    if controlfield_value:\n        doc = etree.Element(\"controlfield\",\n                            attrib={\n                                \"tag\": tag,\n                            })\n        doc.text = unicode(controlfield_value)\n    else:\n        doc = etree.Element(\"datafield\",\n                            attrib={\n                                \"tag\": tag,\n                                \"ind1\": ind1,\n                                \"ind2\": ind2,\n                            })\n        for code, value in subfields:\n            field = etree.SubElement(doc, \"subfield\", attrib={\"code\": code})\n            field.text = value\n    rec.append(doc)\n    return rec\n\ndef record_add_field_dict(rec, tag, ind1='', ind2='', subfields=[],\n                         controlfield_value=''):\n    \"\"\"Add a MARCXML datafield as a new child to a XML document.\"\"\"\n    if controlfield_value:\n        doc = etree.Element(\"controlfield\",\n                            attrib={\n                                \"tag\": tag,\n                            })\n        doc.text = unicode(control",
        "\n\ndef record_xml_output_with_mathml(rec, pretty=True):\n    \"\"\"Given a document, return XML prettified with MathML.\"\"\"\n    from .html_utils import MathMLParser\n    ret = etree.tostring(rec, xml_declaration=False)\n\n    # Special MathML handling\n    ret = re.sub(\"(&lt;)(([\\/]?{0}))\".format(\"|[\\/]?\".join(MathMLParser.mathml_elements)), '<\\g<2>', ret)\n    ret = re.sub(\"&gt;\", '>', ret)\n    if pretty:\n        # We are doing our own prettyfication as etree pretty_print is too insane.\n        ret = ret.replace('</datafield>', '  </datafield>\\n')\n        ret = re.sub(r'<datafield(.*?)>', r'  <datafield\\1>\\n', ret)\n        ret = ret.replace('</subfield>', '</subfield>\\n')\n        ret = ret.replace('<subfield', '    <subfield')\n        ret = ret.replace('record>', 'record>\\n')\n    return ret\n\ndef record_xml_output_with_mathml_with_mathml_elements(rec, pretty=True):\n   ",
        "\n\ndef escape_for_html(data, tags_to_keep=None):\n    \"\"\"Transform & and < to HTML valid &amp; and &lt.\n\n    Pass a list of tags as string to enable replacement of\n    '<' globally but keep any HTML tags in the list.\n    \"\"\"\n    data = re.sub(\"&\", \"&amp;\", data)\n    if tags_to_keep:\n        data = re.sub(r\"(<)(?![\\/]?({0})\\b)\".format(\"|\".join(tags_to_keep)), \"&lt;\", data)\n    else:\n        data = re.sub(\"<\", \"&lt;\", data)\n    return data\n\ndef escape_for_text(data, tags_to_keep=None):\n    \"\"\"Transform & and < to text valid &amp; and &lt.\n\n    Pass a list of tags as string to enable replacement of\n    '<' globally but keep any text tags in the list.\n    \"\"\"\n    data = re.sub(\"&\", \"&amp;\", data)\n    if tags_to_keep:\n        data = re.sub(r\"(<)(?![\\/]?({0})\\b)\".format(\"|\".join(tags_to_keep)), \"&lt;\", data)\n    else:\n        data = re",
        "\n\n\ndef format_arxiv_id_with_version(arxiv_id, version):\n    \"\"\"Properly format arXiv IDs with a version.\"\"\"\n    if arxiv_id and \"/\" not in arxiv_id and \"arXiv\" not in arxiv_id:\n        return \"arXiv:%s/%s\" % (arxiv_id, version)\n    elif arxiv_id and '.' not in arxiv_id and arxiv_id.lower().startswith('arxiv:'):\n        return arxiv_id[6:]  # strip away arxiv: for old identifiers\n    else:\n        return arxiv_id\n\n\ndef format_arxiv_id_with_version_and_id(arxiv_id, version, id):\n    \"\"\"Properly format arXiv IDs with a version and an id.\"\"\"\n    if arxiv_id and \"/\" not in arxiv_id and \"arXiv\" not in arxiv_id:\n        return \"arXiv:%s/%s/%s\" % (arxiv_id, version, id)\n    elif arxiv_id and '.' not in arxiv_id and arxiv_id.lower().startswith('arxiv:'):",
        "\n\ndef fix_journal_name_with_volume(journal, knowledge_base):\n    \"\"\"Convert journal name to Inspire's short form.\"\"\"\n    if not journal:\n        return '', ''\n    if not knowledge_base:\n        return journal, ''\n    if len(journal) < 2:\n        return journal, ''\n    volume = ''\n    if (journal[-1] <= 'Z' and journal[-1] >= 'A') \\\n            and (journal[-2] == '.' or journal[-2] == ' '):\n        volume += journal[-1]\n        journal = journal[:-1]\n    journal = journal.strip()\n\n    if journal.upper() in knowledge_base:\n        journal = knowledge_base[journal.upper()].strip()\n    elif journal in knowledge_base:\n        journal = knowledge_base[journal].strip()\n    elif '.' in journal:\n        journalnodots = journal.replace('. ', ' ')\n        journalnodots = journalnodots.replace('.', ' ').strip().upper()\n        if journalnodots in knowledge_base:\n            journal = knowledge_base[journalnodots].strip()\n\n    journal = journal.replace('. ', '.')\n    return journal, volume\n\ndef fix_journal_name_with_volume_and_journal_name(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".replace(u'\\u2E3A', '-')\n\ndef unidecode(string):\n    \"\"\"Unidecode string.\"\"\"\n    string = string.replace(u'\\u05BE', '-')\n    string = string.replace(u'\\u1806', '-')\n    string = string.replace(u'\\u2E3A', '-')\n    string = string.replace(u'\\u2E3B', '-')\n    return string\n\ndef get_all_words(string):\n    \"\"\"Get all words in string.\"\"\"\n    return re.findall(r'[a-zA-Z]+', string)\n\ndef get_all_words_with_dashes(string):\n    \"\"\"Get all words in string with dashes.\"\"\"\n    return re.findall(r'[a-zA-Z]+', string, re.IGNORECASE)\n\ndef get_all_words_with_underscores(string):\n    \"\"\"Get all words in string with underscores.\"\"\"\n    return re.findall(r'[a-zA-Z]+', string, re.UNICODE)\n\ndef get_all_words_with_dashes_and_underscores(string):\n    \"\"\"Get all words in string with dashes and underscores.\"\"\"\n    return re.findall(r'[a-zA-Z]+', string,",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\ndef convert_html_subscripts_to_latex_with_quotes(text):\n    \"\"\"Convert some HTML tags to latex equivalents.\"\"\"\n    text = re.sub(\"<sub>(.*?)</sub>\", r\"$_{\\1}$\", text)\n    text = re.sub(\"<sup>(.*?)</sup>\", r\"$^{\\1}$\", text)\n    return text\n\ndef convert_html_subscripts_to_latex_with_quotes_and_quotes(text):\n    \"\"\"Convert some HTML tags to latex equivalents.\"\"\"\n    text = re.sub(\"<sub>(.*?)</sub>\", r\"$_{\\1}$\", text)\n    text = re.sub(\"<sup>(.*?)</sup>\", r\"$^{\\1}$\", text)\n    return text\n\ndef convert_html_subscripts_to_latex_with_quotes_and_quotes_and_quotes(text):\n    \"\"\"Convert some HTML tags to latex equivalents.\"\"\"\n    text = re.sub(\"<sub>(.*?)</sub>\", r\"$_{\\1}$\", text)\n    text = re.sub(\"<sup>(.*?)</sup>\", r\"$^{\\1}$\", text)\n    text = re.sub(\"<sub>(.*?)</sub>\", r\"$_{\\1}$\", text",
        "\n\ndef get_temporary_file():\n    \"\"\"Return a temporary file name.\"\"\"\n    return tempfile.mkdtemp()\n",
        "\n\ndef run_shell_command_with_output(commands, **kwargs):\n    \"\"\"Run a shell command with output.\"\"\"\n    p = subprocess.Popen(commands,\n                         stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE,\n                         **kwargs)\n    output, error = p.communicate()\n    return p.returncode, output, error\n\ndef run_shell_command_with_error(commands, **kwargs):\n    \"\"\"Run a shell command with error.\"\"\"\n    p = subprocess.Popen(commands,\n                         stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE,\n                         **kwargs)\n    output, error = p.communicate()\n    return p.returncode, output, error\n\ndef run_shell_command_with_output_and_error(commands, **kwargs):\n    \"\"\"Run a shell command with output and error.\"\"\"\n    p = subprocess.Popen(commands,\n                         stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE,\n                         **kwargs)\n    output, error = p.communicate()\n    return p.returncode, output, error\n\ndef run_shell_command_with_output_and_error_with_output(commands, **kwargs):\n    \"\"\"Run a shell command with output and error with",
        "\n\ndef create_logger_from_file(name,\n                            filename=None,\n                            logging_level=logging.DEBUG):\n    \"\"\"Create a logger object from a file.\"\"\"\n    logger = logging.getLogger(name)\n    formatter = logging.Formatter(('%(asctime)s - %(name)s - '\n                                   '%(levelname)-8s - %(message)s'))\n\n    if filename:\n        fh = logging.FileHandler(filename=filename)\n        fh.setFormatter(formatter)\n        logger.addHandler(fh)\n\n    ch = logging.StreamHandler()\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)\n\n    logger.setLevel(logging_level)\n\n    return logger\n\ndef create_logger_from_string(name,\n                            logging_level=logging.DEBUG):\n    \"\"\"Create a logger object from a string.\"\"\"\n    logger = logging.getLogger(name)\n    formatter = logging.Formatter(('%(asctime)s - %(name)s - '\n                                   '%(levelname)-8s - %(message)s'))\n\n    if logging_level:\n        logger.setLevel(logging_level)\n\n    return logger\n\ndef create_logger_from_file_and_string(name,\n                                    filename=None,\n                                    logging",
        "\n\ndef _do_unzip_all(zipped_file, output_directory):\n    \"\"\"Perform the actual uncompression.\"\"\"\n    for path in os.listdir(zipped_file):\n        relative_path = os.path.join(output_directory, path)\n        dirname, dummy = os.path.split(relative_path)\n        try:\n            if relative_path.endswith(os.sep) and not os.path.exists(dirname):\n                os.makedirs(relative_path)\n            elif not os.path.exists(relative_path):\n                dirname = os.path.join(output_directory, os.path.dirname(path))\n                if os.path.dirname(path) and not os.path.exists(dirname):\n                    os.makedirs(dirname)\n                fd = open(relative_path, \"w\")\n                fd.write(z.read(path))\n                fd.close()\n        except IOError, e:\n            raise e\n    return output_directory\n\ndef _do_unzip_all_files(zipped_file, output_directory):\n    \"\"\"Perform the actual uncompression.\"\"\"\n    for path in os.listdir(zipped_file):\n        relative_path = os.path.join(output_directory, path)\n       ",
        ", filename\n\ndef find_all(pattern, root=os.curdir):\n    \"\"\"Locate all files matching supplied filename pattern recursively.\"\"\"\n    for path, dummy, files in os.walk(os.path.abspath(root)):\n        for filename in fnmatch.filter(files, pattern):\n            yield os.path.join(path, filename)\n\ndef find_all_files(pattern, root=os.curdir):\n    \"\"\"Locate all files matching supplied filename pattern recursively.\"\"\"\n    for path, dummy, files in os.walk(os.path.abspath(root)):\n        for filename in fnmatch.filter(files, pattern):\n            yield os.path.join(path, filename)\n\ndef find_all_files_with_extension(pattern, root=os.curdir):\n    \"\"\"Locate all files matching supplied filename pattern recursively.\"\"\"\n    for path, dummy, files in os.walk(os.path.abspath(root)):\n        for filename in fnmatch.filter(files, pattern):\n            yield os.path.join(path, filename.replace('.', ''))\n\ndef find_all_files_with_extension_and_extension_suffix(pattern, root=os.curdir):\n    \"\"\"Locate all files matching supplied filename pattern recursively.\"\"\"\n    for path, dummy, files",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n    return value\n\ndef convert_iso_to_date(value):\n    \"\"\"Convert an ISO date-value to a date-value.\"\"\"\n    date_formats = [\"%Y-%m-%d\", \"%Y/%m/%d\"]\n    for dformat in date_formats:\n        try:\n            date = datetime.strptime(value, dformat)\n            return date\n        except ValueError:\n            pass\n    return value\n\ndef convert_date_to_time(value):\n    \"\"\"Convert a date-value to a time-value.\"\"\"\n    date_formats = [\"%H:%M:%S\", \"%H:%M:%S\"]\n    for dformat in date_formats:\n        try:\n            date = datetime.strptime(value, dformat)\n            return date\n        except ValueError:\n            pass\n    return value\n\ndef convert_iso_to_time(value):\n    \"\"\"Convert an ISO time-value to a time-value.\"\"\"\n    time_formats = [\"%H:%M:%S\", \"%H:%M:%S\"]\n    for tformat in time_formats:\n        try:\n            time = datetime.strptime(value, tformat)\n            return time\n        except ValueError:\n            pass\n    return value\n\ndef convert_date_to_datetime(value):\n    \"\"\"Convert",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_converted_image_name(image_file):\n    \"\"\"Get the name of the converted image file.\n\n    @param: image_file ([string, string, ...]): the image file\n        extracted from the tarball in step 1\n\n    @return: converted_image_file ([string, string, ...]): The name of the\n        converted image file.\n    \"\"\"\n    image_file = image_file.replace('.png', '')\n    image_file = image_file.replace('.jpg', '')\n    image_file = image_file.replace('.ps', '')\n    image_file = image_file.replace('.psx', '')\n    image_file = image_file.replace('.pstex', '')\n    return image_file\n\ndef run_shell_command(cmd_list):\n    \"\"\"Run shell command.\n\n    @param: cmd_list ([string, string, ...]): the list of shell command\n        to run.\n\n    @return: (string, string, string): The output of the shell command.\n    \"\"\"\n    cmd_out = ''\n    for cmd in cmd_list:\n        cmd_out += cmd + ' '\n    return cmd_out, cmd_out, cmd_out\n\ndef get_image_info(image_file",
        "\n    return filepath\n\n\ndef get_temp_dir():\n    \"\"\"Generate a temporary directory.\"\"\"\n    return get_temporary_file(\"tmp_\",\n                              \"tmp\",\n                              directory=os.getcwd())\n\n\ndef get_temp_file(prefix=\"tmp_\",\n                  suffix=\"\",\n                  directory=None):\n    \"\"\"Generate a temporary file.\"\"\"\n    return get_temporary_file(prefix=prefix,\n                              suffix=suffix,\n                              directory=directory)\n\n\ndef get_temp_file_path(prefix=\"tmp_\",\n                       suffix=\"\",\n                       directory=None):\n    \"\"\"Generate a temporary file path.\"\"\"\n    return get_temporary_file(prefix=prefix,\n                              suffix=suffix,\n                              directory=directory)\n\n\ndef get_temp_file_path_with_extension(prefix=\"tmp_\",\n                                    suffix=\"\",\n                                    directory=None):\n    \"\"\"Generate a temporary file path with extension.\"\"\"\n    return get_temporary_file(prefix=prefix,\n                              suffix=suffix,\n                              directory=directory,\n                              extension=\".tmp\")\n\n\ndef get_temp_file_path_with_extension_with_directory(prefix=\"tmp_\",\n                                                        suffix=\"\",\n                                                        directory=None):\n    \"\"\"Generate a temporary file path with extension and directory.\"\"\"\n   ",
        "\n    return out\n\ndef return_letters_from_string_with_numbers(text):\n    \"\"\"Get letters from string and numbers only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out\n\ndef return_letters_from_string_with_numbers_and_spaces(text):\n    \"\"\"Get letters from string and numbers and spaces only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out\n\ndef return_letters_from_string_with_numbers_and_spaces_and_numbers(text):\n    \"\"\"Get letters from string and numbers and spaces and numbers only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out\n\ndef return_letters_from_string_with_numbers_and_spaces_and_numbers_and_numbers(text):\n    \"\"\"Get letters from string and numbers and spaces and numbers and numbers only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out\n\ndef return_letters_from_string_with_numbers_and_spaces_and_numbers_and_numbers_and_numbers(",
        "\n    return False\n\n\ndef license_is_open_access(license):\n    \"\"\"Return True if license is compatible with Open Access\"\"\"\n    for oal in OPEN_ACCESS_LICENSES:\n        if re.search(oal, license):\n            return True\n    return False\n\n\ndef license_is_open_license(license):\n    \"\"\"Return True if license is compatible with Open License\"\"\"\n    for oal in OPEN_LICENSES:\n        if re.search(oal, license):\n            return True\n    return False\n\n\ndef license_is_open_license_with_oa(license):\n    \"\"\"Return True if license is compatible with Open License with Open Access\"\"\"\n    for oal in OPEN_LICENSES:\n        if re.search(oal, license):\n            return True\n    return False\n\n\ndef license_is_open_license_with_open_access(license):\n    \"\"\"Return True if license is compatible with Open License with Open Access\"\"\"\n    for oal in OPEN_LICENSES:\n        if re.search(oal, license):\n            return True\n    return False\n\n\ndef license_is_open_license_with_open_license(license):\n    \"\"\"Return True if license is compatible with Open License with Open License\"\"\"\n    for oal",
        "\n\ndef _normalize_issue_dir_with_dtd(dirname):\n        \"\"\"\n        Normalize a directory with an XML document type.\n        \"\"\"\n        dirname = dirname.rstrip('/')\n        if dirname.endswith('.xml'):\n            dirname = dirname[:-4]\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname = dirname.rstrip('/')\n        dirname",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_value_in_tag(self, xml_doc, tag):\n        \"\"\"Return the value of a tag in the xml_doc.\"\"\"\n        return xml_doc.find(tag).text\n\ndef get_value_in_tag_with_value(self, xml_doc, tag, value):\n        \"\"\"Return the value of a tag in the xml_doc with a given value.\"\"\"\n        return xml_doc.find(tag).text.replace(value, '')\n\ndef get_value_in_tag_with_value_in_tag(self, xml_doc, tag, value):\n        \"\"\"Return the value of a tag in the xml_doc with a given value in a tag.\"\"\"\n        return xml_doc.find(tag).text.replace(value, '')\n\ndef get_value_in_tag_with_value_in_tag_with_value(self, xml_doc, tag, value, tag_with_value):\n        \"\"\"Return the value of a tag in the xml_doc with a given value in a tag with a given value.\"\"\"\n        return xml_doc.find(tag).text.replace(value, '')\n\ndef get_value_in_tag_with_value_in_tag_with_value(self, xml_doc, tag, value, tag_with_value,",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.security.permission.ActionConstants;\nimport com.hazelcast.security.permission.MapPermission",
        ".parse(parser, token)\n\n\nclass OEmbedAutodiscoverNode(template.Node):\n    def __init__(self, obj):\n        self.obj = obj\n\n    def render(self, context):\n        return '<link rel=\"autodiscover\" href=\"%s\" />' % self.obj.get_url()\n\n\nregister.tag('oembed_autodiscover', do_autodiscover)\n",
        "\n\nregister.tag('oembed_url_scheme', do_url_scheme)\n",
        "\n\ndef get_parser(self):\n    \"\"\"return the parser for the current name\"\"\"\n    return parser()\n\ndef get_subparsers(self):\n    \"\"\"return the parser for the current name\"\"\"\n    return parser().add_subparsers()\n\ndef get_callback(self):\n    \"\"\"return the callback for the current name\"\"\"\n    return self.callbacks[self.function_name]\n\ndef get_module(self):\n    \"\"\"return the module for the current name\"\"\"\n    return self.module\n\ndef get_subcommands(self):\n    \"\"\"return the subcommands for the current name\"\"\"\n    return self.subcommands\n\ndef get_function_name(self):\n    \"\"\"return the function name for the current name\"\"\"\n    return self.function_name\n\ndef get_description(self):\n    \"\"\"return the description for the current name\"\"\"\n    return self.description\n\ndef get_help(self):\n    \"\"\"return the help for the current name\"\"\"\n    return self.help\n\ndef get_arguments(self):\n    \"\"\"return the arguments for the current name\"\"\"\n    return self.arguments\n\ndef get_options(self):\n    \"\"\"return the options for the current name\"\"\"\n    return self.options\n\ndef get_arguments_help(self):\n    \"\"\"return the help for the current name",
        "\n\ndef main():\n    \"\"\"main function\"\"\"\n    # import the module\n    module = module()\n\n    # run the script\n    module.main()\n\nif __name__ == '__main__':\n    main()\n",
        "\n\ndef module(self):\n        \"\"\"get the module name of the script\"\"\"\n        return self.module\n\ndef module_name(self):\n        \"\"\"get the module name of the script\"\"\"\n        return self.module\n\ndef module_path(self):\n        \"\"\"get the module path of the script\"\"\"\n        return self.module_path\n\ndef module_path_relative(self):\n        \"\"\"get the module path relative to the script\"\"\"\n        return self.module_path\n\ndef module_path_absolute(self):\n        \"\"\"get the module path absolute to the script\"\"\"\n        return self.module_path\n\ndef module_path_relative_absolute(self):\n        \"\"\"get the module path relative to the script\"\"\"\n        return self.module_path_absolute\n\ndef module_path_absolute_relative(self):\n        \"\"\"get the module path absolute to the script\"\"\"\n        return self.module_path_relative\n\ndef module_path_absolute_absolute(self):\n        \"\"\"get the module path absolute to the script\"\"\"\n        return self.module_path_absolute\n\ndef module_path_absolute_relative_absolute(self):\n        \"\"\"get the module path absolute to the script\"\"\"\n        return self.module_path_absolute_relative\n\ndef module_path_absolute_absolute_relative(self):",
        "\n\ndef main():\n    \"\"\"main function\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"\"\"\n        Run a script.\n        \"\"\"\n    )\n    parser.add_argument(\"script\", help=\"\"\"\n        The script to run.\n        \"\"\")\n    parser.add_argument(\"-v\", \"--verbose\", action=\"count\", default=0, help=\"\"\"\n        Increase verbosity of the script.\n        \"\"\")\n    parser.add_argument(\"-q\", \"--quiet\", action=\"count\", default=0, help=\"\"\"\n        Increase verbosity of the script.\n        \"\"\")\n    parser.add_argument(\"-q\", \"--quiet-inject\", action=\"append\", default=[], help=\"\"\"\n        Increase verbosity of the script.\n        \"\"\")\n    parser.add_argument(\"-q\", \"--quiet-inject-level\", action=\"append\", default=[], help=\"\"\"\n        Increase verbosity of the script.\n        \"\"\")\n    parser.add_argument(\"-q\", \"--quiet-inject-level-level\", action=\"append\", default=[], help=\"\"\"\n        Increase verbosity of the script.\n        \"\"\")\n    parser.add_argument(\"-q\", \"--quiet-inject-level-level-level\", action=\"append\", default=[], help=\"\"\"\n        Increase verbosity of the",
        "\n\ndef get_path(self, basepath):\n        \"\"\"return that path to be able to call this script from the passed in\n        basename\n\n        example -- \n            basepath = /foo/bar\n            self.path = /foo/bar/che/baz.py\n            self.call_path(basepath) # che/baz.py\n\n        basepath -- string -- the directory you would be calling this script in\n        return -- string -- the minimum path that you could use to execute this script\n            in basepath\n        \"\"\"\n        rel_filepath = self.path\n        if basepath:\n            rel_filepath = os.path.relpath(self.path, basepath)\n\n        basename = self.name\n        if basename in set(['__init__.py', '__main__.py']):\n            rel_filepath = os.path.dirname(rel_filepath)\n\n        return rel_filepath\n\ndef get_basename(self):\n        \"\"\"return the basename of this script\n\n        example -- \n            self.path = /foo/bar/che/baz.py\n            self.call_path(basepath) # che/baz.py\n\n        return -- string -- the basename of this script\n        \"\"\"\n        return self.name\n\ndef get_basename_without_ext(self):\n        \"\"\"return the",
        "\n\ndef main(argv):\n    \"\"\"main function\n\n    This is the main function that is called by the script\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"\"\"\n    A simple script that runs a script and prints the results\n    \"\"\")\n    parser.add_argument(\"script\", help=\"\"\"\n    The script to run\n    \"\"\")\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\", help=\"\"\"\n    Prints more information about the script\n    \"\"\")\n    parser.add_argument(\"-f\", \"--file\", help=\"\"\"\n    The file to write the script to\n    \"\"\")\n    parser.add_argument(\"-p\", \"--path\", help=\"\"\"\n    The path to the script\n    \"\"\")\n    parser.add_argument(\"-b\", \"--body\", help=\"\"\"\n    The script body\n    \"\"\")\n    parser.add_argument(\"-m\", \"--module\", help=\"\"\"\n    The module to import\n    \"\"\")\n    parser.add_argument(\"-c\", \"--callback\", help=\"\"\"\n    The callback to call when the script is finished\n    \"\"\")\n    args = parser.parse_args(argv)\n\n    if args.verbose:\n        print(\"Running script: {}\".format(args.script))\n\n    if",
        "\n\ndef _find_calls(self, ast_tree, name, call_type):\n        \"\"\"find all calls to a function in the given AST tree\"\"\"\n        calls = []\n        for call in ast_tree.body:\n            if call.name == name and call.type == call_type:\n                calls.append(call)\n        return calls\n\ndef main():\n        \"\"\"main function\"\"\"\n        parser = argparse.ArgumentParser(description=\"\"\"\n        Run a script from the command line\n        \"\"\")\n        parser.add_argument(\"-c\", \"--command\", required=True, help=\"\"\"\n        The command to run\n        \"\"\")\n        parser.add_argument(\"-f\", \"--file\", required=True, help=\"\"\"\n        The file to run\n        \"\"\")\n        parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\", help=\"\"\"\n        Print more information about the script\n        \"\"\")\n        parser.add_argument(\"-v\", \"--verbose-file\", action=\"store_true\", help=\"\"\"\n        Print more information about the script\n        \"\"\")\n        parser.add_argument(\"-v\", \"--verbose-call\", action=\"store_true\", help=\"\"\"\n        Print more information about the call\n        \"\"\")\n        parser.add_argument(\"-v\", \"--",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef fetch_json(url, method='GET', user_agent='django-oembed', timeout=SOCKET_TIMEOUT):\n    \"\"\"\n    Fetch response headers and data from a JSON URL, raising a generic exception\n    for any kind of failure.\n    \"\"\"\n    sock = httplib2.Http(timeout=timeout)\n    request_headers = {\n        'User-Agent': user_agent,\n        'Accept-Encoding': 'gzip'}\n    try:\n        headers, raw = sock.request(url, headers=request_headers, method=method)\n    except:\n        raise OEmbedHTTPException('Error fetching %s' % url)\n    return headers, raw\n\ndef fetch_file(url, method='GET', user_agent='django-oembed', timeout=SOCKET_TIMEOUT):\n    \"\"\"\n    Fetch response headers and data from a file, raising a generic exception\n    for any kind of failure.\n    \"\"\"\n    sock = httplib2.Http(timeout=timeout)\n    request_headers = {\n        'User-Agent': user_agent,\n        'Accept-Encoding': 'gzip'}\n    try:\n        headers, raw = sock.request(url, headers=request_headers, method=method)\n    except:\n        raise OEmbedHTTPException('Error fetching %s' % url)",
        "\n\ndef get_domain(url):\n    \"\"\"\n    Given a url, return the domain part of the url, or None if the url is not a\n    relative url.\n    \"\"\"\n    if re.match('https?:\\/\\/', url):\n        return None\n    return url.split('/')[-1]\n\ndef get_example_url(url):\n    \"\"\"\n    Given a url, return the example url, or None if the url is not a relative url.\n    \"\"\"\n    if re.match('https?:\\/\\/', url):\n        return None\n    return url.split('/')[-1]\n\ndef get_example_url_with_domain(url):\n    \"\"\"\n    Given a url, return the example url, or None if the url is not a relative url.\n    \"\"\"\n    if re.match('https?:\\/\\/', url):\n        return None\n    return '%s%s' % (get_example_url(url), get_domain(url))\n\ndef get_example_url_without_domain(url):\n    \"\"\"\n    Given a url, return the example url, or None if the url is not a relative url.\n    \"\"\"\n    if re.match('https?:\\/\\/', url):\n        return None\n    return '%s%s'",
        "\n\ndef mock_response():\n    \"\"\"\n    Generate a fake response object to allow oEmbeds to use context processors.\n    \"\"\"\n    current_site = Site.objects.get_current()\n    response = HttpResponse()\n    response.META['SERVER_NAME'] = current_site.domain\n    return response\n\ndef mock_template(template_name):\n    \"\"\"\n    Generate a fake template object to allow oEmbeds to use context processors.\n    \"\"\"\n    current_site = Site.objects.get_current()\n    template = Template(template_name)\n    template.render(RequestContext(mock_request()))\n    return template\n\ndef mock_template_context(template_name):\n    \"\"\"\n    Generate a fake template context object to allow oEmbeds to use context processors.\n    \"\"\"\n    current_site = Site.objects.get_current()\n    context = RequestContext(mock_request())\n    context['template'] = mock_template(template_name)\n    return context\n\ndef mock_template_context_with_context(template_name, context):\n    \"\"\"\n    Generate a fake template context object with context processors.\n    \"\"\"\n    current_site = Site.objects.get_current()\n    context = RequestContext(mock_request(), context)\n    context['template'] = mock_template(",
        "\ndef import_module(package):\n    \"\"\"\n    dynamically load a module given a string of the format\n    \n    package.Module\n    \"\"\"\n    package, module = package.rsplit('.', 1)\n    module = __import__(module)\n    return getattr(module, package)\n\ndef load_module_class(path):\n    \"\"\"\n    dynamically load a module class given a string of the format\n    \n    package.Module.Class\n    \"\"\"\n    package, module, klass = path.rsplit('.', 1)\n    module = __import__(package)\n    return getattr(module, klass)\n\ndef load_module_method(path):\n    \"\"\"\n    dynamically load a module method given a string of the format\n    \n    package.Module.Method\n    \"\"\"\n    package, module, method = path.rsplit('.', 1)\n    module = __import__(package)\n    return getattr(module, method)\n\ndef load_module_class_method(path):\n    \"\"\"\n    dynamically load a module class method given a string of the format\n    \n    package.Module.Class.Method\n    \"\"\"\n    package, module, klass, method = path.rsplit('.', 1)\n    module = __import__(package)\n    return getattr(module, klass,",
        "\n\ndef get_record_list(self):\n        \"\"\"Override the base get_record_list.\"\"\"\n        self.update_system_numbers()\n        self.add_systemnumber(\"CDS\")\n        self.fields_list = [\n            \"024\", \"041\", \"035\", \"037\", \"088\", \"100\",\n            \"110\", \"111\", \"242\", \"245\", \"246\", \"260\",\n            \"269\", \"300\", \"502\", \"650\", \"653\", \"693\",\n            \"700\", \"710\", \"773\", \"856\", \"520\", \"500\",\n            \"980\"\n        ]\n        self.keep_only_fields()\n\n        self.determine_collections()\n        self.add_cms_link()\n        self.update_languages()\n        self.update_reportnumbers()\n        self.update_date()\n        self.update_pagenumber()\n        self.update_authors()\n        self.update_subject_categories(\"SzGeCERN\", \"INSPIRE\", \"categories_inspire\")\n        self.update_keywords()\n        self.update_experiments()\n        self.update_collaboration()\n        self.update_journals()",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        record_delete_fields(self.record, \"037\")\n\n        # 037 Externals also...\n        rep_038_fields = record_get_field_instances(self.record, '038')\n        for field in rep_038_fields:\n            subs = field_get_subfields(field)\n            if 'a' in subs:\n                for value in subs['a']:\n                    if 'arXiv' in value:\n                        new_subs = [('a', value), ('9', 'arXiv')]\n                        for fld in record_get_field_instances(self.record,  '695'):\n                            for key, val in field_get_subfield_instances(fld):\n                                if key == 'a':\n                                    new_subs.append(('c', val))\n                                    break\n                        nf = create_field(subfields=new_subs)\n                        record_replace_field(self.record, '038', nf, field[4])\n            for key, val in field[0]:\n                if key in ['a', '9'] and val.startswith('SIS-'):\n                    record_delete_field(\n                        self.record, '038', field_position_global=field[4])\n        record_delete_fields(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _wash_indicators(ind1, ind2):\n    \"\"\"\n    Wash indicators between two elements.\n\n    This function is used to wash indicators between two elements.\n    \"\"\"\n    ind1 = ind1.strip()\n    ind2 = ind2.strip()\n    if ind1 == '':\n        ind1 = ' '\n    if ind2 == '':\n        ind2 = ' '\n    return ind1, ind2\n\ndef _check_field_validity(field):\n    \"\"\"\n    Check that the field is valid.\n    \"\"\"\n    if field[0] is None:\n        raise ValueError('Field must have at least one subfield.')\n    if field[1] is None:\n        raise ValueError('Field must have at least one indicator.')\n    if field[2] is None:\n        raise ValueError('Field must have at least one controlfield.')\n    if field[3] is None:\n        raise ValueError('Field must have at least one global position.')\n    if field[4] is None:\n        raise ValueError('Field must have at least one controlfield value.')\n    if field[5] is None:\n        raise ValueError('Field must have at least one global position.')\n\ndef _check_controlfield_validity(controlfield):\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _create_record_lxml(marcxml, verbose=CFG_BIBRECORD_DEFAULT_VERBOSE_LEVEL,\n                      correct=CFG_BIBRECORD_DEFAULT_CORRECT, keep_singletons=CFG_BIBRECORD_KEEP_SINGLETONS):\n    \"\"\"Create a record object from the marcxml description.\n\n    Uses the lxml parser.\n\n    The returned object is a tuple (record, status_code, list_of_errors),\n    where status_code is 0 when there are errors, 1 when no errors.\n\n    The return record structure is as follows::\n\n        Record := {tag : [Field]}\n        Field := (Subfields, ind1, ind2, value)\n        Subfields := [(code, value)]\n\n    .. code-block:: none\n\n                                    .--------.\n                                    | record |\n                                    '---+----'\n                                        |\n               .------------------------+------------------------------------.\n               |record['001']           |record['909']        |record['520'] |\n               |                        |                     |              |\n        [list of fields]           [list of fields]     [list of fields]    ...\n               |                        |                     |\n               |               .--------+--+-----------.      |\n               |               |           |           |",
        "\n\ndef record_filter_field(record_instances, filter_subcode, filter_value,\n                        filter_mode='e'):\n    \"\"\"Filter the given field.\n\n    Filters given field and returns only that field instances that contain\n    filter_subcode with given filter_value. As an input for search function\n    accepts output from record_get_field_instances function. Function can be\n    run in three modes:\n\n    - 'e' - looking for exact match in subfield value\n    - 's' - looking for substring in subfield value\n    - 'r' - looking for regular expression in subfield value\n\n    Example:\n\n    record_filter_field(record_get_field_instances(rec, '999', '%', '%'),\n                        'y', '2001')\n\n    In this case filter_subcode is 'y' and filter_value is '2001'.\n\n    :param record_instances: output from record_get_field_instances\n    :param filter_subcode: name of the subfield\n    :type filter_subcode: string\n    :param filter_value: value of the subfield\n    :type filter_value: string\n    :param filter_mode: 'e','s' or 'r'\n    \"\"\"\n    matched = []\n    if filter_mode == 'e':\n       ",
        "\n\ndef record_drop_duplicate_fields_with_duplicates(record):\n    \"\"\"\n    Return a record where all the duplicate fields have been removed.\n\n    Fields are considered identical considering also the order of their\n    subfields.\n    \"\"\"\n    out = {}\n    position = 0\n    tags = sorted(record.keys())\n    for tag in tags:\n        fields = record[tag]\n        out[tag] = []\n        current_fields = set()\n        for full_field in fields:\n            field = (tuple(full_field[0]),) + full_field[1:4]\n            if field not in current_fields:\n                current_fields.add(field)\n                position += 1\n                out[tag].append(full_field[:4] + (position,))\n    return out\n\ndef record_drop_duplicate_fields_with_duplicates_with_duplicates(record):\n    \"\"\"\n    Return a record where all the duplicate fields have been removed.\n\n    Fields are considered identical considering also the order of their\n    subfields.\n    \"\"\"\n    out = {}\n    position = 0\n    tags = sorted(record.keys())\n    for tag in tags:\n        fields = record[tag]\n        out[tag] = []\n        current_fields = set()\n       ",
        "\n\ndef records_identical_with_005(rec1, rec2, skip_005=True, ignore_field_order=False,\n                                 ignore_subfield_order=False,\n                                 ignore_duplicate_subfields=False,\n                                 ignore_duplicate_controlfields=False):\n    \"\"\"\n    Return True if rec1 is identical to rec2.\n\n    It does so regardless of a difference in the 005 tag (i.e. the timestamp).\n    \"\"\"\n    rec1_keys = set(rec1.keys())\n    rec2_keys = set(rec2.keys())\n    if skip_005:\n        rec1_keys.discard(\"005\")\n        rec2_keys.discard(\"005\")\n    if rec1_keys != rec2_keys:\n        return False\n    for key in rec1_keys:\n        if ignore_duplicate_controlfields and key.startswith('00'):\n            if set(field[3] for field in rec1[key]) != \\\n                    set(field[3] for field in rec2[key]):\n                return False\n            continue\n\n        rec1_fields = rec1[key]\n        rec2_fields = rec2[key]\n        if len(rec1_fields) != len(rec2_fields):\n            # They",
        "\n\ndef record_get_field_values(rec, tag=\"\", ind1=\" \", ind2=\" \"):\n    \"\"\"\n    Return the list of field values for the specified tag and indications.\n\n    Return empty list if not found.\n    If tag is empty string, returns all fields\n\n    Parameters (tag, ind1, ind2) can contain wildcard %.\n\n    :param rec: a record structure as returned by create_record()\n    :param tag: a 3 characters long string\n    :param ind1: a 1 character long string\n    :param ind2: a 1 character long string\n    :param code: a 1 character long string\n    :return: a list of field tuples (Subfields, ind1, ind2, value,\n             field_position_global) where subfields is list of (code, value)\n    \"\"\"\n    if not rec:\n        return []\n    if not tag:\n        return rec.items()\n    else:\n        out = []\n        ind1, ind2 = _wash_indicators(ind1, ind2)\n\n        if '%' in tag:\n            # Wildcard in tag. Check all possible\n            for field_tag in rec:\n                if _tag_matches_pattern(field_tag, tag):\n                    for possible_field_instance in rec[field_",
        "\n\n\ndef record_delete_field_by_tag(rec, tag, ind1=' ', ind2=' ',\n                             field_position_global=None, field_position_local=None):\n    \"\"\"\n    Delete the field with the given tag.\n\n    If global field position is specified, deletes the field with the\n    corresponding global field position.\n    If field_position_local is specified, deletes the field with the\n    corresponding local field position and tag.\n    Else deletes all the fields matching tag and optionally ind1 and\n    ind2.\n\n    If both field_position_global and field_position_local are present,\n    then field_position_local takes precedence.\n\n    :param rec: the record data structure\n    :param tag: the tag of the field to be deleted\n    :param ind1: the first indicator of the field to be deleted\n    :param ind2: the second indicator of the field to be deleted\n    :param field_position_global: the global field position (record wise)\n    :param field_position_local: the local field position (tag wise)\n    :return: the list of deleted fields\n    \"\"\"\n    error = _validate_record_field_positions_global(rec)\n    if error:\n        # FIXME one should write a message here.\n        pass\n\n    if",
        "\n\n\ndef record_add_field(rec, tag, ind1, ind2, subfields, controlfield_value):\n    \"\"\"\n    Add a field to the record at the required position.\n\n    The position is specified by the tag and the field_position_local in the\n    list of fields.\n\n    :param rec: a record structure\n    :param tag: the tag of the field to be moved\n    :param field_position_local: the field_position_local to which the field\n                                 will be inserted. If not specified, appends\n                                 the fields to the tag\n    :param a: list of fields to be added\n    :return: -1 if the operation failed, or the field_position_local if it was\n             successful\n    \"\"\"\n    if field_position_local is None and field_position_global is None:\n        for field in subfields:\n            rec.add_field(tag, ind1, ind2, field, controlfield_value)\n    else:\n        subfields.reverse()\n        for field in subfields:\n            rec.add_field(tag, ind1, ind2, field, controlfield_value,\n                          field_position_local=field_position_local,\n                          field_position_global=field_position_global)\n\n    return field_position_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\ndef record_get_field_by_code(rec, field_code, field_position_global=None,\n                            field_position_local=None):\n    \"\"\"\n    Return the matching field.\n\n    One has to enter either a global field position or a local field position.\n\n    :return: a list of subfield tuples (subfield code, value).\n    :rtype: list\n    \"\"\"\n    if field_position_global is None and field_position_local is None:\n        raise InvenioBibRecordFieldError(\n            \"A field position is required to \"\n            \"complete this operation.\")\n    elif field_position_global is not None and \\\n            field_position_local is not None:\n        raise InvenioBibRecordFieldError(\n            \"Only one field position is required \"\n            \"to complete this operation.\")\n    elif field_position_global:\n        if tag not in rec:\n            raise InvenioBibRecordFieldError(\"No tag '%s' in record.\" % tag)\n\n        for field in rec[tag]:\n            if field[4] == field_position_global:\n                return field\n        raise InvenioBibRecordFieldError(\n            \"No field has the tag '%s' and the \"\n            \"global field position '%",
        "\n\ndef record_replace_field_global(rec, tag, new_field, field_position_global=None):\n    \"\"\"Replace a field with a new field.\"\"\"\n    if field_position_global is None:\n        raise InvenioBibRecordFieldError(\n            \"A field position is required to \"\n            \"complete this operation.\")\n    elif field_position_global is not None:\n        raise InvenioBibRecordFieldError(\n            \"Only one field position is required \"\n            \"to complete this operation.\")\n    else:\n        if tag not in rec:\n            raise InvenioBibRecordFieldError(\"No tag '%s' in record.\" % tag)\n\n        replaced = False\n        for position, field in enumerate(rec[tag]):\n            if field[4] == field_position_global:\n                rec[tag][position] = new_field\n                replaced = True\n\n        if not replaced:\n            raise InvenioBibRecordFieldError(\n                \"No field has the tag '%s' and \"\n                \"the global field position '%d'.\" %\n                (tag, field_position_global))\n\ndef record_replace_field_local(rec, tag, new_field, field_position_local=None):\n    \"\"\"Replace a field with a new field",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n    else:\n        raise InvenioBibRecordFieldError(\n            \"The record does not contain the subfield \"\n            \"'%(subfieldIndex)s' inside the field (local: \"\n            \"'%(fieldIndexLocal)s', global: '%(fieldIndexGlobal)s' ) of tag \"\n            \"'%(tag)s'.\" %\n            {\"subfieldIndex\": subfield_position,\n             \"fieldIndexLocal\": str(field_position_local),\n             \"fieldIndexGlobal\": str(field_position_global),\n             \"tag\": tag})\n\n\ndef record_delete_subfield_from_all(rec, tag, subfield_position,\n                                   field_position_global=None,\n                                   field_position_local=None):\n    \"\"\"\n    Delete subfield from all positions specified.\n\n    Specify the subfield by tag, field number and subfield position.\n    \"\"\"\n    subfields = record_get_subfields(\n        rec, tag,\n        field_position_global=field_position_global,\n        field_position_local=field_position_local)\n\n    for subfield in subfields:\n        record_delete_subfield_from(rec, tag, subfield,\n                                    field_position_global=field_position_global,\n                                    field_position_local=field_position_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.GetOperation;\nimport com.hazelcast.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n    return text\n\ndef record_xml_output(rec, tags):\n    \"\"\"\n    Print a record in XML format.\n\n    :param rec: record to be printed\n    :param tags: list of tags to be printed\n    \"\"\"\n    text = '<record>'\n    text += '<title>' + rec.title + '</title>'\n    text += '<author>' + rec.author + '</author>'\n    text += '<date>' + rec.date + '</date>'\n    text += '<content>' + rec.content + '</content>'\n    text += '<tags>' + tags + '</tags>'\n    text += '</record>'\n    return text\n\ndef record_html_output(rec, tags):\n    \"\"\"\n    Print a record in HTML format.\n\n    :param rec: record to be printed\n    :param tags: list of tags to be printed\n    \"\"\"\n    text = '<record>'\n    text += '<title>' + rec.title + '</title>'\n    text += '<author>' + rec.author + '</author>'\n    text += '<date>' + rec.date + '</date>'\n    text += '<content>' + rec.content + '</content>'\n    text += '<tags>' + tags + '</tags>'\n    text += '</record>'\n    return text\n\ndef record_text_output(rec,",
        "\n\ndef print_rec(rec, format=1, tags=None):\n    \"\"\"\n    Print a single record.\n\n    :param rec: record to be printed\n    :param format: 1 XML, 2 HTML (not implemented)\n    :param tags: list of tags to be printed\n           if 'rec' is not a record it returns empty string\n    \"\"\"\n    if tags is None:\n        tags = []\n    text = \"\"\n\n    if type(rec).__name__ != 'record':\n        return \"\"\n    else:\n        text = \"%s\\n%s\" % (text, print_rec(rec, format, tags))\n    return text\n\ndef print_rec_list(reclist, format=1, tags=None):\n    \"\"\"\n    Print a list of records.\n\n    :param reclist: list of records to be printed\n    :param format: 1 XML, 2 HTML (not implemented)\n    :param tags: list of tags to be printed\n           if 'reclist' is not a list it returns empty string\n    \"\"\"\n    if tags is None:\n        tags = []\n    text = \"\"\n\n    if type(reclist).__name__ != 'list':\n        return \"\"\n    else:\n        for rec in reclist:\n            text = \"%s\\n%",
        "\n\ndef record_find_field_by_tag(rec, tag, field, strict=False):\n    \"\"\"\n    Return the global and local positions of the first occurrence of the field.\n\n    :param rec:    A record dictionary structure\n    :type  rec:    dictionary\n    :param tag:    The tag of the field to search for\n    :type  tag:    string\n    :param field:  A field tuple as returned by create_field()\n    :type  field:  tuple\n    :param strict: A boolean describing the search method. If strict\n                   is False, then the order of the subfields doesn't\n                   matter. Default search method is strict\n    :type  strict: boolean\n    :return:       A tuple of (global_position, local_position) or a\n                   tuple (None, None) if the field is not present.\n    :rtype:        tuple\n    :raise InvenioBibRecordFieldError: If the provided field is invalid.\n    \"\"\"\n    try:\n        _check_field_validity(field)\n    except InvenioBibRecordFieldError:\n        raise\n\n    for local_position, field1 in enumerate(rec.get(tag, [])):\n        if _compare_fields(field, field1, strict):\n            return (field1",
        "\n\ndef record_match_subfields_with_values(rec, tag, ind1=\" \", ind2=\" \", sub_key=None,\n                                    sub_value='', sub_key2=None, sub_value2='',\n                                    case_sensitive=True):\n    \"\"\"\n    Find subfield instances in a particular field.\n\n    It tests values in 1 of 3 possible ways:\n     - Does a subfield code exist? (ie does 773__a exist?)\n     - Does a subfield have a particular value? (ie 773__a == 'PhysX')\n     - Do a pair of subfields have particular values?\n        (ie 035__2 == 'CDS' and 035__a == '123456')\n\n    Parameters:\n     * rec - dictionary: a bibrecord structure\n     * tag - string: the tag of the field (ie '773')\n     * ind1, ind2 - char: a single characters for the MARC indicators\n     * sub_key - char: subfield key to find\n     * sub_value - string: subfield value of that key\n     * sub_key2 - char: key of subfield to compare against\n     * sub_value2 - string: expected value of second subfield\n     * case_sensitive - bool: be case sensitive when matching values\n\n    :return: false if",
        "]\n\n\ndef record_strip_empty_volatile_subfields_with_tags(rec):\n    \"\"\"Remove unchanged volatile subfields from the record with tags.\"\"\"\n    for tag in rec.keys():\n        for field in rec[tag]:\n            field[0][:] = [subfield for subfield in field[0]\n                           if subfield[1][:9] != \"VOLATILE:\"]\n\n\ndef record_strip_empty_volatile_subfields_with_tags_and_tags(rec):\n    \"\"\"Remove unchanged volatile subfields from the record with tags and tags.\"\"\"\n    for tag in rec.keys():\n        for field in rec[tag]:\n            field[0][:] = [subfield for subfield in field[0]\n                           if subfield[1][:9] != \"VOLATILE:\"]\n\n\ndef record_strip_empty_volatile_subfields_with_tags_and_tags_and_tags(rec):\n    \"\"\"Remove unchanged volatile subfields from the record with tags and tags and tags.\"\"\"\n    for tag in rec.keys():\n        for field in rec[tag]:\n            field[0][:] = [subfield for subfield in field[0]\n                           if subfield[1][:9] != \"VOLATILE:\"]\n\n\ndef record_strip_empty_volatile_subfields_with_tags",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n    # Check all tags\n    else:\n        rec[tag] = []\n\n    return rec\n\n\ndef create_field(subfields, value, name, type):\n    \"\"\"\n    Create a new field from a list of subfields and a value and a name and a type.\n\n    :param subfields:  A list of subfields\n    :type  subfields:  list\n    :param value:  The value of the field\n    :type  value:  string\n    :param name:  The name of the field\n    :type  name:  string\n    :param type:  The type of the field\n    :type  type:  string\n    :return:  A new field\n    :rtype:  tuple\n    \"\"\"\n    if type == 'control':\n        return (subfields, value, name, type)\n    else:\n        return (subfields, value, name, type, value)\n\n\ndef create_record(rec):\n    \"\"\"\n    Create a new record from a dictionary structure.\n\n    :param rec:  A record dictionary structure\n    :type  rec:  dictionary\n    :return:  A new record\n    :rtype:  tuple\n    \"\"\"\n    return (rec, rec)\n\n\ndef create_record_from_dict(rec",
        "\n\ndef record_strip_controlfields_from_record(rec):\n    \"\"\"\n    Remove all non-empty controlfields from the record.\n\n    :param rec:  A record dictionary structure\n    :type  rec:  dictionary\n    \"\"\"\n    for tag in rec.keys():\n        if tag[:2] == '00' and rec[tag][0][3]:\n            del rec[tag]\n\ndef record_strip_controlfields_from_record_with_fields(rec, fields):\n    \"\"\"\n    Remove all non-empty controlfields from the record.\n\n    :param rec:  A record dictionary structure\n    :type  rec:  dictionary\n    :param fields:  A list of strings\n    :type  fields:  list\n    \"\"\"\n    for tag in rec.keys():\n        if tag[:2] == '00' and rec[tag][0][3]:\n            del rec[tag]\n\n    for tag in fields:\n        if tag[:2] == '00' and rec[tag][0][3]:\n            del rec[tag]\n\ndef record_strip_controlfields_from_record_with_fields_and_fields_and_fields(rec, fields, fields_and_fields):\n    \"\"\"\n    Remove all non-empty controlfields from the record.\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\ndef _compare_fields_strict(field1, field2, strict=True):\n    \"\"\"\n    Compare 2 fields.\n\n    If strict is True, then the order of the subfield will be taken care of, if\n    not then the order of the subfields doesn't matter.\n\n    :return: True if the field are equivalent, False otherwise.\n    \"\"\"\n    if strict:\n        # Return a simple equal test on the field minus the position.\n        return field1[:4] == field2[:4]\n    else:\n        if field1[1:4] != field2[1:4]:\n            # Different indicators or controlfield value.\n            return False\n        else:\n            # Compare subfields in a loose way.\n            return set(field1[0]) == set(field2[0])\n\n\ndef _compare_fields_strict_strict(field1, field2, strict=True):\n    \"\"\"\n    Compare 2 fields.\n\n    If strict is True, then the order of the subfield will be taken care of, if\n    not then the order of the subfields doesn't matter.\n\n    :return: True if the field are equivalent, False otherwise.\n    \"\"\"\n    if strict:\n        # Return a simple equal test on the field minus the position.\n        return field1",
        "\n\n    if type(field[1]) is not str:\n        raise InvenioBibRecordFieldError(\n            \"Indicator 1 should be a string.\")\n\n    if type(field[2]) is not str:\n        raise InvenioBibRecordFieldError(\n            \"Indicator 2 should be a string.\")\n\n    if type(field[3]) is not str:\n        raise InvenioBibRecordFieldError(\n            \"Controlfield value should be a string.\")\n\n    if type(field[4]) is not int:\n        raise InvenioBibRecordFieldError(\n            \"Global position should be an int.\")\n\n    return field\n\ndef _check_record_validity(record):\n    \"\"\"\n    Check if a record is well-formed.\n\n    :param record: A record tuple as returned by create_record()\n    :type record:  tuple\n    :raise InvenioBibRecordError: If the record is invalid.\n    \"\"\"\n    if type(record) not in (list, tuple):\n        raise InvenioBibRecordError(\n            \"Record should be either a list or a tuple.\")\n\n    if len(record) != 5:\n        raise InvenioBibRecordError(\n            \"Record should have length '%d' \"",
        "\n\ndef _shift_field_positions_global_by_delta(record, start, delta=1):\n    \"\"\"\n    Shift all global field positions by delta.\n\n    Shift all global field positions with global field positions\n    higher or equal to 'start' from the value 'delta'.\n    \"\"\"\n    if not delta:\n        return\n\n    for tag, fields in record.items():\n        newfields = []\n        for field in fields:\n            if field[4] < start:\n                newfields.append(field)\n            else:\n                # Increment the global field position by delta.\n                newfields.append(tuple(list(field[:4]) + [field[4] + delta]))\n        record[tag] = newfields\n\ndef _shift_field_positions_global_by_delta_by_tag(record, start, delta=1):\n    \"\"\"\n    Shift all global field positions by delta by tag.\n\n    Shift all global field positions with global field positions\n    higher or equal to 'start' from the value 'delta'.\n    \"\"\"\n    if not delta:\n        return\n\n    for tag, fields in record.items():\n        newfields = []\n        for field in fields:\n            if field[4] < start:\n                newfields.append(field)\n            else:\n",
        "\n\ndef _tag_matches_pattern_with_wildcard(tag, pattern):\n    \"\"\"Return true if MARC 'tag' matches a 'pattern' with % as wildcard.\n\n    'pattern' is plain text, with % as wildcard\n\n    Both parameters must be 3 characters long strings.\n\n    .. doctest::\n\n        >>> _tag_matches_pattern_with_wildcard(\"909\", \"909\")\n        True\n        >>> _tag_matches_pattern_with_wildcard(\"909\", \"9%9\")\n        True\n        >>> _tag_matches_pattern_with_wildcard(\"909\", \"9%8\")\n        False\n\n    :param tag: a 3 characters long string\n    :param pattern: a 3 characters long string\n    :return: False or True\n    \"\"\"\n    for char1, char2 in zip(tag, pattern):\n        if char2 not in ('%', char1):\n            return False\n    return True\n\ndef _tag_matches_pattern_with_wildcard_and_wildcard(tag, pattern):\n    \"\"\"Return true if MARC 'tag' matches a 'pattern' with % as wildcard and\n    wildcard.\n\n    'pattern' is plain text, with % as wildcard\n\n    Both parameters must be 3 characters long strings.\n\n    .. doctest::\n\n",
        "\n            all_fields.append(field[4])\n    return None\n\n\ndef _validate_record_field_positions_local(record):\n    \"\"\"\n    Check if the local field positions in the record are valid.\n\n    I.e., no duplicate local field positions and global field positions in the\n    list of fields are ascending.\n\n    :param record: the record data structure\n    :return: the first error found as a string or None if no error was found\n    \"\"\"\n    all_fields = []\n    for tag, fields in record.items():\n        previous_field_position_local = -1\n        for field in fields:\n            if field[5] < previous_field_position_local:\n                return (\"Non ascending local field positions in tag '%s'.\" %\n                        tag)\n            previous_field_position_local = field[5]\n            if field[5] in all_fields:\n                return (\"Duplicate local field position '%d' in tag '%s'\" %\n                        (field[5], tag))\n            all_fields.append(field[5])\n    return None\n\n\ndef _validate_record_field_positions_all(record):\n    \"\"\"\n    Check if the global and local field positions in the record are valid.\n\n    I.e., no duplicate global and local field positions",
        "(record[tag])\n    return record\n\ndef _fields_sort_by_indicators(fields):\n    \"\"\"Sort the fields inside the record by indicators.\"\"\"\n    for field in fields:\n        field.sort_by_indicators()\n    return fields\n\ndef _record_sort_by_indicators_by_name(record):\n    \"\"\"Sort the fields inside the record by indicators by name.\"\"\"\n    for tag, fields in record.items():\n        record[tag] = _fields_sort_by_indicators_by_name(fields)\n    return record\n\ndef _fields_sort_by_indicators_by_name(fields):\n    \"\"\"Sort the fields inside the record by indicators by name.\"\"\"\n    for field in fields:\n        field.sort_by_indicators_by_name()\n    return fields\n\ndef _record_sort_by_indicators_by_name_by_value(record):\n    \"\"\"Sort the fields inside the record by indicators by name by value.\"\"\"\n    for tag, fields in record.items():\n        record[tag] = _fields_sort_by_indicators_by_name_by_value(fields)\n    return record\n\ndef _fields_sort_by_indicators_by_name_by_value(fields):\n    \"\"\"Sort the fields inside",
        "\n\ndef _fields_sort_by_indicators_by_position(fields):\n    \"\"\"Sort a set of fields by their indicators and position.\n\n    Return a sorted list with correct global field positions.\n    \"\"\"\n    field_dict = {}\n    field_positions_global = []\n    for field in fields:\n        field_dict.setdefault(field[1:3], []).append(field)\n        field_positions_global.append(field[4])\n\n    indicators = field_dict.keys()\n    indicators.sort()\n\n    field_list = []\n    for indicator in indicators:\n        for field in field_dict[indicator]:\n            field_list.append(field[:4] + (field_positions_global.pop(0),))\n\n    return field_list\n\ndef _fields_sort_by_indicators_by_position_by_indicator(fields):\n    \"\"\"Sort a set of fields by their indicators and position by indicator.\n\n    Return a sorted list with correct global field positions.\n    \"\"\"\n    field_dict = {}\n    field_positions_global = []\n    for field in fields:\n        field_dict.setdefault(field[1:3], []).append(field)\n        field_positions_global.append(field[4])\n\n    indicators",
        "\n\ndef _create_record_xml(marcxml,\n                       verbose=CFG_BIBRECORD_DEFAULT_VERBOSE_LEVEL,\n                       correct=CFG_BIBRECORD_DEFAULT_CORRECT,\n                       keep_singletons=CFG_BIBRECORD_KEEP_SINGLETONS):\n    \"\"\"\n    Create a record object using the XML parser.\n\n    If correct == 1, then perform DTD validation\n    If correct == 0, then do not perform DTD validation\n\n    If verbose == 0, the parser will not give warnings.\n    If 1 <= verbose <= 3, the parser will not give errors, but will warn\n        the user about possible mistakes (implement me!)\n    If verbose > 3 then the parser will be strict and will stop in case of\n        well-formedness errors or DTD errors.\n\n    \"\"\"\n    parser = etree.XMLParser(dtd_validation=correct,\n                             recover=(verbose <= 3))\n    try:\n        tree = etree.parse(StringIO(marcxml), parser)\n        # parser errors are located in parser.error_log\n        # if 1 <= verbose <=3 then show them to the user?\n        # if verbose == 0 then continue\n        # if verbose >3 then an exception will be thrown\n    except Exception as e:\n        raise InvenioBibRecordParser",
        "\n\ndef _get_children_by_tag_name_and_class(node, name, class_):\n    \"\"\"Retrieve all children from node 'node' with name 'name' and class 'class_'.\n\n    :param node: Node to retrieve children from.\n    :param name: Name of the node to retrieve children from.\n    :param class_: Name of the class to retrieve children from.\n    :return: List of children from node 'node' with name 'name' and class 'class_'.\n    \"\"\"\n    children = _get_children_by_tag_name(node, name)\n    return [child for child in children if child.nodeName == name and child.className == class_]\n\ndef _get_children_by_tag_name_and_class_and_id(node, name, class_, id):\n    \"\"\"Retrieve all children from node 'node' with name 'name' and class 'class_' and id 'id'.\n\n    :param node: Node to retrieve children from.\n    :param name: Name of the node to retrieve children from.\n    :param class_: Name of the class to retrieve children from.\n    :param id: Id of the node to retrieve children from.\n    :return: List of children from node 'node' with name 'name' and class '",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _correct_record_with_subfields(record):\n    \"\"\"\n    Check and correct the structure of the record with subfields.\n\n    :param record: the record data structure\n    :return: a list of errors found\n    \"\"\"\n    errors = []\n\n    for tag in record.keys():\n        upper_bound = '999'\n        n = len(tag)\n\n        if n > 3:\n            i = n - 3\n            while i > 0:\n                upper_bound = '%s%s' % ('0', upper_bound)\n                i -= 1\n\n        # Missing tag. Replace it with dummy tag '000'.\n        if tag == '!':\n            errors.append((1, '(field number(s): ' +\n                              str([f[4] for f in record[tag]]) + ')'))\n            record['000'] = record.pop(tag)\n            tag = '000'\n        elif not ('001' <= tag <= upper_bound or\n                  tag in ('FMT', 'FFT', 'BDR', 'BDM')):\n            errors.append(2)\n            record['000'] = record.pop(tag)\n            tag = '000'\n\n        fields = []\n        for subfield in record[tag]:\n            # Datafield without any subfield.\n",
        "\n\ndef _warning_msg(code):\n    \"\"\"\n    Return a warning message of code 'code'.\n\n    If code = (cd, str) it returns the warning message of code 'cd' and appends\n    str at the end\n    \"\"\"\n    if isinstance(code, str):\n        return code\n\n    message = ''\n    if isinstance(code, tuple):\n        if isinstance(code[0], str):\n            message = code[1]\n            code = code[0]\n    return CFG_BIBRECORD_WARNING_MSGS.get(code, '') + message\n\ndef _warning_msg_with_args(code, *args):\n    \"\"\"\n    Return a warning message of code 'code' with arguments 'args'.\n\n    If code = (cd, str) it returns the warning message of code 'cd' and appends\n    str at the end\n    \"\"\"\n    if isinstance(code, str):\n        return code\n\n    message = ''\n    if isinstance(code, tuple):\n        if isinstance(code[0], str):\n            message = code[1]\n            code = code[0]\n    return CFG_BIBRECORD_WARNING_MSGS.get(code, '') + message + ' ' + ' '.join(args)\n\ndef _warning_msg_with_args_with",
        "\n\n\ndef _compare_lists_with_custom_cmp(list1, list2, custom_cmp):\n    \"\"\"Compare twolists using given comparing function.\n\n    :param list1: first list to compare\n    :param list2: second list to compare\n    :param custom_cmp: a function taking two arguments (element of\n        list 1, element of list 2) and\n    :return: True or False depending if the values are the same\n    \"\"\"\n    if len(list1) != len(list2):\n        return False\n    for element1, element2 in zip(list1, list2):\n        if not custom_cmp(element1, element2):\n            return False\n    return True\n\n\ndef _compare_lists_with_custom_cmp_with_custom_cmp(list1, list2, custom_cmp,\n                                                custom_cmp_with_custom_cmp):\n    \"\"\"Compare twolists using given comparing function.\n\n    :param list1: first list to compare\n    :param list2: second list to compare\n    :param custom_cmp: a function taking two arguments (element of\n        list 1, element of list 2) and\n    :param custom_cmp_with_custom_cmp: a function taking two arguments (element of\n        list 1, element of list 2",
        "\n\n        self.logger.debug(\"Parsed %s records.\" % len(self.records))\n\n    def create_deleted_record(self, record):\n        \"\"\"Create a special record with a deleted OAI record.\"\"\"\n        deleted_record = ET.Element('record')\n        deleted_record.set('deleted', 'true')\n        deleted_record.set('id', record.get('id'))\n        deleted_record.set('name', record.get('name'))\n        deleted_record.set('type', record.get('type'))\n        deleted_record.set('created', record.get('created'))\n        deleted_record.set('modified', record.get('modified'))\n        deleted_record.set('deleted', 'true')\n        deleted_record.set('deleted_by', record.get('deleted_by'))\n        deleted_record.set('deleted_on', record.get('deleted_on'))\n        deleted_record.set('deleted_on_date', record.get('deleted_on_date'))\n        deleted_record.set('deleted_on_time', record.get('deleted_on_time'))\n        deleted_record.set('deleted_on_zone', record.get('deleted_on_zone'))\n        deleted_record.set('deleted_on_zone_id', record.get('",
        "\n\ndef strip_xml_namespace(root):\n        \"\"\"Strip XML namespaces from an ElementTree.\n\n        :param root: ElementTree to strip namespaces from\n        \"\"\"\n        for child in root.iter():\n                if child.tag == \"xml\":\n                        child.tag = \"xml:root\"\n                        child.attrib = {}\n                        child.attrib[\"xmlns\"] = \"\"\n                        child.attrib[\"xmlns:xsi\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation:xsi\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation:xsi:schemaLocation\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation:xsi:schemaLocation:xsi\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation:xsi:schemaLocation:xsi\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation:xsi:schemaLocation:xsi\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation:xsi:schemaLocation:xsi\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation:xsi:schemaLocation:xsi\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation:xsi:schemaLocation:xsi\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation:xsi:schemaLocation:xsi\"] = \"\"\n                        child.attrib[\"xsi:schemaLocation:xsi:schemaLocation:xsi\"]",
        "\n\ndef create_deleted_record_with_fields(self, record):\n        \"\"\"Generate the record deletion if deleted form OAI-PMH.\"\"\"\n        identifier = record_get_field_value(record,\n                                            tag=\"037\",\n                                            code=\"a\")\n        recid = identifier.split(\":\")[-1]\n        try:\n            source = identifier.split(\":\")[1]\n        except IndexError:\n            source = \"Unknown\"\n        record_add_field(record, \"035\",\n                         subfields=[(\"9\", source), (\"a\", recid)])\n        record_add_field(record, \"980\",\n                         subfields=[(\"c\", \"DELETED\")])\n        return record\n\ndef create_deleted_record_with_fields_and_fields(self, record):\n        \"\"\"Generate the record deletion if deleted form OAI-PMH.\"\"\"\n        identifier = record_get_field_value(record,\n                                            tag=\"037\",\n                                            code=\"a\")\n        recid = identifier.split(\":\")[-1]\n        try:\n            source = identifier.split(\":\")[1]\n        except IndexError:\n            source = \"Unknown\"\n        record_add_field(record, \"035\",\n                         subfields=[(\"9\", source), (\"a",
        ".get(self._login_url)\n\n\nclass YesssSMS(object):\n    \"\"\"\n    A class for interacting with yesss.at.\n    \"\"\"\n\n    def __init__(self, username, password, session=None):\n        \"\"\"\n        Initialize the yesss.at client.\n\n        :param username: The username of the user.\n        :param password: The password of the user.\n        :param session: The session to use for requests.\n        \"\"\"\n        self._username = username\n        self._password = password\n        self._session = session\n        self._logindata = {\n            'username': self._username,\n            'password': self._password,\n        }\n        self._login_url = 'https://yesss.at/login'\n        self._suspended = False\n\n    def login(self, session=None):\n        \"\"\"\n        Login to yesss.at.\n\n        :param session: The session to use for requests.\n        :return: A tuple of (session, req)\n        \"\"\"\n        return _login(self, session)\n\n    def logout(self, session=None):\n        \"\"\"\n        Logout from yesss.at.\n\n        :param session: The session to use for requests.\n        :return",
        "\n\ndef login_data_invalid(self):\n        \"\"\"Check for invalid login data.\"\"\"\n        login_working = False\n        try:\n            with self._login(requests.Session()) as sess:\n                sess.get(self._login_url)\n        except self.LoginError:\n            pass\n        else:\n            login_working = True\n        return login_working\n\ndef login_data_expired(self):\n        \"\"\"Check for expired login data.\"\"\"\n        login_working = False\n        try:\n            with self._login(requests.Session()) as sess:\n                sess.get(self._login_url)\n        except self.LoginError:\n            pass\n        else:\n            login_working = True\n        return login_working\n\ndef login_data_expired_with_token(self, token):\n        \"\"\"Check for expired login data.\"\"\"\n        login_working = False\n        try:\n            with self._login(requests.Session()) as sess:\n                sess.get(self._login_url, params={'token': token})\n        except self.LoginError:\n            pass\n        else:\n            login_working = True\n        return login_working\n\ndef login_data_expired_with_email(self, email):\n        \"\"\"Check for expired login data.\"\"\"\n        login_working",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\nclass BibRecordPackage(object):\n    \"\"\"A class for parsing MARCXML files.\n\n    This class is a wrapper around the MARCXML package class.\n    \"\"\"\n\n    def __init__(self, source):\n        self.source = source\n        self.parse()\n\n    def parse(self):\n        \"\"\"Parse the MARCXML file and return a BibRecordPackage object.\n\n        This method is a wrapper around the MARCXML package class.\n        \"\"\"\n        self.bibrecs = BibRecordPackage(self.source)\n        self.bibrecs.parse()\n        return self\n\n    def get_records(self):\n        \"\"\"Return a list of BibRecord objects.\n\n        This method is a wrapper around the MARCXML package class.\n        \"\"\"\n        return self.bibrecs.get_records()\n\n    def get_record(self, record_id):\n        \"\"\"Return a BibRecord object.\n\n        This method is a wrapper around the MARCXML package class.\n        \"\"\"\n        return self.bibrecs.get_record(record_id)\n\n    def get_record_by_id(self, record_id):\n        \"\"\"Return a BibRecord object.\n\n        This method is a wrapper around the M",
        ".lower()\n\ndef get_config_item_by_name(cls, key, kb_name):\n        \"\"\"Return the opposite mapping by searching the imported KB.\"\"\"\n        config_dict = cls.kbs.get(kb_name, None)\n        if config_dict:\n            if key in config_dict:\n                return config_dict[key]\n        return key\n\ndef get_config_item_by_name_and_type(cls, key, kb_name, type_):\n        \"\"\"Return the opposite mapping by searching the imported KB.\"\"\"\n        config_dict = cls.kbs.get(kb_name, None)\n        if config_dict:\n            if key in config_dict and type_ in config_dict:\n                return config_dict[key]\n        return key\n\ndef get_config_item_by_name_and_type_and_value(cls, key, kb_name, type_, value):\n        \"\"\"Return the opposite mapping by searching the imported KB.\"\"\"\n        config_dict = cls.kbs.get(kb_name, None)\n        if config_dict:\n            if key in config_dict and type_ in config_dict and value in config_dict:\n                return config_dict[key]\n        return key\n\ndef get_config_item_by",
        "\n\ndef save_config(from_key, to_key, kbs):\n        \"\"\"Save configuration to config.\n\n        Meant to run only once per system process as\n        class variable in subclasses.\"\"\"\n        from .mappings import mappings\n        kbs['config'] = mappings['config']\n        return kbs\n",
        ", of=\"id\")\n\ndef get_record(self, recid):\n        \"\"\"Get a record by its ID.\"\"\"\n        return self.record[\"001\"][0][3] == recid\n\ndef get_record_by_id(self, recid):\n        \"\"\"Get a record by its ID.\"\"\"\n        return self.record[\"001\"][0][3] == recid\n\ndef get_record_by_name(self, name):\n        \"\"\"Get a record by its name.\"\"\"\n        return self.record[\"001\"][0][3] == name\n\ndef get_record_by_name_and_id(self, name, recid):\n        \"\"\"Get a record by its name and ID.\"\"\"\n        return self.record[\"001\"][0][3] == name and recid == recid\n\ndef get_record_by_name_and_id_and_type(self, name, recid, type):\n        \"\"\"Get a record by its name and ID and type.\"\"\"\n        return self.record[\"001\"][0][3] == name and recid == recid and type == type\n\ndef get_record_by_name_and_id_and_type_and_id(self, name, recid, type, id):\n        \"\"\"Get a record by its name and ID and type",
        "\n\ndef record_delete_fields(self, record, tag):\n        \"\"\"Delete fields from record.\"\"\"\n        for field in record.keys():\n            if field not in self.fields_list:\n                record.pop(field, None)\n\ndef record_delete_all_fields(self):\n        \"\"\"Delete all fields from record.\"\"\"\n        for field in self.record.keys():\n            record.pop(field, None)\n\ndef record_delete_all_fields_with_tags(self, tags):\n        \"\"\"Delete all fields from record with tags.\"\"\"\n        for field in self.record.keys():\n            if field in tags:\n                record.pop(field, None)\n\ndef record_delete_all_fields_without_tags(self):\n        \"\"\"Delete all fields from record without tags.\"\"\"\n        for field in self.record.keys():\n            if field not in self.fields_list:\n                record.pop(field, None)\n\ndef record_delete_all_fields_with_tags_and_values(self, tags, values):\n        \"\"\"Delete all fields from record with tags and values.\"\"\"\n        for field in self.record.keys():\n            if field in tags and values in record.get(field, []):\n                record.pop(field, None)\n\ndef record_delete_",
        "\n\ndef record_delete_fields(self, record, tag):\n        \"\"\"Delete a record field from the record.\"\"\"\n        if tag in self.fields_list:\n            record.pop(tag)\n\ndef record_delete_all_fields(self):\n        \"\"\"Delete all fields from the record.\"\"\"\n        for tag in self.record.keys():\n            record_delete_fields(self.record, tag)\n\ndef record_delete_all_tags(self):\n        \"\"\"Delete all tags from the record.\"\"\"\n        for tag in self.record.keys():\n            record_delete_tags(self.record, tag)\n\ndef record_delete_tags(self, record, tag):\n        \"\"\"Delete a record tag from the record.\"\"\"\n        if tag in self.tags_list:\n            record.pop(tag)\n\ndef record_delete_all_tags_and_fields(self):\n        \"\"\"Delete all tags and fields from the record.\"\"\"\n        for tag in self.record.keys():\n            record_delete_tags_and_fields(self.record, tag)\n\ndef record_delete_all_tags_and_fields_and_tags(self):\n        \"\"\"Delete all tags and fields and tags from the record.\"\"\"\n        for tag in self.record.keys():\n            record_delete_tags_and",
        "\n\ndef add_systemnumber_from_recid(self, recid):\n        \"\"\"Add 035 number from 001 recid with given source.\"\"\"\n        if not recid:\n            recid = self.get_recid()\n        if not self.hidden and recid:\n            record_add_field(\n                self.record,\n                tag='035',\n                subfields=[('9', '0'), ('a', recid)]\n            )\n\ndef add_systemnumber_from_source(self, source):\n        \"\"\"Add 035 number from 001 recid with given source.\"\"\"\n        if not self.hidden and source:\n            record_add_field(\n                self.record,\n                tag='035',\n                subfields=[('9', source)]\n            )\n\ndef add_systemnumber_from_source_and_recid(self, source, recid):\n        \"\"\"Add 035 number from 001 recid with given source and recid.\"\"\"\n        if not self.hidden and source and recid:\n            record_add_field(\n                self.record,\n                tag='035',\n                subfields=[('9', source), ('a', recid)]\n            )\n\ndef add_systemnumber_from_source_and_recid_and_source(self",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        record_delete_fields(self.record, \"650\")\n\ndef update_subject_categories_with_subfields(self, primary, secondary, kb):\n        \"\"\"650 Translate Categories with Subfields.\"\"\"\n        category_fields = record_get_field_instances(self.record,\n                                                     tag='650',\n                                                     ind1='1',\n                                                     ind2='7')\n        record_delete_fields(self.record, \"650\")\n        for field in category_fields:\n            for idx, (key, value) in enumerate(field[0]):\n                if key == 'a':\n                    new_value = self.get_config_item(value, kb)\n                    if new_value != value:\n                        new_subs = [('2', secondary), ('a', new_value)]\n                    else:\n                        new_subs = [('2', primary), ('a', value)]\n                    record_add_field(self.record, \"650\", ind1=\"1\", ind2=\"7\",\n                                     subfields=new_subs)\n                    break\n        record_delete_fields(self.record, \"650\")\n\ndef update_subject_categories_with_subfields_with_subfields(self, primary, secondary, kb):\n        \"\"\"650 Translate Categories with Sub",
        ", password=self._passwd)\n\ndef disconnect(self):\n        \"\"\" Disconnects from the server. \"\"\"\n        self._ftp.quit()\n\ndef list_files(self):\n        \"\"\" Returns a list of all files in the server. \"\"\"\n        return self._ftp.listdir()\n\ndef list_directories(self):\n        \"\"\" Returns a list of all directories in the server. \"\"\"\n        return self._ftp.listdir()\n\ndef list_files_in_directory(self, directory):\n        \"\"\" Returns a list of all files in the directory. \"\"\"\n        return self._ftp.listdir(directory)\n\ndef list_directories_in_directory(self, directory):\n        \"\"\" Returns a list of all directories in the directory. \"\"\"\n        return self._ftp.listdir(directory)\n\ndef list_files_in_directory_with_extension(self, directory, extension):\n        \"\"\" Returns a list of all files in the directory with the given extension. \"\"\"\n        return self._ftp.listdir(directory, extension)\n\ndef list_directories_in_directory_with_extension(self, directory, extension):\n        \"\"\" Returns a list of all directories in the directory with the given extension. \"\"\"\n        return self._ftp.listdir(directory, extension)\n\ndef list_files_in_directory_with_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n                else:\n                    self._ftp.cwd(folder)\n\ndef cd_to(self, folder):\n        \"\"\" Changes the working directory on the server.\n\n        :param folder: the desired directory.\n        :type folder: string\n        \"\"\"\n        if folder.startswith('/'):\n            self._ftp.cwd(folder)\n        else:\n            for subfolder in folder.split('/'):\n                if subfolder:\n                    self._ftp.cwd(subfolder)\n\ndef cd_to_root(self):\n        \"\"\" Changes the working directory on the server.\n\n        :param folder: the desired directory.\n        :type folder: string\n        \"\"\"\n        self._ftp.cwd('/')\n\ndef cd_to_subfolder(self, subfolder):\n        \"\"\" Changes the working directory on the server.\n\n        :param subfolder: the desired directory.\n        :type subfolder: string\n        \"\"\"\n        self._ftp.cwd(subfolder)\n\ndef cd_to_subfolder_root(self, subfolder):\n        \"\"\" Changes the working directory on the server.\n\n        :param subfolder: the desired directory.\n        :type subfolder: string\n        \"\"\"\n        self._ftp.cwd(subfolder + '/')\n\ndef cd_to_subfolder_root_root(self, subfolder):\n       ",
        "\n\ndef cd(self, folder=''):\n        \"\"\" Changes the current working directory to a specific folder\n        default is the current working directory.\n\n        :param folder: the folder to be changed.\n        :type folder: string\n\n        :returns: a tuple with the new working directory.\n        \"\"\"\n        current_folder = self._ftp.pwd()\n        self.cd(folder)\n        self._ftp.cwd(current_folder)\n        return current_folder\n\ndef cd_to(self, folder=''):\n        \"\"\" Changes the current working directory to a specific folder\n        default is the current working directory.\n\n        :param folder: the folder to be changed.\n        :type folder: string\n\n        :returns: a tuple with the new working directory.\n        \"\"\"\n        current_folder = self._ftp.pwd()\n        self.cd(folder)\n        self._ftp.cwd(current_folder)\n        return current_folder\n\ndef cd_to_parent(self, folder=''):\n        \"\"\" Changes the current working directory to a specific folder\n        default is the current working directory.\n\n        :param folder: the folder to be changed.\n        :type folder: string\n\n        :returns: a tuple with the new working directory.\n        \"\"\"\n        current_folder = self._ftp.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n                print('550 Delete operation failed folder %s '\n                      'does not exist!' % (foldername,))\n        else:\n            print('550 Delete operation failed folder %s '\n                  'does not exist!' % (foldername,))\n\ndef ls(self):\n        \"\"\" List all files in the server.\n\n        :return: list of files in the server.\n        :rtype: list of string\n        \"\"\"\n        contents = self._ftp.ls()\n        return contents\n\ndef mkdir(self, foldername):\n        \"\"\" Create a folder in the server.\n\n        :param foldername: the folder to be created.\n        :type foldername: string\n        \"\"\"\n        current_folder = self._ftp.pwd()\n        try:\n            self.cd(foldername)\n        except error_perm:\n            print('550 Create operation failed folder %s '\n                  'does not exist!' % (foldername,))\n        else:\n            self.cd(current_folder)\n            try:\n                self._ftp.mkdir(foldername)\n            except error_perm:  # folder not empty\n                self.cd(foldername)\n                contents = self.ls()\n                #create the files\n                map(self._ftp.mkdir, contents[0])\n                #create the sub",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef parse_text(self, text, maxwidth, maxheight, template_dir, context,\n               urlize_all_links):\n        \"\"\"\n        Parses a block of text indiscriminately\n        \"\"\"\n        # create a dictionary of user urls -> rendered responses\n        replacements = {}\n        user_urls = set(re.findall(URL_RE, text))\n        \n        for user_url in user_urls:\n            try:\n                resource = oembed.site.embed(user_url, maxwidth=maxwidth, maxheight=maxheight)\n            except OEmbedException:\n                if urlize_all_links:\n                    replacements[user_url] = '<a href=\"%(LINK)s\">%(LINK)s</a>' % {'LINK': user_url}\n            else:\n                context['minwidth'] = min(maxwidth, resource.width)\n                context['minheight'] = min(maxheight, resource.height)\n                \n                replacement = self.render_oembed(\n                    resource, \n                    user_url, \n                    template_dir=template_dir, \n                    context=context\n                )\n                replacements[user_url] = replacement.strip()\n        \n        # go through the text recording URLs that can be replaced\n        # taking note of their start & end indexes",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef renew_token():\n    \"\"\"\n    Renew the token for the current session.\n\n    :returns: API token.\n    :rtype: string\n    \"\"\"\n    token = session.communicator.get_token(session.email)\n    session.token = token\n    return token\n\ndef logout():\n    \"\"\"\n    Logout the current session.\n\n    :returns: None.\n    :rtype: None\n    \"\"\"\n    session.communicator.logout()\n    session.token = None\n\ndef get_token():\n    \"\"\"\n    Get the current token.\n\n    :returns: API token.\n    :rtype: string\n    \"\"\"\n    return session.token\n\ndef get_api_key():\n    \"\"\"\n    Get the current API key.\n\n    :returns: API key.\n    :rtype: string\n    \"\"\"\n    return session.api_key\n\ndef get_application():\n    \"\"\"\n    Get the current application.\n\n    :returns: Application name.\n    :rtype: string\n    \"\"\"\n    return session.application\n\ndef get_email():\n    \"\"\"\n    Get the current email.\n\n    :returns: Email address.\n    :rtype: string\n    \"\"\"\n    return session.email\n\ndef get_url():",
        "\n\ndef get_token():\n    \"\"\"\n    Get the token from the Midas Server instance.\n\n    :returns: API token.\n    :rtype: string\n    \"\"\"\n    session.token = session.communicator.login_with_api_key(\n        session.email, session.api_key, application=session.application)\n    return session.token\n\ndef get_token_from_otp():\n    \"\"\"\n    Get the token from the Midas Server instance.\n\n    :returns: API token.\n    :rtype: string\n    \"\"\"\n    session.token = session.communicator.mfa_otp_login(\n        session.token, getpass.getpass('One-Time Password: '))\n    return session.token\n\ndef get_token_from_otp_with_password(password):\n    \"\"\"\n    Get the token from the Midas Server instance.\n\n    :returns: API token.\n    :rtype: string\n    \"\"\"\n    session.token = session.communicator.mfa_otp_login(\n        session.token, password)\n    return session.token\n\ndef get_token_from_otp_with_password_and_otp_id(password, otp_id):\n    \"\"\"\n    Get",
        "\n\ndef _create_or_reuse_folder(local_folder, parent_folder_id, reuse_existing=False):\n    \"\"\"\n    Create an item from the local folder in the Midas Server folder corresponding\n    to the parent folder id.\n\n    :param local_folder: full path to a folder on the local file system\n    :type local_folder: string\n    :param parent_folder_id: id of parent folder on the Midas Server instance,\n        where the item will be added\n    :type parent_folder_id: int | long\n    :param reuse_existing: (optional) whether to accept an existing folder of the\n        same name in the same location, or create a new one instead\n    :type reuse_existing: bool\n    \"\"\"\n    local_item_name = os.path.basename(local_folder)\n    item_id = None\n    if reuse_existing:\n        # check by name to see if the item already exists in the folder\n        children = session.communicator.folder_children(\n            session.token, parent_folder_id)\n        items = children['items']\n\n        for item in items:\n            if item['name'] == local_item_name:\n                item_id = item['item_id']\n                break\n\n    if item_",
        "\n\ndef _create_or_reuse_file(local_file, parent_folder_id,\n                         reuse_existing=False):\n    \"\"\"\n    Create a file from the local file in the midas folder corresponding to\n    the parent folder id.\n\n    :param local_file: full path to a file on the local file system\n    :type local_file: string\n    :param parent_folder_id: id of parent folder on the Midas Server instance,\n        where the file will be added\n    :type parent_folder_id: int | long\n    :param reuse_existing: (optional) whether to accept an existing file of\n       the same name in the same location, or create a new one instead\n    :type reuse_existing: bool\n    \"\"\"\n    local_file_name = os.path.basename(local_file)\n    file_id = None\n    if reuse_existing:\n        # check by name to see if the file already exists in the file\n        children = session.communicator.file_children(\n            session.token, parent_folder_id)\n        files = children['files']\n\n        for file in files:\n            if file['name'] == local_file_name:\n                file_id = file['file_id']\n                break\n\n    if file_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\ndef _get_folder_id_for_path(parsed_path):\n    \"\"\"\n    Get the folder id for a given path.\n\n    :param parsed_path: a list of folders from top to bottom of a hierarchy\n    :type parsed_path: list[string]\n    :returns: The id of the found folder or -1\n    :rtype: int | long\n    \"\"\"\n    if len(parsed_path) == 0:\n        return -1\n\n    session.token = verify_credentials()\n\n    base_folder = session.communicator.folder_get(session.token,\n                                                  parsed_path[0])\n    cur_folder_id = -1\n    for path_part in parsed_path[1:]:\n        cur_folder_id = base_folder['folder_id']\n        cur_children = session.communicator.folder_children(\n            session.token, cur_folder_id)\n        for inner_folder in cur_children['folders']:\n            if inner_folder['name'] == path_part:\n                base_folder = session.communicator.folder_get(\n                    session.token, inner_folder['folder_id'])\n                cur_folder_id = base_folder['folder_id']\n                break\n        else:\n",
        "\n\n\ndef _search_item_or_folder_for_item(name, item_id):\n    \"\"\"\n    Find an item or folder matching the name. A folder will be found first if\n    both are present.\n\n    :param name: The name of the resource\n    :type name: string\n    :param item_id: The item to search within\n    :type item_id: int | long\n    :returns: A tuple indicating whether the resource is an item an the id of\n        said resource. i.e. (True, item_id) or (False, folder_id)\n    :rtype: (bool, int | long)\n    \"\"\"\n    session.token = verify_credentials()\n\n    children = session.communicator.item_children(session.token, item_id)\n    for folder in children['folders']:\n        if folder['name'] == name:\n            return False, folder['folder_id']  # Found a folder\n    for item in children['items']:\n        if item['name'] == name:\n            return True, item['item_id']  # Found an item\n    return False, -1\n\n\ndef _search_item_or_folder_for_folder(name, folder_id):\n    \"\"\"\n    Find an item or folder matching the",
        "\n\n\ndef _search_folder_for_item_or_folder(end, leaf_folder_id):\n    \"\"\"\n    Search for an item or folder in a given path.\n\n    :param end: The virtual path on the server.\n    :type end: string\n    :param leaf_folder_id: The folder id of the leaf folder.\n    :type leaf_folder_id: long\n    :returns: The folder id of the item or folder.\n    :rtype: long\n    \"\"\"\n    if end == '':\n        return leaf_folder_id\n    if end.startswith('/'):\n        end = end[1:]\n    if end.startswith('/' + leaf_folder_id):\n        return leaf_folder_id\n    else:\n        return -1\n\n\ndef _descend_folder_for_id(parsed_path, leaf_folder_id):\n    \"\"\"\n    Search for a folder in a given path.\n\n    :param parsed_path: The virtual path on the server.\n    :type parsed_path: list\n    :param leaf_folder_id: The folder id of the leaf folder.\n    :type leaf_folder_id: long\n    :returns: The folder id of the folder or item.\n    :rtype: long\n    \"\"\"\n    if",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef list_user_folders_by_name(self, token, folder_name):\n        \"\"\"\n        List the folders in the users home area.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_name: The name of the folder to list.\n        :type folder_name: string\n        :returns: List of dictionaries containing folder information.\n        :rtype: list[dict]\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['folder_name'] = folder_name\n        response = self.request('midas.user.folders', parameters)\n        return response\n\ndef list_user_folders_by_name_and_type(self, token, folder_name, folder_type):\n        \"\"\"\n        List the folders in the users home area.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_name: The name of the folder to list.\n        :type folder_name: string\n        :param folder_type: The type of folder to list.\n        :type folder_type: string\n        :returns: List of dictionaries containing folder information.\n        :rtype: list[dict]\n        \"\"\"\n        parameters =",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_user(self, user_id):\n        \"\"\"\n        Get a user by id.\n\n        :param user_id: The user id.\n        :type user_id: str\n        :returns: The user.\n        :rtype: dict\n        \"\"\"\n        response = self.request('midas.user.get', {'user_id': user_id})\n        return response\n\ndef create_user(self, user_data):\n        \"\"\"\n        Create a new user.\n\n        :param user_data: The user data.\n        :type user_data: dict\n        :returns: The user.\n        :rtype: dict\n        \"\"\"\n        response = self.request('midas.user.create', user_data)\n        return response\n\ndef update_user(self, user_id, user_data):\n        \"\"\"\n        Update a user.\n\n        :param user_id: The user id.\n        :type user_id: str\n        :param user_data: The user data.\n        :type user_data: dict\n        :returns: The user.\n        :rtype: dict\n        \"\"\"\n        response = self.request('midas.user.update', {'user_id': user_id, 'user_data': user_data})\n",
        "\ndef get_user_by_username(self, username):\n        \"\"\"\n        Get a user by the username of that user.\n\n        :param username: The username of the desired user.\n        :type username: string\n        :returns: The user requested.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['username'] = username\n        response = self.request('midas.user.get', parameters)\n        return response\n\ndef get_user_by_id(self, id):\n        \"\"\"\n        Get a user by the id of that user.\n\n        :param id: The id of the desired user.\n        :type id: int\n        :returns: The user requested.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['id'] = id\n        response = self.request('midas.user.get', parameters)\n        return response\n\ndef get_user_by_name(self, name):\n        \"\"\"\n        Get a user by the name of that user.\n\n        :param name: The name of the desired user.\n        :type name: string\n        :returns: The user requested.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['name'] = name\n        response = self.",
        "\n\ndef update_community(self, token, community_id, **kwargs):\n        \"\"\"\n        Update an existing community.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param community_id: The community id.\n        :type community_id: string\n        :param name: The community name.\n        :type name: string\n        :param description: (optional) The community description.\n        :type description: string\n        :param privacy: (optional) Default 'Public', possible values\n            [Public|Private].\n        :type privacy: string\n        :param can_join: (optional) Default 'Everyone', possible values\n            [Everyone|Invitation].\n        :type can_join: string\n        :returns: The community dao that was updated.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['community_id'] = community_id\n        optional_keys = ['name', 'description', 'privacy', 'can_join']\n        for key in optional_keys:\n            if key in kwargs:\n                parameters[key] = kwargs[key]\n        response = self.request('midas.community.update', parameters)\n        return response\n\ndef delete_community(self, token",
        "\n\ndef get_community_by_id(self, id, token=None):\n        \"\"\"\n        Get a community based on its ID.\n\n        :param id: The ID of the target community.\n        :type id: int\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: The requested community.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['id'] = id\n        if token:\n            parameters['token'] = token\n        response = self.request('midas.community.get', parameters)\n        return response\n\ndef get_community_by_name_and_id(self, name, id, token=None):\n        \"\"\"\n        Get a community based on its name and ID.\n\n        :param name: The name of the target community.\n        :type name: string\n        :param id: The ID of the target community.\n        :type id: int\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: The requested community.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['name'] = name\n        parameters['id'] = id\n        if",
        "\n\ndef get_community_by_name(self, community_name, token=None):\n        \"\"\"\n        Get a community based on its name.\n\n        :param community_name: The name of the target community.\n        :type community_name: str\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: The requested community.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['name'] = community_name\n        if token:\n            parameters['token'] = token\n        response = self.request('midas.community.get', parameters)\n        return response\n\ndef get_community_by_slug(self, community_slug, token=None):\n        \"\"\"\n        Get a community based on its slug.\n\n        :param community_slug: The slug of the target community.\n        :type community_slug: str\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: The requested community.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['slug'] = community_slug\n        if token:\n            parameters['token'] = token\n        response = self.request('midas",
        "\n\ndef get_community_children_by_name(self, community_name, token=None):\n        \"\"\"\n        Get the non-recursive children of the passed in community_name.\n\n        :param community_name: The name of the requested community.\n        :type community_name: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: List of the folders in the community.\n        :rtype: dict[string, list]\n        \"\"\"\n        parameters = dict()\n        parameters['name'] = community_name\n        if token:\n            parameters['token'] = token\n        response = self.request('midas.community.children', parameters)\n        return response\n\ndef get_community_children_by_id(self, community_id, token=None):\n        \"\"\"\n        Get the non-recursive children of the passed in community_id.\n\n        :param community_id: The id of the requested community.\n        :type community_id: int | long\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: List of the folders in the community.\n        :rtype: dict[string, list]\n        \"\"\"\n        parameters",
        "\n\ndef get_community(self, community_id, token=None):\n        \"\"\"\n        Get a community.\n\n        :param community_id: The ID of the community to get.\n        :type community_id: int\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: The community.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        if token:\n            parameters['token'] = token\n        response = self.request('midas.community.get', parameters, community_id)\n        return response\n\ndef create_community(self, community_name, token=None):\n        \"\"\"\n        Create a community.\n\n        :param community_name: The name of the community to create.\n        :type community_name: str\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: The community.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        if token:\n            parameters['token'] = token\n        response = self.request('midas.community.create', parameters, community_name)\n        return response\n\ndef update_community(self, community_id, community_name,",
        "\n\ndef folder_list(self, token, folder_id):\n        \"\"\"\n        Get the list of folders.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the requested folder.\n        :type folder_id: int | long\n        :returns: List of folders.\n        :rtype: list\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['id'] = folder_id\n        response = self.request('midas.folder.list', parameters)\n        return response\n\ndef folder_create(self, token, folder_name, folder_description, folder_type, folder_parent_id, folder_parent_name, folder_parent_description, folder_parent_type, folder_parent_parent_id, folder_parent_parent_name, folder_parent_parent_description, folder_parent_parent_type, folder_parent_parent_parent_id, folder_parent_parent_parent_name, folder_parent_parent_parent_description, folder_parent_parent_parent_type, folder_parent_parent_parent_id, folder_parent_parent_parent_name, folder_parent_parent_parent_description, folder_parent_parent_parent_type, folder",
        "\n\ndef folder_children_by_name(self, token, folder_name):\n        \"\"\"\n        Get the non-recursive children of the passed in folder_name.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_name: The name of the requested folder.\n        :type folder_name: string\n        :returns: Dictionary of two lists: 'folders' and 'items'.\n        :rtype: dict[string, list]\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['name'] = folder_name\n        response = self.request('midas.folder.children', parameters)\n        return response\n\ndef folder_children_by_id(self, token, folder_id):\n        \"\"\"\n        Get the non-recursive children of the passed in folder_id.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the requested folder.\n        :type folder_id: int | long\n        :returns: Dictionary of two lists: 'folders' and 'items'.\n        :rtype: dict[string, list]\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['",
        "\n\ndef get_folder(self, token, folder_id):\n        \"\"\"\n        Get the folder with the passed in folder_id.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the folder to be retrieved.\n        :type folder_id: int | long\n        :returns: The folder with the passed in folder_id.\n        :rtype: MidasFolder\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['id'] = folder_id\n        response = self.request('midas.folder.get', parameters)\n        return response\n\ndef get_folders(self, token):\n        \"\"\"\n        Get all the folders in the system.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :returns: A list of MidasFolders.\n        :rtype: list of MidasFolders\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        response = self.request('midas.folder.get', parameters)\n        return response\n\ndef get_folder_by_name(self, token, folder_name):\n        \"\"\"\n        Get the folder with the passed in folder_name",
        "\n\ndef delete_folder(self, token, folder_id):\n        \"\"\"\n        Delete a folder.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the folder to be deleted.\n        :type folder_id: int | long\n        :returns: Dictionary containing the details of the deleted folder.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['id'] = folder_id\n        response = self.request('midas.folder.delete', parameters)\n        return response\n\ndef get_folder_list(self, token, folder_id):\n        \"\"\"\n        Get a list of folders.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the folder to be retrieved.\n        :type folder_id: int | long\n        :returns: Dictionary containing the details of the retrieved folder list.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['id'] = folder_id\n        response = self.request('midas.folder.list', parameters)\n        return response\n\ndef get_folder",
        "\n\ndef delete_item(self, token, item_id):\n        \"\"\"\n        Delete an item from the server.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item to be deleted.\n        :type item_id: int | long\n        :returns: Dictionary containing the details of the deleted item.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['item_id'] = item_id\n        response = self.request('midas.item.delete', parameters)\n        return response\n\ndef get_item(self, token, item_id):\n        \"\"\"\n        Get an item from the server.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item to be retrieved.\n        :type item_id: int | long\n        :returns: Dictionary containing the details of the retrieved item.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['item_id'] = item_id\n        response = self.request('midas.item.get', parameters)\n        return response\n",
        "\n\ndef item_update(self, token, item_id, attributes):\n        \"\"\"\n        Update the attributes of the specified item.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the requested item.\n        :type item_id: int | string\n        :param attributes: Dictionary of the item attributes.\n        :type attributes: dict\n        :returns: Dictionary of the item attributes.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['id'] = item_id\n        parameters['attributes'] = attributes\n        response = self.request('midas.item.update', parameters)\n        return response\n\ndef item_delete(self, token, item_id):\n        \"\"\"\n        Delete the specified item.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the requested item.\n        :type item_id: int | string\n        :returns: Dictionary of the item attributes.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['id'] = item_id\n        response = self.request('",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_item(self, token, item_id):\n        \"\"\"\n        Get the item with the passed in item_id.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item to be retrieved.\n        :type item_id: int | long\n        :returns: The item with the passed in item_id.\n        :rtype: midas.item.Item\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['id'] = item_id\n        response = self.request('midas.item.get', parameters)\n        return response\n\ndef get_items(self, token):\n        \"\"\"\n        Get all the items with the passed in token.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :returns: A list of items with the passed in token.\n        :rtype: list of midas.item.Item\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        response = self.request('midas.item.get', parameters)\n        return response\n\ndef get_items_by_category(self, token, category_id):\n        \"\"\"\n        Get all",
        "\n\ndef get_item_metadata_by_id(self, item_id, token=None, revision=None):\n        \"\"\"\n        Get the metadata associated with an item.\n\n        :param item_id: The id of the item for which metadata will be returned\n        :type item_id: int | long\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :param revision: (optional) Revision of the item. Defaults to latest\n            revision.\n        :type revision: int | long\n        :returns: List of dictionaries containing item metadata.\n        :rtype: list[dict]\n        \"\"\"\n        parameters = dict()\n        parameters['id'] = item_id\n        if token:\n            parameters['token'] = token\n        if revision:\n            parameters['revision'] = revision\n        response = self.request('midas.item.getmetadata', parameters)\n        return response\n\ndef get_item_metadata_by_name(self, item_name, token=None, revision=None):\n        \"\"\"\n        Get the metadata associated with an item.\n\n        :param item_name: The name of the item for which metadata will be returned\n        :type item_name: string\n        :param token: (optional) A valid token for",
        "\n\ndef get_item_metadata(self, token, item_id, element, qualifier=None):\n        \"\"\"\n        Get the metadata associated with an item.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item for which metadata will be set.\n        :type item_id: int | long\n        :param element: The metadata element name.\n        :type element: string\n        :param qualifier: (optional) The metadata qualifier. Defaults to empty\n            string.\n        :type qualifier: None | string\n        :returns: The metadata value for the field.\n        :rtype: string\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['itemId'] = item_id\n        parameters['element'] = element\n        if qualifier:\n            parameters['qualifier'] = qualifier\n        response = self.request('midas.item.getmetadata', parameters)\n        return response\n\ndef get_item_metadata_by_id(self, token, item_id, element, qualifier=None):\n        \"\"\"\n        Get the metadata associated with an item.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The",
        "\n\ndef unshare_item(self, token, item_id, dest_folder_id):\n        \"\"\"\n        Unshare an item from the destination folder.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item to be unshared.\n        :type item_id: int | long\n        :param dest_folder_id: The id of destination folder where the item is\n            unshared to.\n        :type dest_folder_id: int | long\n        :returns: Dictionary containing the details of the unshared item.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['id'] = item_id\n        parameters['dstfolderid'] = dest_folder_id\n        response = self.request('midas.item.unshare', parameters)\n        return response\n\ndef get_item_details(self, token, item_id):\n        \"\"\"\n        Get the details of an item.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item to be retrieved.\n        :type item_id: int | long\n        :returns: Dictionary containing the",
        "\n\ndef delete_item(self, token, item_id):\n        \"\"\"\n        Delete an item from the source folder.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item to be deleted\n        :type item_id: int | long\n        :returns: Dictionary containing the details of the deleted item\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['id'] = item_id\n        response = self.request('midas.item.delete', parameters)\n        return response\n\ndef get_item_details(self, token, item_id):\n        \"\"\"\n        Get the details of an item.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item to be retrieved\n        :type item_id: int | long\n        :returns: Dictionary containing the details of the retrieved item\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['id'] = item_id\n        response = self.request('midas.item.get', parameters)\n        return response\n\ndef get_item",
        "\n\ndef search_item_by_id(self, id, token=None):\n        \"\"\"\n        Return all items.\n\n        :param id: The id of the item to search by.\n        :type id: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: A list of all items with the given id.\n        :rtype: list[dict]\n        \"\"\"\n        parameters = dict()\n        parameters['id'] = id\n        if token:\n            parameters['token'] = token\n        response = self.request('midas.item.searchbyid', parameters)\n        return response['items']\n\ndef search_item_by_name_and_id(self, name, id, token=None):\n        \"\"\"\n        Return all items.\n\n        :param name: The name of the item to search by.\n        :type name: string\n        :param id: The id of the item to search by.\n        :type id: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: A list of all items with the given name and id.\n        :rtype: list[dict]\n        \"\"\"\n        parameters =",
        "\n\ndef search_item_by_name(self, name, token=None):\n        \"\"\"\n        Return all items with a given name.\n\n        :param name: The name of the item to search by.\n        :type name: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: A list of all items with the given name.\n        :rtype: list[dict]\n        \"\"\"\n        parameters = dict()\n        parameters['name'] = name\n        if token:\n            parameters['token'] = token\n        response = self.request('midas.item.searchbyname', parameters)\n        return response['items']\n\ndef search_item_by_folder_id(self, folder_id, token=None):\n        \"\"\"\n        Return all items with a given parent folder id.\n\n        :param folder_id: The id of the parent folder to search by.\n        :type folder_id: int | long\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: A list of all items with the given parent folder id.\n        :rtype: list[dict]\n        \"\"\"\n        parameters = dict()\n        parameters['folder",
        "\n\ndef search_item_by_name(self, name, token=None):\n        \"\"\"\n        Return all items with a given name.\n\n        :param name: The name of the item to search by.\n        :type name: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: A list of all items with the given name.\n        :rtype: list[dict]\n        \"\"\"\n        parameters = dict()\n        parameters['name'] = name\n        if token:\n            parameters['token'] = token\n        response = self.request('midas.item.searchbyname', parameters)\n        return response['items']\n\ndef search_item_by_folder_name(self, folder_name, token=None):\n        \"\"\"\n        Return all items with a given folder name.\n\n        :param folder_name: The name of the parent folder to search by.\n        :type folder_name: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: A list of all items with the given folder name.\n        :rtype: list[dict]\n        \"\"\"\n        parameters = dict()\n        parameters['folderName'] = folder",
        "\n\ndef delete_link(self, token, folder_id, link_id):\n        \"\"\"\n        Delete a link bitstream.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the folder in which to delete a link\n            bitstream.\n        :type folder_id: int | long\n        :param link_id: The id of the link bitstream to delete.\n        :type link_id: int | long\n        :returns: The item information of the item deleted.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['folderid'] = folder_id\n        parameters['linkid'] = link_id\n        response = self.request('midas.link.delete', parameters)\n        return response\n\ndef get_link(self, token, folder_id, link_id):\n        \"\"\"\n        Get a link bitstream.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the folder in which to get a link\n            bitstream.\n        :type folder_id: int | long\n        :param link_id: The id of the link bitstream to get.\n       ",
        "\n\ndef perform_upload(self, token, item_id, filename, checksum=None):\n        \"\"\"\n        Perform an upload.\n\n        Midas Server uses a single token for each upload. The token\n        corresponds to the file specified and that file only. Passing the MD5\n        checksum allows the server to determine if the file is already in the\n        asset store.\n\n        If :param:`checksum` is passed and the token returned is blank, the\n        server already has this file and there is no need to follow this\n        call with a call to `perform_upload`, as the passed in file will have\n        been added as a bitstream to the item's latest revision, creating a\n        new revision if one doesn't exist.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item in which to upload the file as a\n            bitstream.\n        :type item_id: int | long\n        :param filename: The name of the file to upload.\n        :type filename: string\n        :param checksum: (optional) The checksum of the file to upload.\n        :type checksum: None | string\n        :returns: String of the upload token.\n        :rtype: string\n        \"\"\"\n        parameters = dict()\n        parameters['",
        "\n\ndef perform_download(self, upload_token, filename, **kwargs):\n        \"\"\"\n        Download a file from a given item (or just to the public folder if the\n        item is not specified).\n\n        :param upload_token: The upload token (returned by\n            generate_upload_token)\n        :type upload_token: string\n        :param filename: The upload filename. Also used as the path to the\n            file, if 'filepath' is not set.\n        :type filename: string\n        :param mode: (optional) Stream or multipart. Default is stream.\n        :type mode: string\n        :param folder_id: (optional) The id of the folder to upload into.\n        :type folder_id: int | long\n        :param item_id: (optional) If set, will append item ``bitstreams`` to\n            the latest revision (or the one set using :param:`revision` ) of\n            the existing item.\n        :type item_id: int | long\n        :param revision: (optional) If set, will add a new file into an\n            existing revision. Set this to 'head' to add to the most recent\n            revision.\n        :type revision: string | int | long\n        :param filepath: (optional) The path to the file.\n        :type filepath:",
        "\n\ndef get(self, resource_id, token=None):\n        \"\"\"\n        Get a single resource.\n\n        :param resource_id: The resource ID.\n        :type resource_id: string\n        :param token: (optional) The credentials to use when searching.\n        :type token: None | string\n        :returns: The resource object.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['resource_id'] = resource_id\n        if token:\n            parameters['token'] = token\n        response = self.request('midas.resource.get', parameters)\n        return response\n\ndef create(self, resource_id, resource_type, resource_name, resource_description, resource_tags, resource_properties, resource_properties_type, resource_properties_format, resource_properties_format_type, resource_properties_format_format, resource_properties_format_format_type, resource_properties_format_format_type, resource_properties_format_format_type, resource_properties_format_format_type, resource_properties_format_format_type, resource_properties_format_format_type, resource_properties_format_format_type, resource_properties_format_format_type, resource_properties_format_format_type, resource_properties_format_format",
        "\n\ndef delete_condor_dag(self, token, batchmaketaskid, dagfilename):\n        \"\"\"\n        Delete a Condor DAG from the given Batchmake task.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param batchmaketaskid: id of the Batchmake task for this DAG\n        :type batchmaketaskid: int | long\n        :param dagfilename: Filename of the DAG file\n        :type dagfilename: string\n        :returns: The deleted Condor DAG DAO\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['batchmaketaskid'] = batchmaketaskid\n        parameters['dagfilename'] = dagfilename\n        response = self.request('midas.batchmake.delete.condor.dag', parameters)\n        return response\n\ndef get_condor_dag(self, token, batchmaketaskid, dagfilename):\n        \"\"\"\n        Get a Condor DAG from the given Batchmake task.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param batchmaketaskid: id of the Batchmake task for",
        "\n\ndef delete_condor_job(self, token, batchmaketaskid, jobid):\n        \"\"\"\n        Delete a Condor DAG job from the Condor DAG associated with this\n        Batchmake task\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param batchmaketaskid: id of the Batchmake task for this DAG\n        :type batchmaketaskid: int | long\n        :param jobid: id of the job to delete\n        :type jobid: int | long\n        :return: The deleted Condor job DAO.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['batchmaketaskid'] = batchmaketaskid\n        parameters['jobid'] = jobid\n        response = self.request('midas.batchmake.delete.condor.job', parameters)\n        return response\n\ndef get_condor_job(self, token, batchmaketaskid, jobid):\n        \"\"\"\n        Get a Condor DAG job from the Condor DAG associated with this\n        Batchmake task\n\n        :param token: A valid token for the user in question.\n        :type token",
        "\n\ndef extract_dicommetadata_by_id(self, token, item_id):\n        \"\"\"\n        Extract DICOM metadata from the given item\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: id of the item to be extracted\n        :type item_id: int | long\n        :return: the item revision DAO\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['item'] = item_id\n        response = self.request('midas.dicomextractor.extract', parameters)\n        return response\n\ndef extract_dicommetadata_by_id_and_version(self, token, item_id, version):\n        \"\"\"\n        Extract DICOM metadata from the given item\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: id of the item to be extracted\n        :type item_id: int | long\n        :param version: version of the item to be extracted\n        :type version: int | long\n        :return: the item revision DAO\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['item']",
        "\n\ndef mfa_otp_logout(self, token):\n        \"\"\"\n        Log out from the real token.\n\n        :param token: The token to be logged out\n        :type token: string\n        :returns: A standard token for interacting with the web api.\n        :rtype: string\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        response = self.request('midas.mfa.otp.logout', parameters)\n        return response['token']\n\ndef mfa_otp_get_token(self, token):\n        \"\"\"\n        Get the real token using the token.\n\n        :param token: The token to be logged out\n        :type token: string\n        :returns: A standard token for interacting with the web api.\n        :rtype: string\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        response = self.request('midas.mfa.otp.getToken', parameters)\n        return response['token']\n\ndef mfa_otp_get_token_by_id(self, token_id):\n        \"\"\"\n        Get the real token using the token id.\n\n        :param token_id: The token id to be logged out\n        :type token_id: string\n        :",
        "\n\ndef create_thumbnail(self, token, bitstream_id, item_id, width=575):\n        \"\"\"\n        Create a thumbnail for the given bitstream with the given width.\n        It is used as the main image of the given item and shown in the item\n        view page.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param bitstream_id: The bitstream from which to create the thumbnail.\n        :type bitstream_id: int | long\n        :param item_id: The item on which to set the thumbnail.\n        :type item_id: int | long\n        :param width: (optional) The width in pixels to which to resize (aspect\n            ratio will be preserved). Defaults to 575.\n        :type width: int | long\n        :returns: The ItemthumbnailDao object that was created.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['bitstreamId'] = bitstream_id\n        parameters['itemId'] = item_id\n        parameters['width'] = width\n        response = self.request('midas.thumbnailcreator.create.thumbnail',\n                                parameters)\n        return response\n\ndef delete_thumbnail(self, token, bitstream_id, item_id, thumbnail_",
        "\n\ndef create_large_thumbnail(self, token, item_id):\n        \"\"\"\n        Create a 100x100 large thumbnail for the given item. It is used for\n        preview purpose and displayed in the 'preview' and 'thumbnails'\n        sidebar sections.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The item on which to set the thumbnail.\n        :type item_id: int | long\n        :returns: The item object (with the new thumbnail id) and the path\n            where the newly created thumbnail is stored.\n        :rtype: dict\n        \"\"\"\n        parameters = dict()\n        parameters['token'] = token\n        parameters['itemId'] = item_id\n        response = self.request(\n            'midas.thumbnailcreator.create.large.thumbnail', parameters)\n        return response\n\ndef create_thumbnail(self, token, item_id):\n        \"\"\"\n        Create a thumbnail for the given item. It is used for preview purpose\n        and displayed in the 'preview' and 'thumbnails' sidebar sections.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The item on which to set the thumbnail.\n        :type item_",
        "\n\ndef solr_advanced_search_with_token(self, query, token=None, limit=20):\n        \"\"\"\n        Search item metadata using Apache Solr.\n\n        :param query: The Apache Lucene search query.\n        :type query: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :param limit: (optional) The limit of the search.\n        :type limit: int | long\n        :returns: The list of items that match the search query.\n        :rtype: list[dict]\n        \"\"\"\n        parameters = dict()\n        parameters['query'] = query\n        parameters['limit'] = limit\n        if token:\n            parameters['token'] = token\n        response = self.request('midas.solr.search.advanced', parameters)\n        return response\n\ndef solr_advanced_search_with_token_and_limit(self, query, token=None, limit=20):\n        \"\"\"\n        Search item metadata using Apache Solr.\n\n        :param query: The Apache Lucene search query.\n        :type query: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :param limit: (optional) The limit of the search.",
        "\n\ndef get_scalar_data(self, token, community_id, producer_display_name,\n                     metric_name, producer_revision, submit_time, value,\n                     **kwargs):\n        \"\"\"\n        Get a scalar data point.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param community_id: The id of the community that owns the producer.\n        :type community_id: int | long\n        :param producer_display_name: The display name of the producer.\n        :type producer_display_name: string\n        :param metric_name: The metric name that identifies which trend this\n            point belongs to.\n        :type metric_name: string\n        :param producer_revision: The repository revision of the producer that\n            produced this value.\n        :type producer_revision: int | long | string\n        :param submit_time: The submit timestamp. Must be parsable with PHP\n            strtotime().\n        :type submit_time: string\n        :param value: The value of the scalar.\n        :type value: float\n        :param config_item_id: (optional) If this value pertains to a specific\n            configuration item, pass its id here.\n        :type config_item_id: int | long\n        :param",
        "\n\ndef delete_json_results(self, token, filepath, community_id,\n                         producer_display_name, metric_name,\n                         producer_revision, submit_time, **kwargs):\n        \"\"\"\n        Delete a JSON file containing numeric scoring results to be added as\n        scalars. File is parsed and then deleted from the server.\n\n        :param token: A valid token for the user in question.\n        :param filepath: The path to the JSON file.\n        :param community_id: The id of the community that owns the producer.\n        :param producer_display_name: The display name of the producer.\n        :param metric_name: The name of the metric that produced this value.\n        :param producer_revision: The repository revision of the producer\n            that produced this value.\n        :param submit_time: The submit timestamp. Must be parsable with PHP\n            strtotime().\n        :param config_item_id: (optional) If this value pertains to a specific\n            configuration item, pass its id here.\n        :param test_dataset_id: (optional) If this value pertains to a specific\n            test dataset, pass its id here.\n        :param truth_dataset_id: (optional) If this value pertains to a specific\n            ground truth dataset, pass its id here.\n        :param parent",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n    def available_pins(self):\n        \"\"\"Returns a list of available pins.\n\n        Returns a list of available pins.\n        \"\"\"\n        return self._client.available_pins()\n\n    def map_pin(self, pin):\n        \"\"\"Maps a pin to a Merker, Input or Output in the PLC.\n\n        Maps a pin to a Merker, Input or Output in the PLC.\n        \"\"\"\n        return self._client.map_pin(pin)\n\n    def write_pin(self, pin, value):\n        \"\"\"Writes a value to a pin in the PLC.\n\n        Writes a value to a pin in the PLC.\n        \"\"\"\n        return self._client.write_pin(pin, value)\n\n    def read_pin(self, pin):\n        \"\"\"Reads a value from a pin in the PLC.\n\n        Reads a value from a pin in the PLC.\n        \"\"\"\n        return self._client.read_pin(pin)\n\n    def write_pin_to_output(self, pin, value):\n        \"\"\"Writes a value to a pin in the PLC.\n\n        Writes a value to a pin in the PLC.\n        \"\"\"\n        return self._client.write_pin_to_output(pin, value)\n\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef block_resource_fitnesses_for_node(self, node: block.Node):\n        \"\"\"Returns a map of nodename to average fitness value for this block.\n        Assumes that required resources have been checked on all nodes.\"\"\"\n\n        node_fitnesses = {}\n\n        for resource in node.resources:\n            node_fitnesses = self.resource_fitnesses(resource)\n\n            if not node_fitnesses:\n                raise UnassignableBlock(node.name)\n\n            max_fit = max(node_fitnesses.values())\n            min_fit = min(node_fitnesses.values())\n\n            for node, fitness in node_fitnesses.items():\n                if node not in node_fitnesses:\n                    node_fitnesses[node] = {}\n\n                if not fitness:\n                    # Since we're rescaling, 0 is now an OK value...\n                    # We will check for `is False` after this\n                    node_fitnesses[node][resource.describe()] = False\n                else:\n                    if max_fit - min_fit:\n                        node_fitnesses[node][resource.describe()] = (fitness - min_fit) / (max_fit - min_fit)\n                    else:\n                        # All the values",
        "\n\ndef get_driver_info(name):\n    \"\"\"Returns a driver info object.\n    \"\"\"\n    global __modules\n    global __available\n\n    if type(__modules) is not list:\n        __modules = list(__modules)\n\n    if not __available:\n        __available = [d.ahioDriverInfo.NAME\n                       for d in __modules\n                       if d.ahioDriverInfo.AVAILABLE]\n\n    return __modules[__available.index(name)]\n\ndef get_driver_info_by_name(name):\n    \"\"\"Returns a driver info object.\n    \"\"\"\n    global __modules\n    global __available\n\n    if type(__modules) is not list:\n        __modules = list(__modules)\n\n    if not __available:\n        __available = [d.ahioDriverInfo.NAME\n                       for d in __modules\n                       if d.ahioDriverInfo.AVAILABLE]\n\n    return __modules[__available.index(name)]\n\ndef get_driver_info_by_id(id):\n    \"\"\"Returns a driver info object.\n    \"\"\"\n    global __modules\n    global __available\n\n    if type(__modules) is not list:\n        __modules = list(__modules)\n\n    if not __available:\n        __available =",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        ".\n\ndef _pin_direction(self, pin):\n        \"\"\"Gets the `ahio.Direction` this pin was set to.\n\n        If you're developing a driver, implement _pin_direction(self, pin)\n\n        @arg pin the pin you want to see the mode\n        @returns the `ahio.Direction` the pin is set to\n\n        @throw KeyError if pin isn't mapped.\n        \"\"\"\n        if type(pin) is list:\n            return [self._pin_direction(p) for p in pin]\n\n        pin_id = self._pin_mapping.get(pin, None)\n        if pin_id:\n            return self._pin_direction(pin_id)\n        else:\n            raise KeyError('Requested pin is not mapped: %s' % pin)\n\ndef pin_mode(self, pin):\n        \"\"\"Gets the `ahio.Mode` this pin was set to.\n\n        If you're developing a driver, implement _pin_mode(self, pin)\n\n        @arg pin the pin you want to see the mode\n        @returns the `ahio.Mode` the pin is set to\n\n        @throw KeyError if pin isn't mapped.\n        \"\"\"\n        if type(pin) is list:\n            return [self._pin_mode(p)",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ".\n\ndef _pin_type(self, pin):\n        \"\"\"Gets the `ahio.PortType` this pin was set to.\n\n        If you're developing a driver, implement _pin_type(self, pin)\n\n        @arg pin the pin you want to see the mode\n        @returns the `ahio.PortType` the pin is set to\n\n        @throw KeyError if pin isn't mapped.\n        \"\"\"\n        if type(pin) is list:\n            return [self._pin_type(p) for p in pin]\n\n        pin_id = self._pin_mapping.get(pin, None)\n        if pin_id:\n            return self._pin_type(pin_id)\n        else:\n            raise KeyError('Requested pin is not mapped: %s' % pin)\n\ndef pin_name(self, pin):\n        \"\"\"Gets the name of the pin.\n\n        If you're developing a driver, implement _pin_name(self, pin)\n\n        @arg pin the pin you want to see the mode\n        @returns the name of the pin\n\n        @throw KeyError if pin isn't mapped.\n        \"\"\"\n        if type(pin) is list:\n            return [self._pin_name(p) for p in pin]\n\n        pin_id = self._",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        ".\n\n    def write(self, pin, value):\n        \"\"\"Writes value to pin `pin`.\n\n        Returns the value written to pin `pin`. If it's an analog pin, returns\n        a number in analog.input_range. If it's digital, returns\n        `ahio.LogicValue`.\n\n        If you're developing a driver, implement _write(self, pin, value)\n\n        @arg pin the pin to write to\n        @arg value the value to write to the pin\n        @returns the value written to the pin\n\n        @throw KeyError if pin isn't mapped.\n        \"\"\"\n        if type(pin) is list:\n            return [self.write(p, v) for p, v in zip(pin, value)]\n\n        pin_id = self._pin_mapping.get(pin, None)\n        if pin_id:\n            self._write(pin_id, value)\n            lpin = self._pin_lin.get(pin, None)\n            if lpin and type(lpin['write']) is tuple:\n                write_range = lpin['write']\n                value = self._linear_interpolation(value, *write_range)\n            return value\n        else:\n            raise KeyError('Requested pin is not mapped: %s' % pin)\n\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "\n\ndef rk4(func, y0, time, args=()):\n    \"\"\"Integrate SIR epidemic model\n\n    Simulate a very basic deterministic SIR system.\n\n    :param string func: function name\n    :param 2x1 numpy array y0: initial conditions\n    :param Ntimestep length numpy array time: Vector of time points that \\\n    solution is returned at\n    :param args: arguments to the function\n\n    :returns: (2)x(Ntimestep) numpy array Xsim: first row S(t), second row I(t)\n    \n    \"\"\"\n    Xsim = numpy.zeros((2,2))\n    Xsim[0,0] = y0\n    Xsim[1,0] = time\n    Xsim[0,1] = 1\n    Xsim[1,1] = 1\n    Xsim[0,2] = 1\n    Xsim[1,2] = 1\n    Xsim[0,3] = 1\n    Xsim[1,3] = 1\n    Xsim[0,4] = 1\n    Xsim[1,4] = 1\n    Xsim[0,5] = 1\n    Xsim[1,5] = 1\n    Xsim[0,6] = 1\n    Xsim",
        "\n\ndef get_driver(self, name):\n        \"\"\"\n        Return the driver with the given name.\n\n        :param name: Name of the driver\n        :type name: string\n        :returns: Driver with the given name\n        :rtype: :class:`~pymongo.driver.Driver`\n        \"\"\"\n        for driver in self.drivers:\n            if driver.name == name:\n                return driver\n        raise KeyError(\"Driver with name %s not found\" % name)\n\ndef get_driver_by_name(self, name):\n        \"\"\"\n        Return the driver with the given name.\n\n        :param name: Name of the driver\n        :type name: string\n        :returns: Driver with the given name\n        :rtype: :class:`~pymongo.driver.Driver`\n        \"\"\"\n        for driver in self.drivers:\n            if driver.name == name:\n                return driver\n        raise KeyError(\"Driver with name %s not found\" % name)\n\ndef get_driver_by_id(self, id):\n        \"\"\"\n        Return the driver with the given id.\n\n        :param id: ID of the driver\n        :type id: int\n        :returns: Driver with the given id\n        :rtype: :class:`~pymongo.driver.Driver`",
        "\n\ndef guess_numpy_dtypes_from_idxstats( bam_readers, default=numpy.uint64, force_dtype=False ):\n    \"\"\"Returns a list of numpy dtypes for each idxstats.\n\n    If force_dtype is True, then the dtype will be inferred from the idxstats.\n    If force_dtype is False, then the dtype will be inferred from the idxstats.\n    \"\"\"\n    dtypes = []\n    for bam in bam_readers:\n        rgs = bam.get_read_groups()\n        if rgs:\n            for rg in rgs:\n                if rg not in dtypes:\n                    dtypes.append( numpy.dtype( numpy.uint64 ) )\n    return dtypes\n\ndef guess_numpy_dtypes_from_idx( bam_readers, default=numpy.uint64, force_dtype=False ):\n    \"\"\"Returns a list of numpy dtypes for each idx.\n\n    If force_dtype is True, then the dtype will be inferred from the idx.\n    If force_dtype is False, then the dtype will be inferred from the idx.\n    \"\"\"\n    dtypes = []\n    for bam in bam_readers:\n        rgs = bam.get_read_groups()\n        if rgs:\n            for rg in rgs:\n                if rg not in dtypes",
        "\n    else:\n        logger.info(\"No coverage reports to create.\")\n\n\nif __name__ == '__main__':\n    main()\n",
        "\n\n    def disconnect(self):\n        \"\"\"Disconnect from the Modbus server.\n\n        @throw RuntimeError can't disconnect from Arduino\n        \"\"\"\n        self._client.disconnect()\n\n    def send(self, data):\n        \"\"\"Send a string to the Modbus server.\n\n        @arg data a string that contains the data to send\n        @throw RuntimeError can't send to Arduino\n        \"\"\"\n        self._client.send(data)\n\n    def receive(self):\n        \"\"\"Receive a string from the Modbus server.\n\n        @throw RuntimeError can't receive from Arduino\n        \"\"\"\n        return self._client.receive()\n\n    def send_command(self, command):\n        \"\"\"Send a command to the Modbus server.\n\n        @arg command a string that contains the command to send\n        @throw RuntimeError can't send to Arduino\n        \"\"\"\n        self._client.send_command(command)\n\n    def send_command_with_timeout(self, command, timeout):\n        \"\"\"Send a command to the Modbus server with a timeout.\n\n        @arg command a string that contains the command to send\n        @arg timeout a number of seconds to wait before giving up\n        @throw RuntimeError can't send to Arduino\n        \"\"\"\n        self._client.send_command_",
        "\n\n\nclass BadRequest(Exception):\n    \"\"\"\n    Raised when a request is invalid.\n    \"\"\"\n\n\nclass Unauthorized(Exception):\n    \"\"\"\n    Raised when a request is not authorized.\n    \"\"\"\n\n\nclass Forbidden(Exception):\n    \"\"\"\n    Raised when a request is not authorized.\n    \"\"\"\n\n\nclass NotFound(Exception):\n    \"\"\"\n    Raised when a request is not found.\n    \"\"\"\n\n\nclass MethodNotAllowed(Exception):\n    \"\"\"\n    Raised when a request is not allowed.\n    \"\"\"\n\n\nclass UploadFailed(Exception):\n    \"\"\"\n    Raised when a request is not allowed.\n    \"\"\"\n\n\nclass UploadTokenGenerationFailed(Exception):\n    \"\"\"\n    Raised when a request is not allowed.\n    \"\"\"\n\n\nclass InvalidUploadToken(Exception):\n    \"\"\"\n    Raised when a request is not allowed.\n    \"\"\"\n\n\nclass InvalidPolicy(Exception):\n    \"\"\"\n    Raised when a request is not allowed.\n    \"\"\"\n\n\nclass HTTPError(Exception):\n    \"\"\"\n    Raised when an HTTP error occurs.\n    \"\"\"\n\n\nclass ResponseError(Exception):\n    \"\"\"\n    Raised when a response is invalid.\n    \"\"\"\n\n\nclass BadRequest(Exception):\n    \"\"\"\n    Raised when a request",
        "\n\ndef analog_write(self, pin, value):\n        \"\"\"\n        Write the specified analog data value to the specified pin.\n\n        :param pin: Selected pin\n        :param value: The new value to write to the pin.\n        \"\"\"\n        with self.data_lock:\n            self._command_handler.analog_response_table[pin][self._command_handler.RESPONSE_TABLE_PIN_DATA_VALUE] = value\n\ndef analog_write_all(self, pin, values):\n        \"\"\"\n        Write the specified analog data values to the specified pins.\n\n        :param pin: Selected pin\n        :param values: The values to write to the pins.\n        \"\"\"\n        with self.data_lock:\n            for value in values:\n                self._command_handler.analog_response_table[pin][self._command_handler.RESPONSE_TABLE_PIN_DATA_VALUE] = value\n\ndef analog_write_all_with_lock(self, pin, values):\n        \"\"\"\n        Write the specified analog data values to the specified pins.\n\n        :param pin: Selected pin\n        :param values: The values to write to the pins.\n        :param lock: The lock to use for the write.\n        \"\"\"\n        with self.data_lock:\n           ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_stepper_version_string(self, timeout=20):\n        \"\"\"\n        Get the stepper library version string.\n\n        :param timeout: specify a time to allow arduino to process and return a version\n\n        :return: the stepper version string if it was set.\n        \"\"\"\n        # get current time\n        start_time = time.time()\n\n        # wait for up to 20 seconds for a successful capability query to occur\n\n        while self._command_handler.stepper_library_version <= 0:\n            if time.time() - start_time > timeout:\n                if self.verbose is True:\n                    print(\"Stepper Library Version Request timed-out. \"\n                          \"Did you send a stepper_request_library_version command?\")\n                return\n            else:\n                pass\n        return self._command_handler.stepper_library_version\n\ndef get_stepper_version_string_with_version(self, version):\n        \"\"\"\n        Get the stepper library version string with a specific version.\n\n        :param version: the version to use for the version string\n\n        :return: the stepper version string if it was set.\n        \"\"\"\n        # get current time\n        start_time = time.time()\n\n        # wait for up to 20",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        ")\n\ndef set_analog_latch_range(self, pin, threshold_type, threshold_value, cb=None):\n        \"\"\"\n        This method \"arms\" an analog pin for its data to be latched and saved in the latching table\n        If a callback method is provided, when latching criteria is achieved, the callback function is called\n        with latching data notification. In that case, the latching table is not updated\n\n        :param pin: Analog pin number (value following an 'A' designator, i.e. A5 = 5\n\n        :param threshold_type: ANALOG_LATCH_GT | ANALOG_LATCH_LT  | ANALOG_LATCH_GTE | ANALOG_LATCH_LTE\n\n        :param threshold_value: numerical value - between 0 and 1023\n\n        :param cb: callback method\n\n        :return: True if successful, False if parameter data is invalid\n        \"\"\"\n        if self.ANALOG_LATCH_GT <= threshold_type <= self.ANALOG_LATCH_LTE:\n            if 0 <= threshold_value <= 1023:\n                self._command_handler.set_analog_latch_range(pin, threshold_type, threshold_value, cb)\n                return True\n        else:\n            return False\n\n",
        " False\n\ndef set_analog_latch(self, pin, threshold_type, cb=None):\n        \"\"\"\n        This method \"arms\" a analog pin for its data to be latched and saved in the latching table\n        If a callback method is provided, when latching criteria is achieved, the callback function is called\n        with latching data notification. In that case, the latching table is not updated\n\n        :param pin: Analog pin number\n\n        :param threshold_type: ANALOG_LATCH_HIGH | ANALOG_LATCH_LOW\n\n        :param cb: callback function\n\n        :return: True if successful, False if parameter data is invalid\n        \"\"\"\n        if 0 <= threshold_type <= 1:\n            self._command_handler.set_analog_latch(pin, threshold_type, cb)\n            return True\n        else:\n            return False\n\ndef set_digital_latch_high(self, pin, threshold_type, cb=None):\n        \"\"\"\n        This method \"arms\" a digital pin for its data to be latched and saved in the latching table\n        If a callback method is provided, when latching criteria is achieved, the callback function is called\n        with latching data notification. In that case, the latching table is not updated\n\n        :param",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\ndef set_brightness_to_default(self):\n        \"\"\"\n        Set the brightness level for the entire display to the default\n        @param brightness: brightness level (0 -15)\n        \"\"\"\n        self.set_brightness(self.default_brightness)\n\ndef set_brightness_to_high(self):\n        \"\"\"\n        Set the brightness level for the entire display to the high\n        @param brightness: brightness level (0 -15)\n        \"\"\"\n        self.set_brightness(self.high_brightness)\n\ndef set_brightness_to_low(self):\n        \"\"\"\n        Set the brightness level for the entire display to the low\n        @param brightness: brightness level (0 -15)\n        \"\"\"\n        self.set_brightness(self.low_brightness)\n\ndef set_brightness_to_full(self):\n        \"\"\"\n        Set the brightness level for the entire display to the full\n        @param brightness: brightness level (0 -15)\n        \"\"\"\n        self.set_brightness(self.full_brightness)\n\ndef set_brightness_to_none(self):\n        \"\"\"\n        Set the brightness level for the entire display to the none\n        @param brightness: brightness level (0 -15)\n        \"\"\"\n        self.set_",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;",
        "#include \"stdafx.h\"\n#include \"Game.h\"\n#include \"GameState.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#",
        "\n\ndef set_display_buffer(self, row, column, value):\n        \"\"\"\n        Set the value of the given row and column.\n        \"\"\"\n        self.display_buffer[row][column] = value\n\ndef set_display_buffer_to_zero(self, row, column):\n        \"\"\"\n        Set the value of the given row and column to 0.\n        \"\"\"\n        self.display_buffer[row][column] = 0\n\ndef set_display_buffer_to_one(self, row, column):\n        \"\"\"\n        Set the value of the given row and column to 1.\n        \"\"\"\n        self.display_buffer[row][column] = 1\n\ndef set_display_buffer_to_two(self, row, column):\n        \"\"\"\n        Set the value of the given row and column to 2.\n        \"\"\"\n        self.display_buffer[row][column] = 2\n\ndef set_display_buffer_to_three(self, row, column):\n        \"\"\"\n        Set the value of the given row and column to 3.\n        \"\"\"\n        self.display_buffer[row][column] = 3\n\ndef set_display_buffer_to_four(self, row, column):\n        \"\"\"\n        Set the value of the given row and column to 4.",
        "\n\n        # set the latch data table\n        with self.pymata.data_lock:\n            self.digital_latch_table[port] = [0, 0, 0, 0, None]\n            self.digital_response_table[port][self.RESPONSE_TABLE_PIN_DATA_VALUE] = port_data & 0x01\n            # if the values differ and callback is enabled for the pin, then send out the callback\n            if prev_data != port_data & 0x01:\n                callback = self.digital_response_table[port][self.RESPONSE_TABLE_CALLBACK]\n                if callback:\n                    callback([self.pymata.DIGITAL, port,\n                                  self.digital_response_table[port][self.RESPONSE_TABLE_PIN_DATA_VALUE]])\n\n        # set the latch data table\n        with self.pymata.data_lock:\n            self.digital_latch_table[port] = [0, 0, 0, 0, None]\n            self.digital_response_table[port][self.RESPONSE_TABLE_PIN_DATA_VALUE] = port_data & 0x01\n            # if the values differ and callback is enabled for the pin, then send out the callback\n            if prev_data != port_data & 0x01:",
        "\n                prev_val = val\n        return\n\ndef decoder_data(self, data):\n        \"\"\"\n        This method handles the incoming decoder data message and stores\n        the data in the digital response table.\n\n        :param data: Message data from Firmata\n\n        :return: No return value.\n        \"\"\"\n        prev_val = self.digital_response_table[data[self.RESPONSE_TABLE_MODE]][self.RESPONSE_TABLE_PIN_DATA_VALUE]\n        val = int((data[self.MSB] << 7) + data[self.LSB])\n        # set value so that it shows positive and negative values\n        if val > 8192:\n            val -= 16384\n        pin = data[0]\n        with self.pymata.data_lock:\n            self.digital_response_table[data[self.RESPONSE_TABLE_MODE]][self.RESPONSE_TABLE_PIN_DATA_VALUE] = val\n            if prev_val != val:\n                callback = self.digital_response_table[pin][self.RESPONSE_TABLE_CALLBACK]\n                if callback is not None:\n                    callback([self.pymata.DECODER, pin,\n                              self.digital_response_table[pin][self.RESPONSE_TABLE_PIN_DATA_VALUE]])\n",
        "\n\ndef sonar_data_callback(self, data):\n        \"\"\"\n        This method handles the incoming sonar data message and stores\n        the data in the response table.\n\n        :param data: Message data from Firmata\n\n        :return: No return value.\n        \"\"\"\n        val = int((data[self.MSB] << 7) + data[self.LSB])\n        pin_number = data[0]\n        with self.pymata.data_lock:\n            sonar_pin_entry = self.active_sonar_map[pin_number]\n            # also write it into the digital response table\n            self.digital_response_table[data[self.RESPONSE_TABLE_MODE]][self.RESPONSE_TABLE_PIN_DATA_VALUE] = val\n            # send data through callback if there is a callback function for the pin\n            if sonar_pin_entry[0] is not None:\n                # check if value changed since last reading\n                if sonar_pin_entry[1] != val:\n                    self.active_sonar_map[pin_number][0]([self.pymata.SONAR, pin_number, val])\n            # update the data in the table with latest value\n            sonar_pin_entry[1] = val\n            self",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;",
        "\n\ndef report_version(self):\n        \"\"\"\n        This method is called when the Firmata reports the version of the firmware.\n        \"\"\"\n        print(\"Firmata version: \" + str(self.firmware_version))\n\ndef report_firmware(self):\n        \"\"\"\n        This method is called when the Firmata reports the firmware.\n        \"\"\"\n        print(\"Firmata firmware: \" + str(self.firmware))\n\ndef analog_message(self):\n        \"\"\"\n        This method is called when the Firmata sends an analog message.\n        \"\"\"\n        print(\"Firmata analog message: \" + str(self.analog_message))\n\ndef digital_message(self):\n        \"\"\"\n        This method is called when the Firmata sends a digital message.\n        \"\"\"\n        print(\"Firmata digital message: \" + str(self.digital_message))\n\ndef encoder_data(self):\n        \"\"\"\n        This method is called when the Firmata sends an encoder data.\n        \"\"\"\n        print(\"Firmata encoder data: \" + str(self.encoder_data))\n\ndef sonar_data(self):\n        \"\"\"\n        This method is called when the Firmata sends a sonar data.\n        \"\"\"\n        print(\"Firmata sonar data: \" +",
        "\n\nclass RetrieveError(Exception):\n    \"\"\"\n    Exception for retrieving content\n    \"\"\"\n\n    def __init__(self, message):\n        super(RetrieveError, self).__init__(message)\n\n\nclass DownloadError(Exception):\n    \"\"\"\n    Exception for downloading content\n    \"\"\"\n\n    def __init__(self, message):\n        super(DownloadError, self).__init__(message)\n\n\nclass DownloadError(Exception):\n    \"\"\"\n    Exception for downloading content\n    \"\"\"\n\n    def __init__(self, message):\n        super(DownloadError, self).__init__(message)\n\n\nclass DownloadError(Exception):\n    \"\"\"\n    Exception for downloading content\n    \"\"\"\n\n    def __init__(self, message):\n        super(DownloadError, self).__init__(message)\n\n\nclass DownloadError(Exception):\n    \"\"\"\n    Exception for downloading content\n    \"\"\"\n\n    def __init__(self, message):\n        super(DownloadError, self).__init__(message)\n\n\nclass DownloadError(Exception):\n    \"\"\"\n    Exception for downloading content\n    \"\"\"\n\n    def __init__(self, message):\n        super(DownloadError, self).__init__(message)\n\n\nclass DownloadError(Exception):\n    \"\"\"",
        "\n\ndef get_image_urls(self):\n        \"\"\"\n        Return all image urls\n        \"\"\"\n\n        return self.finder_image_urls + self.extender_image_urls\n\ndef get_image_urls_by_type(self, type):\n        \"\"\"\n        Return all image urls by type\n        \"\"\"\n\n        return self.finder_image_urls + self.extender_image_urls[type]\n\ndef get_image_urls_by_type_and_name(self, type, name):\n        \"\"\"\n        Return all image urls by type and name\n        \"\"\"\n\n        return self.finder_image_urls + self.extender_image_urls[type][name]\n\ndef get_image_urls_by_type_and_name_and_type(self, type, name, type):\n        \"\"\"\n        Return all image urls by type and name and type\n        \"\"\"\n\n        return self.finder_image_urls + self.extender_image_urls[type][name][type]\n\ndef get_image_urls_by_type_and_name_and_type_and_name(self, type, name, type, name_and_type):\n        \"\"\"\n        Return all image urls by type and name and type and name\n        \"\"\"\n\n        return self",
        "\n\ndef image_finder(pipeline_index,\n                  soup,\n                  finder_image_urls=[],\n                  *args, **kwargs):\n    \"\"\"\n    Find image URL in background-image\n\n    Example:\n    <div style=\"width: 100%; height: 100%; background-image: url(http://distilleryimage10.ak.instagram.com/bde04558a43b11e28e5d22000a1f979a_7.jpg);\" class=\"Image iLoaded iWithTransition Frame\" src=\"http://distilleryimage10.ak.instagram.com/bde04558a43b11e28e5d22000a1f979a_7.jpg\"></div>\n    to\n    http://distilleryimage10.ak.instagram.com/bde04558a43b11e28e5d22000a1f979a_7.jpg\n    \"\"\"\n\n    now_finder_image_urls = []\n\n    for tag in soup.find_all(style=True):\n        style_string = tag['style']\n        if 'background-image' in style_string.lower():\n            style = cssutils.parseStyle(style_string)\n            if background_image:\n                for property_value in",
        ")\n\ndef _getnodenamefor_node(self, name):\n        \"Return the node name where the ``name`` would land to\"\n        return 'node_' + str(\n            (abs(binascii.crc32(b(name)) & 0xffffffff) % self.no_servers) + 1)\n\ndef _getnodenamefor_node_with_port(self, name, port):\n        \"Return the node name where the ``name`` would land to\"\n        return 'node_' + str(\n            (abs(binascii.crc32(b(name)) & 0xffffffff) % self.no_servers) + 1)\n\ndef _getnodenamefor_node_with_port_and_name(self, name, port, name):\n        \"Return the node name where the ``name`` would land to\"\n        return 'node_' + str(\n            (abs(binascii.crc32(b(name)) & 0xffffffff) % self.no_servers) + 1)\n\ndef _getnodenamefor_node_with_port_and_name_and_port(self, name, port, name, port):\n        \"Return the node name where the ``name`` would land to\"\n        return 'node_' + str(\n            (abs(binascii.crc32(b(name))",
        "\n\ndef getnodebyname(self, name):\n        \"Return the node where the ``name`` would land to\"\n        node = self._getnodenamefor(name)\n        return {node: self.cluster['nodes'][node]}\n\ndef getnodebyip(self, ip):\n        \"Return the node where the ``ip`` would land to\"\n        node = self._getnodenamefor(ip)\n        return {node: self.cluster['nodes'][node]}\n\ndef getnodebyipandport(self, ip, port):\n        \"Return the node where the ``ip`` and ``port`` would land to\"\n        node = self._getnodenamefor(ip, port)\n        return {node: self.cluster['nodes'][node]}\n\ndef getnodebyipandname(self, ip, name):\n        \"Return the node where the ``ip`` and ``name`` would land to\"\n        node = self._getnodenamefor(ip, name)\n        return {node: self.cluster['nodes'][node]}\n\ndef getnodebyipandnameandport(self, ip, name, port):\n        \"Return the node where the ``ip`` and ``name`` and ``port`` would land to\"\n        node = self._getnodenamefor(ip, name, port",
        "\n\ndef set(self, infotype, key, value):\n        \"Set the value for the key\"\n        redisent = self.redises[self._getnodenamefor(key) + '_slave']\n        return getattr(redisent, 'set')(infotype, key, value)\n\ndef incr(self, infotype, key):\n        \"Increment the value for the key\"\n        redisent = self.redises[self._getnodenamefor(key) + '_slave']\n        return getattr(redisent, 'incr')(infotype, key)\n\ndef decr(self, infotype, key):\n        \"Decrement the value for the key\"\n        redisent = self.redises[self._getnodenamefor(key) + '_slave']\n        return getattr(redisent, 'decr')(infotype, key)\n\ndef incrby(self, infotype, key, delta):\n        \"Increment the value by the delta\"\n        redisent = self.redises[self._getnodenamefor(key) + '_slave']\n        return getattr(redisent, 'incrby')(infotype, key, delta)\n\ndef decrby(self, infotype, key, delta):\n        \"Decrement the value by the delta\"\n        redisent = self.redises",
        "\n\ndef _rc_brpoplpush_with_timeout(self, src, dst, timeout=0):\n        \"\"\"\n        Pop a value off the tail of ``src``, push it on the head of ``dst``,\n        and then return it.\n\n        This command blocks until a value is in ``src`` or until ``timeout``\n        seconds elapse, whichever is first. A ``timeout`` value of 0 blocks\n        forever.\n        Not atomic\n        \"\"\"\n        rpop = self.brpop_with_timeout(src, timeout)\n        if rpop is not None:\n            self.lpush(dst, rpop[1])\n            return rpop[1]\n        return None\n\ndef _rc_brpoplpush_with_timeout_with_timeout(self, src, dst, timeout=0, timeout_with_timeout=0):\n        \"\"\"\n        Pop a value off the tail of ``src``, push it on the head of ``dst``,\n        and then return it.\n\n        This command blocks until a value is in ``src`` or until ``timeout``\n        seconds elapse, whichever is first. A ``timeout`` value of 0 blocks\n        forever.\n        Not atomic\n        \"\"\"\n        rpop = self.brpop_with_timeout_with_",
        "\n        return None\n\ndef _rc_rpoplpush_with_timeout(self, src, dst, timeout):\n        \"\"\"\n        RPOP a value off of the ``src`` list and LPUSH it\n        on to the ``dst`` list with a timeout.  Returns the value.\n        \"\"\"\n        rpop = self.rpop(src)\n        if rpop is not None:\n            self.lpush(dst, rpop, timeout)\n            return rpop\n        return None\n\ndef _rc_rpoplpush_with_timeout_with_timeout(self, src, dst, timeout, timeout_factor):\n        \"\"\"\n        RPOP a value off of the ``src`` list and LPUSH it\n        on to the ``dst`` list with a timeout and a timeout factor.\n        Returns the value.\n        \"\"\"\n        rpop = self.rpop(src)\n        if rpop is not None:\n            self.lpush(dst, rpop, timeout, timeout_factor)\n            return rpop\n        return None\n\ndef _rc_rpoplpush_with_timeout_with_timeout_factor(self, src, dst, timeout, timeout_factor):\n        \"\"\"\n        RPOP a value off of the ``src`` list and LPUSH it\n        on to the ``dst`` list",
        "\n\ndef _rc_srem(self, src, value):\n        \"\"\"\n        Remove ``value`` from set ``src``\n        not atomic\n        \"\"\"\n        if self.type(src) != b(\"set\"):\n            return self.srem(src + \"{\" + src + \"}\", value)\n        if self.type(dst) != b(\"set\"):\n            return self.srem(dst + \"{\" + dst + \"}\", value)\n        if self.srem(src, value):\n            return 1 if self.sadd(dst, value) else 0\n        return 0\n\ndef _rc_sadd(self, src, value):\n        \"\"\"\n        Add ``value`` to set ``src``\n        not atomic\n        \"\"\"\n        if self.type(src) != b(\"set\"):\n            return self.sadd(src + \"{\" + src + \"}\", value)\n        if self.type(dst) != b(\"set\"):\n            return self.sadd(dst + \"{\" + dst + \"}\", value)\n        if self.sadd(src, value):\n            return 1 if self.sadd(dst, value) else 0\n        return 0\n\ndef _rc_srem(self, src, value):\n        \"\"\"\n        Remove ``value`` from set ``src``\n       ",
        "\n\ndef _rc_union(self, src, *args):\n        \"\"\"\n        Returns the members of the set resulting from the union between the\n        first set and all the successive sets.\n        \"\"\"\n        args = list_or_args(src, args)\n        src_set = self.smembers(args.pop(0))\n        if src_set is not set([]):\n            for key in args:\n                src_set.update(self.smembers(key))\n        return src_set\n\ndef _rc_intersection(self, src, *args):\n        \"\"\"\n        Returns the members of the set resulting from the intersection between\n        the first set and all the successive sets.\n        \"\"\"\n        args = list_or_args(src, args)\n        src_set = self.smembers(args.pop(0))\n        if src_set is not set([]):\n            for key in args:\n                src_set.update(self.smembers(key))\n        return src_set\n\ndef _rc_difference(self, src, *args):\n        \"\"\"\n        Returns the members of the set resulting from the difference between\n        the first set and all the successive sets.\n        \"\"\"\n        args = list_or_args(src, args)\n        src_set",
        "\n\ndef _rc_sunionstore_all(self, dst, src, *args):\n        \"\"\"\n        Store the union of sets ``src``,  ``args`` into a new set named\n        ``dest``.  Returns the number of keys in the new set.\n        \"\"\"\n        args = list_or_args(src, args)\n        result = self.sunion(*args)\n        if result is not set([]):\n            return self.sadd(dst, *list(result))\n        return 0\n\ndef _rc_sunionstore_all_all(self, dst, src, *args):\n        \"\"\"\n        Store the union of sets ``src``,  ``args`` into a new set named\n        ``dest``.  Returns the number of keys in the new set.\n        \"\"\"\n        args = list_or_args(src, args)\n        result = self.sunion(*args)\n        if result is not set([]):\n            return self.sadd(dst, *list(result))\n        return 0\n\ndef _rc_sunionstore_all_none(self, dst, src, *args):\n        \"\"\"\n        Store the union of sets ``src``,  ``args`` into a new set named\n        ``dest``.  Returns the number of keys in the new",
        "(mapping)\n\ndef _rc_mset(self, mapping):\n        \"\"\"\n        Sets each key in the ``mapping`` dict to its corresponding value if\n        none of the keys are already set\n        \"\"\"\n        for k in iterkeys(mapping):\n            if self.exists(k):\n                return False\n\n        return self._rc_msetnx(mapping)\n\ndef _rc_mget(self, mapping):\n        \"\"\"\n        Returns the value for each key in the ``mapping`` dict\n        \"\"\"\n        for k in iterkeys(mapping):\n            if self.exists(k):\n                return self._rc_mget(mapping, k)\n\n        return None\n\ndef _rc_mgetnx(self, mapping):\n        \"\"\"\n        Returns the value for each key in the ``mapping`` dict\n        \"\"\"\n        for k in iterkeys(mapping):\n            if self.exists(k):\n                return self._rc_mgetnx(mapping, k)\n\n        return None\n\ndef _rc_msetitem(self, mapping, key, value):\n        \"\"\"\n        Sets the value for the given key in the ``mapping`` dict\n        \"\"\"\n        for k in iterkeys(mapping):\n            if self.exists(k):\n                return False\n\n        return self._rc_mset(mapping,",
        "\n\ndef _rc_get(self, src):\n        \"\"\"\n        Get key ``src``\n        \"\"\"\n        return self.get(src)\n\ndef _rc_set(self, src, value):\n        \"\"\"\n        Set key ``src`` to ``value``\n        \"\"\"\n        return self.set(src, value)\n\ndef _rc_expire(self, src, ttl):\n        \"\"\"\n        Set key ``src`` to ``ttl``\n        \"\"\"\n        return self.expire(src, ttl)\n\ndef _rc_exists(self, src):\n        \"\"\"\n        Check if key ``src`` exists\n        \"\"\"\n        return self.exists(src)\n\ndef _rc_delete(self, src):\n        \"\"\"\n        Delete key ``src``\n        \"\"\"\n        return self.delete(src)\n\ndef _rc_exists_and_delete(self, src):\n        \"\"\"\n        Check if key ``src`` exists and delete it\n        \"\"\"\n        return self.exists_and_delete(src)\n\ndef _rc_exists_and_delete_and_expire(self, src):\n        \"\"\"\n        Check if key ``src`` exists and delete it and expire it\n        \"\"\"\n        return self.exists_and_delete_and_expire(src)\n\ndef _rc_",
        "(src, dst)\n\ndef _rc_rename(self, src, dst):\n        \"Rename key ``src`` to ``dst`` if ``dst`` doesn't already exist\"\n        if self.exists(dst):\n                return False\n\n        return self._rc_set(src, dst)\n\ndef _rc_set(self, src, dst):\n        \"Set key ``src`` to ``dst`` if ``dst`` doesn't already exist\"\n        if self.exists(dst):\n                return False\n\n        return self._rc_set(src, dst, self.get(src))\n\ndef _rc_set_multi(self, src, dst):\n        \"Set key ``src`` to ``dst`` if ``dst`` doesn't already exist\"\n        if self.exists(dst):\n                return False\n\n        return self._rc_set(src, dst, self.get(src, []))\n\ndef _rc_set_multi_multi(self, src, dst):\n        \"Set key ``src`` to ``dst`` if ``dst`` doesn't already exist\"\n        if self.exists(dst):\n                return False\n\n        return self._rc_set(src, dst, self.get(src, [], []))\n\ndef _rc_set_multi_multi_multi(self,",
        "\n        return result\n\ndef _rc_keys_with_prefix(self, pattern='*'):\n        \"Returns a list of keys matching ``pattern`` with a prefix\"\n\n        result = []\n        for alias, redisent in iteritems(self.redises):\n            if alias.find('_slave') == -1:\n                continue\n\n            result.extend(redisent.keys(pattern, prefix=alias))\n\n        return result\n\ndef _rc_keys_with_prefix_and_suffix(self, pattern='*'):\n        \"Returns a list of keys matching ``pattern`` with a prefix and suffix\"\n\n        result = []\n        for alias, redisent in iteritems(self.redises):\n            if alias.find('_slave') == -1:\n                continue\n\n            result.extend(redisent.keys(pattern, prefix=alias, suffix=pattern))\n\n        return result\n\ndef _rc_keys_with_prefix_and_suffix_and_prefix(self, pattern='*'):\n        \"Returns a list of keys matching ``pattern`` with a prefix and suffix and prefix\"\n\n        result = []\n        for alias, redisent in iteritems(self.redises):\n            if alias.find('_slave') == -1:\n                continue\n\n            result.extend(redisent.keys",
        "\n        return result\n\ndef _rc_dbsize_all(self):\n        \"Returns the number of keys in the current database\"\n\n        result = 0\n        for alias, redisent in iteritems(self.redises):\n            if alias.find('_slave') == -1:\n                continue\n\n            result += redisent.dbsize_all()\n\n        return result\n\ndef _rc_dbsize_slave(self):\n        \"Returns the number of keys in the current database\"\n\n        result = 0\n        for alias, redisent in iteritems(self.redises):\n            if alias.find('_slave') == -1:\n                continue\n\n            result += redisent.dbsize_slave()\n\n        return result\n\ndef _rc_dbsize_slave_all(self):\n        \"Returns the number of keys in the current database\"\n\n        result = 0\n        for alias, redisent in iteritems(self.redises):\n            if alias.find('_slave') == -1:\n                continue\n\n            result += redisent.dbsize_slave_all()\n\n        return result\n\ndef _rc_dbsize_slave_slave(self):\n        \"Returns the number of keys in the current database\"\n\n        result = 0\n        for alias, redisent in iteritems(self",
        "\n\nclass Attribute(object):\n    \"\"\"An attribute is a set of values that can be serialized.\n    \"\"\"\n\n    def __init__(self, name, value, namespace=None):\n        \"\"\"Initialize the attribute.\n        \"\"\"\n\n        self.name = name\n        self.value = value\n        self.namespace = namespace\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the attribute.\n        \"\"\"\n\n        return \"<Attribute %s>\" % self.name\n\n    def __str__(self):\n        \"\"\"Return a string representation of the attribute.\n        \"\"\"\n\n        return \"<Attribute %s>\" % self.name\n\n    def __eq__(self, other):\n        \"\"\"Return true if the two attributes are equal.\n        \"\"\"\n\n        return self.name == other.name\n\n    def __ne__(self, other):\n        \"\"\"Return true if the two attributes are not equal.\n        \"\"\"\n\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        \"\"\"Return the hash of the attribute.\n        \"\"\"\n\n        return hash(self.name)\n\n    def __str__(self):\n        \"\"\"Return a string representation of the attribute.\n        \"\"\"\n\n        return \"<Attribute %s>\" % self.name\n\n",
        "\n\ndef sign(xml, stream):\n    \"\"\"\n    Sign the document with the given certificate.\n    Returns `True` if the document is signed with a valid signature.\n    Returns `False` if the document is not signed or if the signature is\n    invalid.\n\n    :param lxml.etree._Element xml: The document to sign\n    :param file stream: The private key to sign the document with\n\n    :rtype: Boolean\n    \"\"\"\n    # Import xmlsec here to delay initializing the C library in\n    # case we don't need it.\n    import xmlsec\n\n    # Find the <Signature/> node.\n    signature_node = xmlsec.tree.find_node(xml, xmlsec.Node.SIGNATURE)\n    if signature_node is None:\n        # No `signature` node found; we cannot sign\n        return False\n\n    # Create a digital signature context (no key manager is needed).\n    ctx = xmlsec.SignatureContext()\n\n    # Register <Response/> and <Assertion/>\n    ctx.register_id(xml)\n    for assertion in xml.xpath(\"//*[local-name()='Assertion']\"):\n        ctx.register_id(assertion)\n\n    # Load the public key.\n    key = None\n    for fmt in [\n            xmlsec.KeyFormat.PEM,",
        ".count())\n\nclass GalleryAdmin(admin.ModelAdmin):\n    list_display = ('name', 'description', 'photo_count')\n    list_filter = ('photo_count',)\n    search_fields = ('name', 'description', 'photo_count')\n    search_fields_list = ('name', 'description', 'photo_count')\n    list_editable = ('photo_count',)\n    search_editable = ('photo_count',)\n    list_filter_horizontal = ('photo_count',)\n    search_filter_horizontal = ('photo_count',)\n    list_filter_horizontal_links = ('photo_count',)\n    search_filter_horizontal_links = ('photo_count',)\n    list_filter_horizontal_links_list = ('photo_count',)\n    search_filter_horizontal_links_list = ('photo_count',)\n    list_filter_horizontal_links_list_editable = ('photo_count',)\n    search_filter_horizontal_links_list_editable = ('photo_count',)\n    list_filter_horizontal_links_list_editable = ('photo_count',)\n    list_filter_horizontal_links_list_editable = ('photo_count',)\n    list_filter_horizontal_links_list_editable = ('photo_count',)",
        "\n        \"\"\"\n        Save the model to the database.\n        \"\"\"\n        obj.save()\n        obj.author = request.user\n        obj.save()\n        obj.save_image(form, change)\n        obj.save_thumbnail(form, change)\n        obj.save_thumbnail_image(form, change)\n        obj.save_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_image(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj.save_thumbnail_thumbnail_thumbnail(form, change)\n        obj",
        "\n        return instances\n\ndef delete_formset(self, request, form, formset, change):\n        \"\"\"\n        For each photo set it's author to currently authenticated user.\n        \"\"\"\n        instances = formset.save(commit=False)\n        for instance in instances:\n            if isinstance(instance, Photo):\n                instance.author = request.user\n            instance.delete()\n        return instances\n\ndef delete_form(self, request, form, formset, change):\n        \"\"\"\n        For each photo set it's author to currently authenticated user.\n        \"\"\"\n        instances = formset.save(commit=False)\n        for instance in instances:\n            if isinstance(instance, Photo):\n                instance.author = request.user\n            instance.delete()\n        return instances\n\ndef delete_formset(self, request, form, formset, change):\n        \"\"\"\n        For each photo set it's author to currently authenticated user.\n        \"\"\"\n        instances = formset.save(commit=False)\n        for instance in instances:\n            if isinstance(instance, Photo):\n                instance.author = request.user\n            instance.delete()\n        return instances\n\ndef delete_form(self, request, form, formset, change):\n        \"\"\"\n        For each photo set it's author to currently authenticated user.",
        "\n\ndef parse_byteranges_header(cls, environ):\n        \"\"\"\n        Outputs a list of tuples with ranges or the empty list\n        According to the rfc, start or end values can be omitted\n        \"\"\"\n        r = []\n        s = environ.get(cls.header_range, '').replace(' ','lower()').lower()\n        if s:\n            l = s.split('=')\n            if len(l) == 2:\n                unit, vals = tuple(l)\n                if unit == 'bytes' and vals:\n                    gen_rng = ( tuple(rng.split('-')) for rng in vals.split(',') if '-' in rng )\n                    for start, end in gen_rng:\n                        if start or end:\n                            r.append( (int(start) if start else None, int(end) if end else None) )\n        return r\n\ndef parse_byteranges_header_value(cls, environ):\n        \"\"\"\n        Outputs a list of tuples with ranges or the empty list\n        According to the rfc, start or end values can be omitted\n        \"\"\"\n        r = []\n        s = environ.get(cls.header_range, '').replace(' ','lower()').lower()\n        if s:\n            l = s.split('=')",
        "\n\ndef check_ranges_with_length(cls, ranges, length):\n        \"\"\"Removes errored ranges with length\"\"\"\n        result = []\n        for start, end in ranges:\n            if isinstance(start, int) or isinstance(end, int):\n                if isinstance(start, int) and not (0 <= start < length):\n                    continue\n                elif isinstance(start, int) and isinstance(end, int) and not (start <= end):\n                    continue\n                elif start is None and end == 0:\n                    continue\n                result.append( (start,end) )\n        return result\n\ndef check_ranges_with_length_and_start(cls, ranges, length, start):\n        \"\"\"Removes errored ranges with length and start\"\"\"\n        result = []\n        for start, end in ranges:\n            if isinstance(start, int) or isinstance(end, int):\n                if isinstance(start, int) and not (0 <= start < length):\n                    continue\n                elif isinstance(start, int) and isinstance(end, int) and not (start <= end):\n                    continue\n                elif start is None and end == 0:\n                    continue\n                result.append( (start,end) )\n        return result\n\ndef check_ranges_with_length_and_start_and_end(cls, ranges,",
        "\n\ndef convert_bytes(cls, bytes, length):\n        \"\"\"Converts to valid byte ranges\"\"\"\n        result = []\n        for start, end in bytes:\n            if end is None:\n                s = length - start\n                result.append( (0 if s < 0 else s, length-1) )\n            elif start is None:\n                s = length - end\n                result.append( (0 if s < 0 else s, length-1) )\n            else:\n                result.append( (start, end if end < length else length-1) )\n        return result\n\ndef convert_bytes_to_ranges(cls, bytes, length):\n        \"\"\"Converts to valid byte ranges\"\"\"\n        result = []\n        for start, end in bytes:\n            if end is None:\n                s = length - start\n                result.append( (0 if s < 0 else s, length-1) )\n            elif start is None:\n                s = length - end\n                result.append( (0 if s < 0 else s, length-1) )\n            else:\n                result.append( (start, end if end < length else length-1) )\n        return result\n\ndef convert_bytes_to_bytes(cls, bytes, length):\n        \"\"\"Converts to valid byte ranges\"\"\"\n        result = []",
        "\n    def merge_ranges(cls, ranges):\n        \"\"\"Merges two ranges\"\"\"\n        result = []\n        if ranges:\n            result.extend(condense_ranges(cls, ranges))\n        return result\n\n    def merge_ranges_by_length(cls, ranges):\n        \"\"\"Merges two ranges by length\"\"\"\n        result = []\n        if ranges:\n            result.extend(condense_ranges(cls, ranges))\n        return result\n\n    def merge_ranges_by_length_and_start(cls, ranges):\n        \"\"\"Merges two ranges by length and start\"\"\"\n        result = []\n        if ranges:\n            result.extend(condense_ranges(cls, ranges))\n        return result\n\n    def merge_ranges_by_length_and_end(cls, ranges):\n        \"\"\"Merges two ranges by length and end\"\"\"\n        result = []\n        if ranges:\n            result.extend(condense_ranges(cls, ranges))\n        return result\n\n    def merge_ranges_by_start_and_end(cls, ranges):\n        \"\"\"Merges two ranges by start and end\"\"\"\n        result = []\n        if ranges:\n            result.extend(condense_ranges(cls, ranges))\n        return result\n\n    def merge_ranges_by_start_and_end_and_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef export_posterior_probability_matrix(self, filename, title=\"Posterior Probability Matrix\"):\n        \"\"\"\n        Writes the posterior probability of read origin\n\n        :param filename: File name for output\n        :param title: The title of the posterior probability matrix\n        :return: Nothing but the method writes a file in EMASE format (PyTables)\n        \"\"\"\n        self.probability.save(h5file=filename, title=title)\n\ndef export_posterior_probability_matrix_from_file(self, filename, title=\"Posterior Probability Matrix From File\"):\n        \"\"\"\n        Writes the posterior probability of read origin\n\n        :param filename: File name for output\n        :param title: The title of the posterior probability matrix\n        :return: Nothing but the method writes a file in EMASE format (PyTables)\n        \"\"\"\n        self.probability.save(h5file=filename, title=title)\n\ndef export_posterior_probability_matrix_from_file_with_header(self, filename, title=\"Posterior Probability Matrix From File With Header\"):\n        \"\"\"\n        Writes the posterior probability of read origin\n\n        :param filename: File name for output\n        :param title: The title of the posterior probability matrix\n        :return: Nothing but the method writes a file in EMASE format",
        "\r\n        print '--'\r\n\r\ndef print_read_data(self, rid):\r\n        \"\"\"\r\n        Prints nonzero rows of the read wanted\r\n\r\n        \"\"\"\r\n        if self.rname is not None:\r\n            print self.rname[rid]\r\n            print '--'\r\n        r = self.get_read_data(rid)\r\n        aligned_loci = np.unique(r.nonzero()[1])\r\n        for locus in aligned_loci:\r\n            nzvec = r[:, locus].todense().transpose()[0].A.flatten()\r\n            if self.lname is not None:\r\n                print self.lname[locus],\r\n            else:\r\n                print locus,\r\n            print nzvec\r\n        print '--'\r\n\r\ndef print_read_data_with_loci(self, rid):\r\n        \"\"\"\r\n        Prints nonzero rows of the read wanted\r\n\r\n        \"\"\"\r\n        if self.rname is not None:\r\n            print self.rname[rid]\r\n            print '--'\r\n        r = self.get_read_data(rid)\r\n        aligned_loci = np.unique(r.nonzero()[1])\r\n        for locus in aligned_loci:",
        "\n\n\ndef _roman_with_togglers(data, scheme_map, **kw):\n  \"\"\"Transliterate `data` with the given `scheme_map`. This function is used\n  when the source scheme is a Roman scheme.\n\n  :param data: the data to transliterate\n  :param scheme_map: a dict that maps between characters in the old scheme\n                     and characters in the new scheme\n  \"\"\"\n  vowels = scheme_map.vowels\n  marks = scheme_map.marks\n  virama = scheme_map.virama\n  consonants = scheme_map.consonants\n  non_marks_viraama = scheme_map.non_marks_viraama\n  max_key_length_from_scheme = scheme_map.max_key_length_from_scheme\n  to_roman = scheme_map.to_scheme.is_roman\n\n  togglers = kw.pop('togglers', set())\n  suspend_on = kw.pop('suspend_on', set())\n  suspend_off = kw.pop('suspend_off', set())\n  if kw:\n    raise TypeError('Unexpected keyword argument %s' % list(kw.keys())[0])\n\n  buf = []\n  i = 0\n  had_con",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.security.permission.ActionConstants;\nimport com.hazelcast.security.permission.MapPermission;",
        "_OR_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_HK_AND_H",
        "\r\n    SCHEMES[HANJA].update({\r\n        'vowels': s(\"\"\"a A i I u U R RR lR lRR E ai O au\"\"\") + s(\"\"\"e o\"\"\"),\r\n        'marks': s(\"\"\"A i I u U R RR lR lRR E ai O au\"\"\") + s(\"\"\"e o\"\"\"),\r\n        'consonants': sanscript.SCHEMES[HANJA]['consonants'] + s(\"\"\"n2 r2 zh\"\"\")\r\n    })\r\n    pop_all(SCHEMES[HANJA].synonym_map, s(\"\"\"e o\"\"\"))\r\n    SCHEMES[HANJA].update({\r\n        'vowels': s(\"\"\"a A i I u U R RR lR lRR E ai O au\"\"\") + s(\"\"\"e o\"\"\"),\r\n        'marks': s(\"\"\"A i I u U R RR lR lRR E ai O au\"\"\") + s(\"\"\"e o\"\"\"),\r\n        'consonants': sanscript.SCHEMES[HANJA]['consonants'] + s(\"\"\"n2 r2 zh\"\"\")\r\n    })\r\n    pop_all(SCHEMES[HANJA].synonym_map, s(\"\"\"e",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        " True\n\ndef get_script(self):\n        \"\"\"\n        get the current script\n        \n        \"\"\"\n        return self.curr_script\n\ndef set_delta(self, i):\n        \"\"\"\n        set the value of delta to reflect the current codepage\n        \n        \"\"\"\n\n        if i in range(1, 10):\n            n = i - 1\n        else:\n            raise IllegalInput(\"Invalid Value for ATR %s\" % (hex(i)))\n\n        if n > -1: # n = -1 is the default script ..\n            self.curr_script = n\n            self.delta = n * DELTA\n        \n        return\n\ndef get_delta(self):\n        \"\"\"\n        get the current script\n        \n        \"\"\"\n        return self.delta\n\ndef set_curr_script(self, i):\n        \"\"\"\n        set the current script to i\n        \n        \"\"\"\n\n        if i in range(1, 10):\n            n = i - 1\n        else:\n            raise IllegalInput(\"Invalid Value for ATR %s\" % (hex(i)))\n\n        if n > -1: # n = -1 is the default script ..\n            self.curr_script = n\n            self.delta = n * DELTA\n        \n        return\n\ndef",
        ")\n\ndef _recognised(chr):\n    \"\"\" Handle recognised characters. \"\"\"\n    if options['handleUnrecognised'] == RECOGNISED_ECHO:\n        return chr\n    elif options['handleUnrecognised'] == RECOGNISED_SUBSTITUTE:\n        return options['substituteChar']\n    else:\n        raise (KeyError, chr)\n\ndef _unrecognised_substitute(chr):\n    \"\"\" Handle unrecognised characters. \"\"\"\n    if options['handleUnrecognised'] == UNRECOGNISED_ECHO:\n        return options['substituteChar']\n    elif options['handleUnrecognised'] == RECOGNISED_SUBSTITUTE:\n        return options['substituteChar']\n    else:\n        raise (KeyError, chr)\n\ndef _recognised_substitute(chr):\n    \"\"\" Handle recognised characters. \"\"\"\n    if options['handleUnrecognised'] == RECOGNISED_ECHO:\n        return options['substituteChar']\n    elif options['handleUnrecognised'] == RECOGNISED_SUBSTITUTE:\n        return options['substituteChar']\n    else:\n        raise (KeyError, chr)\n\ndef _recognised_substitute_sub",
        "\n\ndef _equivalent_with_implicitA(self, char, prev, next, implicitA):\n        \"\"\" Transliterate a Latin character equivalent to Devanagari.\n        \n        Add VIRAMA for ligatures.\n        Convert standalone to dependent vowels.\n        \n        \"\"\"\n        result = []\n        if char.isVowel == False:\n            result.append(char.chr)\n        if char.isConsonant \\\n        and ((next is not None and next.isConsonant) \\\n        or next is None): \n            result.append(DevanagariCharacter._VIRAMA)\n        else:\n            if prev is None or prev.isConsonant == False:\n                result.append(char.chr)\n            else:\n                if char._dependentVowel is not None:\n                    result.append(char._dependentVowel)\n        return result\n\ndef _equivalent_with_implicitB(self, char, prev, next, implicitB):\n        \"\"\" Transliterate a Latin character equivalent to Devanagari.\n        \n        Add VIRAMA for ligatures.\n        Convert standalone to dependent vowels.\n        \n        \"\"\"\n        result = []\n        if char.isVowel == False:\n            result.append(char.chr)\n        if char.isConsonant",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef make_present_participles_with_empower(verbs):\n    \"\"\"Make the list of verbs into present participles\n\n    E.g.:\n\n        empower -> empowering\n        drive -> driving\n    \"\"\"\n    res = []\n    for verb in verbs:\n        parts = verb.split()\n        if parts[0].endswith(\"e\"):\n            parts[0] = parts[0][:-1] + \"ing\"\n        else:\n            parts[0] = parts[0] + \"ing\"\n        res.append(\" \".join(parts))\n    return res\n\ndef make_present_participles_with_drive(verbs):\n    \"\"\"Make the list of verbs into present participles\n\n    E.g.:\n\n        empower -> empowering\n        drive -> driving\n    \"\"\"\n    res = []\n    for verb in verbs:\n        parts = verb.split()\n        if parts[0].endswith(\"e\"):\n            parts[0] = parts[0][:-1] + \"ing\"\n        else:\n            parts[0] = parts[0] + \"ing\"\n        res.append(\" \".join(parts))\n    return res\n\ndef make_present_participles",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef readNamelist(filename, unique_glyphs, cache):\n  \"\"\"Read a Namelist file.\n\n  This is an implementation detail of readNamelist.\n  \"\"\"\n  with open(filename, \"rb\") as f:\n    return _loadNamelistIncludes(readNamelistHeader(f), unique_glyphs, cache)\n\ndef readNamelistHeader(f):\n  \"\"\"Read a Namelist file header.\n\n  This is an implementation detail of readNamelist.\n  \"\"\"\n  header = {}\n  for line in f:\n    if line.startswith(\"#\") or line.startswith(\"#\"):\n      continue\n    if line.startswith(\"# encoding \"):\n      line = line[6:]\n      header[\"encoding\"] = line\n    elif line.startswith(\"# encoding \"):\n      line = line[6:]\n      header[\"encoding\"] = line.split(\"=\")[1]\n    elif line.startswith(\"# encoding \"):\n      line = line[6:]\n      header[\"encoding\"] = line.split(\"=\")[1]\n    elif line.startswith(\"# encoding \"):\n      line = line[6:]\n      header[\"encoding\"] = line.split(\"=\")[1]\n    elif line.startswith(\"# encoding \"):",
        "\n\ndef _loadNamelistIncludes(item, unique_glyphs, cache):\n  \"\"\"Load the includes for a given Namelist item.\n\n  This is an implementation detail of _loadNamelistIncludes.\n  \"\"\"\n  if item[\"includes\"] is not None:\n    return\n\n  # load the includes\n  if unique_glyphs:\n    item[\"includes\"] = _loadNamelistIncludesUnique(item, cache)\n  else:\n    item[\"includes\"] = _loadNamelistIncludes(item, cache)\n\ndef _loadNamelistIncludesUnique(item, cache):\n  \"\"\"Load the includes for a given Namelist item.\n\n  This is an implementation detail of _loadNamelistIncludesUnique.\n  \"\"\"\n  if item[\"ownCharset\"] is not None:\n    item[\"includes\"] = _loadNamelistIncludesUniqueCharset(item, cache)\n  else:\n    item[\"includes\"] = _loadNamelistIncludesUniqueNoCharcode(item, cache)\n\ndef _loadNamelistIncludes(item, cache):\n  \"\"\"Load the includes for a given Namelist item.\n\n  This is an implementation detail of _loadNamelistIncludes.\n  \"\"\"\n  if item[\"ownCharset\"] is not None:\n    item[\"includes\"] = _loadNam",
        "\n\ndef readNamelist(cache, namFilename, unique_glyphs):\n  \"\"\" Read a list of glyph names from a file.\n\n  This is an implementation detail of readNamelist.\n\n  Raises NamelistRecursionError if namFilename is in the process of being included\n  \"\"\"\n  # normalize\n  filename = os.path.abspath(os.path.normcase(namFilename))\n  if filename in cache:\n    raise NamelistRecursionError(filename)\n  cache[filename] = True\n  try:\n    result = __readNamelist(cache, filename, unique_glyphs)\n  finally:\n    cache[filename] = False\n  return result\n\ndef __readNamelist(cache, filename, unique_glyphs):\n  \"\"\" Read a list of glyph names from a file.\n\n  This is an implementation detail of readNamelist.\n\n  Raises NamelistRecursionError if namFilename is in the process of being included\n  \"\"\"\n  # normalize\n  filename = os.path.abspath(os.path.normcase(filename))\n  if filename in cache:\n    raise NamelistRecursionError(filename)\n  cache[filename] = True\n  try:\n    result = cache[filename]\n  finally:\n    cache[filename",
        "\n\ndef readNamelist(namFilename, unique_glyphs=False, cache=None):\n  \"\"\"Reads a Namelist file and returns a dictionary of codepoints.\n\n  This is a replacement CodepointsInSubset and implements the \"#$ include\"\n  header format.\n\n  Args:\n    namFilename: The path to the  Namelist file.\n    unique_glyphs: Optional, whether to only include glyphs unique to subset.\n    cache: Optional, a cache object to use for caching the result.\n  Returns:\n    A dictionary of codepoints.\n  \"\"\"\n  internals_dir = os.path.dirname(os.path.abspath(__file__))\n  target = os.path.join(internals_dir, namFilename)\n  result = {}\n  with open(target, 'r') as f:\n    for line in f:\n      if line.startswith('#$ include'):\n        result[line[len('#$ include'):]] = line[len('#$ include'):].strip()\n  return result\n\ndef writeNamelist(namFilename, result, cache=None):\n  \"\"\"Writes a Namelist file and returns a dictionary of codepoints.\n\n  This is a replacement CodepointsInSubset and implements the \"#$ include\"\n  header format",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef generate_oauth2_token(self):\n        \"\"\"Generates token for oauth2\n        \"\"\"\n        encoded_credentials = base64.b64encode(('{0}:{1}'.format(self.consumer_key,self.consumer_secret)).encode('utf-8'))\n        token = '{0}:{1}'.format(self.access_token,encoded_credentials)\n        return token\n\ndef generate_oauth2_token_secret(self):\n        \"\"\"Generates token secret for oauth2\n        \"\"\"\n        encoded_credentials = base64.b64encode(('{0}:{1}'.format(self.consumer_key,self.consumer_secret)).encode('utf-8'))\n        token_secret = '{0}:{1}'.format(self.access_token_secret,encoded_credentials)\n        return token_secret\n\ndef generate_oauth2_url(self):\n        \"\"\"Generates url for oauth2\n        \"\"\"\n        return 'https://{0}:{1}'.format(self.host,self.port)\n\ndef generate_oauth2_request(self,method,url,params=None,headers=None,data=None):\n        \"\"\"Generates oauth2 request\n        \"\"\"\n        if params is None:\n                params = {}\n        if headers is None:\n                headers = {}\n        if",
        "\n\ndef oauth2_token_parser(self, raw_token):\n        \"\"\"Parse oauth2 token\n        \"\"\"\n        parsed_token = json.loads(raw_token.content.decode('utf-8'))\n        self.access_token = parsed_token['access_token']\n        self.token_type = parsed_token['token_type']\n        self.refresh_token = parsed_token['refresh_token']\n        self.guid = parsed_token['xoauth_yahoo_guid']\n\n        credentials = {\n            'access_token': self.access_token,\n            'token_type': self.token_type,\n            'refresh_token': self.refresh_token,\n            'guid': self.guid\n        }\n        \n        return credentials\n\ndef oauth2_user_parser(self, raw_user):\n        \"\"\"Parse oauth2 user\n        \"\"\"\n        parsed_user = json.loads(raw_user.content.decode('utf-8'))\n        self.username = parsed_user['username']\n        self.email = parsed_user['email']\n        self.password = parsed_user['password']\n        self.guid = parsed_user['xoauth_yahoo_guid']\n\n        credentials = {\n            'username': self.username,\n            'email",
        "\n\ndef generate_oauth2_headers(self,):\n        \"\"\"Generate OAuth2 headers\n        \"\"\"\n        headers = {}\n        headers['Authorization'] = 'Bearer %s' % self.access_token\n        headers['Content-Type'] = 'application/x-www-form-urlencoded'\n        return headers\n\ndef oauth2_access_parser(raw_access):\n        \"\"\"Parse OAuth2 access token\n        \"\"\"\n        access_token = raw_access['access_token']\n        access_token_secret = raw_access['access_token_secret']\n        session_handle = raw_access['oauth_session_handle']\n        return {\n            'access_token': access_token,\n            'access_token_secret': access_token_secret,\n            'session_handle': session_handle\n        }\n\ndef get_user_info(self,):\n        \"\"\"Get user info\n        \"\"\"\n        logger.debug(\"GET USER INFO\")\n        user_info = {\n            'username': self.username,\n            'email': self.email,\n            'first_name': self.first_name,\n            'last_name': self.last_name,\n            'gender': self.gender,\n            'birthday': self.birthday,\n            'gender_id': self.gender_",
        "\n\ndef get_file_extension(filename):\n    \"\"\"Returns name and extension of file\n    \"\"\"\n    name, ext = os.path.splitext(filename)\n    return name, ext\n\ndef json_get_data(filename):\n    \"\"\"Returns data as json\n    \"\"\"\n    with open(filename, 'r') as f:\n        return json.load(f)\n\ndef yaml_get_data(filename):\n    \"\"\"Returns data as yaml\n    \"\"\"\n    with open(filename, 'r') as f:\n        return yaml.load(f)\n\ndef get_file_name(filename):\n    \"\"\"Returns name of file\n    \"\"\"\n    return os.path.splitext(filename)[0]\n\ndef get_file_extension_name(filename):\n    \"\"\"Returns extension of file\n    \"\"\"\n    return os.path.splitext(filename)[1]\n\ndef get_file_extension_ext(filename):\n    \"\"\"Returns extension of file\n    \"\"\"\n    return os.path.splitext(filename)[2]\n\ndef get_file_extension_ext_name(filename):\n    \"\"\"Returns extension of file\n    \"\"\"\n    return os.path.splitext(filename)[3]\n\ndef get_file_extension_ext_ext(filename):\n    \"\"\"Returns extension of",
        "\n\ndef json_write_data(data, filename):\n    \"\"\"Call right func to save data according to file extension\n    \"\"\"\n    name, ext = get_file_extension(filename)\n    func = json_write_data_with_header\n    return func(data, filename)\n\ndef yaml_write_data(data, filename):\n    \"\"\"Call right func to save data according to file extension\n    \"\"\"\n    name, ext = get_file_extension(filename)\n    func = yaml_write_data_with_header\n    return func(data, filename)\n\ndef json_write_data_with_header(data, filename):\n    \"\"\"Call right func to save data according to file extension\n    \"\"\"\n    name, ext = get_file_extension(filename)\n    func = json_write_data_with_header\n    return func(data, filename)\n\ndef yaml_write_data_with_header(data, filename):\n    \"\"\"Call right func to save data according to file extension\n    \"\"\"\n    name, ext = get_file_extension(filename)\n    func = yaml_write_data_with_header\n    return func(data, filename)\n\ndef get_file_extension(filename):\n    \"\"\"Get file extension from filename\n    \"\"\"\n    filename = os.path.split",
        "\n\ndef json_read_data(filename):\n    \"\"\"Read json data from a file\n    \"\"\"\n    with open(filename, 'r') as fp:\n        return json.load(fp)\n\ndef json_write_data_to_file(json_data, filename):\n    \"\"\"Write json data into a file\n    \"\"\"\n    with open(filename, 'w') as fp:\n        json.dump(json_data, fp, indent=4, sort_keys=True, ensure_ascii=False)\n        return True\n\ndef json_read_data_from_file(filename):\n    \"\"\"Read json data from a file\n    \"\"\"\n    with open(filename, 'r') as fp:\n        return json.load(fp)\n\ndef json_write_data_to_csv(json_data, filename):\n    \"\"\"Write json data into a csv file\n    \"\"\"\n    with open(filename, 'w') as fp:\n        csv.writer(fp, delimiter=',', quotechar='\"').writerow(json_data)\n        return True\n\ndef json_read_data_from_csv(filename):\n    \"\"\"Read json data from a csv file\n    \"\"\"\n    with open(filename, 'r') as fp:\n        return json.load(fp)\n\ndef json_write",
        "\n\ndef json_get_data_from_file(filename):\n    \"\"\"Get data from json file\n    \"\"\"\n    with open(filename) as fp:\n        json_data = json.load(fp)\n        return json_data\n\ndef json_get_data_from_file_with_header(filename, header):\n    \"\"\"Get data from json file\n    \"\"\"\n    with open(filename) as fp:\n        json_data = json.load(fp, object_pairs_hook=OrderedDict)\n        json_data.update(header)\n        return json_data\n\ndef json_get_data_from_file_with_header_and_data(filename, header, data):\n    \"\"\"Get data from json file\n    \"\"\"\n    with open(filename) as fp:\n        json_data = json.load(fp, object_pairs_hook=OrderedDict)\n        json_data.update(header)\n        json_data.update(data)\n        return json_data\n\ndef json_get_data_from_file_with_header_and_data_with_header(filename, header, data, header_name):\n    \"\"\"Get data from json file\n    \"\"\"\n    with open(filename) as fp:\n        json_data = json.load(fp, object_pairs",
        "\n\ndef yaml_get_data_from_file(filename):\n    \"\"\"Get data from .yml file\n    \"\"\"\n    with open(filename, 'rb') as fd:\n        yaml_data = yaml.load(fd)\n        return yaml_data\n\ndef yaml_get_data_from_file_with_header(filename, header):\n    \"\"\"Get data from .yml file\n    \"\"\"\n    with open(filename, 'rb') as fd:\n        yaml_data = yaml.load(fd, Loader=yaml.FullLoader)\n        yaml_data.update(header)\n        return yaml_data\n\ndef yaml_get_data_from_file_with_header_and_data(filename, header, data):\n    \"\"\"Get data from .yml file\n    \"\"\"\n    with open(filename, 'rb') as fd:\n        yaml_data = yaml.load(fd, Loader=yaml.FullLoader)\n        yaml_data.update(header)\n        yaml_data.update(data)\n        return yaml_data\n\ndef yaml_get_data_from_file_with_header_and_data_with_header(filename, header, data, header_data):\n    \"\"\"Get data from .yml file\n    \"\"\"\n    with open(filename, 'rb') as fd:\n        yaml",
        "\n\ndef yaml_read_data(filename):\n    \"\"\"Read data from a .yml file\n    \"\"\"\n    with open(filename, 'r') as fd:\n        yaml.load(fd, default_flow_style=False)\n        return True\n\ndef yaml_write_data_from_file(yaml_data, filename):\n    \"\"\"Write data from a .yml file\n    \"\"\"\n    with open(filename, 'w') as fd:\n        yaml.dump(yaml_data, fd, default_flow_style=False)\n        return True\n\ndef yaml_read_data_from_file(filename):\n    \"\"\"Read data from a .yml file\n    \"\"\"\n    with open(filename, 'r') as fd:\n        yaml.load(fd, default_flow_style=False)\n        return True\n\ndef yaml_write_data_from_file_with_header(yaml_data, filename, header):\n    \"\"\"Write data from a .yml file\n    \"\"\"\n    with open(filename, 'w') as fd:\n        yaml.dump(yaml_data, fd, default_flow_style=False,\n                  default_start_tag='#', default_end_tag='#')\n        return True\n\ndef yaml_read_data_from_file_with_header(filename,",
        "\n\ndef transform_inverse(self, X):\n        '''\n        Turns distances into RBF values.\n\n        Parameters\n        ----------\n        X : array\n            The raw pairwise distances.\n\n        Returns\n        -------\n        X_rbf : array of same shape as X\n            The distances in X passed through the RBF kernel.\n        '''\n        X = check_array(X)\n        X_rbf = np.empty_like(X) if self.copy else X\n\n        X_in = X\n        if not self.squared:\n            np.power(X_in, 2, out=X_rbf)\n            X_in = X_rbf\n\n        if self.scale_by_median:\n            scale = self.median_ if self.squared else self.median_ ** 2\n            gamma = self.gamma * scale\n        else:\n            gamma = self.gamma\n        np.multiply(X_in, -gamma, out=X_rbf)\n\n        np.exp(X_rbf, out=X_rbf)\n        return X_rbf\n\ndef transform_inverse_with_mean(self, X):\n        '''\n        Turns distances into RBF values.\n\n        Parameters\n        ----------\n        X : array\n            The raw",
        "\n\n    def predict(self, X):\n        '''\n        Predict the values of the input similarities.\n\n        Parameters\n        ----------\n        X : array, shape [n, n]\n            The *symmetric* input similarities. If X is asymmetric, it will be\n            treated as if it were symmetric based on its lower-triangular part.\n        '''\n        n = X.shape[0]\n        if X.shape != (n, n):\n            raise TypeError(\"Input must be a square matrix.\")\n\n        # TODO: only get negative eigs somehow?\n        memory = get_memory(self.memory)\n        vals, vecs = memory.cache(scipy.linalg.eigh, ignore=['overwrite_a'])(\n            X, overwrite_a=not self.copy)\n        vals = vals.reshape(-1, 1)\n\n        if self.min_eig == 0:\n            inner = vals > self.min_eig\n        else:\n            with np.errstate(divide='ignore'):\n                inner = np.where(vals >= self.min_eig, 1,\n                                 np.where(vals == 0, 0, self.min_eig / vals))\n\n        return np.dot(vecs, inner * vecs.T)\n\n    def transform(self",
        "\n\n    def predict(self, X):\n        '''\n        Predict the inverse of the linear transformation to flipped eigenvalues.\n\n        Parameters\n        ----------\n        X : array, shape [n, n]\n            The *symmetric* input similarities. If X is asymmetric, it will be\n            treated as if it were symmetric based on its lower-triangular part.\n        '''\n        n = X.shape[0]\n        if X.shape != (n, n):\n            raise TypeError(\"Input must be a square matrix.\")\n\n        # TODO: only get negative eigs somehow?\n        memory = get_memory(self.memory)\n        vals, vecs = memory.cache(scipy.linalg.eigh, ignore=['overwrite_a'])(\n            X, overwrite_a=not self.copy)\n        vals = vals[:, None]\n\n        self.flip_ = np.dot(vecs, np.sign(vals) * vecs.T)\n        return self.flip_\n\n    def fit_transform(self, X, y=None):\n        '''\n        Fit the linear transformation to flipped eigenvalues.\n\n        Parameters\n        ----------\n        X : array, shape [n, n]\n            The *symmetric* input similarities. If X is asymmetric, it will be\n            treated as",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\nclass Symmetrize(BaseEstimator):\n    '''\n    A class for transforming a matrix of similarities using symmetric\n    eigenvalues.\n\n    This class is a subclass of BaseEstimator, which is used to\n    transform a matrix of similarities using symmetric eigenvalues.\n\n    Parameters\n    ----------\n    copy : bool, optional\n        If True, the matrix is copied.\n\n    Returns\n    -------\n    Xt : array, shape [n, n]\n        The transformed training similarities.\n    '''\n    def __init__(self, copy=True):\n        self.copy = copy\n\n    def fit_transform(self, X, y=None):\n        '''\n        Flips the negative eigenvalues of X.\n\n        Parameters\n        ----------\n        X : array, shape [n, n]\n            The *symmetric* input similarities. If X is asymmetric, it will be\n            treated as if it were symmetric based on its lower-triangular part.\n\n        Returns\n        -------\n        Xt : array, shape [n, n]\n            The transformed training similarities.\n        '''\n        n = X.shape[0]\n        if X.shape != (n, n):\n            raise TypeError(\"Input must be a square matrix.\")\n\n        memory = get_memory(self.memory)",
        "\n\n    def predict(self, X):\n        '''\n        Predict the transformation to shifted eigenvalues.\n\n        Parameters\n        ----------\n        X : array, shape [n, n]\n            The *symmetric* input similarities.\n        '''\n        n = X.shape[0]\n        if X.shape != (n, n):\n            raise TypeError(\"Input must be a square matrix.\")\n\n        self.train_ = X\n\n        memory = get_memory(self.memory)\n        lo, = memory.cache(scipy.linalg.eigvalsh)(X, eigvals=(0, 0))\n        self.shift_ = max(self.min_eig - lo, 0)\n\n        return self.shift_\n\n    def predict_proba(self, X):\n        '''\n        Predict the transformation to shifted eigenvalues.\n\n        Parameters\n        ----------\n        X : array, shape [n, n]\n            The *symmetric* input similarities.\n        '''\n        n = X.shape[0]\n        if X.shape != (n, n):\n            raise TypeError(\"Input must be a square matrix.\")\n\n        self.train_ = X\n\n        memory = get_memory(self.memory)\n        lo, = memory.cache(scipy.linalg.",
        "\n\ndef fit(X, y, fit_params=None, fit_intercept=None, fit_intercept_params=None,\n        fit_intercept_intercept=None, fit_intercept_intercept_params=None,\n        fit_intercept_intercept_intercept=None, fit_intercept_intercept_intercept_params=None,\n        fit_intercept_intercept_intercept_intercept=None, fit_intercept_intercept_intercept_intercept=None,\n        fit_intercept_intercept_intercept_intercept=None, fit_intercept_intercept_intercept_intercept=None,\n        fit_intercept_intercept_intercept_intercept=None, fit_intercept_intercept_intercept_intercept=None,\n        fit_intercept_intercept_intercept_intercept=None, fit_intercept_intercept_intercept_intercept=None,\n        fit_intercept_intercept_intercept_intercept=None, fit_intercept_intercept_intercept_intercept=None,\n        fit_intercept_intercept_intercept_intercept=None, fit_intercept_intercept_intercept_intercept=None,\n        fit_intercept_intercept_intercept_intercept=None, fit_intercept_intercept_intercept_intercept=None,\n        fit_intercept_intercept_intercept_intercept=None, fit_intercept_intercept_intercept_intercept=None,\n        fit_intercept_intercept_intercept_intercept=None, fit_intercept_",
        "\n\n    def predict(self, X):\n        '''\n        Predicts the values of the basis for the given data.\n\n        Parameters\n        ----------\n        X : an integer, a :class:`Features` instance, or a list of bag features\n            The input data, or just its dimension, since only the dimension is\n            needed here.\n        '''\n        if is_integer(X):\n            dim = X\n        else:\n            X = as_features(X)\n            dim = X.dim\n        M = self.smoothness\n        inds = np.mgrid[(slice(M + 1),) * dim].reshape(dim, (M + 1) ** dim).T\n        return inds[self.inds_]\n\n    def predict_proba(self, X):\n        '''\n        Predicts the probabilities of the basis for the given data.\n\n        Parameters\n        ----------\n        X : an integer, a :class:`Features` instance, or a list of bag features\n            The input data, or just its dimension, since only the dimension is\n            needed here.\n        '''\n        if is_integer(X):\n            dim = X\n        else:\n            X = as_features(X)\n            dim = X.dim\n        M = self.smoothness\n        inds = np.",
        "\n\ndef as_features(X):\n    '''\n    Convert a list of bag features into a list of features.\n\n    Parameters\n    ----------\n    X : :class:`skl_groups.features.Features` or list of bag feature arrays\n        New data to transform. The data should all lie in [0, 1];\n        use :class:`skl_groups.preprocessing.BagMinMaxScaler` if not.\n\n    Returns\n    -------\n    X_new : :class:`skl_groups.features.Features`\n        New data transformed into the new space.\n    '''\n    X = np.asarray(X)\n    if X.ndim != 1:\n        raise ValueError(\"model fit for dimension {} but got dim {}\".format(X.ndim, X.dim))\n\n    Xt = np.empty((len(X), self.inds_.shape[0]))\n    Xt.fill(np.nan)\n\n    if self.basis == 'cosine':  # TODO: put this in a C extension?\n        coefs = (np.pi * np.arange(self.smoothness + 1))[..., :]\n        for i, bag in enumerate(X):\n            if do_check:\n                if np.min(bag) < 0 or np.max(bag",
        "\n\ndef get_long_description(self):\n        \"\"\"\n        Get distribution long description.\n\n        This method is enhanced compared to original distutils implementation.\n        If the long description string is set to a special value then instead of\n        using the actual value the real long description is obtained by querying\n        versiontools.\n\n        If versiontools package is not installed then the long description is obtained\n        from the standard section of the ``PKG-INFO`` file. This file is\n        automatically created by any source distribution. This method is less\n        useful as it cannot take advantage of version control information that\n        is automatically loaded by versiontools. It has the advantage of not\n        requiring versiontools installation and that it does not depend on\n        ``setup_requires`` feature of ``setuptools``.\n        \"\"\"\n        if (self.name is not None and self.version is not None\n            and self.version.startswith(\":versiontools:\")):\n            return (self.__get_live_long_description() or self.__get_frozen_long_description()\n                    or self.__fail_to_get_any_long_description())\n        else:\n            return self.__base.get_long_description(self)\n\ndef get_url(self):\n        \"\"\"\n        Get distribution URL.\n\n        This method is enhanced",
        "\n\ndef __get_live_version_string(self):\n        \"\"\"\n        Get a live version string using versiontools\n        \"\"\"\n        try:\n            import versiontools\n        except ImportError:\n            return None\n        else:\n            return str(versiontools.Version.from_expression(self.name))\n\ndef __get_live_version_string_with_version(self):\n        \"\"\"\n        Get a live version string using versiontools\n        \"\"\"\n        try:\n            import versiontools\n        except ImportError:\n            return None\n        else:\n            return str(versiontools.Version.from_expression(self.name))\n\ndef __get_live_version_string_with_version_and_build(self):\n        \"\"\"\n        Get a live version string using versiontools\n        \"\"\"\n        try:\n            import versiontools\n        except ImportError:\n            return None\n        else:\n            return str(versiontools.Version.from_expression(self.name))\n\ndef __get_live_version_string_with_version_and_build_and_revision(self):\n        \"\"\"\n        Get a live version string using versiontools\n        \"\"\"\n        try:\n            import versiontools\n        except ImportError:\n            return None\n        else:\n            return str(versiontools.Version.from_expression",
        "\n\n    def predict(self, X):\n        '''\n        Predict the labels for the stacked points.\n\n        Parameters\n        ----------\n        X : :class:`Features` or list of arrays of shape ``[n_samples[i], n_features]``\n            Training set. If a Features object, it will be stacked.\n\n        Returns\n        -------\n        y : :class:`numpy.ndarray` of shape ``[n_samples[i], n_labels]``\n            Predicted labels.\n        '''\n        X = as_features(X, stack=True)\n        return self.transformer.predict(X.stacked_features)\n\n    def predict_proba(self, X):\n        '''\n        Predict the probabilities for the stacked points.\n\n        Parameters\n        ----------\n        X : :class:`Features` or list of arrays of shape ``[n_samples[i], n_features]``\n            Training set. If a Features object, it will be stacked.\n\n        Returns\n        -------\n        y : :class:`numpy.ndarray` of shape ``[n_samples[i], n_labels]``\n            Predicted labels.\n        '''\n        X = as_features(X, stack=True)\n        return self.transformer.predict_proba(X.stacked_features",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n    def predict(self, X):\n        \"\"\"Compute the predicted values for each feature.\n\n        Parameters\n        ----------\n        X : array-like, shape [n_samples, n_features]\n            The data used to compute the per-feature predicted values.\n\n        Returns\n        -------\n        y : array-like, shape [n_samples]\n            The predicted values for each feature.\n        \"\"\"\n        X = check_array(X, copy=self.copy,\n                        dtype=[np.float64, np.float32, np.float16, np.float128])\n\n        if self.fit_feature_range is not None:\n            X = X[self.fit_feature_range]\n\n        if self.min_ is None:\n            self.min_ = np.min(X, axis=0)\n\n        if self.scale_ is None:\n            self.scale_ = np.max(X, axis=0) / self.data_range\n\n        return np.clip(X - self.min_, 0.0, 1.0)\n\n    def predict_proba(self, X):\n        \"\"\"Compute the predicted probabilities for each feature.\n\n        Parameters\n        ----------\n        X : array-like, shape [n_samples, n_features]\n            The",
        "\n\ndef transform_features(self, X, feature_range):\n        \"\"\"Scaling features of X according to feature_range.\n\n        Parameters\n        ----------\n        X : array-like with shape [n_samples, n_features]\n            Input data that will be transformed.\n        feature_range : tuple of int\n            Feature range of X.\n        \"\"\"\n        X = check_array(X, copy=self.copy)\n        X *= self.scale_\n        X += self.min_\n        if self.truncate:\n            np.maximum(feature_range[0], X, out=X)\n            np.minimum(feature_range[1], X, out=X)\n        return X\n\ndef transform_features_with_mean(self, X, feature_range):\n        \"\"\"Scaling features of X according to feature_range.\n\n        Parameters\n        ----------\n        X : array-like with shape [n_samples, n_features]\n            Input data that will be transformed.\n        feature_range : tuple of int\n            Feature range of X.\n        \"\"\"\n        X = check_array(X, copy=self.copy)\n        X *= self.scale_\n        X += self.min_\n        if self.truncate:\n            np.maximum(feature_range[0], X, out",
        "\n\ndef inverse_transform_with_clip(self, X, clip_range=None, clip_value=None,\n                               clip_mode='clip', clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range=None, clip_value_range=None,\n                               clip_mode_range",
        "\n\n    def predict(self, X):\n        '''\n        Predict the codewords based on a test set.\n\n        Parameters\n        ----------\n        X : :class:`skl_groups.features.Features` or list of arrays of shape ``[n_samples[i], n_features]``\n            Test set. If a Features object, it will be stacked.\n        '''\n        self.kmeans_predict_ = copy(self.kmeans)\n        X = as_features(X, stack=True)\n        self.kmeans_predict_.fit(X.stacked_features) \n        return self\n\n    def predict_proba(self, X):\n        '''\n        Predict the codewords based on a test set.\n\n        Parameters\n        ----------\n        X : :class:`skl_groups.features.Features` or list of arrays of shape ``[n_samples[i], n_features]``\n            Test set. If a Features object, it will be stacked.\n        '''\n        self.kmeans_predict_proba_ = copy(self.kmeans)\n        X = as_features(X, stack=True)\n        self.kmeans_predict_proba_.fit(X.stacked_features) \n        return self\n\n    def predict_proba_fit(self",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.",
        "\n\ndef is_integer_type(ary):\n    \"Checks whether the array is either integral or boolean.\"\n    ary = np.asanyarray(ary)\n    return ary.dtype.kind == 'i'\n\ndef is_floating_point_type(ary):\n    \"Checks whether the array is either integral or boolean.\"\n    ary = np.asanyarray(ary)\n    return ary.dtype.kind == 'f'\n\ndef is_string_type(ary):\n    \"Checks whether the array is either string or boolean.\"\n    ary = np.asanyarray(ary)\n    return ary.dtype.kind == 's'\n\ndef is_complex_type(ary):\n    \"Checks whether the array is either complex or boolean.\"\n    ary = np.asanyarray(ary)\n    return ary.dtype.kind == 'c'\n\ndef is_complex_type_with_dtype(ary, dtype):\n    \"Checks whether the array is either complex or boolean.\"\n    ary = np.asanyarray(ary)\n    return ary.dtype.kind == 'c' and ary.dtype == dtype\n\ndef is_complex_type_with_dtype_and_shape(ary, dtype, shape):\n    \"Checks whether the array is either complex or boolean.\"\n    ary = np.asany",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        if total is None:\n            total = self.total\n        self.logger.info(json.dumps(['START', self.name, total]))\n\ndef stop(self):\n        '''\n        Signal the stop of the process.\n\n        Parameters\n        ----------\n        '''\n        self.logger.info(json.dumps(['STOP', self.name]))\n\ndef step(self, step):\n        '''\n        Signal a step in the process.\n\n        Parameters\n        ----------\n        step : int\n            The step number in the process, or None if unknown.\n        '''\n        self.logger.info(json.dumps(['STEP', self.name, step]))\n\ndef step_done(self):\n        '''\n        Signal the end of the process.\n\n        Parameters\n        ----------\n        '''\n        self.logger.info(json.dumps(['STEP_DONE', self.name]))\n\ndef step_failed(self):\n        '''\n        Signal the end of the process.\n\n        Parameters\n        ----------\n        '''\n        self.logger.info(json.dumps(['STEP_FAILED', self.name]))\n\ndef step_aborted(self):\n        '''\n        Signal the end of the process.\n\n        Parameters\n        ----------\n        '''\n        self.",
        "\n\ndef _build_index(X, flann_args):\n    \"Builds FLANN index for each bag.\"\n    # TODO: should probably multithread this\n    logger.info(\"Building index...\")\n    indices = [None] * len(X)\n    for i, bag in enumerate(plog(X, name=\"index building\")):\n        indices[i] = idx = FLANNIndex(**flann_args)\n        idx.build_index(bag)\n    return indices\n\ndef _build_index_from_bag(X, flann_args):\n    \"Builds FLANN index for each bag.\"\n    # TODO: should probably multithread this\n    logger.info(\"Building index from bag...\")\n    indices = [None] * len(X)\n    for i, bag in enumerate(plog(X, name=\"index building\")):\n        indices[i] = idx = FLANNIndex(**flann_args)\n        idx.build_index_from_bag(bag)\n    return indices\n\ndef _build_index_from_bag_with_index(X, flann_args):\n    \"Builds FLANN index for each bag.\"\n    # TODO: should probably multithread this\n    logger.info(\"Building index from bag with index...\"",
        "\n\n\ndef _get_rhos_from_bag(X, indices, Ks, max_K, save_all_Ks, min_dist):\n    \"Gets within-bag distances for each bag.\"\n    logger.info(\"Getting within-bag distances...\")\n\n    if max_K >= X.n_pts.min():\n        msg = \"asked for K = {}, but there's a bag with only {} points\"\n        raise ValueError(msg.format(max_K, X.n_pts.min()))\n\n    # need to throw away the closest neighbor, which will always be self\n    # thus K=1 corresponds to column 1 in the result array\n    which_Ks = slice(1, None) if save_all_Ks else Ks\n\n    indices = plog(indices, name=\"within-bag distances\")\n    rhos = [None] * len(X)\n    for i, (idx, bag) in enumerate(zip(indices, X)):\n        r = np.sqrt(idx.nn_index(bag, max_K + 1)[1][:, which_Ks])\n        np.maximum(min_dist, r, out=r)\n        rhos[i] = r\n    return rhos\n\n\ndef _get_rhos_from_bag",
        "(Ks, dim, num_q, rhos, nus)\n\ndef _get_linear(Ks, dim):\n    '''\n    Returns a function that computes the linear inner product \\int p q between two\n    distributions, based on kNN distances.\n    '''\n    return lambda num_q, rhos, nus: (\n        Ks.log_prob(num_q) + Ks.log_prob(num_q) * (1 - Ks.log_prob(num_q) / Ks.log_prob(num_q))\n    )\n\ndef _get_log_prob(Ks, dim):\n    '''\n    Returns a function that computes the log probability of the inner product \\int p q\n    between two distributions, based on kNN distances.\n    '''\n    return lambda num_q, rhos, nus: (\n        Ks.log_prob(num_q) + Ks.log_prob(num_q) * (1 - Ks.log_prob(num_q) / Ks.log_prob(num_q))\n    )\n\ndef _get_log_prob_2(Ks, dim):\n    '''\n    Returns a function that computes the log probability of the inner product \\int p q\n    between two distributions, based on",
        "\n\n\ndef l2_distance(Ks, dim, rhos, required=None):\n    r'''\n    Estimates \\int p^2 based on kNN distances.\n\n    In here because it's used in the l2 distance, above.\n\n    Returns array of shape (num_Ks,).\n    '''\n    # Estimated with alpha=1, beta=0:\n    #   B_{k,d,1,0} is the same as B_{k,d,0,1} in linear()\n    # and the full estimator is\n    #   B / (n - 1) * mean(rho ^ -dim)\n    N = rhos.shape[0]\n    Ks = np.asarray(Ks)\n    Bs = (Ks - 1) / np.pi ** (dim / 2) * gamma(dim / 2 + 1)  # shape (num_Ks,)\n    est = Bs / (N - 1) * np.mean(rhos ** (-dim), axis=0)\n    return est\n\n\ndef linear(Ks, dim, rhos, required=None):\n    r'''\n    Estimates \\int p^2 based on kNN distances.\n\n    In here because it's used in the l2 distance, above.\n\n    Returns",
        "\n\ndef iteritems(d):\n    '''\n    Returns a dict of (key, value) pairs.\n    '''\n    return dict((k, d[k]) for k in d)\n\ndef itervalues(d):\n    '''\n    Returns a dict of (key, value) pairs.\n    '''\n    return dict((k, d[k]) for k in d)\n",
        "\n\ndef _get_Ks_array(self):\n        \"Ks as an array and type-checked.\"\n        Ks = _get_Ks()\n        if Ks.ndim != 1:\n            raise TypeError(\"Ks should be 1-dim, got shape {}\".format(Ks.shape))\n        if Ks.min() < 1:\n            raise ValueError(\"Ks should be positive; got {}\".format(Ks.min()))\n        return Ks\n\ndef _get_Ks_array_type(self):\n        \"Ks as an array and type-checked.\"\n        Ks = _get_Ks()\n        if Ks.ndim != 1:\n            raise TypeError(\"Ks should be 1-dim, got shape {}\".format(Ks.shape))\n        if Ks.min() < 1:\n            raise ValueError(\"Ks should be positive; got {}\".format(Ks.min()))\n        return Ks\n\ndef _get_Ks_array_type_array(self):\n        \"Ks as an array and type-checked.\"\n        Ks = _get_Ks()\n        if Ks.ndim != 1:\n            raise TypeError(\"Ks should be 1-dim, got shape {}\".format(Ks.shape))\n",
        "\n\ndef _flann_algorithm(self, X):\n        \"The algorithm to use for FLANN.\"\n        if self.flann_algorithm == 'auto':\n            if X is None or X.dim > 5:\n                return 'linear'\n            else:\n                return 'kdtree_single'\n        else:\n            return self.flann_algorithm\n\ndef _flann_args(self, X=None):\n        \"The dictionary of arguments to give to FLANN.\"\n        args = {'cores': self._n_jobs}\n        if self.flann_algorithm == 'auto':\n            if X is None or X.dim > 5:\n                return 'linear'\n            else:\n                return 'kdtree_single'\n        else:\n            return self.flann_algorithm\n\ndef _flann_algorithm_args(self, X=None):\n        \"The dictionary of arguments to give to FLANN.\"\n        args = {'cores': self._n_jobs}\n        if self.flann_algorithm == 'auto':\n            if X is None or X.dim > 5:\n                return 'linear'\n            else:\n                return 'kdtree_single'\n        else:\n            return self.flann_algorithm\n\ndef _flann_args_dict(",
        " self\n\n    def transform(self, X, y=None):\n        '''\n        Transform the data X into a new data X.\n        Builds FLANN indices for each bag, and maybe gets within-bag distances.\n\n        Parameters\n        ----------\n        X : list of arrays or :class:`skl_groups.features.Features`\n            The bags to transform.\n\n        Returns\n        -------\n        X : list of arrays or :class:`skl_groups.features.Features`\n            The transformed bags.\n        '''\n        self.features_ = X = as_features(X, stack=True, bare=True)\n        self.indices_ = id = memory.cache(_build_indices)(X, self._flann_args())\n        if self.do_sym:\n            self.rhos_ = _get_rhos(X, id, self.Ks, self.max_K, self.save_all_Ks, self.min_dist)\n        else:\n            self.rhos_ = None\n        return self\n\n    def _get_Ks(self):\n        '''\n        Returns a list of K values for each bag.\n        '''\n        return self.Ks\n\n    def _build_indices(self, X, args):\n        '''\n        Build",
        ".\n\ndef make_unstacked(self):\n        \"If stacked, convert to unstacked. If unstacked, do nothing.\"\n        if self.stacked:\n            return\n\n        self._boundaries = np.r_[0, np.cumsum(self.n_pts)]\n        self.stacked_features = np.vstack(self.features)\n        self.features = np.array(\n            [self.stacked_features[bounds[i-1]:bounds[i]] for i in xrange(1, len(bounds))],\n            dtype=object)\n        self.stacked = False\n\ndef make_stacked_features(self):\n        \"If stacked, convert to stacked features. If unstacked, do nothing.\"\n        if self.stacked:\n            return\n\n        self._boundaries = np.r_[0, np.cumsum(self.n_pts)]\n        self.stacked_features = np.vstack(self.features)\n        self.features = np.array(\n            [self.stacked_features[bounds[i-1]:bounds[i]] for i in xrange(1, len(bounds))],\n            dtype=object)\n        self.stacked = True\n\ndef make_unstacked_features(self):\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n    def predict(self, X):\n        '''\n        Compute the kernel values for the given data.\n\n        Parameters\n        ----------\n        X : list of arrays or :class:`skl_groups.features.Features`\n            The bags to compute \"to\".\n        '''\n        return self.kernel_(self.features_(X))\n\n    def kernel_(self, X):\n        '''\n        Compute the kernel values for the given data.\n\n        Parameters\n        ----------\n        X : list of arrays or :class:`skl_groups.features.Features`\n            The bags to compute \"to\".\n        '''\n        return self.kernel_.fit(X)\n\n    def predict_proba(self, X):\n        '''\n        Compute the probability of the given data.\n\n        Parameters\n        ----------\n        X : list of arrays or :class:`skl_groups.features.Features`\n            The bags to compute \"to\".\n        '''\n        return self.kernel_.predict_proba(X)\n\n    def predict_proba_(self, X):\n        '''\n        Compute the probability of the given data.\n\n        Parameters\n        ----------\n        X : list of arrays or :class:`skl_groups.features.Features`\n            The bags to compute \"to\".",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef disconnect(self):\n        \"\"\"Disconnect from the server\n\n        :raise ConnectionError: If socket cannot disconnect\n\n        \"\"\"\n        try:\n            logger.info(u'Disconnecting %s:%d' % (self.host, self.port))\n            self.sock.close()\n        except socket.error:\n            raise ConnectionError()\n        self.state = DISCONNECTED\n\ndef send(self, data):\n        \"\"\"Send data to the server\n\n        :raise ConnectionError: If socket cannot send data\n\n        \"\"\"\n        try:\n            logger.info(u'Sending %s:%d' % (self.host, self.port))\n            self.sock.sendall(data)\n        except socket.error:\n            raise ConnectionError()\n\ndef receive(self):\n        \"\"\"Receive data from the server\n\n        :raise ConnectionError: If socket cannot receive data\n\n        \"\"\"\n        try:\n            logger.info(u'Receiving %s:%d' % (self.host, self.port))\n            return self.sock.recv(1024)\n        except socket.error:\n            raise ConnectionError()\n\ndef send_command(self, command):\n        \"\"\"Send a command to the server\n\n        :raise ConnectionError: If socket cannot send command\n\n        \"\"\"\n        try:\n            logger.info",
        "\n        logger.info(u'Disconnected')\n\ndef connect(self, host, port):\n        \"\"\"Connect to the server\"\"\"\n        logger.info(u'Connecting to %s:%s' % (host, port))\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.connect((host, port))\n        self.state = CONNECTING\n\ndef send(self, data):\n        \"\"\"Send data to the server\"\"\"\n        logger.info(u'Sending %s' % data)\n        self.sock.sendall(data)\n\ndef receive(self):\n        \"\"\"Receive data from the server\"\"\"\n        logger.info(u'Receiving')\n        return self.sock.recv(1024)\n\ndef send_command(self, command):\n        \"\"\"Send a command to the server\"\"\"\n        logger.info(u'Sending command %s' % command)\n        self.sock.sendall(command)\n\ndef receive_command(self):\n        \"\"\"Receive a command from the server\"\"\"\n        logger.info(u'Receiving command')\n        return self.sock.recv(1024)\n\ndef send_message(self, message):\n        \"\"\"Send a message to the server\"\"\"\n        logger.info(u'Sending message %",
        "\n\nclass SendTimeoutError(Exception):\n        \"\"\"Raised when the server sends a command that timed out\"\"\"\n        pass\n\nclass SendTimeout(object):\n        \"\"\"A class that can be used to send a command to the server\"\"\"\n        def __init__(self, timeout=5):\n                self.timeout = timeout\n\n        def __call__(self, command):\n                self.send(command, self.timeout)\n\n        def __str__(self):\n                return u'Sending %s in %s seconds' % (command, self.timeout)\n\n\nclass Server(object):\n        \"\"\"A class that can be used to communicate with the server\"\"\"\n        def __init__(self, port=8080):\n                self.port = port\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                self.sock.bind((u'127.0.0.1', self.port))\n                self.sock.listen(1)\n\n        def __call__(self, command):\n                self.send(command)\n\n        def __str__(self):\n                return u'Listening on %s' % self.sock.getsockname",
        "\n\ndef _writeline(self, line):\n        \"\"\"Write a line to the server. Data is written to the socket until a character ``\\n`` is found\n\n        :param line: the line to write\n        :type line: string\n\n        \"\"\"\n        while 1:\n            writable, _, __ = select.select([self.sock], [], [], 0.5)\n            if self._stop:\n                break\n            if not writable:\n                continue\n            data = unicode(line, self.encoding)\n            writable[0].sendall(data)\n            if data == '\\n':\n                break\n\ndef _read(self, size=None):\n        \"\"\"Read a chunk of data from the server.\n\n        :param size: the size of the chunk to read\n        :type size: int\n\n        \"\"\"\n        if size is None:\n            size = self.size\n        data = ''\n        while 1:\n            readable, _, __ = select.select([self.sock], [], [], 0.5)\n            if self._stop:\n                break\n            if not readable:\n                continue\n            data += readable[0].recv(size)\n            if data == '\\n':\n                break\n        return data\n\ndef _write(self, data):\n        \"\"\"Write a chunk",
        "\n        return block\n\ndef _readline(self):\n        \"\"\"Read a line from the server. Lines are read until a character ``.`` is found\n\n        :return: the read line\n        :rtype: string\n\n        \"\"\"\n        line = ''\n        while not self._stop:\n            line = self._readline()\n            if line == '.':\n                break\n            yield line\n\ndef _readlines(self, count=1):\n        \"\"\"Read a list of lines from the server. Lines are read until a character ``.`` is found\n\n        :param count: the number of lines to read\n        :type count: int\n\n        :return: the read lines\n        :rtype: list\n\n        \"\"\"\n        lines = []\n        while not self._stop:\n            line = self._readline()\n            if line == '.':\n                break\n            lines.append(line)\n            if len(lines) == count:\n                break\n        return lines\n\ndef _readfile(self, filename):\n        \"\"\"Read a file from the server. Lines are read until a character ``.`` is found\n\n        :param filename: the filename to read\n        :type filename: string\n\n        :return: the read file\n        :rtype: string\n\n        \"\"\"\n        with open(filename",
        "\n\ndef _readblock(self):\n        \"\"\"Read a block and return the result as a string\n\n        :return: block as string\n        :rtype: str\n\n        \"\"\"\n        block = self._readline()\n        if block:\n            return block\n        else:\n            return None\n\ndef _readline(self):\n        \"\"\"Read a line and return the result as a string\n\n        :return: line as string\n        :rtype: str\n\n        \"\"\"\n        line = self._readline()\n        if line:\n            return line\n        else:\n            return None\n\ndef _readblock_xml(self):\n        \"\"\"Read a block and return the result as XML\n\n        :return: block as xml\n        :rtype: xml.etree.ElementTree\n\n        \"\"\"\n        block = _readxml()\n        if block:\n            return block\n        else:\n            return None\n\ndef _readblock_text(self):\n        \"\"\"Read a block and return the result as a string\n\n        :return: block as string\n        :rtype: str\n\n        \"\"\"\n        block = self._readline()\n        if block:\n            return block\n        else:\n            return None\n\ndef _readblock_text_xml(self):\n        \"\"\"Read a block and",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "\n\ndef get_user_id(user_name):\n    \"\"\"Get the user ID of a user name, using both the OSM API and the Mapbox\n    comments APIself.\n    \"\"\"\n    reasons = []\n    try:\n        url = OSM_USERS_API.format(user_name=requests.compat.quote(user_name))\n        user_request = requests.get(url)\n        if user_request.status_code == 200:\n            user_data = user_request.content\n            xml_data = ET.fromstring(user_data).getchildren()[0].getchildren()\n            user_id = xml_data[0].get('id')\n            reasons.append(user_id)\n    except Exception as e:\n        message = 'Could not verify user name: {}, {}'\n        print(message.format(user_name, str(e)))\n    return reasons\n\ndef get_user_name(user_id):\n    \"\"\"Get the user name of a user ID, using both the OSM API and the Mapbox\n    comments APIself.\n    \"\"\"\n    reasons = []\n    try:\n        url = OSM_USERS_API.format(user_id=requests.compat.quote(user_id))\n        user_request = requests.get(url)\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.GetOperation;\nimport com.hazelcast.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        ".split(',')[1])\n\ndef get_area_from_geojson(self, geojson):\n        \"\"\"Read the first feature from the geojson and return it as a Polygon object.\n        \"\"\"\n        geojson = json.load(open(geojson, 'r'))\n        self.area = Polygon(geojson['features'][0]['geometry']['coordinates'][0])\n\ndef get_area_from_geojson_with_coordinates(self, geojson):\n        \"\"\"Read the first feature from the geojson and return it as a Polygon object.\n        \"\"\"\n        geojson = json.load(open(geojson, 'r'))\n        self.area = Polygon(geojson['features'][0]['geometry']['coordinates'][0])\n\ndef get_area_from_geojson_with_coordinates_and_name(self, geojson):\n        \"\"\"Read the first feature from the geojson and return it as a Polygon object.\n        \"\"\"\n        geojson = json.load(open(geojson, 'r'))\n        self.area = Polygon(geojson['features'][0]['geometry']['coordinates'][0])\n\ndef get_area_from_geojson_with_coordinates_and_name_and_type(self, geojson):\n        \"\"\"Read the first feature from the geojson and return it as a Polygon object.\n        \"\"\"\n       ",
        "\n        ]\n\ndef get_bounds(ch):\n        \"\"\"Get the bounds of the given change.\"\"\"\n        return ch.geometry.get_bounds()\n\ndef get_changesets(self):\n        \"\"\"Get the changesets from the geojson geometry.\"\"\"\n        return self.xml.getchildren()\n\ndef get_changesets_by_type(self, type):\n        \"\"\"Get the changesets that match the given type.\"\"\"\n        return [\n            ch\n            for ch in self.xml.getchildren()\n            if ch.type == type\n        ]\n\ndef get_changesets_by_type_and_id(self, type, id):\n        \"\"\"Get the changesets that match the given type and id.\"\"\"\n        return [\n            ch\n            for ch in self.xml.getchildren()\n            if ch.type == type and ch.id == id\n        ]\n\ndef get_changesets_by_type_and_name(self, type, name):\n        \"\"\"Get the changesets that match the given type and name.\"\"\"\n        return [\n            ch\n            for ch in self.xml.getchildren()\n            if ch.type == type and ch.name == name\n        ]\n\ndef get_changesets_by_type_and_name_and_id(self, type, name, id):",
        "\n        self.powerfull_comment = None\n        self.powerfull_source = None\n        self.powerfull_imagery_used = None\n        self.powerfull_suspicion_reasons = []\n        self.powerfull_is_suspect = False\n        self.powerfull_is_powerfull = False\n        self.powerfull_is_powerfull_comment = False\n        self.powerfull_is_powerfull_source = False\n        self.powerfull_is_powerfull_imagery_used = False\n        self.powerfull_is_powerfull_suspicion_reasons = False\n        self.powerfull_is_powerfull_is_suspect = False\n        self.powerfull_is_powerfull_is_powerfull_comment = False\n        self.powerfull_is_powerfull_is_powerfull_source = False\n        self.powerfull_is_powerfull_is_powerfull_imagery_used = False\n        self.powerfull_is_powerfull_is_powerfull_suspicion_reasons = False\n        self.powerfull_is_powerfull_is_powerfull_is_suspect = False\n        self.powerfull_is_powerfull_is_powerfull_is_powerfull_",
        "\n\ndef label_suspicious_reason(self, reason):\n        \"\"\"Add suspicion reason and set the suspicious flag.\"\"\"\n        self.suspicion_reasons.append(reason)\n        self.is_suspect = True\n\ndef label_suspicious_reasons(self, reasons):\n        \"\"\"Add suspicion reason and set the suspicious flag.\"\"\"\n        self.suspicion_reasons = reasons\n        self.is_suspect = True\n\ndef label_suspicious_reason_list(self, reasons):\n        \"\"\"Add suspicion reason and set the suspicious flag.\"\"\"\n        self.suspicion_reasons = reasons\n        self.is_suspect = True\n\ndef label_suspicious_reason_list_all(self, reasons):\n        \"\"\"Add suspicion reason and set the suspicious flag.\"\"\"\n        self.suspicion_reasons = reasons\n        self.is_suspect = True\n\ndef label_suspicious_reason_list_all_reasons(self, reasons):\n        \"\"\"Add suspicion reason and set the suspicious flag.\"\"\"\n        self.suspicion_reasons = reasons\n        self.is",
        "\n        else:\n            self.label_suspicious('Review not requested')\n\n        if self.review_requested == 'no':\n            self.label_suspicious('Review not requested')\n\n        if self.review_requested == 'yes':\n            self.label_suspicious('Review requested')\n\n        if self.review_requested == 'no':\n            self.label_suspicious('Review not requested')\n\n        if self.review_requested == 'yes':\n            self.label_suspicious('Review requested')\n\n        if self.review_requested == 'no':\n            self.label_suspicious('Review not requested')\n\n        if self.review_requested == 'yes':\n            self.label_suspicious('Review requested')\n\n        if self.review_requested == 'no':\n            self.label_suspicious('Review not requested')\n\n        if self.review_requested == 'yes':\n            self.label_suspicious('Review requested')\n\n        if self.review_requested == 'no':\n            self.label_suspicious('Review not requested')\n\n        if self.review_requested == 'yes':\n            self.label_suspicious('Review requested')\n\n        if self",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n    logger.info(\n        'Unwrapped stream from URI (%s) failed: '\n        'timed out in %sms', uri, timeout)\n    return None\n\n\ndef _unwrap_playlist(uri, timeout, scanner, requests_session):\n    \"\"\"\n    Get a stream URI from a playlist URI, ``uri``.\n    Unwraps nested playlists until something that's not a playlist is found or\n    the ``timeout`` is reached.\n    \"\"\"\n\n    original_uri = uri\n    seen_uris = set()\n    deadline = time.time() + timeout\n\n    while time.time() < deadline:\n        if uri in seen_uris:\n            logger.info(\n                'Unwrapping playlist from URI (%s) failed: '\n                'playlist referenced itself', uri)\n            return None\n        else:\n            seen_uris.add(uri)\n\n        logger.debug('Unwrapping playlist from URI: %s', uri)\n\n        try:\n            scan_timeout = deadline - time.time()\n            if scan_timeout < 0:\n                logger.info(\n                    'Unwrapping playlist from URI (%s) failed: '\n                    'timed out in %sms', uri, timeout)\n                return None\n            scan_result = scanner.scan(uri, timeout=",
        "\n\n\nclass HttpProtocol(object):\n    \"\"\"HTTP protocol class.\n\n    :param loop: asyncio compatible event loop\n    :param connections: list of connections\n    :param signal: signal handler\n    :param request_handler: Sanic request handler with middleware\n    :param error_handler: Sanic error handler with middleware\n    :param debug: enables debug output (slows server)\n    :param request_timeout: time in seconds\n    :param ssl: SSLContext\n    :param sock: Socket for the server to accept connections from\n    :param request_max_size: size in bytes, `None` for no limit\n    :param reuse_port: `True` for multiple workers\n    :param loop: asyncio compatible event loop\n    :param protocol: subclass of asyncio protocol class\n    :return: Nothing\n    \"\"\"\n    def __init__(self, loop=None, connections=None, signal=None,\n                 request_handler=None, error_handler=None, debug=False,\n                 request_timeout=60, ssl=None, sock=None,\n                 request_max_size=None, reuse_port=False, loop=None,\n                 protocol=HttpProtocol, **kwargs):\n        self.loop = loop\n        self.connections = connections\n        self.signal = signal\n        self.request_handler =",
        "\n\n        self.gods = {}\n        self.breed = {}\n        self.gods['XX'] = egg_donors\n        self.breed['XY'] = sperm_donors\n\n        self.add_god(self.breed['XY'])\n        self.add_god(self.breed['XX'])\n\n        self.add_god(self.breed['XY'])\n        self.add_god(self.breed['XX'])\n\n        self.add_god(self.breed['XY'])\n        self.add_god(self.breed['XX'])\n\n        self.add_god(self.breed['XY'])\n        self.add_god(self.breed['XX'])\n\n        self.add_god(self.breed['XY'])\n        self.add_god(self.breed['XX'])\n\n        self.add_god(self.breed['XY'])\n        self.add_god(self.breed['XX'])\n\n        self.add_god(self.breed['XY'])\n        self.add_god(self.breed['XX'])\n\n        self.add_god(self.breed['XY'])\n        self",
        "\n\ndef send_birth_announcement(self, egg_donor, sperm_donor, child):\n        \"\"\"Send a birth announcement.\"\"\"\n        try:\n            child.send_birth_announcement()\n        except:\n            print(\"Failed to send birth announcement.\")\n\ndef send_birth_announcement_with_name(self, egg_donor, sperm_donor, child):\n        \"\"\"Send a birth announcement with a name.\"\"\"\n        try:\n            child.send_birth_announcement(child.name)\n        except:\n            print(\"Failed to send birth announcement.\")\n\ndef send_birth_announcement_with_name_and_age(self, egg_donor, sperm_donor, child):\n        \"\"\"Send a birth announcement with a name and age.\"\"\"\n        try:\n            child.send_birth_announcement(child.name, child.age)\n        except:\n            print(\"Failed to send birth announcement.\")\n\ndef send_birth_announcement_with_name_and_age_and_gender(self, egg_donor, sperm_donor, child):\n        \"\"\"Send a birth announcement with a name and age and gender.\"\"\"\n        try:\n            child.send_birth_announcement(child.name",
        ".0\n\ndef dot(vec1, vec2):\n    \"\"\"Compare vectors. Borrowed from A. Parish.\"\"\"\n    return dot(vec1, vec2)\n\ndef norm(vec):\n    \"\"\"Return the length of a vector.\"\"\"\n    return norm(vec)\n\ndef normalize(vec):\n    \"\"\"Normalize a vector.\"\"\"\n    return normalize(vec, 1.0)\n\ndef normalize(vec, factor):\n    \"\"\"Normalize a vector.\n\n    Parameters\n    ----------\n    vec : array_like\n        The vector to normalize.\n    factor : float\n        The factor to normalize the vector by.\n\n    Returns\n    -------\n    normalized : array_like\n        The normalized vector.\n    \"\"\"\n    return normalize(vec, factor, 1.0)\n\ndef normalize(vec, factor, epsilon):\n    \"\"\"Normalize a vector.\n\n    Parameters\n    ----------\n    vec : array_like\n        The vector to normalize.\n    factor : float\n        The factor to normalize the vector by.\n    epsilon : float\n        The epsilon to normalize the vector by.\n\n    Returns\n    -------\n    normalized : array_like\n        The normalized vector.\n    \"\"\"\n    if norm(vec) > 0:\n        return vec / (norm(vec) * factor)\n    else:\n        return 0",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".append(egg_donor)\n        self.reproduce_sexually(egg_donor, sperm_donor)\n\ndef set_inherited_traits_from_god(self, god):\n        \"\"\"Accept either strings or Gods as inputs.\"\"\"\n        if type(god) == str:\n            self.reproduce_asexually(god, None)\n        else:\n            self.reproduce_sexually(god, None)\n\ndef set_inherited_traits_from_gods(self, gods):\n        \"\"\"Accept either strings or Gods as inputs.\"\"\"\n        for god in gods:\n            self.reproduce_sexually(god, None)\n\ndef set_inherited_traits_from_gods_and_gods(self, gods, gods_and_gods):\n        \"\"\"Accept either strings or Gods as inputs.\"\"\"\n        for god in gods_and_gods:\n            self.reproduce_sexually(god, gods)\n\ndef set_inherited_traits_from_gods_and_gods_and_gods(self, gods_and_god",
        "(egg + sperm)\n\ndef main():\n        \"\"\"Main function.\"\"\"\n        parser = argparse.ArgumentParser(description='Reproduce a sexual reproduction.')\n        parser.add_argument('-e', '--egg', help='The name of the egg to reproduce.', required=True)\n        parser.add_argument('-s', '--sperm', help='The name of the sperm to reproduce.', required=True)\n        args = parser.parse_args()\n\n        reproduce_asexually(args.egg, args.sperm)\n\nif __name__ == '__main__':\n        main()\n",
        "#include \"stdafx.h\"\n#include \"Game.h\"\n#include \"GameState.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _request(self, path, data=None, headers=None, method=None):\n        \"\"\"Performs a HTTP request to the Go server\n\n        Args:\n          path (str): The full path on the Go server to request\n            This includes any query string attributes\n          data (str, dict, bool, optional): If any data is present this\n            request will become a POST request\n          headers (dict, optional): Headers to set for this particular\n            request\n          method (str, optional): The HTTP method to use for this particular\n            request\n\n        Raises:\n          HTTPError: when the HTTP request fails\n\n        Returns:\n          file like object: The response from a\n            :func:`urllib2.urlopen` call\n        \"\"\"\n        if data is None:\n            data = ''\n        if headers is None:\n            headers = {}\n        if method is None:\n            method = 'GET'\n\n        if method == 'GET':\n            url = self._url + path\n        elif method == 'POST':\n            url = self._url + path + '?' + urllib.urlencode(data)\n        else:\n            raise ValueError('Method must be GET or POST')\n\n        try:\n            response = urlopen(url, headers=headers)\n        except HTTPError as e:\n            raise HTTPError(e.code",
        "\n\n        self._set_session_cookie(response)\n\n        self._session_id = self.get('JSESSIONID')\n\n        if not self._session_id:\n            raise AuthenticationFailed('No session id extracted from request.')\n\n        self._set_session_cookie(response)\n\n        self._authenticity_token = self.get('authenticity_token')\n\n        if not self._authenticity_token:\n            raise AuthenticationFailed('No authenticity token extracted from request.')\n\n        self._set_session_cookie(response)\n\n        self._session_id = self.get('JSESSIONID')\n\n        if not self._session_id:\n            raise AuthenticationFailed('No session id extracted from request.')\n\n        self._set_session_cookie(response)\n\n        self._authenticity_token = self.get('authenticity_token')\n\n        if not self._authenticity_token:\n            raise AuthenticationFailed('No authenticity token extracted from request.')\n\n        self._set_session_cookie(response)\n\n        self._session_id = self.get('JSESSIONID')\n\n        if not self._session_id:\n            raise AuthenticationFailed('No session id extracted from request.')\n\n        self._set_session_cookie",
        "\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef console_output_with_metadata(self, instance=None):\n        \"\"\"Yields the output and metadata from all jobs in the pipeline\n\n        Args:\n          instance: The result of a :meth:`instance` call, if not supplied\n            the latest of the pipeline will be used.\n\n        Yields:\n          tuple: (metadata (dict), output (str)).\n\n          metadata contains:\n            - pipeline\n            - pipeline_counter\n            - stage\n            - stage_counter\n            - job\n            - job_result\n        \"\"\"\n        if instance is None:\n            instance = self.instance()\n\n        for stage in instance['stages']:\n            for job in stage['jobs']:\n                if job['result'] not in self.final_results:\n                    continue\n\n                artifact = self.artifact(\n                    instance['counter'],\n                    stage['name'],\n                    job['name'],\n                    stage['counter']\n                )\n                output = artifact.get('cruise-output/console.log')\n\n                yield (\n                    {\n                        'pipeline': self.name,\n                        'pipeline_counter': instance['counter'],\n                        'stage': stage['name'],\n                        'stage_counter': stage['counter'],\n                        'job': job['name'],\n                        'job_result': job",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef pipeline(self, name):\n        \"\"\"Returns a pipeline from the last response\n\n        Returns:\n          Pipeline: Response success: the pipeline with the given name\n               Response failure: an empty pipeline\n        \"\"\"\n        if not self.response:\n            return None\n        elif self._pipeline is None and self.response:\n            self._pipeline = self.response.payload[0]['pipeline']\n            return self._pipeline\n\n        return None\n\ndef pipeline_groups(self):\n        \"\"\"Returns a list of all pipeline groups from the last response\n\n        Returns:\n          list: Response success: all the pipeline groups available in the response\n               Response failure: an empty list\n        \"\"\"\n        if not self.response:\n            return []\n        elif self._pipeline_groups is None and self.response:\n            self._pipeline_groups = []\n            for group in self.response.payload:\n                for pipeline in group['pipelineGroups']:\n                    self._pipeline_groups.append(pipeline['name'])\n\n        return self._pipeline_groups\n\ndef pipeline_group(self, name):\n        \"\"\"Returns a pipeline group from the last response\n\n        Returns:\n          PipelineGroup: Response success: the pipeline group with the given name\n               Response failure: an empty pipeline group\n        \"\"\"\n        if not self.response:\n           ",
        "\n\ndef get_file(self, path_to_file, timeout=30, backoff=0.4, max_wait=4):\n        \"\"\"Gets an artifact file by its path.\n\n        See the `Go artifact file documentation`__ for example responses.\n\n        .. __: http://api.go.cd/current/#get-artifact-file\n\n        .. note::\n          Getting a file relies on Go creating a zip file of the\n          file in question. Because of this Go will zip the file in\n          the background and return a 202 Accepted response. It's then up\n          to the client to check again later and get the final file.\n\n          To work with normal assumptions this :meth:`get_file` will\n          retry itself up to ``timeout`` seconds to get a 200 response to\n          return. At that point it will then return the response as is, no\n          matter whether it's still 202 or 200. The retry is done with an\n          exponential backoff with a max value between retries. See the\n          ``backoff`` and ``max_wait`` variables.\n\n          If you want to handle the retry logic yourself then use :meth:`get`\n          and add '.zip' as a suffix on the file.\n\n        Args:\n          path_to_file (str): The path to the file to get.\n",
        ", **kwargs_config)\n\n\ndef invenio_config_loader(app, **kwargs_config):\n    \"\"\"Configuration loader.\n\n    Adds support for loading templates from the ``<instance_folder>/templates``\n    folder.\n    \"\"\"\n    app.jinja_loader = ChoiceLoader([\n        FileSystemLoader(app.instance_path, 'templates'),\n        app.jinja_loader,\n    ])\n\n    app.jinja_options = dict(\n        app.jinja_options,\n        cache_size=1000,\n        bytecode_cache=BytecodeCache(app)\n    )\n\n    invenio_config_loader(app, **kwargs_config)\n\n\ndef invenio_config_loader(app, **kwargs_config):\n    \"\"\"Configuration loader.\n\n    Adds support for loading templates from the ``<instance_folder>/templates``\n    folder.\n    \"\"\"\n    app.jinja_loader = ChoiceLoader([\n        FileSystemLoader(app.instance_path, 'templates'),\n        app.jinja_loader,\n    ])\n\n    app.jinja_options = dict(\n        app.jinja_options,\n        cache_size=1000,\n        bytecode_cache=BytecodeCache(app)\n    )\n\n    invenio_config_",
        "\n\n\ndef create_app(config=None):\n    \"\"\"Create Flask application.\n\n    :param config: Flask application configuration.\n    \"\"\"\n    app = app_class()\n    app.config.from_object(config)\n    return app\n",
        "\n        return app\n\n\ndef get_ipaddr(request):\n    \"\"\"Get the IP address of the current request.\n\n    :param request: A :class:`~flask.Request` instance.\n    \"\"\"\n    return request.remote_addr\n\n\ndef init_config(app):\n    \"\"\"Initialize the configuration.\n\n    :param app: An instance of :class:`~flask.Flask`.\n    \"\"\"\n    # Set the default settings\n    app.config['APP_DEFAULT_SECURE_HEADERS'] = {\n        'X-Forwarded-Proto': 'https',\n        'X-Forwarded-Proto-Strict': '1.1',\n        'X-Forwarded-Proto-Max': '1024',\n        'X-Forwarded-Proto-Min': '1',\n        'X-Forwarded-Proto-Max-Age': '3600',\n        'X-Forwarded-Proto-Min-Age': '1',\n        'X-Forwarded-Proto-Max-Age': '3600',\n        'X-Forwarded-Proto-Min-Age': '1',\n        'X-Forwarded-Proto-Max-Age': '3600',\n        'X-Forwarded-Proto-Min-Age': '1',\n        'X-Forwarded-Proto-Max-Age': '3600',\n        'X-",
        "\n\n        if app.config['DEBUG']:\n            app.config.setdefault('APP_DEFAULT_SECURE_HEADERS', {})\n            headers = app.config['APP_DEFAULT_SECURE_HEADERS']\n            # ensure `content_security_policy` is not set to {}\n            if headers.get('content_security_policy') != {}:\n                headers.setdefault('content_security_policy', {})\n                csp = headers['content_security_policy']\n                # ensure `default-src` is not set to []\n                if csp.get('default-src') != []:\n                    csp.setdefault('default-src', [])\n                    # add default `content_security_policy` value when debug\n                    csp['default-src'] += flask_talisman_debug_mode\n\n        if app.config['DEBUG']:\n            app.config.setdefault('APP_DEFAULT_SECURE_HEADERS', {})\n            headers = app.config['APP_DEFAULT_SECURE_HEADERS']\n            # ensure `content_security_policy` is not set to {}\n            if headers.get('content_security_policy') != {}:\n                headers.setdefault('content_security_policy', {})\n                csp = headers['content_security_policy']\n                # ensure `default-src` is not set",
        ".title()\n\n\ndef word2camel(string):\n    \"\"\"Covert name from \"Normal case\" to \"CamelCase\".\n\n    >>> word2camel('CamelCase')\n    'camel case'\n    >>> word2camel('CaseWithSpec')\n    'case with spec'\n    \"\"\"\n    return string[0].lower() + string[1:]\n\n\ndef camel2word_with_underscore(string):\n    \"\"\"Covert name from \"CamelCase\" to \"Normal case\".\n\n    >>> camel2word_with_underscore('CamelCase')\n    'camel case'\n    >>> camel2word_with_underscore('CaseWithSpec')\n    'case with spec'\n    \"\"\"\n    return string[0].lower() + string[1:]\n\n\ndef word2camel_with_underscore(string):\n    \"\"\"Covert name from \"Normal case\" to \"CamelCase\".\n\n    >>> word2camel_with_underscore('camel case')\n    'camel case'\n    >>> word2camel_with_underscore('case with spec')\n    'case with spec'\n    \"\"\"\n    return string[0].lower() + string[1:]\n\n\ndef camel2word_with_underscore_and_underscore(string):\n    \"\"\"Covert name from \"CamelCase\" to \"Normal case\".\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".format(br.join(['{']))\n\n\ndef pplist(list_to_print, br='\\n', html=False, key_align='l', sort_keys=True,\n           key_preffix='', key_suffix='', value_prefix='', value_suffix='', left_margin=3, indent=2):\n    \"\"\"Indent representation of a list\"\"\"\n    if list_to_print:\n        if sort_keys:\n            dic = list_to_print.copy()\n            keys = list(dic.keys())\n            keys.sort()\n            list_to_print = OrderedDict()\n            for k in keys:\n                list_to_print[k] = dic[k]\n\n        tmp = ['{']\n        ks = [type(x) == str and \"'%s'\" % x or x for x in list_to_print.keys()]\n        vs = [type(x) == str and \"'%s'\" % x or x for x in list_to_print.values()]\n        max_key_len = max([len(str(x)) for x in ks])\n\n        for i in range(len(ks)):\n            k = {1: str(ks[i]).ljust(max_key_len),\n                 key_align == 'r':",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.internal.nio.Connection;\nimport com.hazelcast.internal.nio.ConnectionState;\nimport com.hazelcast.internal.protocol.ClientMessage;\nimport com.hazelcast.internal.protocol.codec.MapRemove",
        ".setup)\n\ndef my_getattr(obj, name, *args, **kwargs):\n    \"\"\"\n    Returns the value of the attribute on ``obj`` which is a class, with link to ``obj``.\n\n    Adds a convenience accessor which instantiates ``obj`` and then calls its\n    ``setup`` method.\n\n    Recurses on those objects as well.\n    \"\"\"\n    if name == 'setup':\n        obj._parent_inst = obj\n        obj._parent = obj\n        obj.__getattr__ = my_getattr\n        flag_inner_classes(obj.setup)\n    return obj.__getattr__(obj, name, *args, **kwargs)\n\ndef class_members(obj):\n    \"\"\"\n    Returns a list of tuples of the form (class, member) for each class in ``obj``.\n\n    Adds a convenience accessor which instantiates ``obj`` and then calls its\n    ``setup`` method.\n\n    Recurses on those objects as well.\n    \"\"\"\n    return [(tup[0], tup[1]) for tup in class_members(obj)]\n\ndef class_members_with_parent(obj):\n    \"\"\"\n    Returns a list of tuples of the form (class, member) for each class in ``obj``\n    which is a parent of ``obj`",
        "\n\n\ndef pvpc_calc_tcu_cp_feu_d_kwh(df, verbose=True, convert_kwh=True):\n    \"\"\"Procesa TCU, CP, FEU diario.\n\n    :param df:\n    :param verbose:\n    :param convert_kwh:\n    :return:\n    \"\"\"\n    if 'TCU' + TARIFAS[0] not in df.columns:\n        # Pasa de \u20ac/MWh a \u20ac/kWh:\n        if convert_kwh:\n            cols_mwh = [c + t for c in COLS_PVPC for t in TARIFAS if c != 'COF']\n            df[cols_mwh] = df[cols_mwh].applymap(lambda x: x / 1000.)\n        # Obtiene columnas TCU, CP, precio d\u00eda\n        gb_t = df.groupby(lambda x: TARIFAS[np.argmax([t in x for t in TARIFAS])], axis=1)\n        for k, g in gb_t:\n            if verbose:\n                print('TARIFA {}'.format(k))\n                print(g.head())\n\n            # C",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef class_members(cls):\n        \"\"\"\n        Returns a dictionary of class members\n        \"\"\"\n        members = {}\n        for name, cls in cls.__dict__.items():\n            if isinstance(cls, type):\n                members[name] = cls\n        return members\n\ndef isValidClass(cls):\n        \"\"\"\n        Returns True if the class is valid\n        \"\"\"\n        return cls in self._valid_classes\n\nclass Class(object):\n        \"\"\"\n        A class that can be used to create a new instance of a class\n        \"\"\"\n        def __init__(self, name, parent=None):\n                \"\"\"\n                Constructor\n                \"\"\"\n                self._name = name\n                self._parent = parent\n                self._valid_classes = []\n\n        def __getattr__(self, name):\n                \"\"\"\n                Returns the class member\n                \"\"\"\n                return self._members[name]\n\n        def __setattr__(self, name, value):\n                \"\"\"\n                Sets the class member\n                \"\"\"\n                self._members[name] = value\n\n        def __delattr__(self, name):\n                \"\"\"\n                Deletes the class member\n                \"\"\"\n                del self._members[name]\n\n        def __repr__(self):\n                \"\"\"\n                Returns a string representation of the class\n",
        ".is_abstract\n\ndef registerGoodClass(self, class_):\n        \"\"\"\n        Register a good class.\n        \"\"\"\n        if not isValidClass(class_):\n                raise ValueError(\"Class %s is not valid\" % class_)\n        self._good_classes.append(class_)\n\ndef wantClass(self, class_):\n        \"\"\"\n        Want a good class.\n        \"\"\"\n        if not isValidClass(class_):\n                raise ValueError(\"Class %s is not valid\" % class_)\n        self._want_classes.append(class_)\n\ndef registerGoodModule(self, module_):\n        \"\"\"\n        Register a good module.\n        \"\"\"\n        if not isValidModule(module_):\n                raise ValueError(\"Module %s is not valid\" % module_)\n        self._good_modules.append(module_)\n\ndef registerGoodNamedModule(self, module_):\n        \"\"\"\n        Register a good named module.\n        \"\"\"\n        if not isValidModule(module_):\n                raise ValueError(\"Module %s is not valid\" % module_)\n        self._good_named_modules.append(module_)\n\ndef registerGoodClass(self, class_):\n        \"\"\"\n        Register a good class.\n        \"\"\"\n        if not isValidClass(class_):",
        "\n\ndef get_resample_data_daily(self):\n        \"\"\"Obtiene los dataframes de los datos de PVPC con resampling diario y mensual.\"\"\"\n        if self.data is not None:\n            if self._pvpc_mean_daily is None:\n                self._pvpc_mean_daily = self.data['data'].resample('D').mean()\n            if self._pvpc_mean_monthly is None:\n                self._pvpc_mean_monthly = self.data['data'].resample('MS').mean()\n        return self._pvpc_mean_daily, self._pvpc_mean_monthly\n\ndef get_resample_data_monthly(self):\n        \"\"\"Obtiene los dataframes de los datos de PVPC con resampling diario y mensual.\"\"\"\n        if self.data is not None:\n            if self._pvpc_mean_daily is None:\n                self._pvpc_mean_daily = self.data['data'].resample('D').mean()\n            if self._pvpc_mean_monthly is None:\n                self._pvpc_mean_monthly = self.data['data'].resample('MS').mean()\n        return self._pvpc_mean_daily, self._pvpc_mean_monthly\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _validate_schema_instance(obj):\n    \"\"\"Ensures the passed schema instance is compatible\n\n    :param obj: object to validate\n    :return: obj\n    :raises:\n        - IncompatibleSchema if the passed schema is of an incompatible type\n    \"\"\"\n\n    if obj is not None and not isinstance(obj, Schema):\n        raise IncompatibleSchema('Schema must be of type {0}'.format(Schema))\n\n    return obj\n\n\nclass IncompatibleSchema(Exception):\n    \"\"\"Raised when the passed schema is incompatible with the passed object\n\n    :param obj: object to validate\n    :param schema: schema to validate against\n    \"\"\"\n\n    def __init__(self, obj, schema):\n        self.obj = obj\n        self.schema = schema\n\n    def __str__(self):\n        return 'IncompatibleSchema: {0} is incompatible with {1}'.format(self.obj, self.schema)\n\n\nclass Schema(object):\n    \"\"\"Represents a schema object\n\n    :param name: name of the schema\n    :param type: type of the schema\n    :param description: description of the schema\n    :param properties: properties of the schema\n    :param required: whether the schema is required\n    :param optional: whether the schema is optional\n    :param",
        "\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\",
        "\n        return ret\n\ndef second(self, symbols):\n        \"\"\"Computes the intermediate SECOND set using symbols.\"\"\"\n        ret = set()\n\n        if EPSILON in symbols:\n            return set([EPSILON])\n\n        for symbol in symbols:\n            ret |= self._second[symbol] - set([EPSILON])\n            if EPSILON not in self._second[symbol]:\n                break\n        else:\n            ret.add(EPSILON)\n\n        return ret\n\ndef third(self, symbols):\n        \"\"\"Computes the intermediate THIRD set using symbols.\"\"\"\n        ret = set()\n\n        if EPSILON in symbols:\n            return set([EPSILON])\n\n        for symbol in symbols:\n            ret |= self._third[symbol] - set([EPSILON])\n            if EPSILON not in self._third[symbol]:\n                break\n        else:\n            ret.add(EPSILON)\n\n        return ret\n\ndef fourth(self, symbols):\n        \"\"\"Computes the intermediate FOURTH set using symbols.\"\"\"\n        ret = set()\n\n        if EPSILON in symbols:\n            return set([EPSILON])\n\n        for symbol in symbols:\n            ret |= self._fourth[symbol] - set([EPSILON])\n            if EPSILON not in self._fourth[symbol]:\n               ",
        "\n\n        return self._first\n\ndef _compute_first_set(self):\n        \"\"\"Computes the FIRST set for every symbol in the grammar.\n\n        Tenatively based on _compute_first in PLY.\n        \"\"\"\n        for terminal in self.terminals:\n            self._first_set[terminal].add(terminal)\n        self._first_set[END_OF_INPUT].add(END_OF_INPUT)\n\n        while True:\n            changed = False\n\n            for nonterminal, productions in self.nonterminals.items():\n                for production in productions:\n                    new_first = self.first(production.rhs)\n                    if new_first - self._first_set[nonterminal]:\n                        self._first_set[nonterminal] |= new_first\n                        changed = True\n\n            if not changed:\n                break\n\n            if self._first_set[END_OF_INPUT] == self._first_set[END_OF_INPUT]:\n                break\n\n            return self._first_set\n\ndef _compute_first_set_set(self):\n        \"\"\"Computes the FIRST set for every symbol in the grammar.\n\n        Tenatively based on _compute_first_set in PLY.\n        \"\"\"\n        for terminal in self.terminals:\n            self",
        "\n\n        return self._follow\n\n\ndef _compute_nonterminals(self):\n        \"\"\"Computes the nonterminals for every nonterminal in the grammar.\n\n        Tenatively based on _compute_nonterminals in PLY.\n        \"\"\"\n        self._nonterminals = {}\n        for nonterminal, productions in self.nonterminals.items():\n            for production in productions:\n                for i, symbol in enumerate(production.rhs):\n                    if symbol not in self.nonterminals:\n                        continue\n\n                    first = self.first(production.rhs[i + 1:])\n                    new_nonterminal = first - set([EPSILON])\n                    if EPSILON in first or i == (len(production.rhs) - 1):\n                        new_nonterminal |= self._nonterminals[nonterminal]\n\n                    if new_nonterminal - self._nonterminals[symbol]:\n                        self._nonterminals[symbol] |= new_nonterminal\n                        changed = True\n\n        return self._nonterminals\n\n\ndef _compute_symbols(self):\n        \"\"\"Computes the symbols for every nonterminal in the grammar.\n\n        Tenatively based on _compute_symbols in PLY.\n        \"\"\"\n        self._symbols = {}\n        for nonterminal, productions in self.non",
        "(first_rule)\n\ndef closure(self, rules):\n        \"\"\"Computes the closure using the rules given.\"\"\"\n        return self.closure_generator(rules)\n\ndef closure_generator(self, rules):\n        \"\"\"Computes the closure using the rules given.\"\"\"\n        return self.closure_generator(rules, self.start)\n\ndef closure_generator(self, rules, start):\n        \"\"\"Computes the closure using the rules given.\"\"\"\n        return self.closure_generator(rules, start, self.start)\n\ndef closure_generator(self, rules, start, end):\n        \"\"\"Computes the closure using the rules given.\"\"\"\n        return self.closure_generator(rules, start, end, self.start)\n\ndef closure_generator(self, rules, start, end, start_rule):\n        \"\"\"Computes the closure using the rules given.\"\"\"\n        return self.closure_generator(rules, start, end, start_rule, self.start)\n\ndef closure_generator(self, rules, start, end, start_rule, end_rule):\n        \"\"\"Computes the closure using the rules given.\"\"\"\n        return self.closure_generator(rules, start, end, start_rule, end_rule, self.start)\n\ndef closure_generator(self, rules, start, end, start_rule, end_rule, start_rule",
        "\n\ndef dot_rules(self, rules):\n        \"\"\"Computes the next closure for rules based on the symbol we got.\n\n        Args:\n            rules - an iterable of DottedRules\n\n        Returns: frozenset of DottedRules\n        \"\"\"\n        return self.closure(\n            {rule.move_dot() for rule in rules\n             if not rule.at_end and rule.rhs[rule.pos] == '.'},\n        )\n\ndef dot_rules_with_end(self, rules):\n        \"\"\"Computes the next closure for rules based on the symbol we got.\n\n        Args:\n            rules - an iterable of DottedRules\n\n        Returns: frozenset of DottedRules\n        \"\"\"\n        return self.closure(\n            {rule.move_dot() for rule in rules\n             if not rule.at_end and rule.rhs[rule.pos] == '.' and rule.end},\n        )\n\ndef dot_rules_with_start(self, rules):\n        \"\"\"Computes the next closure for rules based on the symbol we got.\n\n        Args:\n            rules - an iterable of DottedRules\n\n        Returns: frozenset of DottedRules\n        \"\"\"\n        return self.closure(\n            {rule.move_dot() for rule in rules\n             if not rule.at_end and rule.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        self._attached_bundles = []\n\n        for bundle in self._registered_bundles:\n            bundle['blueprints'].append(bundle)\n\n        self._registered_bundles = []\n\n        for bundle in self._attached_bundles:\n            bundle['blueprints'].append(bundle)\n\n        self._attached_bundles = []\n\n        for bundle in self._registered_bundles:\n            bundle['blueprints'].append(bundle)\n\n        self._registered_bundles = []\n\n        for bundle in self._attached_bundles:\n            bundle['blueprints'].append(bundle)\n\n        self._attached_bundles = []\n\n        for bundle in self._registered_bundles:\n            bundle['blueprints'].append(bundle)\n\n        self._registered_bundles = []\n\n        for bundle in self._attached_bundles:\n            bundle['blueprints'].append(bundle)\n\n        self._attached_bundles = []\n\n        for bundle in self._registered_bundles:\n            bundle['blueprints'].append(bundle)\n\n        self._registered_bundles = []\n\n        for bundle in self._attached_bundles:\n            bundle['blueprints'].append(bundle)\n\n        self._attached_bundles = []\n\n        for bundle in self._registered_bundles:\n            bundle['blueprints'].append(bundle)\n\n       ",
        "\n\ndef routes_simple_with_blueprints(self):\n        \"\"\"Returns simple info about registered blueprints\n\n        :return: Tuple containing endpoint, path and allowed methods for each route\n        \"\"\"\n\n        routes = []\n\n        for bundle in self._registered_bundles:\n            bundle_path = bundle['path']\n            for blueprint in bundle['blueprints']:\n                for child in blueprint['routes']:\n                    routes.append(\n                        (\n                            child['endpoint'],\n                            bundle_path + blueprint['path'],\n                            child['methods']\n                        )\n                    )\n\n        return routes\n\ndef routes_simple_with_blueprints_and_routes(self):\n        \"\"\"Returns simple info about registered blueprints and routes\n\n        :return: Tuple containing endpoint, path and allowed methods for each route\n        \"\"\"\n\n        routes = []\n\n        for bundle in self._registered_bundles:\n            bundle_path = bundle['path']\n            for blueprint in bundle['blueprints']:\n                for child in blueprint['routes']:\n                    routes.append(\n                        (\n                            child['endpoint'],\n                            bundle_path + blueprint['path'],\n                            child['methods']\n                        )\n                    )\n\n        return routes\n\ndef routes_simple_with_blueprints_and_routes_with_blueprints(self):",
        "\n        return False\n\n    def _bundle_exists_at_path(self, path):\n        \"\"\"Checks if a bundle exists at the provided path\n\n        :param path: Bundle path\n        :return: bool\n        \"\"\"\n\n        for attached_bundle in self._attached_bundles:\n            if attached_bundle.path == path:\n                return True\n\n        return False\n\n    def _bundle_exists_at_path_and_name(self, path, name):\n        \"\"\"Checks if a bundle exists at the provided path and name\n\n        :param path: Bundle path\n        :param name: Bundle name\n        :return: bool\n        \"\"\"\n\n        for attached_bundle in self._attached_bundles:\n            if attached_bundle.path == path and attached_bundle.name == name:\n                return True\n\n        return False\n\n    def _bundle_exists_at_path_and_name_and_version(self, path, name, version):\n        \"\"\"Checks if a bundle exists at the provided path and name and version\n\n        :param path: Bundle path\n        :param name: Bundle name\n        :param version: Bundle version\n        :return: bool\n        \"\"\"\n\n        for attached_bundle in self._attached_bundles:\n            if attached_bundle.path == path and attached_bundle.name",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_blueprint_routes_for_blueprint(blueprint):\n        \"\"\"Returns detailed information about registered blueprint routes matching the `BlueprintBundle` path\n\n        :param blueprint: Blueprint instance to obtain rules from\n        :return: List of route detail dicts\n        \"\"\"\n\n        routes = []\n\n        for child in blueprint.url_map.iter_rules():\n            if child.rule.startswith(blueprint.base_path):\n                relative_path = child.rule[len(blueprint.base_path):]\n                routes.append({\n                    'path': relative_path,\n                    'endpoint': child.endpoint,\n                    'methods': list(child.methods)\n                })\n\n        return routes\n\ndef get_blueprint_routes_for_blueprint_bundle(blueprint_bundle):\n        \"\"\"Returns detailed information about registered blueprint routes matching the `BlueprintBundle` path\n\n        :param blueprint_bundle: Blueprint bundle instance to obtain rules from\n        :return: List of route detail dicts\n        \"\"\"\n\n        routes = []\n\n        for child in blueprint_bundle.url_map.iter_rules():\n            if child.rule.startswith(blueprint_bundle.base_path):\n                relative_path = child.rule[len(blueprint_bundle.base_path):]\n                routes.append({\n                    'path': relative",
        "\n\ndef compute_precedence_levels(terminals, productions):\n        \"\"\"Computes the precedence levels of terminal and production.\n\n        The precedence levels are the precedence of each terminal and the\n        precedence of each production. For a production, the precedence is the\n        right-most terminal (if it exists). The default precedence is\n        DEFAULT_PREC - (LEFT, 0).\n\n        Returns:\n            precedence_levels - list[tuple[terminal | production] = (assoc, level)]\n\n        \"\"\"\n        precedence_levels = []\n        for terminal, production in productions:\n            precedence_levels.append((terminal,\n                                       compute_precedence(terminals,\n                                                          productions,\n                                                          [terminal])))\n        return precedence_levels\n\ndef compute_precedence_symbols(terminals, productions):\n        \"\"\"Computes the precedence symbols of terminal and production.\n\n        The precedence symbols are the precedence of each terminal and the\n        precedence of each production. For a production, the precedence is the\n        right-most terminal (if it exists). The default precedence is\n        DEFAULT_PREC - (LEFT, 0).\n\n        Returns:\n            precedence_symbols - list[tuple[terminal | production] = (assoc, symbol)]\n\n        \"\"\"\n        precedence_symbols = []\n        for terminal, production in productions",
        "\n",
        "\n\ndef parse_definite_clause_list(s):\n    \"Return the antecedents and the consequent of a definite clause list.\"\n    assert is_definite_clause_list(s)\n    if is_symbol(s.op):\n        return [], s\n    else:\n        antecedent, consequent = s.args\n        return conjuncts(antecedent), consequent\n\ndef parse_definite_clause_list_with_consequent(s):\n    \"Return the antecedents and the consequent of a definite clause list with consequent.\"\n    assert is_definite_clause_list_with_consequent(s)\n    if is_symbol(s.op):\n        return [], s\n    else:\n        antecedent, consequent = s.args\n        return conjuncts(antecedent), consequent\n\ndef parse_definite_clause_list_with_consequent_list(s):\n    \"Return the antecedents and the consequent of a definite clause list with consequent list.\"\n    assert is_definite_clause_list_with_consequent_list(s)\n    if is_symbol(s.op):\n        return [], s\n    else:\n        antecedent, consequent",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "))\n\ndef is_prop_symbol(op):\n    \"Return True if op is a propositional symbol.\"\n    return op.op == 'prop'\n\ndef is_prop_symbol_list(op):\n    \"Return True if op is a propositional symbol list.\"\n    return op.op == 'prop_list'\n\ndef is_prop_symbol_tuple(op):\n    \"Return True if op is a propositional symbol tuple.\"\n    return op.op == 'prop_tuple'\n\ndef is_prop_symbol_tuple_list(op):\n    \"Return True if op is a propositional symbol tuple list.\"\n    return op.op == 'prop_tuple_list'\n\ndef is_prop_symbol_tuple_tuple(op):\n    \"Return True if op is a propositional symbol tuple tuple.\"\n    return op.op == 'prop_tuple_tuple'\n\ndef is_prop_symbol_tuple_tuple_list(op):\n    \"Return True if op is a propositional symbol tuple tuple list.\"\n    return op.op == 'prop_tuple_tuple_list'\n\ndef is_prop_symbol_tuple_tuple_tuple(op):\n    \"Return True if op is a propositional symbol tuple tuple tuple.\"\n    return op.op == 'prop",
        "\n\ndef pl_false(exp, model={}):\n    \"\"\"Return True if the propositional logic expression is false in the model,\n    and False if it is true. If the model does not specify the value for\n    every proposition, this may return None to indicate 'not obvious';\n    this may happen even when the expression is tautological.\"\"\"\n    op, args = exp.op, exp.args\n    if exp == TRUE:\n        return False\n    elif exp == FALSE:\n        return True\n    elif is_prop_symbol(op):\n        return model.get(exp)\n    elif op == '~':\n        p = pl_false(args[0], model)\n        if p is None: return None\n        else: return not p\n    elif op == '|':\n        result = False\n        for arg in args:\n            p = pl_false(arg, model)\n            if p is True: return True\n            if p is None: result = None\n        return result\n    elif op == '&':\n        result = True\n        for arg in args:\n            p = pl_false(arg, model)\n            if p is False: return False\n            if p is None: result = None\n        return result\n    p, q = args\n    if op == '>>':\n        return pl_false",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "(c)\n\ndef to_cnf(sentence):\n        \"Convert a sentence to a list of conjuncts.\"\n        return [c for c in conjuncts(sentence)]\n\ndef conjuncts(sentence):\n        \"Convert a sentence to a list of conjuncts.\"\n        return [c for c in sentence if c in self.clauses]\n\ndef to_sentence(self, sentence):\n        \"Convert a list of conjuncts to a sentence.\"\n        return [c for c in sentence if c in self.clauses]\n\ndef to_sentence_list(self, sentence):\n        \"Convert a list of conjuncts to a sentence.\"\n        return [c for c in sentence if c in self.clauses]\n\ndef to_sentence_list_with_conjuncts(self, sentence):\n        \"Convert a list of conjuncts to a sentence.\"\n        return [c for c in sentence if c in self.clauses]\n\ndef to_sentence_list_with_conjuncts_and_conjuncts(self, sentence):\n        \"Convert a list of conjuncts to a sentence.\"\n        return [c for c in sentence if c in self.clauses and c in self.clauses]\n\ndef to_sentence_list_with_conjuncts_",
        "\n\n    def get_value(self, name, default=None):\n        \"\"\"\n        Returns the value of the setting with the given name.\n        \"\"\"\n        try:\n            return self.get(name, default)\n        except KeyError:\n            return default\n\n    def set_value(self, name, value):\n        \"\"\"\n        Sets the value of the setting with the given name.\n        \"\"\"\n        self.set(name, value)\n\n    def delete_value(self, name):\n        \"\"\"\n        Deletes the value of the setting with the given name.\n        \"\"\"\n        self.delete(name)\n\n    def clear(self):\n        \"\"\"\n        Clears all settings.\n        \"\"\"\n        self.clear_cache()\n\n    def clear_cache(self):\n        \"\"\"\n        Clears the cache.\n        \"\"\"\n        self.empty_cache = True\n\n    def clear_cache_for_model(self, model):\n        \"\"\"\n        Clears the cache for the given model.\n        \"\"\"\n        self.clear_cache()\n\n    def clear_cache_for_queryset(self, queryset):\n        \"\"\"\n        Clears the cache for the given queryset.\n        \"\"\"\n        self.clear_cache()\n\n    def clear_cache_for_queryset_and_model",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        ")\n\ndef winner(self, state, player):\n        \"Return the value to player; 1 for win, -1 for loss, 0 otherwise.\"\n        return if_(player == 'X', state.winner, -state.winner)\n\ndef lossner(self, state, player):\n        \"Return the value to player; 1 for win, -1 for loss, 0 otherwise.\"\n        return if_(player == 'X', state.lossner, -state.lossner)\n\ndef if_(self, condition, value, default):\n        \"Return the value if condition is true, else default.\"\n        return condition and value else default\n\ndef random_choice(self, choices):\n        \"Return a random choice from choices.\"\n        return random.choice(choices)\n\ndef random_choice_from_list(self, choices):\n        \"Return a random choice from choices.\"\n        return random.choice(choices)\n\ndef random_choice_from_list_of_strings(self, choices):\n        \"Return a random choice from choices.\"\n        return random.choice(choices)\n\ndef random_choice_from_list_of_integers(self, choices):\n        \"Return a random choice from choices.\"\n        return random.choice(choices)\n\ndef random_choice_from_list_",
        "\n\ndef if_(condition, a, b):\n    \"If condition is true, return a; if condition is false, return b.\"\n    if condition:\n        return a\n    else:\n        return b\n\ndef k_in_row(self, board, move, player, (x, y)):\n    \"Return True if the row is in the board.\"\n    return (board[move[0]][move[1]] == player) and (board[move[0]][move[2]] == player)\n\ndef print_board(self, board):\n    \"Print the board.\"\n    for row in board:\n        for col in row:\n            print(col, end=' ')\n\ndef main():\n    \"Main function.\"\n    board = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0],",
        "_in_row(board, move, player, (delta_x, delta_y))\n\ndef k_in_column(self, board, move, player, (delta_x, delta_y)):\n        \"Return true if there is a line through move on board for player.\"\n        x, y = move\n        n = 0 # n is number of moves in column\n        while board.get((x, y)) == player:\n            n += 1\n            x, y = x + delta_x, y + delta_y\n        x, y = move\n        while board.get((x, y)) == player:\n            n += 1\n            x, y = x - delta_x, y - delta_y\n        n -= 1 # Because we counted move itself twice\n        return n >= self.k_in_column(board, move, player, (delta_x, delta_y))\n\ndef k_in_diagonal(self, board, move, player, (delta_x, delta_y)):\n        \"Return true if there is a line through move on board for player.\"\n        x, y = move\n        n = 0 # n is number of moves in diagonal\n        while board.get((x, y)) == player:\n            n += 1\n            x, y = x + delta_x, y",
        "\n\ndef update_dict(x, **entries):\n    \"\"\"Update a dict, or an object with slots, according to `entries` dict.\n\n    >>> update_dict({'a': 1}, a=10, b=20)\n    {'a': 10, 'b': 20}\n    >>> update_dict(Struct(a=1), a=10, b=20)\n    Struct(a=10, b=20)\n    \"\"\"\n    if isinstance(x, dict):\n        x.update(entries)\n    else:\n        x.__dict__.update(entries)\n    return x\n\ndef update_list(x, **entries):\n    \"\"\"Update a list, or an object with slots, according to `entries` dict.\n\n    >>> update_list([1, 2, 3], a=10, b=20)\n    [1, 2, 3]\n    >>> update_list(Struct(a=1), a=10, b=20)\n    Struct(a=10, b=20)\n    \"\"\"\n    if isinstance(x, list):\n        x.update(entries)\n    else:\n        x.__dict__.update(entries)\n    return x\n\ndef update_tuple(x, **entries):\n    \"\"\"Update a tuple, or an object with slots, according to `entries",
        "(n) if s in weights]\n\ndef weighted_sample(seq, weights):\n    \"\"\"Pick n samples from seq at random, with the probability of each\n    element in proportion to its corresponding weight.\"\"\"\n    sample = weighted_sampler(seq, weights)\n    return [sample() for s in range(len(seq))]\n\ndef weighted_sampler(seq, weights):\n    \"\"\"Return a function that returns a random sample from seq, with\n    the probability of each element in proportion to its corresponding\n    weight.\"\"\"\n    return lambda: (1 - weights) * (seq[random.randint(0, len(seq)-1)])\n\ndef weighted_sample_with_replacement_with_weights(seq, weights, n):\n    \"\"\"Pick n samples from seq at random, with replacement, with the\n    probability of each element in proportion to its corresponding\n    weight, and with weights.\"\"\"\n    sample = weighted_sample_with_replacement(seq, weights, n)\n    return [sample() for s in range(n)]\n\ndef weighted_sample_with_replacement_with_weights_and_n(seq, weights, n):\n    \"\"\"Pick n samples from seq at random, with replacement, with the\n    probability of each element in proportion to its corresponding\n    weight, and with weights and n.\"\"\"\n    sample = weighted",
        "\n\ndef weighted_sampler_with_weights(seq, weights):\n    \"Return a random-sample function that picks from seq weighted by weights.\"\n    totals = []\n    for w in weights:\n        totals.append(w + totals[-1] if totals else w)\n    return lambda: seq[bisect.bisect(totals, random.uniform(0, totals[-1]))]\n\ndef weighted_sampler_with_weights_and_weights(seq, weights, weights_and_weights):\n    \"Return a random-sample function that picks from seq weighted by weights and weights_and_weights.\"\n    totals = []\n    for w in weights:\n        totals.append(w + totals[-1] if totals else w)\n    for w in weights_and_weights:\n        totals.append(w + totals[-1] if totals else w)\n    return lambda: seq[bisect.bisect(totals, random.uniform(0, totals[-1]))]\n\ndef weighted_sampler_with_weights_and_weights_and_weights(seq, weights_and_weights_and_weights, weights_and_weights):\n    \"Return a random-sample function that picks from seq weighted by weights and weights_and_weights and weights_and_weights.\"\n    totals",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ")\n\ndef __name__(object):\n    \"Try to find some reasonable name for the object.\"\n    return name(object)\n\ndef __repr__(object):\n    \"Try to find some reasonable name for the object.\"\n    return name(object)\n\ndef __str__(object):\n    \"Try to find some reasonable name for the object.\"\n    return name(object)\n\ndef __repr__(object):\n    \"Try to find some reasonable name for the object.\"\n    return name(object)\n\ndef __str__(object):\n    \"Try to find some reasonable name for the object.\"\n    return name(object)\n\ndef __repr__(object):\n    \"Try to find some reasonable name for the object.\"\n    return name(object)\n\ndef __str__(object):\n    \"Try to find some reasonable name for the object.\"\n    return name(object)\n\ndef __repr__(object):\n    \"Try to find some reasonable name for the object.\"\n    return name(object)\n\ndef __str__(object):\n    \"Try to find some reasonable name for the object.\"\n    return name(object)\n\ndef __repr__(object):\n    \"Try to find some reasonable name for the object.\"\n    return name(object)\n\ndef __str__(object",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "(dataset.examples[0])\n\n\ndef CountingProbDist(values):\n    \"\"\"Count how many times each value of each input attribute occurs.\"\"\"\n    return sum(product(values))\n\n\ndef argmax(values, func):\n    \"\"\"Return the argmax of the values in the list.\"\"\"\n    return max(values, key=func)\n",
        "(values))\n\ndef log_likelihood(values):\n    \"Number of bits to represent the log likelihood distribution in values.\"\n    probabilities = normalize(removeall(0, values))\n    return sum(-p * log2(p) for p in probabilities)\n\ndef log_likelihood_content(values):\n    \"Number of bits to represent the log likelihood distribution in values.\"\n    probabilities = normalize(removeall(0, values))\n    return sum(-p * log2(p) for p in probabilities)\n\ndef log_likelihood_content_content(values):\n    \"Number of bits to represent the log likelihood distribution in values.\"\n    probabilities = normalize(removeall(0, values))\n    return sum(-p * log2(p) for p in probabilities)\n\ndef log_likelihood_content_content_content(values):\n    \"Number of bits to represent the log likelihood distribution in values.\"\n    probabilities = normalize(removeall(0, values))\n    return sum(-p * log2(p) for p in probabilities)\n\ndef log_likelihood_content_content_content(values):\n    \"Number of bits to represent the log likelihood distribution in values.\"\n    probabilities = normalize(removeall(0, values))\n    return sum(-p * log2(p) for p in probabilities)\n\ndef log_likelihood_content",
        "(dataset)\n\n   for i in range(len(sizes)):\n      weights.append(np.zeros(sizes[i]))\n\n   for i in range(len(sizes)):\n      weights[i] = np.zeros(sizes[i])\n\n   for i in range(len(sizes)):\n      weights[i] = np.zeros(sizes[i])\n\n   for i in range(len(sizes)):\n      weights[i] = np.zeros(sizes[i])\n\n   for i in range(len(sizes)):\n      weights[i] = np.zeros(sizes[i])\n\n   for i in range(len(sizes)):\n      weights[i] = np.zeros(sizes[i])\n\n   for i in range(len(sizes)):\n      weights[i] = np.zeros(sizes[i])\n\n   for i in range(len(sizes)):\n      weights[i] = np.zeros(sizes[i])\n\n   for i in range(len(sizes)):\n      weights[i] = np.zeros(sizes[i])\n\n   for i in range(len(sizes)):\n      weights[i] = np.zeros(sizes[i])\n\n   for i in range(len(sizes)):\n      weights[",
        "\n\ndef mode(predictors, mode):\n    \"\"\"Given a list of predictors, return the mode of the predictors.\"\"\"\n    return mode(predictors, mode)\n\ndef mode(predictors, mode):\n    \"\"\"Given a list of predictors, return the mode of the predictors.\"\"\"\n    return mode(predictors, mode)\n\ndef mode(predictors, mode):\n    \"\"\"Given a list of predictors, return the mode of the predictors.\"\"\"\n    return mode(predictors, mode)\n\ndef mode(predictors, mode):\n    \"\"\"Given a list of predictors, return the mode of the predictors.\"\"\"\n    return mode(predictors, mode)\n\ndef mode(predictors, mode):\n    \"\"\"Given a list of predictors, return the mode of the predictors.\"\"\"\n    return mode(predictors, mode)\n\ndef mode(predictors, mode):\n    \"\"\"Given a list of predictors, return the mode of the predictors.\"\"\"\n    return mode(predictors, mode)\n\ndef mode(predictors, mode):\n    \"\"\"Given a list of predictors, return the mode of the predictors.\"\"\"\n    return mode(predictors, mode)\n\ndef mode(predictors, mode):\n    \"\"\"Given a list of predictors, return the mode of the predictors.\"\"\"\n    return mode(",
        "\n    return predict\n\ndef weighted_mode(predictors, weights):\n    \"Return a predictor that takes a weighted vote.\"\n    def predict(example):\n        return weighted_mode((predictor(example) for predictor in predictors),\n                             weights)\n    return predict\n\ndef weighted_mode(predictors, weights):\n    \"Return a predictor that takes a weighted vote.\"\n    def predict(example):\n        return weighted_mode((predictor(example) for predictor in predictors),\n                             weights)\n    return predict\n\ndef weighted_mode(predictors, weights):\n    \"Return a predictor that takes a weighted vote.\"\n    def predict(example):\n        return weighted_mode((predictor(example) for predictor in predictors),\n                             weights)\n    return predict\n\ndef weighted_mode(predictors, weights):\n    \"Return a predictor that takes a weighted vote.\"\n    def predict(example):\n        return weighted_mode((predictor(example) for predictor in predictors),\n                             weights)\n    return predict\n\ndef weighted_mode(predictors, weights):\n    \"Return a predictor that takes a weighted vote.\"\n    def predict(example):\n        return weighted_mode((predictor(example) for predictor in predictors),\n                             weights)\n    return predict",
        ", n\n    return result\n\n\ndef weighted_replicate(examples, weights, n):\n    \"\"\"Replicate examples in proportion to their weights.\n\n    Parameters\n    ----------\n    examples : list of examples\n        List of examples to replicate.\n    weights : list of float\n        List of weights to replicate.\n    n : int\n        Number of examples to replicate.\n\n    Returns\n    -------\n    list of examples\n        List of examples replicated in proportion to their weights.\n    \"\"\"\n    result = []\n    for example in examples:\n        result.append(example)\n        for weight in weights:\n            example[weight] *= n\n    return result\n\n\ndef weighted_replicate_with_weights(examples, weights, n):\n    \"\"\"Replicate examples in proportion to their weights.\n\n    Parameters\n    ----------\n    examples : list of examples\n        List of examples to replicate.\n    weights : list of float\n        List of weights to replicate.\n    n : int\n        Number of examples to replicate.\n\n    Returns\n    -------\n    list of examples\n        List of examples replicated in proportion to their weights.\n    \"\"\"\n    result = []\n    for example in examples:\n        result.append(example)\n        for weight in weights:\n            example[weight] *= n\n    return",
        ")\n\n\ndef cross_validation(learner, dataset, k=1):\n    \"\"\"Cross-validation over the dataset.\n\n    Parameters\n    ----------\n    learner : Learner\n        Learner to use.\n    dataset : Dataset\n        Dataset to cross-validate.\n    k : int\n        Number of examples to cross-validate.\n\n    Returns\n    -------\n    cross_val : Dataset\n        Cross-validated dataset.\n    \"\"\"\n    cross_val = Dataset()\n    for i in range(k):\n        cross_val.examples.append(learner.predict(dataset.examples[i]))\n    return cross_val\n\n\ndef cross_validation_with_weights(learner, dataset, weights):\n    \"\"\"Cross-validation over the dataset with weights.\n\n    Parameters\n    ----------\n    learner : Learner\n        Learner to use.\n    dataset : Dataset\n        Dataset to cross-validate.\n    weights : dict\n        Dictionary of weights to use.\n\n    Returns\n    -------\n    cross_val : Dataset\n        Cross-validated dataset.\n    \"\"\"\n    cross_val = Dataset()\n    for i in range(k):\n        cross_val.examples.append(learner.predict(dataset.examples[i], weights=weights))\n    return cross_val\n\n",
        ".sample(n) for i in range(n)])\n\ndef SyntheticRestaurant2(n=20):\n    \"Generate a DataSet with n examples.\"\n    def gen():\n        example = map(random.choice, restaurant.values)\n        example[restaurant.target] = Fig[18,2](example)\n        return example\n    return RestaurantDataSet([gen() for i in range(n)])\n\ndef SyntheticRestaurant3(n=20):\n    \"Generate a DataSet with n examples.\"\n    def gen():\n        example = map(random.choice, restaurant.values)\n        example[restaurant.target] = Fig[18,2](example)\n        return example\n    return RestaurantDataSet([gen() for i in range(n)])\n\ndef SyntheticRestaurant4(n=20):\n    \"Generate a DataSet with n examples.\"\n    def gen():\n        example = map(random.choice, restaurant.values)\n        example[restaurant.target] = Fig[18,2](example)\n        return example\n    return RestaurantDataSet([gen() for i in range(n)])\n\ndef SyntheticRestaurant5(n=20):\n    \"Generate a DataSet with n examples.\"\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        ".append(example)\n\ndef check_example(self, example):\n        \"Check if the example is valid, and if not, raise an error.\"\n        if not example.valid():\n                raise ValueError(\"Example is not valid.\")\n\ndef get_examples(self):\n        \"Return a list of examples.\"\n        return self.examples\n\ndef get_example(self, index):\n        \"Return an example at the given index.\"\n        return self.examples[index]\n\ndef get_examples_count(self):\n        \"Return the number of examples in the list.\"\n        return len(self.examples)\n\ndef get_example_by_id(self, id):\n        \"Return an example by its id.\"\n        for example in self.examples:\n                if example.id == id:\n                        return example\n        raise ValueError(\"Example with id %s not found.\" % id)\n\ndef get_example_by_name(self, name):\n        \"Return an example by its name.\"\n        for example in self.examples:\n                if example.name == name:\n                        return example\n        raise ValueError(\"Example with name %s not found.\" % name)\n\ndef get_example_by_description(self, description):\n        \"Return an example by its description.\"\n        for example in self.examples",
        "(self.values[a], self.attrnames[a], example))\n        return example\n\nclass BaseModel(object):\n    \"\"\"Base class for all model classes.\n\n    This class is used to define the interface for all model classes.\n    \"\"\"\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the model.\n\n        :param kwargs: A dictionary of keyword arguments.\n        \"\"\"\n        self.attrs = kwargs.pop('attrs', [])\n        self.values = kwargs.pop('values', {})\n        self.attrnames = kwargs.pop('attrnames', [])\n        self.kwargs = kwargs\n\n    def __call__(self, example):\n        \"\"\"Run the model.\n\n        :param example: A dictionary of keyword arguments.\n        :return: A dictionary of keyword arguments.\n        \"\"\"\n        return self.check_example(example)\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the model.\n\n        :return: A string representation of the model.\n        \"\"\"\n        return '<%s %s>' % (self.__class__.__name__, self.kwargs)\n\n    def __str__(self):\n        \"\"\"Return a string representation of the model.\n\n        :return: A string representation of the model.\n        \"\"\"\n       ",
        ":\n            return self.attrs.index(attr)\n\ndef attrnames(self):\n        \"Returns a list of all attribute names.\"\n        return self.attrnames\n\ndef attrnames_(self):\n        \"Returns a list of all attribute names.\"\n        return self.attrnames\n\ndef attrnames_(self, attr):\n        \"Returns a list of all attribute names, which can be a name, or -n .. n-1.\"\n        if attr < 0:\n            return self.attrnames + attr\n        elif isinstance(attr, str):\n            return self.attrnames.index(attr)\n        else:\n            return self.attrnames\n\ndef attrnames_(self, attr):\n        \"Returns a list of all attribute names, which can be a name, or -n .. n-1.\"\n        if attr < 0:\n            return self.attrnames + attr\n        elif isinstance(attr, str):\n            return self.attrnames.index(attr)\n        else:\n            return self.attrnames\n\ndef attrnames_(self, attr):\n        \"Returns a list of all attribute names, which can be a name, or -n .. n-1.\"\n        if attr < 0:\n            return self.attrnames + attr\n        elif isinstance(attr, str):\n            return self.",
        "]\n\ndef sanitize_example(self, example):\n       \"Return a copy of example, with non-input attributes replaced by None.\"\n       return [attr_i if i in self.inputs else None\n               for i, attr_i in enumerate(example)]\n\ndef sanitize_example_with_inputs(self, example):\n       \"Return a copy of example, with non-input attributes replaced by None.\"\n       return [attr_i if i in self.inputs else None\n               for i, attr_i in enumerate(example)]\n\ndef sanitize_example_with_outputs(self, example):\n       \"Return a copy of example, with non-input attributes replaced by None.\"\n       return [attr_i if i in self.outputs else None\n               for i, attr_i in enumerate(example)]\n\ndef sanitize_example_with_outputs_with_inputs(self, example):\n       \"Return a copy of example, with non-input attributes replaced by None.\"\n       return [attr_i if i in self.outputs_with_inputs else None\n               for i, attr_i in enumerate(example)]\n\ndef sanitize_example_with_outputs_with_inputs_with_outputs(self, example):\n       \"Return a copy of example, with non-input attributes replaced by None.\"\n       return [attr_i if i",
        "(o)\n\ndef smooth_for(self, o):\n        \"Smooth for an observation o.\"\n        self.smooth_for_obs(o)\n        self.smooth_for_obs_dict(o)\n        self.smooth_for_obs_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o)\n        self.smooth_for_obs_dict_dict_dict(o",
        ".smooth_for(o)\n\ndef smooth_for_all(self):\n        \"\"\"Include all possible observations, whether or not\n        it's been observed yet.\"\"\"\n        for o in self.dictionary:\n            self.smooth_for(o)\n\ndef smooth_for_all_with_noise(self, noise):\n        \"\"\"Include all possible observations, whether or not\n        it's been observed yet, and noise.\"\"\"\n        for o in self.dictionary:\n            self.smooth_for(o, noise)\n\ndef smooth_for_all_with_noise_and_noise(self, noise, noise2):\n        \"\"\"Include all possible observations, whether or not\n        it's been observed yet, and noise and noise2.\"\"\"\n        for o in self.dictionary:\n            self.smooth_for(o, noise, noise2)\n\ndef smooth_for_all_with_noise_and_noise2(self, noise, noise2, noise3):\n        \"\"\"Include all possible observations, whether or not\n        it's been observed yet, and noise and noise2, noise3.\"\"\"\n        for o in self.dictionary:\n            self.smooth_for(o, noise, noise2, noise3)\n\ndef smooth_for_all_with_noise_and_noise3(self, noise, noise2, noise3",
        "\n\ndef weighted_sampler(keys, values):\n        \"Return a weighted sampler.\"\n        if len(keys) == len(values):\n            return lambda: values[random.randint(0, len(values) - 1)]\n        else:\n            return lambda: random.choice(keys)\n\ndef weighted_sampler_with_probability(keys, values):\n        \"Return a weighted sampler with probability.\"\n        if len(keys) == len(values):\n            return lambda: values[random.randint(0, len(values) - 1)]\n        else:\n            return lambda: random.choice(keys)\n\ndef weighted_sampler_with_probability_with_probability(keys, values):\n        \"Return a weighted sampler with probability and probability.\"\n        if len(keys) == len(values):\n            return lambda: values[random.randint(0, len(values) - 1)]\n        else:\n            return lambda: random.choice(keys)\n\ndef weighted_sampler_with_probability_with_probability_with_probability(keys, values):\n        \"Return a weighted sampler with probability and probability and probability.\"\n        if len(keys) == len(values):\n            return lambda: values[random.randint(0, len(values) - 1)]\n        else:\n           ",
        "\n\ndef solve(csp, Xi, Xj, removals):\n    \"Return true if we remove a value.\"\n    revised = False\n    for x in csp.curr_domains[Xi][:]:\n        # If Xi=x conflicts with Xj=y for every possible y, eliminate Xi=x\n        if every(lambda y: not csp.constraints(Xi, x, Xj, y),\n                 csp.curr_domains[Xj]):\n            csp.prune(Xi, x, removals)\n            revised = True\n    return revised\n\ndef solve_revise(csp, Xi, Xj, removals):\n    \"Return true if we remove a value.\"\n    return revise(csp, Xi, Xj, removals)\n\ndef solve_revise_all(csp, Xi, Xj, removals):\n    \"Return true if we remove a value.\"\n    return revise_all(csp, Xi, Xj, removals)\n\ndef solve_revise_all_revise(csp, Xi, Xj, removals):\n    \"Return true if we remove a value.\"\n    return revise_all_revise(csp, Xi, Xj, removals)\n\ndef solve_revise_all_rev",
        ",\n        lambda var: num_legal_values(csp, var, assignment))\n\n\ndef num_legal_values(csp, var, assignment):\n    \"\"\"Return the number of legal values for a given variable.\"\"\"\n    return len(csp.vars[var]) - len(assignment)\n\n\ndef argmin_random_tie(vars, func, seed):\n    \"\"\"Return the least-recently-used variable.\"\"\"\n    return min(vars, key=func, seed=seed)\n\n\ndef argmin_random_tie_with_seed(vars, func, seed):\n    \"\"\"Return the least-recently-used variable with a given seed.\"\"\"\n    return min(vars, key=func, seed=seed)\n\n\ndef argmin_random_tie_with_seed_and_vars(vars, func, seed, vars):\n    \"\"\"Return the least-recently-used variable with a given seed and\n    variables.\"\"\"\n    return min(vars, key=func, seed=seed, vars=vars)\n\n\ndef argmin_random_tie_with_seed_and_vars_and_vars(vars, func, seed, vars, vars2):\n    \"\"\"Return the least-recently-used variable with a given seed and\n    variables and variables2.\"\"\"\n    return min(vars, key=func, seed=seed, vars",
        ")\n\ndef lcv_all(var, assignment, csp):\n    \"Least-constraining-values heuristic.\"\n    return sorted(csp.choices(var),\n                  key=lambda val: csp.nconflicts(var, val, assignment))\n\ndef lcv_all_all(var, assignment, csp):\n    \"Least-constraining-values heuristic.\"\n    return sorted(csp.choices(var),\n                  key=lambda val: csp.nconflicts(var, val, assignment))\n\ndef lcv_all_all_all(var, assignment, csp):\n    \"Least-constraining-values heuristic.\"\n    return sorted(csp.choices(var),\n                  key=lambda val: csp.nconflicts(var, val, assignment))\n\ndef lcv_all_all_all(var, assignment, csp):\n    \"Least-constraining-values heuristic.\"\n    return sorted(csp.choices(var),\n                  key=lambda val: csp.nconflicts(var, val, assignment))\n\ndef lcv_all_all_all(var, assignment, csp):\n    \"Least-constraining-values heuristic.\"\n    return sorted(csp.choices(var),\n                  key=lambda val: csp.nconflicts(var, val, assignment))\n\ndef lc",
        "\n\ndef backward_checking(csp, var, value, assignment, removals):\n    \"Prune neighbor values inconsistent with var=value.\"\n    for B in csp.neighbors[var]:\n        if B not in assignment:\n            for b in csp.curr_domains[B][:]:\n                if not csp.constraints(var, value, B, b):\n                    csp.prune(B, b, removals)\n            if not csp.curr_domains[B]:\n                return False\n    return True\n\ndef prune_neighbor_values(csp, var, value, assignment, removals):\n    \"Prune neighbor values inconsistent with var=value.\"\n    for B in csp.neighbors[var]:\n        if B not in assignment:\n            for b in csp.curr_domains[B][:]:\n                if not csp.constraints(var, value, B, b):\n                    csp.prune(B, b, removals)\n            if not csp.curr_domains[B]:\n                return False\n    return True\n\ndef prune_neighbor_values_backward(csp, var, value, assignment, removals):\n    \"Prune neighbor values inconsistent with var=value.\"\n    for B in csp.neighbors[var]:\n        if B not in assignment:\n            for b in csp.curr_domains[B][:]:\n                if",
        ", value, assignment, removals)\n\ndef ac3(csp, arcs, removals):\n    \"Compute arc consistency.\"\n    return AC3(csp, arcs, removals)\n\ndef ac3_mac(csp, var, value, assignment, removals):\n    \"Compute arc consistency.\"\n    return mac(csp, var, value, assignment, removals)\n\ndef ac3_mac_with_removals(csp, var, value, assignment, removals):\n    \"Compute arc consistency.\"\n    return mac(csp, var, value, assignment, removals)\n\ndef ac3_mac_with_assignment(csp, var, value, assignment, removals):\n    \"Compute arc consistency.\"\n    return mac(csp, var, value, assignment, removals)\n\ndef ac3_mac_with_removals_and_assignment(csp, var, value, assignment, removals):\n    \"Compute arc consistency.\"\n    return mac(csp, var, value, assignment, removals)\n\ndef ac3_mac_with_removals_and_assignment_and_removals(csp, var, value, assignment, removals):\n    \"Compute arc consistency.\"\n    return mac(csp, var, value, assignment, removals)\n\ndef ac3_mac_with_remov",
        "\n\ndef min_conflicts_value(csp, var, current):\n    \"\"\"Return the minimum value of a variable in the CSP.\"\"\"\n    if var in current:\n        return current[var]\n    else:\n        return csp.min_conflicts_value(var)\n\ndef min_conflicts_value_with_conflicts(csp, var, current):\n    \"\"\"Return the minimum value of a variable in the CSP with conflicts.\"\"\"\n    if var in current:\n        return current[var]\n    else:\n        return csp.min_conflicts_value_with_conflicts(var)\n\ndef min_conflicts_value_with_conflicts_with_conflicts(csp, var, current):\n    \"\"\"Return the minimum value of a variable in the CSP with conflicts and conflicts.\"\"\"\n    if var in current:\n        return current[var]\n    else:\n        return csp.min_conflicts_value_with_conflicts_with_conflicts(var)\n\ndef min_conflicts_value_with_conflicts_with_conflicts_with_conflicts(csp, var, current):\n    \"\"\"Return the minimum value of a variable in the CSP with conflicts and conflicts and conflicts with conflicts.\"\"\"\n    if var in current:\n        return current[var]\n    else:\n       ",
        ")\n\ndef min_conflicts_value_random(csp, var, current):\n    \"\"\"Return the value that will give var the least number of conflicts.\n    If there is a tie, choose at random.\"\"\"\n    return argmin_random_tie(csp.domains[var],\n                             lambda val: csp.nconflicts(var, val, current))\n\ndef min_conflicts_value_random_tie(csp, var, current):\n    \"\"\"Return the value that will give var the least number of conflicts.\n    If there is a tie, choose at random.\"\"\"\n    return argmin_random_tie(csp.domains[var],\n                             lambda val: csp.nconflicts(var, val, current))\n\ndef min_conflicts_value_random_tie_random(csp, var, current):\n    \"\"\"Return the value that will give var the least number of conflicts.\n    If there is a tie, choose at random.\"\"\"\n    return argmin_random_tie(csp.domains[var],\n                             lambda val: csp.nconflicts(var, val, current))\n\ndef min_conflicts_value_random_tie_random_tie(csp, var, current):\n    \"\"\"Return the value that will give var the least number of conflicts.\n    If there is a tie, choose at random.\"\"\"\n    return argmin_random",
        ")\n\ndef count_if(func, iterable):\n        \"Return the number of times func is called.\"\n        def _count(x):\n                return func(x)\n        return count(x for x in iterable if _count(x))\n\ndef count_if_not(func, iterable):\n        \"Return the number of times func is called.\"\n        def _count(x):\n                return not func(x)\n        return count(x for x in iterable if _count(x))\n\ndef count_if_not_not(func, iterable):\n        \"Return the number of times func is called.\"\n        def _count(x):\n                return not func(x) and not func(x)\n        return count(x for x in iterable if _count(x))\n\ndef count_if_not_not_not(func, iterable):\n        \"Return the number of times func is called.\"\n        def _count(x):\n                return not func(x) and not func(x) and not func(x)\n        return count(x for x in iterable if _count(x))\n\ndef count_if_not_not_not(func, iterable):\n        \"Return the number of times func is called.\"\n        def _count(x):\n                return not func(x) and not func(",
        "(var, value)]\n\ndef suppose_all(self, var, value):\n        \"Start accumulating inferences from assuming var=value.\"\n        self.support_pruning()\n        self.curr_domains[var] = [value]\n        return self.suppose(var, value)\n\ndef suppose_all_all(self, var, value):\n        \"Start accumulating inferences from assuming var=value.\"\n        self.support_pruning()\n        self.curr_domains[var] = [value]\n        return self.suppose_all(var, value)\n\ndef suppose_all_all_all(self, var, value):\n        \"Start accumulating inferences from assuming var=value.\"\n        self.support_pruning()\n        self.curr_domains[var] = [value]\n        return self.suppose_all_all(var, value)\n\ndef suppose_all_all_all(self, var, value):\n        \"Start accumulating inferences from assuming var=value.\"\n        self.support_pruning()\n        self.curr_domains[var] = [value]\n        return self.suppose_all_all(var, value)\n\ndef suppose_all_all_all_all(self, var, value):\n       ",
        "\n\ndef prune_all(self):\n        \"Prune all domains.\"\n        for var in self.curr_domains:\n                prune(var, self.curr_domains[var], None)\n\ndef prune_all_by_var(self, var):\n        \"Prune all domains by var.\"\n        for value in self.curr_domains[var]:\n                prune(var, value, None)\n\ndef prune_all_by_value(self, value):\n        \"Prune all domains by value.\"\n        for var in self.curr_domains:\n                prune(var, value, None)\n\ndef prune_all_by_value_and_var(self, value, var):\n        \"Prune all domains by value and var.\"\n        for var in self.curr_domains[var]:\n                prune(var, value, [var])\n\ndef prune_all_by_value_and_var_and_value(self, value, var, value2):\n        \"Prune all domains by value and var and value2.\"\n        for var in self.curr_domains[var]:\n                prune(var, value, [var, value2])\n\ndef prune_all_by_value_and_var_and_value_and_var(self, value, var, value2, value3):\n        \"Prune",
        ")\n                    if v in self.curr_domains)\n\ndef infer_assignment_from_domain(self, domain):\n        \"Return the partial assignment implied by the current inferences.\"\n        self.support_pruning()\n        return dict((v, self.curr_domains[v][0])\n                    for v in self.vars if 1 == len(self.curr_domains[v]))\n\ndef infer_assignment_from_domain_with_pruning(self, domain):\n        \"Return the partial assignment implied by the current inferences.\"\n        self.support_pruning()\n        return dict((v, self.curr_domains[v][0])\n                    for v in self.vars if 1 == len(self.curr_domains[v]))\n\ndef infer_assignment_from_domain_with_pruning_and_domain(self, domain, pruning_domain):\n        \"Return the partial assignment implied by the current inferences.\"\n        self.support_pruning()\n        return dict((v, self.curr_domains[v][0])\n                    for v in self.vars if 1 == len(self.curr_domains[v])\n                    and self.curr_domains[v][0] == pruning_domain)\n\ndef infer_assignment_from_domain_with_pruning_and_domain_with",
        " in removals:\n            self.curr_domains[B].remove(b)\n\n        for B, b in self.curr_domains.items():\n            self.curr_domains[B].clear()\n\n        self.curr_domains = {}\n\n        self.curr_domains_count = 0\n\n        self.curr_domains_count_old = 0\n\n        self.curr_domains_count_new = 0\n\n        self.curr_domains_count_removed = 0\n\n        self.curr_domains_count_removed_old = 0\n\n        self.curr_domains_count_removed_new = 0\n\n        self.curr_domains_count_removed_removed = 0\n\n        self.curr_domains_count_removed_removed_old = 0\n\n        self.curr_domains_count_removed_removed_new = 0\n\n        self.curr_domains_count_removed_removed_removed = 0\n\n        self.curr_domains_count_removed_removed_removed = 0\n\n        self.curr_domains_count_removed_removed_removed = 0\n\n        self.curr_domains_count_removed_removed_removed = 0\n\n        self.curr_domains_count_removed_removed_removed = 0\n\n        self.curr_domains_count_removed_removed_",
        "]\n\ndef nconflicts(var, current, current_copy):\n        \"Return true if current variable is in conflict with current_copy\"\n        return current[var] != current_copy[var]\n\ndef get_conflicted_vars(self, current):\n        \"Return a list of variables in current assignment that are in conflict\"\n        return [var for var in self.vars\n                if self.nconflicts(var, current[var], current)]\n\ndef get_conflicted_vars_copy(self, current):\n        \"Return a copy of the conflicted_vars list\"\n        return [var for var in self.vars\n                if self.nconflicts(var, current[var], current_copy[var])]\n\ndef get_conflicted_vars_copy_copy(self, current):\n        \"Return a copy of the conflicted_vars list with the current assignment copied\"\n        return [var for var in self.vars\n                if self.nconflicts(var, current[var], current_copy[var])]\n\ndef get_conflicted_vars_copy_copy_copy(self, current):\n        \"Return a copy of the conflicted_vars list with the current assignment copied and copied\"\n        return [var for var in self.vars\n                if self.nconflicts(var",
        "\n\ndef nconflicts_for_var(self, var, val, assignment):\n        \"\"\"The number of conflicts, as recorded with each assignment.\n        Count conflicts in row and in up, down diagonals. If there\n        is a queen there, it can't conflict with itself, so subtract 3.\"\"\"\n        n = len(self.vars)\n        c = self.rows[val] + self.downs[var+val] + self.ups[var-val+n-1]\n        if assignment.get(var, None) == val:\n            c -= 3\n        return c\n\ndef nconflicts_for_var_and_val(self, var, val, assignment):\n        \"\"\"The number of conflicts, as recorded with each assignment.\n        Count conflicts in row and in up, down diagonals. If there\n        is a queen there, it can't conflict with itself, so subtract 3.\"\"\"\n        n = len(self.vars)\n        c = self.rows[val] + self.downs[var+val] + self.ups[var-val+n-1]\n        if assignment.get(var, None) == val:\n            c -= 3\n        return c\n\ndef nconflicts_for_var_and_val_for_var(self, var, val,",
        "\n        assignment[var] = val\n\ndef record_conflict(self, assignment, var, val, op):\n        \"Record conflict between var and val.\"\n        assignment[var] = val\n        assignment[var] = op\n\ndef CSP(self, var, val, assignment):\n        \"CSP var, and keep track of conflicts.\"\n        oldval = assignment.get(var, None)\n        if val != oldval:\n            if oldval is not None: # Remove old val if there was one\n                self.record_conflict(assignment, var, oldval, -1)\n            self.record_conflict(assignment, var, val, +1)\n            CSP.assign(self, var, val, assignment)\n\ndef CSP_(self, var, val, assignment):\n        \"CSP var, and keep track of conflicts.\"\n        oldval = assignment.get(var, None)\n        if val != oldval:\n            if oldval is not None: # Remove old val if there was one\n                self.record_conflict(assignment, var, oldval, -1)\n            self.record_conflict(assignment, var, val, +1)\n            CSP.assign(self, var, val, assignment)\n\ndef CSP_(self, var, val, assignment):\n       ",
        ", delta\n        self.vars[var] += delta\n        self.vars[var + val] += delta\n        self.vars[var - val + n - 1] += delta\n        self.vars[var + n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var + n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var - n - 1] += delta\n        self.vars[var",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".translate(trans)\n\ndef decode(plaintext, code):\n    \"Decodes text, using a code which is a permutation of the alphabet.\"\n    from string import maketrans\n    trans = maketrans(code + code.upper(), alphabet + alphabet.upper())\n    return plaintext.translate(trans)\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    from random import randint\n    from string import ascii_letters\n    from string import digits\n    from string import digits\n    from string import letters\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n    from string import letters\n    from string import digits\n   ",
        "\n\ndef main():\n    \"\"\"Main program.\"\"\"\n    parser = argparse.ArgumentParser(description='Generate random text.')\n    parser.add_argument('-n', '--n', type=int, default=10,\n                        help='Number of words to generate.')\n    parser.add_argument('-c', '--cond-prob', type=str, default='',\n                        help='Conditional probability to use.')\n    args = parser.parse_args()\n    nwords = int(args.n)\n    cond_prob = args.cond_prob\n    if cond_prob == ' ':\n        cond_prob = ' '\n    print(samples(nwords))\n\nif __name__ == '__main__':\n    main()\n",
        ", filename)\n\ndef index_document(self, document, filename):\n        \"Index a single document.\"\n        self.index_document_with_id(document, filename)\n\ndef index_document_with_id(self, document, filename):\n        \"Index a single document with a unique id.\"\n        self.index_document_with_id_with_id(document, filename)\n\ndef index_document_with_id_with_id(self, document, filename):\n        \"Index a single document with a unique id and a unique id.\"\n        self.index_document_with_id_with_id_with_id(document, filename)\n\ndef index_document_with_id_with_id_with_id(self, document, filename):\n        \"Index a single document with a unique id and a unique id with a unique id.\"\n        self.index_document_with_id_with_id_with_id_with_id(document, filename)\n\ndef index_document_with_id_with_id_with_id(self, document, filename):\n        \"Index a single document with a unique id and a unique id with a unique id with a unique id.\"\n        self.index_document_with_id_with_id_with_id_with_id(document, filename",
        "\n                self.stopwords.remove(word)\n                self.stopwords.remove(word.lower())\n                self.stopwords.remove(word.upper())\n                self.stopwords.remove(word.replace(' ', ''))\n                self.stopwords.remove(word.replace('.', ''))\n                self.stopwords.remove(word.replace('-', ''))\n                self.stopwords.remove(word.replace('+', ''))\n                self.stopwords.remove(word.replace('.', ''))\n                self.stopwords.remove(word.replace('-', ''))\n                self.stopwords.remove(word.replace('+', ''))\n                self.stopwords.remove(word.replace('.', ''))\n                self.stopwords.remove(word.replace('-', ''))\n                self.stopwords.remove(word.replace('+', ''))\n                self.stopwords.remove(word.replace('.', ''))\n                self.stopwords.remove(word.replace('-', ''))\n                self.stopwords.remove(word.replace('+', ''))\n                self.stopwords.remove(word.replace('.', ''))\n                self.stopwords.remove(word.replace('-', ''))\n                self.stopwords.remove",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n                   % (doc.title[:45].expandtabs()))\n\ndef main():\n        \"Main function.\"\n        parser = argparse.ArgumentParser(description=\"Print the results of a search.\")\n        parser.add_argument(\"-d\", \"--documents\", help=\"The documents to search.\", required=True)\n        parser.add_argument(\"-p\", \"--print-results\", help=\"Print the results of a search.\", action=\"store_true\")\n        args = parser.parse_args()\n\n        if args.print_results:\n            present(self, self.search(args.documents))\n        else:\n            print(self.search(args.documents))\n\nif __name__ == \"__main__\":\n        main()\n",
        ", n)\n\ndef present_results_with_query_text(self, query_text, n=10):\n        \"Get results for the query and present them with a query text.\"\n        self.present(self.query(query_text, n))\n\ndef present_results_with_query_text_and_n(self, query_text, n=10):\n        \"Get results for the query and present them with a query text and n.\"\n        self.present(self.query(query_text, n))\n\ndef present_results_with_query_text_and_n_and_query_text(self, query_text, n=10, query_text):\n        \"Get results for the query and present them with a query text and n and query text.\"\n        self.present(self.query(query_text, n, query_text))\n\ndef present_results_with_query_text_and_n_and_query_text_and_n(self, query_text, n=10, query_text, n=10):\n        \"Get results for the query and present them with a query text and n and query text and n and query text.\"\n        self.present(self.query(query_text, n, query_text, n))\n\ndef present_results_with_",
        "\n        return s\n\ndef bigrams(self, plaintext):\n        \"Return a list of bigrams of the given string.\"\n        bigrams = []\n        for bi in plaintext:\n                if bi in self.P2:\n                        bigrams.append(bi)\n        return bigrams\n\ndef bigrams_of_words(self, plaintext):\n        \"Return a list of bigrams of the given string.\"\n        bigrams = []\n        for bi in plaintext:\n                if bi in self.P2:\n                        bigrams.append(bi)\n        return bigrams\n\ndef bigrams_of_words_with_p2(self, plaintext):\n        \"Return a list of bigrams of the given string.\"\n        bigrams = []\n        for bi in plaintext:\n                if bi in self.P2:\n                        bigrams.append(bi)\n        for bi in bigrams(plaintext):\n                if bi in self.P2:\n                        bigrams.append(bi)\n        return bigrams\n\ndef bigrams_of_words_with_p2_and_p3(self, plaintext):\n        \"Return a list of bigrams of the given string.\"\n        bigrams = []\n        for bi in plaintext:\n                if bi in self.P2:\n                        bigrams.append(bi",
        "\n\ndef main():\n    \"Main function.\"\n    cipher = Cipher(b'abcdefghijklmnopqrstuvwxyz')\n    print(cipher.decode(b'abcdefghijklmnopqrstuvwxyz'))\n\nif __name__ == '__main__':\n    main()\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\nclass SettingDict(object):\n    \"\"\"\n    A ``SettingDict`` object.\n    \"\"\"\n    def __init__(self, **kwargs):\n        self.update(kwargs)\n\n    def update(self, **kwargs):\n        \"\"\"\n        Updates the ``SettingDict`` object.\n        \"\"\"\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n    def __repr__(self):\n        return '<SettingDict %r>' % self\n\n    def __str__(self):\n        return str(self)\n\n    def __eq__(self, other):\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.__dict__)\n\n    def __eq__(self, other):\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __str__(self):\n        return str(self)\n\n    def __repr__(self):\n        return '<SettingDict %r>' % self\n\n    def __str__(self):\n        return str(self)\n",
        ".items()])\n\ndef expected_utility_with_state(a, s, U, mdp):\n    \"The expected utility of doing a in state s, according to the MDP and U.\"\n    return expected_utility(a, s, U, mdp)\n\ndef expected_utility_with_state_and_state(a, s, U, mdp):\n    \"The expected utility of doing a in state s, according to the MDP and U.\"\n    return expected_utility(a, s, U, mdp)\n\ndef expected_utility_with_state_and_state_and_state(a, s, U, mdp):\n    \"The expected utility of doing a in state s, according to the MDP and U.\"\n    return expected_utility(a, s, U, mdp)\n\ndef expected_utility_with_state_and_state_and_state(a, s, U, mdp):\n    \"The expected utility of doing a in state s, according to the MDP and U.\"\n    return expected_utility(a, s, U, mdp)\n\ndef expected_utility_with_state_and_state_and_state(a, s, U, mdp):\n    \"The expected utility of doing a in",
        ")\n\ndef vector_add(self, state, direction):\n        \"Return the state that results from adding this direction to the state.\"\n        state1 = vector_add(state, direction)\n        return if_(state1 in self.states, state1, state)\n\ndef vector_subtract(self, state, direction):\n        \"Return the state that results from subtracting this direction from the state.\"\n        state1 = vector_subtract(state, direction)\n        return if_(state1 in self.states, state1, state)\n\ndef vector_multiply(self, state, direction):\n        \"Return the state that results from multiplying this direction by this value.\"\n        state1 = vector_multiply(state, direction)\n        return if_(state1 in self.states, state1, state)\n\ndef vector_divide(self, state, direction):\n        \"Return the state that results from dividing this direction by this value.\"\n        state1 = vector_divide(state, direction)\n        return if_(state1 in self.states, state1, state)\n\ndef vector_add_vector(self, state, vector):\n        \"Return the state that results from adding this vector to the state.\"\n        state1 = vector_add(state, vector)\n        return if_",
        ".as_dict()\n        return settings\n\nclass SettingDict(object):\n    \"\"\"\n    A ``SettingDict`` object for this queryset.\n    \"\"\"\n    def __init__(self, queryset, default=None):\n        self.queryset = queryset\n        self.default = default\n\n    def __repr__(self):\n        return \"<SettingDict %r>\" % self.queryset\n\n    def __eq__(self, other):\n        return self.queryset == other.queryset\n\n    def __ne__(self, other):\n        return self.queryset != other.queryset\n\n    def __lt__(self, other):\n        return self.queryset < other.queryset\n\n    def __le__(self, other):\n        return self.queryset <= other.queryset\n\n    def __gt__(self, other):\n        return self.queryset > other.queryset\n\n    def __ge__(self, other):\n        return self.queryset >= other.queryset\n\n    def __eq__(self, other):\n        return self.queryset == other.queryset\n\n    def __ne__(self, other):\n        return self.queryset != other.queryset\n\n    def __lt__(self, other):\n        return self.queryset < other.queryset\n\n    def __le__(self, other):\n       ",
        "\n\ndef get_queryset(self):\n        \"\"\"\n        Returns a queryset of all settings.\n        \"\"\"\n        return Setting.objects.all()\n\ndef get_queryset_for_value(value):\n        \"\"\"\n        Returns a queryset of all settings for the given ``value``.\n        \"\"\"\n        return Setting.objects.filter(value=value)\n\ndef get_queryset_for_name(name):\n        \"\"\"\n        Returns a queryset of all settings for the given ``name``.\n        \"\"\"\n        return Setting.objects.filter(name=name)\n\ndef get_queryset_for_name_and_value(name, value):\n        \"\"\"\n        Returns a queryset of all settings for the given ``name`` and ``value``.\n        \"\"\"\n        return Setting.objects.filter(name=name, value=value)\n\ndef get_queryset_for_name_and_value_and_type(name, value, type):\n        \"\"\"\n        Returns a queryset of all settings for the given ``name`` and ``value``\n        and ``type``.\n        \"\"\"\n        return Setting.objects.filter(name=name, value=value, type=type)\n\ndef get_queryset_for_name_and_value_and_type_and_value(name, value, type, value):\n        \"\"\"",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.internal.nio.Connection;\nimport com.hazelcast.internal.nio.ConnectionState;\nimport com.hazelcast.internal.protocol.ClientMessage;\nimport com.hazelcast.internal.protocol.codec.MapRemove",
        "(t, limit)\n\ndef exp_schedule_2(k=20, lam=0.005, limit=100):\n    \"One possible schedule function for simulated annealing\"\n    return lambda t: if_(t < limit, k * math.exp(-lam * t), 0)\n\ndef exp_schedule_3(k=20, lam=0.005, limit=100):\n    \"One possible schedule function for simulated annealing\"\n    return lambda t: if_(t < limit, k * math.exp(-lam * t), 0)\n\ndef exp_schedule_4(k=20, lam=0.005, limit=100):\n    \"One possible schedule function for simulated annealing\"\n    return lambda t: if_(t < limit, k * math.exp(-lam * t), 0)\n\ndef exp_schedule_5(k=20, lam=0.005, limit=100):\n    \"One possible schedule function for simulated annealing\"\n    return lambda t: if_(t < limit, k * math.exp(-lam * t), 0)\n\ndef exp_schedule_6(k=20, lam=0.005, limit=100):\n    \"One possible schedule function for simulated annealing\"\n    return lambda t: if_(",
        "\n\ndef genetic_algorithm(states, fitness_fn, ngen=1000, pmut=0.1, n=20):\n    \"\"\"Call genetic_algorithm on the appropriate parts of a problem.\n    This requires the problem to have states that can mate and mutate,\n    plus a value method that scores states.\"\"\"\n    s = problem.initial_state\n    states = [problem.result(s, a) for a in problem.actions(s)]\n    random.shuffle(states)\n    return genetic_algorithm(states[:n], fitness_fn, ngen, pmut, n)\n\ndef genetic_algorithm(states, fitness_fn, ngen=1000, pmut=0.1, n=20):\n    \"\"\"Call genetic_algorithm on the appropriate parts of a problem.\n    This requires the problem to have states that can mate and mutate,\n    plus a value method that scores states.\"\"\"\n    s = problem.initial_state\n    states = [problem.result(s, a) for a in problem.actions(s)]\n    random.shuffle(states)\n    return genetic_algorithm(states[:n], fitness_fn, ngen, pmut, n)\n\ndef genetic_algorithm(states, fitness_fn, ngen=1000, pmut=0.1, n=20",
        "\n\ndef random_boggle_2(n=4):\n    \"\"\"Return a random Boggle board of size n x n.\n    We represent a board as a linear list of letters.\"\"\"\n    cubes = [cubes16[i % 16] for i in range(n*n)]\n    random.shuffle(cubes)\n    return map(random.choice, cubes)\n\ndef random_boggle_3(n=4):\n    \"\"\"Return a random Boggle board of size n x n.\n    We represent a board as a linear list of letters.\"\"\"\n    cubes = [cubes16[i % 16] for i in range(n*n)]\n    random.shuffle(cubes)\n    return map(random.choice, cubes)\n\ndef random_boggle_4(n=4):\n    \"\"\"Return a random Boggle board of size n x n.\n    We represent a board as a linear list of letters.\"\"\"\n    cubes = [cubes16[i % 16] for i in range(n*n)]\n    random.shuffle(cubes)\n    return map(random.choice, cubes)\n\ndef random_boggle_5(n=4):\n    \"\"\"Return a random Boggle board of size n x n.\n    We represent a board as a linear list of letters.\"\"\"\n    cubes =",
        "#include \"stdafx.h\"\n#include \"Game.h\"\n#include \"GameState.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#include \"GameStateManager.h\"\n#",
        "\n\ndef exact_sqrt(n):\n    \"\"\"Return the exact square root of n.\"\"\"\n    return int(math.sqrt(n))\n\ndef exact_int(n):\n    \"\"\"Return the exact integer root of n.\"\"\"\n    return int(math.floor(n))\n\ndef exact_float(n):\n    \"\"\"Return the exact float root of n.\"\"\"\n    return float(math.floor(n))\n\ndef exact_long(n):\n    \"\"\"Return the exact long root of n.\"\"\"\n    return long(math.floor(n))\n\ndef exact_ulong(n):\n    \"\"\"Return the exact ulong root of n.\"\"\"\n    return ulong(math.floor(n))\n\ndef exact_longlong(n):\n    \"\"\"Return the exact long long root of n.\"\"\"\n    return longlong(math.floor(n))\n\ndef exact_ulonglong(n):\n    \"\"\"Return the exact ulong long root of n.\"\"\"\n    return ulonglong(math.floor(n))\n\ndef exact_longdouble(n):\n    \"\"\"Return the exact long double root of n.\"\"\"\n    return longdouble(math.floor(n))\n\ndef exact_ulongdouble(n):\n    \"\"\"Return the exact ulong double root of n.\"\"\"\n    return ulong",
        ", n2\n\ndef exact_sqrt_2(n2):\n    \"If n2 is a perfect square, return its square root, else raise error.\"\n    n = int(math.sqrt(n2))\n    assert n * n == n2\n\ndef exact_sqrt_3(n2):\n    \"If n2 is a perfect square, return its square root, else raise error.\"\n    n = int(math.sqrt(n2))\n    assert n * n == n2\n\ndef exact_sqrt_4(n2):\n    \"If n2 is a perfect square, return its square root, else raise error.\"\n    n = int(math.sqrt(n2))\n    assert n * n == n2\n\ndef exact_sqrt_5(n2):\n    \"If n2 is a perfect square, return its square root, else raise error.\"\n    n = int(math.sqrt(n2))\n    assert n * n == n2\n\ndef exact_sqrt_6(n2):\n    \"If n2 is a perfect square, return its square root, else raise error.\"\n    n = int(math.sqrt(n2))\n    assert n * n == n2\n\ndef exact_sqrt_7(n2):\n    \"If n2 is a perfect square, return its square",
        "(problem)]\n\ndef solve(problem):\n        \"Solve the problem.\"\n        return [self.child_node(problem, action)\n                for action in problem.actions(self.state)]\n\ndef main():\n        \"Main function.\"\n        problem = Problem()\n        problem.add_node(Node(1, 'a', 'b'))\n        problem.add_node(Node(2, 'c', 'd'))\n        problem.add_node(Node(3, 'e', 'f'))\n        problem.add_node(Node(4, 'g', 'h'))\n        problem.add_node(Node(5, 'i', 'j'))\n        problem.add_node(Node(6, 'k', 'l'))\n        problem.add_node(Node(7, 'm', 'n'))\n        problem.add_node(Node(8, 'o', 'p'))\n        problem.add_node(Node(9, 'q', 'r'))\n        problem.add_node(Node(10, 's', 't'))\n        problem.add_node(Node(11, 'u', 'v'))\n        problem.add_node(Node(12, 'w', 'x'))\n        problem.add_node(Node(13, 'y', 'z'))\n        problem",
        "),\n                    problem.path_cost(self.path_cost, self.state, action, next))\n\ndef child_node_2(self, problem, action):\n        \"Fig. 3.11\"\n        next = problem.result(self.state, action)\n        return Node(next, self, action,\n                    problem.path_cost(self.path_cost, self.state, action, next),\n                    problem.path_cost(self.path_cost, self.state, action, next))\n\ndef child_node_3(self, problem, action):\n        \"Fig. 3.12\"\n        next = problem.result(self.state, action)\n        return Node(next, self, action,\n                    problem.path_cost(self.path_cost, self.state, action, next),\n                    problem.path_cost(self.path_cost, self.state, action, next))\n\ndef child_node_4(self, problem, action):\n        \"Fig. 3.13\"\n        next = problem.result(self.state, action)\n        return Node(next, self, action,\n                    problem.path_cost(self.path_cost, self.state, action, next),\n                    problem.path_cost(self.path_cost, self.",
        ")\n\ndef reverse_path(self):\n        \"Return a list of nodes forming the path from the root to this node.\"\n        node, path_back = self, []\n        while node:\n            path_back.append(node)\n            node = node.parent\n        return list(reversed(path_back))\n\ndef is_path_empty(self):\n        \"Return True if the path is empty.\"\n        return len(self.path()) == 0\n\ndef is_path_full(self):\n        \"Return True if the path is full.\"\n        return len(self.path()) == 1\n\ndef is_path_single(self):\n        \"Return True if the path is single.\"\n        return len(self.path()) == 2\n\ndef is_path_multiple(self):\n        \"Return True if the path is multiple.\"\n        return len(self.path()) == 3\n\ndef is_path_empty_multiple(self):\n        \"Return True if the path is empty and multiple.\"\n        return len(self.path()) == 2 and self.path()[0] == self.path()[1]\n\ndef is_path_full_multiple(self):\n        \"Return True if the path is full and multiple.\"\n        return len(self.path()) == 3 and self.",
        ", self.genes[c:])\n\ndef cross(self, other):\n        \"Return a new individual crossing self and other.\"\n        c = random.randrange(len(self.genes))\n        return self.__class__(self.genes[c:], self.genes[c:])\n\ndef cross_random(self, other):\n        \"Return a new individual crossing self and other.\"\n        c = random.randrange(len(self.genes))\n        return self.__class__(self.genes[c:], self.genes[c:])\n\ndef cross_random_random(self, other):\n        \"Return a new individual crossing self and other.\"\n        c = random.randrange(len(self.genes))\n        return self.__class__(self.genes[c:], self.genes[c:])\n\ndef cross_random_random_random(self, other):\n        \"Return a new individual crossing self and other.\"\n        c = random.randrange(len(self.genes))\n        return self.__class__(self.genes[c:], self.genes[c:])\n\ndef cross_random_random_random(self, other):\n        \"Return a new individual crossing self and other.\"\n        c = random.randrange(len(self.genes))",
        ", b)\n        self.dict.update({a: {b: 0 for b in self.dict[a]}});\n\ndef make_directed(self):\n        \"Make a digraph into a directed graph by adding symmetric edges.\"\n        for a in self.dict.keys():\n            for (b, distance) in self.dict[a].items():\n                self.connect1(a, b, distance)\n        self.dict.update({a: {b: 0 for b in self.dict[a]}});\n\ndef make_directed_with_edges(self):\n        \"Make a digraph into a directed graph by adding symmetric edges and adding edges to the edges.\"\n        for a in self.dict.keys():\n            for (b, distance) in self.dict[a].items():\n                self.connect1(a, b, distance)\n                self.connect2(a, b, distance)\n        self.dict.update({a: {b: 0 for b in self.dict[a]}});\n\ndef make_directed_with_edges_and_edges(self):\n        \"Make a digraph into a directed graph by adding symmetric edges and adding edges to the edges and adding edges to the edges.\"\n        for a in self.dict.keys():\n            for (b, distance) in self",
        ".connect1(B, A, distance)\n\ndef connect1(self, A, B, distance):\n        \"\"\"Add a link from A and B of given distance, and also add the inverse\n        link if the graph is undirected.\"\"\"\n        self.add_edge(A, B, distance)\n        if not self.directed: self.add_edge(B, A, distance)\n\ndef connect2(self, A, B, distance=1):\n        \"\"\"Add a link from A and B of given distance, and also add the inverse\n        link if the graph is undirected.\"\"\"\n        self.add_edge(A, B, distance)\n        if not self.directed: self.add_edge(B, A, distance)\n\ndef connect3(self, A, B, distance=1):\n        \"\"\"Add a link from A and B of given distance, and also add the inverse\n        link if the graph is undirected.\"\"\"\n        self.add_edge(A, B, distance)\n        if not self.directed: self.add_edge(B, A, distance)\n\ndef connect4(self, A, B, distance=1):\n        \"\"\"Add a link from A and B of given distance, and also add the inverse\n        link if the graph is undirected.\"\"\"\n        self.add_edge(A",
        ", self.dict.setdefault(B,{})[A] = distance\n\ndef connect2(self, A, B, distance):\n        \"Add a link from A to B of given distance, in two directions only.\"\n        self.dict.setdefault(A,{})[B] = distance\n\ndef connect3(self, A, B, distance):\n        \"Add a link from A to B of given distance, in three directions only.\"\n        self.dict.setdefault(A,{})[B] = distance\n\ndef connect4(self, A, B, distance):\n        \"Add a link from A to B of given distance, in four directions only.\"\n        self.dict.setdefault(A,{})[B] = distance\n\ndef connect5(self, A, B, distance):\n        \"Add a link from A to B of given distance, in five directions only.\"\n        self.dict.setdefault(A,{})[B] = distance\n\ndef connect6(self, A, B, distance):\n        \"Add a link from A to B of given distance, in six directions only.\"\n        self.dict.setdefault(A,{})[B] = distance\n\ndef connect7(self, A, B, distance):\n        \"Add a link from A to B of given distance, in seven directions only",
        ".\n\ndef distance(s1, s2):\n        \"distance function is the distance between two states.\"\n        return math.sqrt(math.pow(s1.state - s2.state, 2) +\n                        math.pow(s1.state - s2.state, 3) +\n                        math.pow(s1.state - s2.state, 4))\n\ndef distance_to_goal(self, node):\n        \"distance_to_goal function is the distance between two states.\"\n        return math.sqrt(math.pow(node.state - self.goal, 2) +\n                        math.pow(node.state - self.goal, 3) +\n                        math.pow(node.state - self.goal, 4))\n\ndef distance_to_node(self, node):\n        \"distance_to_node function is the distance between two states.\"\n        return math.sqrt(math.pow(node.state - self.goal, 2) +\n                        math.pow(node.state - self.goal, 3) +\n                        math.pow(node.state - self.goal, 4))\n\ndef distance_to_goal_and_node(self, node):\n        \"distance_to_goal_and_node function is the distance between two states.\"\n        return math.sqrt(math.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        return new\n\ndef main():\n        \"Main function.\"\n        state = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 1",
        "\n\ndef random_boggle(self):\n        \"Generate a random boggle.\"\n        return [random.choice(self.board) for i in range(len(self.board))]\n\ndef boggle_neighbors(self, n):\n        \"Generate a random number of neighbors.\"\n        return [random.choice(self.neighbors) for i in range(n)]\n\ndef find(self, lo, hi, i, words, word):\n        \"Find the word in the board, and return the index.\"\n        if word in self.found:\n            return self.found[word]\n        self.found[word] = i\n        for j in range(len(words)):\n            if lo <= words[j] <= hi:\n                self.find(lo, hi, i, words[j:], word)\n        return i\n\ndef main():\n        \"Main function.\"\n        board = set_board()\n        print board\n        print board[0]\n        print board[1]\n        print board[2]\n        print board[3]\n        print board[4]\n        print board[5]\n        print board[6]\n        print board[7]\n        print board[8]\n        print board[9]\n        print board[10]\n        print board[11]\n",
        "])\n\ndef word_count(self):\n        \"The number of words in the sentence.\"\n        return len(self.words())\n\ndef word_score(self, word):\n        \"The score of the word.\"\n        return self.scores[len(word)]\n\ndef word_score_list(self, word):\n        \"The score of the word, in a list.\"\n        return [word_score(self, w) for w in self.words()]\n\ndef word_score_list_sorted(self, word):\n        \"The score of the word, in a list sorted by score.\"\n        return sorted([word_score(self, w) for w in self.words()])\n\ndef word_score_list_sorted_sorted(self, word):\n        \"The score of the word, in a list sorted by score, sorted by score.\"\n        return sorted([word_score(self, w) for w in self.words()], key=word_score_list_sorted)\n\ndef word_score_list_sorted_sorted_sorted(self, word):\n        \"The score of the word, in a list sorted by score, sorted by score, sorted by score.\"\n        return sorted([word_score(self, w) for w in self.words()], key=word_score_list_",
        "\n\ndef TraceAgentWithOutput(agent):\n    \"\"\"Wrap the agent's program to print its input and output. This will let\n    you see what the agent is doing in the environment. This will also\n    print the output of the program.\n    \"\"\"\n    old_program = agent.program\n    def new_program(percept):\n        action = old_program(percept)\n        print '%s perceives %s and does %s' % (agent, percept, action)\n        return action\n    agent.program = new_program\n    return agent\n\ndef TraceAgentWithOutputAndOutput(agent):\n    \"\"\"Wrap the agent's program to print its input and output. This will let\n    you see what the agent is doing in the environment. This will also\n    print the output of the program. This will also print the output of the\n    program.\n    \"\"\"\n    old_program = agent.program\n    def new_program(percept):\n        action = old_program(percept)\n        print '%s perceives %s and does %s' % (agent, percept, action)\n        return action\n    agent.program = new_program\n    return agent\n\ndef TraceAgentWithOutputAndOutputAndOutput(agent):\n    \"\"\"Wrap the agent's program to print its input and output. This will",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.GetOperation;\nimport com.hazelcast.",
        "\n        self.exogenous_change()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n        self.agents.pop()\n",
        "\n        self.step()\n\ndef main():\n    \"\"\"\n    Run the Environment.\n    \"\"\"\n    env = Environment()\n    env.run()\n\nif __name__ == '__main__':\n    main()\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.GetOperation;\nimport com.hazelcast.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.GetOperation;\nimport com.hazelcast.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input",
        "\n                for thing in self.things_near(agent.location)]\n\ndef percept_with_radius(self, agent, radius):\n        \"By default, agent perceives things within a specified radius.\"\n        return [self.thing_percept(thing, agent)\n                for thing in self.things_near(agent.location, radius)]\n\ndef percept_with_radius_and_location(self, agent, radius, location):\n        \"By default, agent perceives things within a specified radius and location.\"\n        return [self.thing_percept(thing, agent)\n                for thing in self.things_near(location, radius)]\n\ndef percept_with_location_and_radius(self, agent, location, radius):\n        \"By default, agent perceives things within a specified location and radius.\"\n        return [self.thing_percept(thing, agent)\n                for thing in self.things_near(location, radius)]\n\ndef percept_with_location_and_radius_and_location(self, agent, location, radius, location):\n        \"By default, agent perceives things within a specified location and radius and location.\"\n        return [self.thing_percept(thing, agent)\n                for thing in self.things_near(location",
        "\n        else:\n            thing.bump = False\n            thing.location = destination\n            for o in self.observers:\n                o.thing_moved(thing)\n\ndef move_to_next_location(self, thing, destination):\n        \"Move a thing to a new location.\"\n        thing.bump = self.some_things_at(destination, Obstacle)\n        if not thing.bump:\n            thing.location = destination\n            for o in self.observers:\n                o.thing_moved(thing)\n\ndef move_to_previous_location(self, thing, destination):\n        \"Move a thing to a new location.\"\n        thing.bump = self.some_things_at(destination, Obstacle)\n        if not thing.bump:\n            thing.location = destination\n            for o in self.observers:\n                o.thing_moved(thing)\n\ndef move_to_next_obstacle(self, thing, destination):\n        \"Move a thing to a new obstacle.\"\n        thing.bump = self.some_things_at(destination, Obstacle)\n        if not thing.bump:\n            thing.location = destination\n            for o in self.observers:\n                o.thing",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\",
        "\n\ndef main():\n    \"\"\"Main function.\"\"\"\n    parser = argparse.ArgumentParser(description='Parse a list of words.')\n    parser.add_argument('-w', '--words', help='List of words to parse.', nargs='+')\n    args = parser.parse_args()\n    return parse(args.words)\n\nif __name__ == '__main__':\n    main()\n",
        ".add_edge(edge)\n\ndef extend(self, edge):\n        \"Extend edge to chart, and see if it extends or predicts another edge.\"\n        start, end, lhs, found, expects = edge\n        if edge not in self.chart[end]:\n            self.chart[end].extend(edge)\n            if self.trace:\n                print '%10s: extended %s' % (caller(2), edge)\n            if not expects:\n                self.extender(edge)\n            else:\n                self.predictor(edge)\n\ndef predictor(self, edge):\n        \"Predict edge to chart, and see if it extends or predicts another edge.\"\n        start, end, lhs, found, expects = edge\n        if edge not in self.chart[end]:\n            self.chart[end].predict(edge)\n            if self.trace:\n                print '%10s: predicted %s' % (caller(2), edge)\n            if not expects:\n                self.extender(edge)\n            else:\n                self.predictor(edge)\n\ndef extender(self, edge):\n        \"Extend edge to chart, and see if it extends or predicts another edge.\"\n        start, end, lhs, found, expects = edge\n        if edge not in self.chart[",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;",
        ", rhs])\n        else:\n            self.add_edge([j, j, B, [], rhs])\n\ndef main():\n    parser = argparse.ArgumentParser(description='Predict the grammar of a grammar file.')\n    parser.add_argument('-f', '--file', required=True, help='The grammar file to predict.')\n    parser.add_argument('-p', '--predict', action='store_true', help='Predict the grammar.')\n    args = parser.parse_args()\n\n    if args.predict:\n        predictor = Predictor()\n        predictor.predict()\n    else:\n        grammar = Grammar()\n        grammar.load(args.file)\n        grammar.predict()\n\nif __name__ == '__main__':\n    main()\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;",
        ".render(request, 'settings.html', context)\n\ndef settings_post(request):\n    \"\"\"\n    Adds a ``SettingDict`` object for the ``Setting`` model to the context as\n    ``SETTINGS``. Automatically creates non-existent settings with an empty\n    string as the default value.\n    \"\"\"\n    settings = Setting.objects.all().as_dict(default='')\n    context = {\n        'SETTINGS': settings,\n    }\n    return HttpResponse(json.dumps(context), content_type='application/json')\n\ndef settings_delete(request, pk):\n    \"\"\"\n    Deletes a ``Setting`` model from the database.\n    \"\"\"\n    setting = Setting.objects.get(pk=pk)\n    setting.delete()\n    return HttpResponse(json.dumps({'success': True}), content_type='application/json')\n\ndef settings_get(request, pk):\n    \"\"\"\n    Returns a ``Setting`` model from the database.\n    \"\"\"\n    setting = Setting.objects.get(pk=pk)\n    return HttpResponse(json.dumps(setting), content_type='application/json')\n\ndef settings_put(request, pk):\n    \"\"\"\n    Updates a ``Setting`` model in the database.\n    \"\"\"\n    setting = Setting.objects.get(pk=",
        ", e)\n\ndef all_events(vars, bn, e):\n    \"\"\"Return all events in bn's joint distribution given e.\n    That is, bn's full joint distribution, projected to accord with e,\n    is the pointwise product of these factors for bn's variables.\"\"\"\n    return [e1 for e1 in bn.events if e1[var] in e]\n\ndef event_values(e1, vars):\n    \"\"\"Return the event values for e1 in vars.\"\"\"\n    return [e1[var] for e1 in vars]\n\ndef factor_values(f, vars):\n    \"\"\"Return the factor values for f in vars.\"\"\"\n    return [f.p(e1[var], e1) for e1 in vars]\n\nclass Factor(object):\n    \"\"\"A factor is a pair of variables and a pointwise product of factors.\"\"\"\n    def __init__(self, vars, cpt):\n        self.vars = vars\n        self.cpt = cpt\n\n    def __str__(self):\n        return \"Factor(%s, %s)\" % (self.vars, self.cpt)\n\n    def __repr__(self):\n        return \"Factor(%s, %s)\" % (self.vars, self.cpt)\n\n    def __eq__(self, other):",
        "\n\ndef pointwise_product(factors, bn):\n    \"Return a pointwise product of all factors.\"\n    result = []\n    for f in factors:\n        result.append(f.pointwise_product(bn))\n    return result\n\ndef pointwise_product_bn(factors, bn):\n    \"Return a pointwise product of all factors and bn.\"\n    result = []\n    for f in factors:\n        result.append(f.pointwise_product(bn))\n    return result\n\ndef pointwise_product_bn_var(factors, bn):\n    \"Return a pointwise product of all factors and bn and var.\"\n    result = []\n    for f in factors:\n        result.append(f.pointwise_product(bn, var))\n    return result\n\ndef pointwise_product_bn_var_bn(factors, bn):\n    \"Return a pointwise product of all factors and bn and var and bn.\"\n    result = []\n    for f in factors:\n        result.append(f.pointwise_product(bn, var, bn))\n    return result\n\ndef pointwise_product_bn_var_bn_var(factors, bn):\n    \"Return a pointwise product of all factors and bn and var and bn and var.\"\n    result = []\n    for f",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ")\n\n\ndef consistent_with_all(event, evidence):\n    \"Is event consistent with all the given evidence?\"\n    return all(consistent_with(event, evidence),\n               event.items())\n\n\ndef consistent_with_any(event, evidence):\n    \"Is event consistent with any of the given evidence?\"\n    return any(consistent_with(event, evidence),\n               event.items())\n\n\ndef consistent_with_none(event, evidence):\n    \"Is event consistent with none of the given evidence?\"\n    return none(consistent_with(event, evidence),\n               event.items())\n\n\ndef consistent_with_all_or_none(event, evidence):\n    \"Is event consistent with all or none of the given evidence?\"\n    return all(consistent_with_all(event, evidence),\n               event.items())\n\n\ndef consistent_with_any_or_none(event, evidence):\n    \"Is event consistent with any or none of the given evidence?\"\n    return any(consistent_with_any(event, evidence),\n               event.items())\n\n\ndef consistent_with_none_or_all(event, evidence):\n    \"Is event consistent with none or all of the given evidence?\"\n    return none(consistent_with_none(event, evidence),\n               event.items",
        "\n\ndef weighted_sample_from_bn(bn, e):\n    \"\"\"Sample an event from bn that's consistent with the evidence e;\n    return the event and its weight, the likelihood that the event\n    accords to the evidence.\"\"\"\n    w = 1\n    event = dict(e) # boldface x in Fig. 14.15\n    for node in bn.nodes:\n        Xi = node.variable\n        if Xi in e:\n            w *= node.p(e[Xi], event)\n        else:\n            event[Xi] = node.sample(event)\n    return event, w\n\ndef weighted_sample_from_bn_with_weights(bn, e):\n    \"\"\"Sample an event from bn that's consistent with the evidence e;\n    return the event and its weight, the likelihood that the event\n    accords to the evidence.\"\"\"\n    w = 1\n    event = dict(e) # boldface x in Fig. 14.15\n    for node in bn.nodes:\n        Xi = node.variable\n        if Xi in e:\n            w *= node.p(e[Xi], event)\n        else:\n            event[Xi] = node.sample(event)\n    return event, w\n\ndef weighted_sample_from_bn_",
        "\n                          if p > 0])\n\ndef show_prob(self, numfmt='%.3g'):\n        \"\"\"Show the probabilities rounded and sorted by key, for the\n        sake of portable doctests.\"\"\"\n        return ', '.join([('%s: ' + numfmt) % (v, p)\n                          for (v, p) in sorted(self.prob.items())])\n\ndef show_prob_approx(self, numfmt='%.3g'):\n        \"\"\"Show the probabilities rounded and sorted by key, for the\n        sake of portable doctests.\"\"\"\n        return ', '.join([('%s: ' + numfmt) % (v, p)\n                          for (v, p) in sorted(self.prob_approx.items())])\n\ndef show_prob_approx_approx(self, numfmt='%.3g'):\n        \"\"\"Show the probabilities rounded and sorted by key, for the\n        sake of portable doctests.\"\"\"\n        return ', '.join([('%s: ' + numfmt) % (v, p)\n                          for (v, p) in sorted(self.prob_approx_approx.items())])\n\ndef show_prob_approx_approx_approx(self, numfmt='%.3g'):\n        \"\"\"Show the probabilities rounded and sorted by key, for the\n        s",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ")\n\ndef pointwise_product_with_bn(self, other, bn):\n        \"Multiply two factors, combining their variables, and with a given bn.\"\n        vars = list(set(self.vars) | set(other.vars))\n        cpt = dict((event_values(e, vars), self.p(e) * other.p(e), bn)\n                   for e in all_events(vars, bn, {}))\n        return Factor(vars, cpt)\n\ndef pointwise_product_with_bn_with_bn(self, other, bn):\n        \"Multiply two factors, combining their variables, and with a given bn, and with a given bn.\"\n        vars = list(set(self.vars) | set(other.vars))\n        cpt = dict((event_values(e, vars), self.p(e) * other.p(e), bn)\n                   for e in all_events(vars, bn, {}))\n        return Factor(vars, cpt)\n\ndef pointwise_product_with_bn_with_bn_with_bn(self, other, bn):\n        \"Multiply two factors, combining their variables, and with a given bn, and with a given bn, and with a given bn.\"\n        vars = list(set(self.vars) | set(other.vars))",
        ")\n\ndef extend(e, var, val):\n        \"Extend var by val.\"\n        return e.extend(var, val)\n\ndef all_events(vars, bn, events):\n        \"Return all events in bn that are in events.\"\n        return [e for e in bn.events if e in events]\n\ndef event_values(e, vars):\n        \"Return the values of all events in vars.\"\n        return [e.values() for e in vars]\n\ndef extend(e, var, val):\n        \"Extend var by val.\"\n        return e.extend(var, val)\n\ndef factor_values(self, vars):\n        \"Return the values of all factors in vars.\"\n        return [self.p(e) for e in vars]\n\ndef factor_p(self, vars):\n        \"Return the probability of each factor in vars.\"\n        return [self.p(e) for e in vars]\n\ndef factor_p_values(self, vars):\n        \"Return the probability of each factor in vars.\"\n        return [self.p_values(e) for e in vars]\n\ndef factor_p_values_values(self, vars):\n        \"Return the probability of each factor in vars.\"\n        return [self.p_values_values(e) for",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\",
        "\ndef getJsonFromApiWithError(view, request):\n\t\"\"\"Return json from querying Web Api with error\n\n\t\tArgs:\n\t\t\tview: django view function.\n\t\t\trequest: http request object got from django\n\t\t\t\t\n\t\tReturns: json format dictionary\n\t\t\"\"\"\n\tjsonText = view(request)\n\tjsonText = json.loads(jsonText.content.decode('utf-8'))\n\treturn jsonText\n\ndef getJsonFromApiWithSuccess(view, request):\n\t\"\"\"Return json from querying Web Api with success\n\n\t\tArgs:\n\t\t\tview: django view function.\n\t\t\trequest: http request object got from django\n\t\t\t\t\n\t\tReturns: json format dictionary\n\t\t\"\"\"\n\tjsonText = view(request)\n\tjsonText = json.loads(jsonText.content.decode('utf-8'))\n\treturn jsonText\n\ndef getJsonFromApiWithErrorWithSuccess(view, request):\n\t\"\"\"Return json from querying Web Api with error and success\n\n\t\tArgs:\n\t\t\tview: django view function.\n\t\t\trequest: http request object got from django\n\t\t\t\t\n\t\tReturns: json format dictionary\n\t\t\"\"\"\n\tjsonText = view(request)\n\tjsonText = json.loads(jsonText.content.decode('utf-8'))\n\treturn jsonText\n\n",
        ", *args):\n    \"\"\"\n    put text on on screen\n    a tuple as first argument tells absolute position for the text\n    does not change TermCursor position\n    args = list of optional position, formatting tokens and strings\n    \"\"\"\n    cmd = [TermCursor.save, TermCursor.move(*xy), ''.join(args), TermCursor.restore]\n    write(''.join(cmd))\n\ndef write(s):\n    \"\"\"\n    write text to the terminal\n    s = string to write\n    \"\"\"\n    TermCursor.write(s)\n\ndef clear():\n    \"\"\"\n    clear the terminal\n    \"\"\"\n    TermCursor.clear()\n\ndef cursor_position():\n    \"\"\"\n    get current cursor position\n    \"\"\"\n    return TermCursor.position()\n\ndef cursor_position_xy():\n    \"\"\"\n    get current cursor position in absolute coordinates\n    \"\"\"\n    return TermCursor.position_xy()\n\ndef cursor_position_xy_xy():\n    \"\"\"\n    get current cursor position in absolute coordinates and absolute coordinates\n    \"\"\"\n    return TermCursor.position_xy_xy()\n\ndef cursor_position_xy_xy_xy():\n    \"\"\"\n    get current cursor position in absolute coordinates and absolute coordinates and absolute coordinates\n    \"\"\"\n    return TermCursor.position_xy_xy_xy()\n\n",
        "\n\ndef getuser(prompt=\"Username: \"):\n    \"\"\"\n    get user input without echo\n    \"\"\"\n\n    fd = sys.stdin.fileno()\n    old = termios.tcgetattr(fd)\n    new = termios.tcgetattr(fd)\n    new[3] &= ~termios.ECHO          # lflags\n    try:\n        termios.tcsetattr(fd, termios.TCSADRAIN, new)\n        username = raw_input(prompt)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old)\n    return username\n\ndef getuser_password(prompt=\"Password: \"):\n    \"\"\"\n    get user input without echo\n    \"\"\"\n\n    fd = sys.stdin.fileno()\n    old = termios.tcgetattr(fd)\n    new = termios.tcgetattr(fd)\n    new[3] &= ~termios.ECHO          # lflags\n    try:\n        termios.tcsetattr(fd, termios.TCSADRAIN, new)\n        password = raw_input(prompt)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old)\n    return password\n\ndef getuser",
        "\n\ndef getch_with_timeout(timeout):\n    \"\"\"\n    get character. waiting for key\n    \"\"\"\n    try:\n        termios.tcsetattr(_fd, termios.TCSANOW, _new_settings)\n        ch = sys.stdin.read(1)\n    except KeyboardInterrupt:\n        return None\n    except:\n        return None\n    if timeout is not None:\n        time.sleep(timeout)\n        return getch()\n    return ch\n\ndef getch_with_timeout_and_return(timeout, return_value):\n    \"\"\"\n    get character. waiting for key\n    \"\"\"\n    try:\n        termios.tcsetattr(_fd, termios.TCSANOW, _new_settings)\n        ch = sys.stdin.read(1)\n    except KeyboardInterrupt:\n        return return_value\n    except:\n        return return_value\n    if timeout is not None:\n        time.sleep(timeout)\n        return getch()\n    return ch\n\ndef getch_with_timeout_and_return_with_timeout(timeout, return_value, timeout):\n    \"\"\"\n    get character. waiting for key\n    \"\"\"\n    try:\n        termios.tcsetattr(_fd, termios.TCSANOW, _new_settings)\n",
        "\n\ndef formatException(self, exc_info):\n        \"\"\"tweaked from source of base\"\"\"\n        if exc_info is None:\n            return None\n        if isinstance(exc_info, Exception):\n            return exc_info.message\n        if isinstance(exc_info, (tuple, list)):\n            return ', '.join(map(str, exc_info))\n        return str(exc_info)\n\ndef formatTime(self, record, fmt):\n        \"\"\"tweaked from source of base\"\"\"\n        if record.asctime is None:\n            return None\n        if fmt == 'H':\n            return '%02d' % record.asctime.hour\n        elif fmt == 'M':\n            return '%02d' % record.asctime.minute\n        elif fmt == 'S':\n            return '%02d' % record.asctime.second\n        elif fmt == 'w':\n            return '%02d' % record.asctime.weekday\n        elif fmt == 'w':\n            return '%02d' % record.asctime.weekday\n        elif fmt == 'd':\n            return '%02d' % record.asctime.day\n        elif fmt == 'd':\n            return '%02d' % record.asctime.day\n        elif fmt == 'H':\n            return '%",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n    except ValueError:\n        return None\n\n\ndef getProcessOwnerStr(pid):\n    '''\n        getProcessOwnerStr - Returns the string of process owner, or uid if no mapping can be found, or \"unknown\" if neither could be determined.\n\n            @param pid <int> - A running process ID on this system\n\n            @return <str> - The string of process owner, or uid if no mapping can be found, or \"unknown\" if neither could be determined.\n    '''\n    try:\n        try:\n            pid = int(pid)\n        except ValueError as e:\n            sys.stderr.write('Expected an integer, got %s for pid.\\n' %(str(type(pid)),))\n            raise e\n            \n\n        owner = getProcessOwner(pid)\n        if not owner:\n            return \"unknown\"\n\n        return owner\n    except OSError:\n        return \"unknown\"\n    except IOError:\n        return \"unknown\"\n    except FileNotFoundError:\n        return \"unknown\"\n    except PermissionError:\n        return \"unknown\"\n    except ValueError:\n        return \"unknown\"\n\n\ndef getProcessCwd(pid):\n    '''\n        getProcessCwd - Returns the string of process cwd, or None if no mapping can be found, or \"unknown\" if neither could be determined.\n\n            @param",
        "\n\ndef scanProcessForCwd(pid, searchPortion, isExactMatch=False):\n    '''\n        scanProcessForCwd - Scans a process for a given search pattern.\n\n            @param pid <int> - The process id to scan\n            @param searchPortion <str> - Any portion of directory to search\n            @param isExactMatch <bool> Default False - If match should be exact, otherwise a partial match is performed.\n\n            @return - <dict> - A dictionary of pid -> cwdResults for each pid that matched the search pattern. For format of \"cwdResults\", @see scanProcessForCwd\n    '''\n\n    if isExactMatch:\n        return scanProcessForCwdExact(pid, searchPortion)\n    else:\n        return scanProcessForCwdPartial(pid, searchPortion)\n\ndef scanProcessForCwdExact(pid, searchPortion):\n    '''\n        scanProcessForCwdExact - Scans a process for a given search pattern.\n\n            @param pid <int> - The process id to scan\n            @param searchPortion <str> - Any portion of directory to search\n\n            @return - <dict> - A dictionary of pid -> cwdResults for each pid that matched the search pattern. For format of \"cwdResults\", @see scanProcessForCwd\n   ",
        "\n    except ValueError:\n        return None\n\n\ndef getProcessCommandLineStr(pid):\n    '''\n        getProcessCommandLineStr - Returns the command line string for a given process ID.\n\n            @param pid <int> - A running process ID on this system\n\n            @return <str> - The command line string for the given process ID.\n    '''\n    try:\n        try:\n            pid = int(pid)\n        except ValueError as e:\n            sys.stderr.write('Expected an integer, got %s for pid.\\n' %(str(type(pid)),))\n            raise e\n\n        with open('/proc/%d/cmdline' %(pid,), 'r') as f:\n            contents = f.read()\n\n        return contents.split('\\n')[0]\n    except OSError:\n        return None\n    except IOError:\n        return None\n    except FileNotFoundError:\n        return None\n    except PermissionError:\n        return None\n    except ValueError:\n        return None\n\n\ndef getProcessOwnerStr(pid):\n    '''\n        getProcessOwnerStr - Returns the process owner string for a given process ID.\n\n            @param pid <int> - A running process ID on this system\n\n            @return <str> - The process owner string for the given process ID.\n    '''\n    try:",
        "\n\ndef scanProcessForMapping(pid, searchPortion, isExactMatch=False, ignoreCase=False):\n    '''\n        scanProcessForMapping - Scans a process for a given mapping.\n\n            @param pid <int> - The process id to scan.\n            @param searchPortion <str> - A mapping for which to search, example: libc or python or libz. Give empty string to return all mappings.\n            @param isExactMatch <bool> Default False - If match should be exact, otherwise a partial match is performed.\n            @param ignoreCase <bool> Default False - If True, search will be performed case-insensitively\n\n            @return - <dict> - A dictionary of pid -> mappingResults for each pid that matched the search pattern. For format of \"mappingResults\", @see scanProcessForMapping\n    '''\n    try:\n        process = os.popen('ps -ef | grep -v ' + searchPortion + ' | grep -v ' + pid)\n        mappingResults = process.read().splitlines()\n        process.close()\n    except OSError:\n        return None\n\n    if isExactMatch:\n        return mappingResults[0]\n    else:\n        return mappingResults[1]\n\ndef getAllRunningPids():\n    '''\n        getAllRunningPids - Returns a list of",
        "\n    except ValueError:\n        return None\n\n\ndef getProcessCommandLineStr(pid):\n    '''\n        getProcessCommandLineStr - Returns the command line string for a given pid\n\n            @param pid <int> - The passed pid (as an integer)\n\n        @return -  The command line string for the given pid\n    '''\n    try:\n        pid = int(pid)\n    except ValueError as e:\n        sys.stderr.write('Expected an integer, got %s for pid.\\n' %(str(type(pid)),))\n        raise e\n\n    prefixDir = \"/proc/%d/cmdline\" % (pid,)\n\n    processCmdline = os.readlink(prefixDir + '/' + pid)\n\n    return processCmdline\n\n\ndef getProcessOwnerStr(pid):\n    '''\n        getProcessOwnerStr - Returns the process owner string for a given pid\n\n            @param pid <int> - The passed pid (as an integer)\n\n        @return -  The process owner string for the given pid\n    '''\n    try:\n        pid = int(pid)\n    except ValueError as e:\n        sys.stderr.write('Expected an integer, got %s for pid.\\n' %(str(type(pid)),))\n        raise e\n\n    prefixDir = \"/proc/%d/owner\"",
        "\n\ndef scanProcessForOpenFile(pid, searchPortion, isExactMatch=True, ignoreCase=False):\n    '''\n        scanProcessForOpenFile - Scans a process for a given filename\n\n            @param pid <int> - Process ID\n            @param searchPortion <str> - Filename to check\n            @param isExactMatch <bool> Default True - If match should be exact, otherwise a partial match is performed.\n            @param ignoreCase <bool> Default False - If True, search will be performed case-insensitively\n\n            @return - <dict> - A dictionary of pid -> mappingResults for each pid that matched the search pattern. For format of \"mappingResults\", @see scanProcessForOpenFile\n    '''\n    try:\n        process = os.popen('ps -ef | grep -v ' + searchPortion)\n        process.close()\n    except OSError:\n        return None\n\n    if isExactMatch:\n        return process.read().split()\n    else:\n        return process.read().split(searchPortion)\n\ndef getAllRunningPids():\n    '''\n        getAllRunningPids - Returns a list of all running processes\n\n            @return - <list> - A list of all running processes\n    '''\n    return os.popen('ps -ef | grep -v').read",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef receive(self):\n        \"\"\"Receive TCP command from hub and return response.\"\"\"\n        # use lock to make TCP send/receive thread safe\n        with self._lock:\n            try:\n                return self._socket.recv(1024)\n            except socket.error as error:\n                _LOGGER.error(\"Error receiving command: %s\", error)\n                return \"\"\n\ndef connect(self):\n        \"\"\"Connect to hub and return response.\"\"\"\n        # use lock to make TCP send/receive thread safe\n        with self._lock:\n            try:\n                self._socket.connect(self._hub_address)\n                return \"\"\n            except socket.error as error:\n                _LOGGER.error(\"Error connecting to hub: %s\", error)\n                return \"\"\n\ndef disconnect(self):\n        \"\"\"Disconnect from hub and return response.\"\"\"\n        # use lock to make TCP send/receive thread safe\n        with self._lock:\n            try:\n                self._socket.close()\n                return \"\"\n            except socket.error as error:\n                _LOGGER.error(\"Error disconnecting from hub: %s\", error)\n                return \"\"\n\ndef get_status(self):\n        \"\"\"Return status of hub.\"\"\"\n        # use lock to make TCP send/receive thread safe\n        with self._lock:\n            try:\n",
        "\n\n\ndef send(self, message):\n        \"\"\"Send TCP message.\"\"\"\n        try:\n            self._socket.send(message)\n        except socket.timeout as error:\n            # Something is wrong, assume it's offline temporarily\n            _LOGGER.error(\"Error sending: %s\", error)\n            # self._socket.close()\n            return \"\"\n\n\ndef send_command(self, command):\n        \"\"\"Send command to the server.\"\"\"\n        try:\n            self._socket.send(command)\n        except socket.timeout as error:\n            # Something is wrong, assume it's offline temporarily\n            _LOGGER.error(\"Error sending: %s\", error)\n            # self._socket.close()\n            return \"\"\n\n\ndef send_command_with_timeout(self, command, timeout):\n        \"\"\"Send command to the server, with a timeout.\"\"\"\n        try:\n            self._socket.send(command)\n        except socket.timeout as error:\n            # Something is wrong, assume it's offline temporarily\n            _LOGGER.error(\"Error sending: %s\", error)\n            # self._socket.close()\n            return \"\"\n\n\ndef send_command_with_timeout_with_timeout(self, command, timeout, timeout_with_timeout):\n        \"\"\"Send command to the server, with a timeout,",
        "\n\n\ndef set_data(self, data):\n        \"\"\"Set new light data.\"\"\"\n        response = self.send_command(SET_LIGHTS_COMMAND, data)\n        _LOGGER.debug(\"set_data response: %s\", repr(response))\n        if not response:\n            _LOGGER.debug(\"Empty response: %s\", response)\n            return\n        response = response.strip()\n        # Check string before splitting (avoid IndexError if malformed)\n        if not (response.startswith(\"GLB\") and response.endswith(\";\")):\n            _LOGGER.debug(\"Invalid response: %s\", repr(response))\n            return\n\n        # deconstruct response string into light data. Example data:\n        # GLB 143E,1,1,25,255,255,255,0,0;287B,1,1,22,255,255,255,0,0;\\r\\n\n        response = response[4:-3]  # strip start (GLB) and end (;\\r\\n)\n        light_strings = response.split(';')\n        for light_string in light_strings:\n            values = light_string.split(',')\n            try:\n                light_data_by_id[values[0]] = [int(values[2]), int",
        "\n\n\nclass Bulb(object):\n    \"\"\"Representation of a single bulb.\"\"\"\n\n    def __init__(self, hass, zid, online, red, green, blue, level):\n        \"\"\"Initialize the bulb.\"\"\"\n        self._hass = hass\n        self._zid = zid\n        self._online = online\n        self._red = red\n        self._green = green\n        self._blue = blue\n        self._level = level\n\n    @property\n    def zid(self):\n        \"\"\"Return the unique ID of the bulb.\"\"\"\n        return self._zid\n\n    @property\n    def online(self):\n        \"\"\"Return true if the bulb is online.\"\"\"\n        return self._online\n\n    @property\n    def red(self):\n        \"\"\"Return the red color of the bulb.\"\"\"\n        return self._red\n\n    @property\n    def green(self):\n        \"\"\"Return the green color of the bulb.\"\"\"\n        return self._green\n\n    @property\n    def blue(self):\n        \"\"\"Return the blue color of the bulb.\"\"\"\n        return self._blue\n\n    @property\n    def level(self):\n        \"\"\"Return the level of the bulb.\"\"\"\n        return self._level\n\n    @property\n    def name(self",
        "\n\ndef set_color_temperature(self, color_temperature):\n        \"\"\"Set color temperature of bulb.\"\"\"\n        command = \"C {},,,,{},\\r\\n\".format(self._zid, color_temperature)\n        response = self._hub.send_command(command)\n        _LOGGER.debug(\"Set color temperature %s: %s\", repr(command), response)\n        return response\n\ndef set_color_temperature_max(self, color_temperature_max):\n        \"\"\"Set color temperature max of bulb.\"\"\"\n        command = \"C {},,,,{},\\r\\n\".format(self._zid, color_temperature_max)\n        response = self._hub.send_command(command)\n        _LOGGER.debug(\"Set color temperature max %s: %s\", repr(command), response)\n        return response\n\ndef set_color_temperature_min(self, color_temperature_min):\n        \"\"\"Set color temperature min of bulb.\"\"\"\n        command = \"C {},,,,{},\\r\\n\".format(self._zid, color_temperature_min)\n        response = self._hub.send_command(command)\n        _LOGGER.debug(\"Set color temperature min %s: %s\", repr(command), response)\n        return response\n\ndef set_color_temperature_step",
        "\n\ndef set_color(self, red, green, blue, brightness):\n        \"\"\"Set color of bulb.\"\"\"\n        command = \"C {},{},{},{},{},\\r\\n\".format(self._zid, red, green, blue,\n                                                 brightness)\n        response = self._hub.send_command(command)\n        _LOGGER.debug(\"Set color %s: %s\", repr(command), response)\n        return response\n\ndef set_brightness(self, brightness):\n        \"\"\"Set brightness of bulb.\"\"\"\n        command = \"B {},{},\\r\\n\".format(self._zid, brightness)\n        response = self._hub.send_command(command)\n        _LOGGER.debug(\"Set brightness %s: %s\", repr(command), response)\n        return response\n\ndef set_hue(self, hue):\n        \"\"\"Set hue of bulb.\"\"\"\n        command = \"H {},{},\\r\\n\".format(self._zid, hue)\n        response = self._hub.send_command(command)\n        _LOGGER.debug(\"Set hue %s: %s\", repr(command), response)\n        return response\n\ndef set_saturation(self, saturation):\n        \"\"\"Set saturation of bulb.\"\"\"\n        command = \"S {},{},\\r\\n",
        "\n            return\n        for light in bulbs:\n            if light.state == 'on':\n                self._hub.set_light(light.id, True)\n            elif light.state == 'off':\n                self._hub.set_light(light.id, False)\n            else:\n                _LOGGER.debug(\"%s is not on or off, send command failed\", self.zid)\n                self._online = False\n\n        self._hub.update()\n\n        if self._online:\n            self.update()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n        self._hub.update_state()\n\n       ",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;",
        "\n\ndef readcsv(filepath):\n    \"\"\" read file as is\"\"\"\n    with open(filepath, 'rt') as f:\n        lines = f.readlines()\n    return lines\n\ndef readcsv_with_header(filepath):\n    \"\"\" read file as is\"\"\"\n    with open(filepath, 'rt') as f:\n        lines = f.readlines()\n    return lines[:-1]\n\ndef readcsv_with_header_and_header(filepath):\n    \"\"\" read file as is\"\"\"\n    with open(filepath, 'rt') as f:\n        lines = f.readlines()\n    return lines[:-1] + lines[-1:]\n\ndef readcsv_with_header_and_header_and_header(filepath):\n    \"\"\" read file as is\"\"\"\n    with open(filepath, 'rt') as f:\n        lines = f.readlines()\n    return lines[:-1] + lines[-1:] + lines[-2:]\n\ndef readcsv_with_header_and_header_and_header(filepath):\n    \"\"\" read file as is\"\"\"\n    with open(filepath, 'rt') as f:\n        lines = f.readlines()\n    return lines[:-1] + lines[-1:] + lines[-2:] + lines[-3:]\n\ndef readcsv_with",
        "\n\ndef _create_directories(paths):\n    \"\"\"\n    Create directories for the given paths.\n    @param {[String]} A list of file paths specifying the directories we've created\n        during run. Will all be created.\n    @return {None}\n    \"\"\"\n    print('Creating directories')\n    for path in paths:\n        os.makedirs(path)\n\ndef _create_files(paths):\n    \"\"\"\n    Create files for the given paths.\n    @param {[String]} A list of file paths specifying the files we've created\n        during run. Will all be created.\n    @return {None}\n    \"\"\"\n    print('Creating files')\n    for path in paths:\n        with open(path, 'w') as f:\n            f.write('This is a test file')\n\ndef _create_files_with_content(paths):\n    \"\"\"\n    Create files for the given paths, with content.\n    @param {[String]} A list of file paths specifying the files we've created\n        during run. Will all be created.\n    @return {None}\n    \"\"\"\n    print('Creating files with content')\n    for path in paths:\n        with open(path, 'w') as f:\n            f.write('This is a test file with content')\n\ndef",
        "\n\ndef _get_index_file_path(location):\n    \"\"\"\n    Get the full path (location plus filename) of the index file for the given\n    location.\n    @param {String} location - The current directory of the crawl.\n    @return {String} The full path (location plus filename) of the index\n        file for the given location.\n    \"\"\"\n    return location + '/' + INDEX_FILE_NAME\n\ndef _get_thumbnail_src_from_file(\n        root_dir, image_file, force_no_processing=False):\n    \"\"\"\n    Get the thumbnail src for the given image file.\n    @param {String} root_dir - The root directory of the entire crawl. Used to\n        ascertain whether the given location is the top level.\n    @param {String} image_file - The current directory of the crawl. The image\n        file will be created here.\n    @param {Boolean=False} force_no_processing - If True, do not attempt to\n        actually process thumbnails, PIL images or anything. Simply index\n        <img> tags with original file src attributes.\n    @return {String} The full path (location plus filename) of the thumbnail\n        src for the given image file.\n    \"\"\"\n    # Get the full path (location plus filename) of the thumbnail",
        "\n\ndef _create_index_file(root_dir, here, image_files, dirs, force_no_processing=False):\n    \"\"\"\n    Create an HTML file in the given directory, with the given image files and\n    directories.\n    @param {String} root_dir - The top level directory to crawl down from. In\n        normal usage, this will be '.'.\n    @param {String} here - The directory to crawl down from. In normal usage, this\n        will be '.'.\n    @param {Array<String>} image_files - The image files to index.\n    @param {Array<String>} dirs - The directories to index.\n    @param {Boolean=False} force_no_processing - If True, do not attempt to\n        actually process thumbnails, PIL images or anything. Simply index\n        <img> tags with original file src attributes.\n    @return {String} The full path to the created file.\n    \"\"\"\n    # Create the index file\n    index_file = os.path.join(root_dir, here + '.html')\n    # Create the index HTML file\n    with open(index_file, 'w') as f:\n        f.write(\n            '<html><head><title>Image Index</title></head><body>'\n            '<h1>Image Index</h1",
        "\n\ndef _get_image_from_file_with_quality(dir_path, image_file, quality):\n    \"\"\"\n    Get an instance of PIL.Image from the given file.\n    @param {String} dir_path - The directory containing the image file\n    @param {String} image_file - The filename of the image file within dir_path\n    @param {int} quality - The quality of the image file\n    @return {PIL.Image} An instance of the image file as a PIL Image, or None\n        if the functionality is not available. This could be because PIL is not\n        present, or because it can't process the given file type.\n    \"\"\"\n    # Save ourselves the effort if PIL is not present, and return None now\n    if not PIL_ENABLED:\n        return None\n    # Put together full path\n    path = os.path.join(dir_path, image_file)\n    # Try to read the image\n    img = None\n    try:\n        img = Image.open(path, quality=quality)\n    except IOError as exptn:\n        print('Error loading image file %s: %s' % (path, exptn))\n    # Return image or None\n    return img\n\ndef _get_image_from_file_with_quality_and_quality",
        "\n\ndef _get_src_from_file(file_path, fallback_image_file):\n    \"\"\"\n    Get base-64 encoded data as a string for the given file. Fallback to return\n    fallback_image_file if cannot get the image data or file_path is None\n    @param {String} file_path - The path to the file to get src data for\n    @param {String} fallback_image_file - The filename of the image file,\n        to be used when image data capture fails\n    @return {String} The base-64 encoded image data string, or path to the file\n        itself if not supported\n    \"\"\"\n    # If the file is None, then we can't process, so we should return the\n    # path to the file itself\n    if file_path is None:\n        return fallback_image_file\n    # If we have an actual Image, great - put together the base64 image string\n    try:\n        with open(file_path, 'rb') as f:\n            return _get_src_from_image(f.read(), fallback_image_file)\n    except IOError as exptn:\n        print('IOError while saving image bytes: %s' % exptn)\n        return fallback_image_file\n\ndef _get_src_from_url(url,",
        "\n\ndef _get_thumbnail_image_from_file_with_quality(dir_path, image_file, quality):\n    \"\"\"\n    Get a PIL.Image from the given image file which has been scaled down to\n    THUMBNAIL_WIDTH wide.\n    @param {String} dir_path - The directory containing the image file\n    @param {String} image_file - The filename of the image file within dir_path\n    @param {int} quality - The quality of the image to be resized\n    @return {PIL.Image} An instance of the thumbnail as a PIL Image, or None\n        if the functionality is not available. See _get_image_from_file for\n        details.\n    \"\"\"\n    # Get image\n    img = _get_image_from_file(dir_path, image_file)\n    # If it's not supported, exit now\n    if img is None:\n        return None\n    if img.format.lower() == 'gif':\n        return None\n    # Get image dimensions\n    img_width, img_height = img.size\n    # We need to perform a resize - first, work out the scale ratio to take the\n    # image width to THUMBNAIL_WIDTH (THUMBNAIL_WIDTH:img_width ratio)\n    scale_ratio = THUM",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n    return wrap\n\ndef static_method(**kwargs):\n    \"\"\" USE carefully ^^ \"\"\"\n    def wrap(fn):\n        fn.func_globals['static_method'] = fn\n        fn.__dict__.update(kwargs)\n        return fn\n    return wrap\n\ndef static_method_with_kwargs(**kwargs):\n    \"\"\" USE carefully ^^ \"\"\"\n    def wrap(fn):\n        fn.func_globals['static_method_with_kwargs'] = fn\n        fn.__dict__.update(kwargs)\n        return fn\n    return wrap\n\ndef static_method_with_kwargs_with_kwargs(**kwargs):\n    \"\"\" USE carefully ^^ \"\"\"\n    def wrap(fn):\n        fn.func_globals['static_method_with_kwargs_with_kwargs'] = fn\n        fn.__dict__.update(kwargs)\n        return fn\n    return wrap\n\ndef static_method_with_kwargs_with_kwargs_with_kwargs(**kwargs):\n    \"\"\" USE carefully ^^ \"\"\"\n    def wrap(fn):\n        fn.func_globals['static_method_with_kwargs_with_kwargs_with_kwargs'] = fn\n        fn.__dict__.update(kwargs)\n        return fn\n    return wrap\n\ndef static_method_with_kwargs_with_kwargs_",
        ", noise\n\n\ndef rand_blend_mask_2d(shape, rand=rand.uniform(-10, 10), **kwargs):\n    \"\"\" random blending masks \"\"\"\n    # batch, channel = shape[0], shape[3]\n    z = rand(shape[0])  # seed\n    noise = snoise2dz((shape[1], shape[2]), z, **kwargs)\n\n    return noise, noise\n\n\ndef rand_blend_mask_3d(shape, rand=rand.uniform(-10, 10), **kwargs):\n    \"\"\" random blending masks \"\"\"\n    # batch, channel = shape[0], shape[3]\n    z = rand(shape[0])  # seed\n    noise = snoise2dz((shape[1], shape[2]), z, **kwargs)\n\n    return noise, noise, noise\n\n\ndef rand_blend_mask_4d(shape, rand=rand.uniform(-10, 10), **kwargs):\n    \"\"\" random blending masks \"\"\"\n    # batch, channel = shape[0], shape[3]\n    z = rand(shape[0])  # seed\n    noise = snoise2dz((shape[1], shape[2]), z, **kwargs)\n\n    return noise, noise, noise, noise\n\n\n",
        "\n\ndef snoise3d(size, z=0.0, scale=0.05, octaves=1, persistence=0.25, lacunarity=2.0):\n    \"\"\"\n    z value as like a seed\n    \"\"\"\n    import noise\n    data = np.empty(size, dtype='float32')\n    for y in range(size[0]):\n        for x in range(size[1]):\n            v = noise.snoise3(x * scale, y * scale, z,\n                              octaves=octaves, persistence=persistence, lacunarity=lacunarity)\n            data[x, y] = v\n    data = data * 0.5 + 0.5\n    if __debug__:\n        assert data.min() >= 0. and data.max() <= 1.0\n    return data\n\ndef snoise4d(size, z=0.0, scale=0.05, octaves=1, persistence=0.25, lacunarity=2.0):\n    \"\"\"\n    z value as like a seed\n    \"\"\"\n    import noise\n    data = np.empty(size, dtype='float32')\n    for y in range(size[0]):\n        for x in range(size[1]):\n            v = noise.",
        "\n\ndef to_permutation(matches):\n    \"\"\"Converts a permutation into a permutation matrix.\n\n    `matches` is a dictionary whose keys are vertices and whose values are\n    partners. For each vertex ``u`` and ``v``, entry (``u``, ``v``) in the\n    returned matrix will be a ``1`` if and only if ``matches[u] == v``.\n\n    Pre-condition: `matches` must be a permutation on an initial subset of the\n    natural numbers.\n\n    Returns a permutation matrix as a square NumPy array.\n\n    \"\"\"\n    n = len(matches)\n    P = np.zeros((n, n))\n    # This is a cleverer way of doing\n    #\n    #     for (u, v) in matches.items():\n    #         P[u, v] = 1\n    #\n    P[list(zip(*(matches.items())))] = 1\n    return P\n\ndef to_permutation_matrix_from_list(matches):\n    \"\"\"Converts a permutation into a permutation matrix.\n\n    `matches` is a dictionary whose keys are vertices and whose values are\n    partners. For each vertex ``u`` and ``v``, entry (``u``, ``v``) in the\n    returned matrix will be a ``1",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef to_pattern_matrix_with_zeros(D):\n    \"\"\"Returns the Boolean matrix in the same shape as `D` with ones exactly\n    where there are nonzero entries in `D`.\n\n    `D` must be a NumPy array.\n\n    \"\"\"\n    result = np.zeros_like(D)\n    # This is a cleverer way of doing\n    #\n    #     for (u, v) in zip(*(D.nonzero())):\n    #         result[u, v] = 1\n    #\n    result[D.nonzero()] = 1\n    return result\n\ndef to_pattern_matrix_with_zeros_and_ones(D):\n    \"\"\"Returns the Boolean matrix in the same shape as `D` with ones exactly\n    where there are nonzero entries in `D`.\n\n    `D` must be a NumPy array.\n\n    \"\"\"\n    result = np.zeros_like(D)\n    # This is a cleverer way of doing\n    #\n    #     for (u, v) in zip(*(D.nonzero())):\n    #         result[u, v] = 1\n    #\n    result[D.nonzero()] = 1\n    result[D.nonzero()] = 1\n    return result\n\ndef to_pattern_matrix",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ".format(filename))\n\ndef fail(msg):\n    print >> sys.stderr, msg\n    sys.exit(1)\n\ndef main():\n    \"\"\"Main function.\"\"\"\n    parser = argparse.ArgumentParser(description='Generate a new version of the project.')\n    parser.add_argument('-f', '--file', required=True, help='The path to the project file.')\n    parser.add_argument('-v', '--version', required=True, help='The version of the project.')\n    args = parser.parse_args()\n\n    version = get_version(args.file, args.version)\n    print >> sys.stderr, 'Version: {}'.format(version)\n\n    with open(args.file, 'w') as f:\n        f.write('# This file was generated by {}.\\n'.format(__file__))\n        f.write('# This file is automatically generated by {}.\\n'.format(__file__))\n        f.write('# This file is automatically generated by {}.\\n'.format(__file__))\n        f.write('# This file is automatically generated by {}.\\n'.format(__file__))\n        f.write('# This file is automatically generated by {}.\\n'.format(__file__))\n        f.write('# This file is",
        "\n\ndef ok(message=None, exit_status=None):\n    \"\"\"Prints the specified message and exits the program with the specified\n    exit status.\n\n    \"\"\"\n    print('OK:', message, file=sys.stderr)\n    sys.exit(exit_status or 0)\n\ndef warn(message=None, exit_status=None):\n    \"\"\"Prints the specified message and exits the program with the specified\n    exit status.\n\n    \"\"\"\n    print('Warning:', message, file=sys.stderr)\n    sys.exit(exit_status or 1)\n\ndef error(message=None, exit_status=None):\n    \"\"\"Prints the specified message and exits the program with the specified\n    exit status.\n\n    \"\"\"\n    print('Error:', message, file=sys.stderr)\n    sys.exit(exit_status or 2)\n\ndef fatal(message=None, exit_status=None):\n    \"\"\"Prints the specified message and exits the program with the specified\n    exit status.\n\n    \"\"\"\n    print('Fatal:', message, file=sys.stderr)\n    sys.exit(exit_status or 3)\n\ndef exit(message=None, exit_status=None):\n    \"\"\"Prints the specified message and exits the program with the specified\n    exit status.\n\n    \"\"\"\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        self.env.load_all_templates()\n        self.env.load_all_data()\n        self.env.load_all_variables()\n        self.env.load_all_functions()\n        self.env.load_all_functions_with_globals()\n        self.env.load_all_functions_with_globals_and_data()\n        self.env.load_all_functions_with_globals_and_data_and_variables()\n        self.env.load_all_functions_with_globals_and_data_and_variables_and_functions()\n        self.env.load_all_functions_with_globals_and_data_and_variables_and_functions_with_globals()\n        self.env.load_all_functions_with_globals_and_data_and_variables_and_functions_with_globals()\n        self.env.load_all_functions_with_globals_and_data_and_variables_and_functions_with_globals()\n        self.env.load_all_functions_with_globals_and_data_and_variables_and_functions_with_globals()\n        self.env.load_all_functions_with_globals_and_data_and_variables_and_functions_with_globals()\n        self",
        "\n\ndef render_template(self, template, **data):\n        \"\"\"Render data with template, return html unicodes.\n        parameters\n          template   str  the template's filename\n          data       dict the data to render\n        \"\"\"\n        # make a copy and update the copy\n        dct = self.global_data.copy()\n        dct.update(data)\n\n        try:\n            html = self.env.get_template(template).render(**dct)\n        except TemplateNotFound:\n            raise JinjaTemplateNotFound\n        return html\n\ndef render_template_file(self, template, filename):\n        \"\"\"Render data with template, return html unicodes.\n        parameters\n          template   str  the template's filename\n          filename   str  the template's filename\n        \"\"\"\n        # make a copy and update the copy\n        dct = self.global_data.copy()\n        dct.update({'filename': filename})\n\n        try:\n            html = self.env.get_template(template).render(**dct)\n        except TemplateNotFound:\n            raise JinjaTemplateNotFound\n        return html\n\ndef render_template_file_with_data(self, template, filename, data):\n        \"\"\"Render data with template, return html unicodes.\n        parameters\n          template   str ",
        ")\n\ndef render_to_string(self, path, template, **data):\n        \"\"\"Render data with template and then write to path\"\"\"\n        html = self.render(template, **data)\n        with open(path, 'w') as f:\n            f.write(html.encode(charset))\n\ndef render_to_file(self, path, template, **data):\n        \"\"\"Render data with template and then write to path\"\"\"\n        with open(path, 'w') as f:\n            f.write(self.render(template, **data).encode(charset))\n\ndef render_to_file_string(self, path, template, **data):\n        \"\"\"Render data with template and then write to path\"\"\"\n        with open(path, 'w') as f:\n            f.write(self.render(template, **data).encode(charset))\n\ndef render_to_file_file(self, path, template, **data):\n        \"\"\"Render data with template and then write to path\"\"\"\n        with open(path, 'w') as f:\n            f.write(self.render(template, **data).encode(charset))\n\ndef render_to_file_file_string(self, path, template, **data):\n        \"\"\"Render data with template and then write to path\"\"\"\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_dataframe_from_request(self, request):\n        \"\"\"\n        Get the DataFrame for this view.\n        Defaults to using `self.dataframe`.\n\n        This method should always be used rather than accessing `self.dataframe`\n        directly, as `self.dataframe` gets evaluated only once, and those results\n        are cached for all subsequent requests.\n\n        You may want to override this if you need to provide different\n        dataframes depending on the incoming request.\n        \"\"\"\n        assert self.dataframe is not None, (\n            \"'%s' should either include a `dataframe` attribute, \"\n            \"or override the `get_dataframe()` method.\"\n            % self.class__.__name__\n        )\n\n        dataframe = self.dataframe\n        return dataframe\n\ndef get_dataframe_from_response(self, response):\n        \"\"\"\n        Get the DataFrame for this view.\n        Defaults to using `self.dataframe`.\n\n        This method should always be used rather than accessing `self.dataframe`\n        directly, as `self.dataframe` gets evaluated only once, and those results\n        are cached for all subsequent requests.\n\n        You may want to override this if you need to provide different\n        dataframes depending on the incoming request.\n        \"\"\"\n        assert self.dataframe is not None, (\n            \"'%s' should",
        ".to_frame()\n\ndef index_columns(self, dataframe):\n        \"\"\"\n        Indexes the columns based on the request parameters.\n        \"\"\"\n        return dataframe.loc[self.kwargs[self.lookup_url_kwarg]].to_frame().columns\n\ndef index_columns_by_name(self, dataframe):\n        \"\"\"\n        Indexes the columns based on the request parameters.\n        \"\"\"\n        return dataframe.loc[self.kwargs[self.lookup_url_kwarg]].to_frame().columns.name\n\ndef index_columns_by_name_by_name(self, dataframe):\n        \"\"\"\n        Indexes the columns based on the request parameters.\n        \"\"\"\n        return dataframe.loc[self.kwargs[self.lookup_url_kwarg]].to_frame().columns.name.name\n\ndef index_columns_by_name_by_name_by_name(self, dataframe):\n        \"\"\"\n        Indexes the columns based on the request parameters.\n        \"\"\"\n        return dataframe.loc[self.kwargs[self.lookup_url_kwarg]].to_frame().columns.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name",
        "\n\ndef get_queryset(self):\n        \"\"\"\n        Returns the queryset the view is displaying.\n\n        You may want to override this if you need to provide non-standard\n        queryset lookups.  Eg if objects are referenced using multiple\n        keyword arguments in the url conf.\n        \"\"\"\n        return self.get_object().objects.all()\n\ndef get_dataframe(self):\n        \"\"\"\n        Returns a dataframe of the view's data.\n\n        You may want to override this if you need to provide non-standard\n        queryset lookups.  Eg if objects are referenced using multiple\n        keyword arguments in the url conf.\n        \"\"\"\n        return self.get_object().objects.all().values_list(self.lookup_field, flat=True)\n\ndef get_object_permissions(self, request, obj):\n        \"\"\"\n        Checks the permissions for the given object.\n\n        You may want to override this if you need to provide non-standard\n        queryset lookups.  Eg if objects are referenced using multiple\n        keyword arguments in the url conf.\n        \"\"\"\n        return obj.has_perm(self.permission_name)\n\ndef get_object_or_404(self, obj):\n        \"\"\"\n        Returns the object or a 404 if the object does not exist.\n\n        You may want to override this",
        "\n\ndef get_paginator(self):\n    \"\"\"\n    Returns the paginator instance associated with the view, or `None`.\n    \"\"\"\n    return paginator()\n\ndef get_paginator_class(self):\n    \"\"\"\n    Returns the paginator class associated with the view, or `None`.\n    \"\"\"\n    return getattr(self, '_paginator_class', None)\n\ndef get_paginator_kwargs(self):\n    \"\"\"\n    Returns the paginator kwargs associated with the view, or `None`.\n    \"\"\"\n    return getattr(self, '_paginator_kwargs', None)\n\ndef get_paginator_page(self):\n    \"\"\"\n    Returns the paginator page associated with the view, or `None`.\n    \"\"\"\n    return getattr(self, '_paginator_page', None)\n\ndef get_paginator_page_kwargs(self):\n    \"\"\"\n    Returns the paginator page kwargs associated with the view, or `None`.\n    \"\"\"\n    return getattr(self, '_paginator_page_kwargs', None)\n\ndef get_paginator_page_num(self):\n    \"\"\"\n    Returns the paginator page number associated with the view, or `None`.\n    \"\"\"\n    return getattr(self, '_paginator_page_num', None)\n\ndef get_paginator_page_num_kwargs",
        "\n\nclass BaseView(object):\n    \"\"\"\n    Base class for all views.\n    \"\"\"\n    def get_queryset(self):\n        \"\"\"\n        Return a queryset for this view.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_context_data(self, **kwargs):\n        \"\"\"\n        Return context data for this view.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_context_data_for_instance(self, instance, **kwargs):\n        \"\"\"\n        Return context data for this view for an instance.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_context_data_for_request(self, request, **kwargs):\n        \"\"\"\n        Return context data for this view for a request.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_context_data_for_template(self, template_name, **kwargs):\n        \"\"\"\n        Return context data for this view for a template.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_context_data_for_template_name(self, template_name, **kwargs):\n        \"\"\"\n        Return context data for this view for a template.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_context_data_for_request_method(self, request_method, **kwargs):\n        \"\"\"\n        Return context data for this view for",
        "\n        return config\n\ndef exists(self):\n        \"\"\"check if a file exists\"\"\"\n\n        if exists(self.filepath):\n            return True\n        else:\n            return False\n\ndef charset():\n        \"\"\"get the charset\"\"\"\n\n        return \"utf-8\"\n\ndef write(self, config):\n        \"\"\"write config to file\"\"\"\n\n        if exists(self.filepath):\n            with open(self.filepath, \"w\") as f:\n                f.write(toml.dumps(config))\n        else:\n            with open(self.filepath, \"w\") as f:\n                f.write(toml.dumps(config))\n\ndef write_config(self, config):\n        \"\"\"write config to file\"\"\"\n\n        if exists(self.filepath):\n            with open(self.filepath, \"w\") as f:\n                f.write(toml.dumps(config))\n        else:\n            with open(self.filepath, \"w\") as f:\n                f.write(toml.dumps(config))\n\ndef write_config_file(self, config):\n        \"\"\"write config to file\"\"\"\n\n        if exists(self.filepath):\n            with open(self.filepath, \"w\") as f:\n                f.write(toml.dum",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_files_mtime(self, path):\n        \"\"\"get source file's update time\"\"\"\n\n        if not exists(path):\n            logger.error(SourceFileNotFound.__doc__)\n            sys.exit(SourceFileNotFound.exit_code)\n\n        return stat(path).st_mtime\n\ndef get_files_mtime_by_name(self, name):\n        \"\"\"get source file's update time by name\"\"\"\n\n        if not exists(name):\n            logger.error(SourceFileNotFound.__doc__)\n            sys.exit(SourceFileNotFound.exit_code)\n\n        return stat(join(Post.src_dir, name)).st_mtime\n\ndef get_files_mtime_by_path(self, path):\n        \"\"\"get source file's update time by path\"\"\"\n\n        if not exists(path):\n            logger.error(SourceFileNotFound.__doc__)\n            sys.exit(SourceFileNotFound.exit_code)\n\n        return stat(join(Post.src_dir, path)).st_mtime\n\ndef get_files_mtime_by_name_and_path(self, name, path):\n        \"\"\"get source file's update time by name and path\"\"\"\n\n        if not exists(name):\n            logger.error(SourceFileNotFound.__doc__)",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_block_context(context):\n    '''\n    Get the block_context from the current context\n    '''\n    return context.render_context[BLOCK_CONTEXT_KEY]\n\ndef get_block_context_for_request(request):\n    '''\n    Get the block_context from the current context for the given request\n    '''\n    return get_block_context(request.context)\n\ndef get_block_context_for_template(template):\n    '''\n    Get the block_context from the current context for the given template\n    '''\n    return get_block_context(template.context)\n\ndef get_block_context_for_request_context(request_context):\n    '''\n    Get the block_context from the current context for the given request context\n    '''\n    return get_block_context(request_context.context)\n\ndef get_block_context_for_template_context(template_context):\n    '''\n    Get the block_context from the current context for the given template context\n    '''\n    return get_block_context(template_context.context)\n\ndef get_block_context_for_template_name(template_name):\n    '''\n    Get the block_context from the current context for the given template name\n    '''\n    return get_",
        "\n\ndef resolve_blocks(template_name, context):\n    '''\n    Resolve blocks from a template.\n    '''\n    template = Template(template_name)\n    return template.render(context)\n\ndef get_widget_context(context, alias):\n    '''\n    Get the widget context for a given widget.\n    '''\n    return context.render_context[WIDGET_CONTEXT_KEY][alias]\n\ndef get_block_context(context, alias):\n    '''\n    Get the block context for a given block.\n    '''\n    return context.render_context[BLOCK_CONTEXT_KEY][alias]\n\ndef get_block_context_for_alias(context, alias):\n    '''\n    Get the block context for a given block.\n    '''\n    return get_block_context(context, alias)[BLOCK_CONTEXT_KEY]\n\ndef get_block_context_for_alias_and_template(context, alias, template_name):\n    '''\n    Get the block context for a given block.\n    '''\n    return get_block_context(context, alias)[BLOCK_CONTEXT_KEY][template_name]\n\ndef get_block_context_for_alias_and_template_and_context(context, alias, template_name, context):\n    '''\n    Get the block",
        "\n\ndef auto_field(field):\n    '''Return a list of field names for the provided field.'''\n    # Auto-detect\n    info = {\n        'field': field.field.__class__.__name__,\n        'name': field.name,\n    }\n\n    return [\n        fmt.format(**info)\n        for fmt in (\n            '{field}_{widget}_{name}',\n            '{field}_{name}',\n            '{widget}_{name}',\n            '{field}_{widget}',\n            '{name}',\n            '{widget}',\n            '{field}',\n        )\n    ]\n\ndef auto_widget_field(field):\n    '''Return a list of widget names for the provided field.'''\n    # Auto-detect\n    info = {\n        'widget': field.field.widget.__class__.__name__,\n        'field': field.field.__class__.__name__,\n        'name': field.name,\n    }\n\n    return [\n        fmt.format(**info)\n        for fmt in (\n            '{field}_{widget}_{name}',\n            '{field}_{name}',\n            '{widget}_{name}',\n            '{field}_{widget}',\n            '{name}',\n            '{widget}',\n            '{field}',\n        )\n    ]\n\ndef auto_field_widget(field):\n    '''",
        "\n\ndef block_context(context, block_name, **kwargs):\n    '''\n    Create a block context for a given block name.\n\n    {% block_context _myblock foo=bar %}\n\n    If passed a list of block names, will use the first that matches:\n\n    {% block_context list_of_block_names .... %}\n    '''\n    try:\n        block_context = context.render_context[BLOCK_CONTEXT_KEY]\n    except KeyError:\n        block_context = BlockContext()\n\n    if not isinstance(block_name, (str, unicode)):\n        block_name = block_name.strip()\n\n    if not isinstance(block_name, (list, tuple)):\n        block_name = [block_name]\n\n    for block in block_name:\n        block = block_context.get_block(block)\n        if block:\n            break\n    else:\n        return ''\n\n    with context.push(kwargs):\n        return block.render(context)\n\ndef block_context_for_template(context, template_name, **kwargs):\n    '''\n    Create a block context for a given template name.\n\n    {% block_context_for_template 'mytemplate' foo=bar %}\n\n    If",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\n    return message.read\n\n\ndef mark_read_all(user, message):\n    \"\"\"\n    Mark all messages as read for user.\n    Returns True if all messages were `unread` and thus actually marked as `read` or False in case\n    all messages are already `read` or all messages do not exist at all.\n\n    :param user: user instance for the recipient\n    :param message: a Message instance to mark as read\n    \"\"\"\n    BackendClass = stored_messages_settings.STORAGE_BACKEND\n    backend = BackendClass()\n    backend.inbox_delete(user, message)\n    backend.inbox_delete_all(user, message)\n    return message.read\n\n\ndef mark_read_all_all(user, message):\n    \"\"\"\n    Mark all messages as read for all users.\n    Returns True if all messages were `unread` and thus actually marked as `read` or False in case\n    all messages are already `read` or all messages do not exist at all.\n\n    :param user: user instance for the recipient\n    :param message: a Message instance to mark as read\n    \"\"\"\n    BackendClass = stored_messages_settings.STORAGE_BACKEND\n    backend = BackendClass()\n    backend.inbox_delete_all(user, message)\n    backend",
        ".mark_all_read(user)\n\n\ndef mark_all_read_by_user(user):\n    \"\"\"\n    Mark all message instances for a user as read by a specific user.\n\n    :param user: user instance for the recipient\n    \"\"\"\n    BackendClass = stored_messages_settings.STORAGE_BACKEND\n    backend = BackendClass()\n    backend.inbox_purge_by_user(user)\n\n\ndef mark_all_read_by_id(id):\n    \"\"\"\n    Mark all message instances for a user as read by a specific message id.\n\n    :param id: message id for the recipient\n    \"\"\"\n    BackendClass = stored_messages_settings.STORAGE_BACKEND\n    backend = BackendClass()\n    backend.inbox_purge_by_id(id)\n\n\ndef mark_all_read_by_id_by_user(id, user):\n    \"\"\"\n    Mark all message instances for a user as read by a specific message id by a specific user.\n\n    :param id: message id for the recipient\n    :param user: user instance for the recipient\n    \"\"\"\n    BackendClass = stored_messages_settings.STORAGE_BACKEND\n    backend = BackendClass()\n    backend.inbox_purge_by_id_by_user(id, user)",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.",
        "\n\n\nclass StorageMixin(object):\n    \"\"\"\n    Mixin for storage backends\n    \"\"\"\n    def _get(self, *args, **kwargs):\n        \"\"\"\n        Retrieve unread messages for current user, both from the inbox and\n        from other storages\n        \"\"\"\n        messages, all_retrieved = super(StorageMixin, self)._get(*args, **kwargs)\n        if self.user.is_authenticated():\n            inbox_messages = self.backend.inbox_list(self.user)\n        else:\n            inbox_messages = []\n\n        return messages + inbox_messages, all_retrieved\n\n    def _delete(self, *args, **kwargs):\n        \"\"\"\n        Delete unread messages for current user, both from the inbox and\n        from other storages\n        \"\"\"\n        messages, all_retrieved = super(StorageMixin, self)._delete(*args, **kwargs)\n        if self.user.is_authenticated():\n            inbox_messages = self.backend.inbox_list(self.user)\n        else:\n            inbox_messages = []\n\n        return messages + inbox_messages, all_retrieved\n\n    def _delete_all(self, *args, **kwargs):\n        \"\"\"\n        Delete all unread messages for current user, both from the inbox and\n        from",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n    def _store_many(self, messages, response, *args, **kwargs):\n        \"\"\"\n        persistent messages are already in the database inside the 'archive',\n        so we can say they're already \"stored\".\n        Here we put them in the inbox, or remove from the inbox in case the\n        messages were iterated.\n\n        messages contains only new msgs if self.used==True\n        else contains both new and unread messages\n        \"\"\"\n        contrib_messages = []\n        if self.user.is_authenticated():\n            if not messages:\n                # erase inbox\n                self.backend.inbox_purge(self.user)\n            else:\n                for m in messages:\n                    try:\n                        self.backend.inbox_store([self.user], m)\n                    except MessageTypeNotSupported:\n                        contrib_messages.append(m)\n\n        super(StorageMixin, self)._store_many(contrib_messages, response, *args, **kwargs)\n\n    def _store_many_many(self, messages, response, *args, **kwargs):\n        \"\"\"\n        persistent messages are already in the database inside the 'archive',\n        so we can say they're already \"stored\".\n        Here we put them in the inbox, or remove from the inbox in case the\n        messages were iterated.\n\n        messages",
        "\n\ndef _prepare_messages(self, messages):\n        \"\"\"\n        Like the base class method, prepares a list of messages for storage\n        but avoid to do this for `models.Message` instances.\n        \"\"\"\n        for message in messages:\n            if not self.backend.can_handle(message):\n                message._prepare()\n\ndef _prepare_messages_for_bulk(self, messages):\n        \"\"\"\n        Like the base class method, prepares a list of messages for storage\n        but avoid to do this for `models.Message` instances.\n        \"\"\"\n        for message in messages:\n            if not self.backend.can_handle(message):\n                message._prepare()\n\ndef _prepare_messages_for_bulk_for_bulk(self, messages):\n        \"\"\"\n        Like the base class method, prepares a list of messages for storage\n        but avoid to do this for `models.Message` instances.\n        \"\"\"\n        for message in messages:\n            if not self.backend.can_handle(message):\n                message._prepare()\n\ndef _prepare_messages_for_bulk_for_bulk(self, messages):\n        \"\"\"\n        Like the base class method, prepares a list of messages for storage\n        but avoid to do this for `models.Message` instances.\n        \"\"\"\n        for message in messages",
        "(options)\n\n\ndef ver_check():\n    \"\"\"Check for version of jocker.\"\"\"\n    try:\n        import jocker_lgr\n        return jocker_lgr.__version__\n    except ImportError:\n        return 'unknown'\n\n\ndef jocker_run(options):\n    \"\"\"Run jocker.\"\"\"\n    jocker_lgr.debug(options)\n    jocker_lgr.info(options)\n    jocker_lgr.warn(options)\n    jocker_lgr.error(options)\n    jocker_lgr.critical(options)\n    jocker_lgr.debug(options)\n    jocker_lgr.info(options)\n    jocker_lgr.warn(options)\n    jocker_lgr.error(options)\n    jocker_lgr.critical(options)\n    jocker_lgr.debug(options)\n    jocker_lgr.info(options)\n    jocker_lgr.warn(options)\n    jocker_lgr.error(options)\n    jocker_lgr.critical(options)\n    jocker_lgr.debug(options)\n    jocker_lgr.info(options)\n    jocker_lgr.warn(options)\n    jocker_lgr.error(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef configure_custom_factory(self, config):\n        \"\"\"Configure an object with a user-supplied factory.\"\"\"\n        c = config.pop('()')\n        if not hasattr(c, '__call__') and \\\n                hasattr(types, 'ClassType') and isinstance(c, types.ClassType):\n            c = self.resolve(c)\n        props = config.pop('.', None)\n        # Check for valid identifiers\n        kwargs = dict((k, config[k]) for k in config if valid_ident(k))\n        result = c(**kwargs)\n        if props:\n            for name, value in props.items():\n                setattr(result, name, value)\n        return result\n\ndef configure_custom_factory_with_args(self, config):\n        \"\"\"Configure an object with a user-supplied factory.\"\"\"\n        c = config.pop('()')\n        if not hasattr(c, '__call__') and \\\n                hasattr(types, 'ClassType') and isinstance(c, types.ClassType):\n            c = self.resolve(c)\n        props = config.pop('.', None)\n        # Check for valid identifiers\n        kwargs = dict((k, config[k]) for k in config if valid_ident(k))\n        result = c(**kwargs)\n        if props:",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n    except yaml.parser.YAMLError as ex:\n        jocker_lgr.error('invalid yaml file: {0}'.format(ex))\n        raise RuntimeError('invalid yaml file')\n\n\ndef _import_config_file(config_file):\n    \"\"\"returns a configuration object\n\n    :param string config_file: path to config file\n    \"\"\"\n    # get config file path\n    jocker_lgr.debug('config file is: {0}'.format(config_file))\n    # append to path for importing\n    try:\n        jocker_lgr.debug('importing config...')\n        with open(config_file, 'r') as c:\n            return yaml.safe_load(c.read())\n    except IOError as ex:\n        jocker_lgr.error(str(ex))\n        raise RuntimeError('cannot access config file')\n    except yaml.parser.ParserError as ex:\n        jocker_lgr.error('invalid yaml file: {0}'.format(ex))\n        raise RuntimeError('invalid yaml file')\n\n\ndef _import_config_file_with_defaults(config_file):\n    \"\"\"returns a configuration object\n\n    :param string config_file: path to config file\n    \"\"\"\n    # get config file path\n    jocker_lgr",
        "\n    if outputfile is None:\n        outputfile = varsfile\n    if configfile is None:\n        configfile = varsfile\n    j = Jocker(varsfile, templatefile, outputfile, configfile, dryrun,\n               build, push)\n    formatted_text = j.generate()\n    if dryrun:\n        g = j.dryrun(formatted_text)\n    if build or push:\n        j.build_image()\n    if push:\n        j.push_image()\n    if verbose:\n        print(formatted_text)\n    return g\n\n\ndef _set_global_verbosity_level(verbose):\n    \"\"\"set the global verbosity level for the Jocker class\"\"\"\n    global _verbosity\n    _verbosity = verbose\n\n\nclass Jocker(object):\n    \"\"\"Jocker class\n\n    This class is used to generate Dockerfiles and images.\n    It is used to generate Dockerfiles and images.\n    It is used to generate Dockerfiles and images.\n    It is used to generate Dockerfiles and images.\n    It is used to generate Dockerfiles and images.\n    It is used to generate Dockerfiles and images.\n    It is used to generate Dockerfiles and images.\n    It is used to generate Dockerfiles and images.\n    It is used to generate Dockerfiles and images",
        "\n\ndef _parse_dumb_push_output_with_error(self, string):\n        \"\"\"since the push process outputs a single unicode string consisting of\n        multiple JSON formatted \"status\" lines, we need to parse it so that it\n        can be read as multiple strings, and raise an exception if it can't\n        parse.\n\n        This will receive the string as an input, count curly braces and ignore\n        any newlines. When the curly braces stack is 0, it will append the\n        entire string it has read up until then to a list and so forth.\n\n        :param string: the string to parse\n        :rtype: list of JSON's\n        \"\"\"\n        stack = 0\n        tmp_json = ''\n        for char in string:\n            if not char == '\\r' and not char == '\\n':\n                tmp_json += char\n            if char == '{':\n                stack += 1\n            elif char == '}':\n                stack -= 1\n            if stack == 0:\n                if not len(tmp_json) == 0:\n                    raise Exception(\"Error parsing push output\")\n                tmp_json = ''\n        return json_list = []\n        return json_list\n\ndef _parse_dumb_push_output_with_error_with_error(self, string):\n        \"\"\"since the push process",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "\n\ndef is_ipv4(ip):\n    \"\"\"Return true if the IP address is an IPv4 address.\"\"\"\n    return is_dot(ip) and ip.startswith('0.0.0.0')\n\ndef is_ipv6(ip):\n    \"\"\"Return true if the IP address is an IPv6 address.\"\"\"\n    return is_dot(ip) and ip.startswith('::1')\n\ndef is_ipv6_v4(ip):\n    \"\"\"Return true if the IP address is an IPv6 address.\"\"\"\n    return is_dot(ip) and ip.startswith('::1.0.0.0')\n\ndef is_ipv6_v6(ip):\n    \"\"\"Return true if the IP address is an IPv6 address.\"\"\"\n    return is_dot(ip) and ip.startswith('::1.0.0.1')\n\ndef is_ipv6_v4_v6(ip):\n    \"\"\"Return true if the IP address is an IPv6 address.\"\"\"\n    return is_dot(ip) and ip.startswith('::1.0.0.0.0.0.0')\n\ndef is_ipv6_v6_v4(ip):\n    \"\"\"Return true if the IP address is an IPv6 address.\"\"\"\n    return is_dot(ip) and ip.",
        "\n\ndef is_ipv4(ip):\n    \"\"\"Return true if the IP address is a valid IPv4 address.\"\"\"\n    try:\n        ip = str(ip)\n        if len(ip) != 4:\n            return False\n        ip = int(ip, 16)\n    except (TypeError, ValueError):\n        return False\n    return True\n\ndef is_ipv6(ip):\n    \"\"\"Return true if the IP address is a valid IPv6 address.\"\"\"\n    try:\n        ip = str(ip)\n        if len(ip) != 16:\n            return False\n        ip = int(ip, 16)\n    except (TypeError, ValueError):\n        return False\n    return True\n\ndef is_ipv6_prefix(ip):\n    \"\"\"Return true if the IP address is a valid IPv6 prefix.\"\"\"\n    try:\n        ip = str(ip)\n        if len(ip) != 16:\n            return False\n        ip = int(ip, 16)\n    except (TypeError, ValueError):\n        return False\n    return True\n\ndef is_ipv4_prefix(ip):\n    \"\"\"Return true if the IP address is a valid IPv4 prefix.\"\"\"\n    try:\n        ip = str(ip)\n        if len(ip) != 4:\n            return False\n        ip = int(ip, 4",
        "\n\ndef is_ipv4(ip):\n    \"\"\"Return true if the IP address is a valid IPv4 address.\"\"\"\n    try:\n        ip = int(str(ip), 16)\n    except (TypeError, ValueError):\n        return False\n    return ip >= 0 and ip <= 255\n\n\ndef is_ipv6(ip):\n    \"\"\"Return true if the IP address is a valid IPv6 address.\"\"\"\n    try:\n        ip = int(str(ip), 16)\n    except (TypeError, ValueError):\n        return False\n    return ip >= 0 and ip <= 65535\n\n\ndef is_ipv6_or_ipv4(ip):\n    \"\"\"Return true if the IP address is a valid IPv6 address or IPv4 address.\"\"\"\n    try:\n        ip = int(str(ip), 16)\n    except (TypeError, ValueError):\n        return False\n    return ip >= 0 and ip <= 65535 or is_ipv4(ip)\n\n\ndef is_ipv6_or_ipv4_or_ipv6(ip):\n    \"\"\"Return true if the IP address is a valid IPv6 address or IPv4 address or IPv6 address.\"\"\"\n    try:\n        ip = int(str(ip), 16)\n    except (TypeError, ValueError):\n        return False\n    return ip >= 0 and ip <= 65535 or is_ipv4",
        "\n    return True\n\ndef is_ip(ip):\n    \"\"\"Return true if the IP address is an IP address.\"\"\"\n    try:\n        ip = int(str(ip))\n    except ValueError:\n        return False\n    return True\n\ndef is_ipv6(ip):\n    \"\"\"Return true if the IP address is an IPv6 address.\"\"\"\n    try:\n        ip = int(str(ip))\n    except ValueError:\n        return False\n    return True\n\ndef is_ipv4(ip):\n    \"\"\"Return true if the IP address is an IPv4 address.\"\"\"\n    try:\n        ip = int(str(ip))\n    except ValueError:\n        return False\n    return True\n\ndef is_ipv6_ipv4(ip):\n    \"\"\"Return true if the IP address is an IPv6 IPv4 address.\"\"\"\n    try:\n        ip = int(str(ip))\n    except ValueError:\n        return False\n    return True\n\ndef is_ipv6_ipv6(ip):\n    \"\"\"Return true if the IP address is an IPv6 IPv6 address.\"\"\"\n    try:\n        ip = int(str(ip))\n    except ValueError:\n        return False\n    return True\n\ndef is_ipv4_ipv6(ip):\n    \"\"\"Return true if the IP address is an IPv4 IPv",
        "\n\n\ndef _check_netmask(netmask, notation):\n    \"\"\"Function internally used to check if the given netmask\n    is of the specified notation.\"\"\"\n    # Convert to decimal, and check if it's in the list of valid netmasks.\n    _NETMASK_CHECK_FUNCT = {\n        NM_DOT: _dot_to_dec,\n        NM_HEX: _hex_to_dec,\n        NM_BIN: _bin_to_dec,\n        NM_OCT: _oct_to_dec,\n        NM_DEC: _dec_to_dec_long}\n    try:\n        dec = _NETMASK_CHECK_FUNCT[notation](netmask, check=True)\n    except ValueError:\n        return False\n    if dec in _NETMASKS_VALUES:\n        return True\n    return False\n\n\ndef _check_netmask_long(netmask, notation):\n    \"\"\"Function internally used to check if the given netmask\n    is of the specified notation.\"\"\"\n    # Convert to decimal, and check if it's in the list of valid netmasks.\n    _NETMASK_CHECK_FUNCT = {\n        NM_DOT: _dot_to_dec_long,\n        NM_HEX: _hex_to_dec_long",
        "\n\ndef is_ip_nm(nm):\n    \"\"\"Return true if the netmask is in IP notatation.\"\"\"\n    try:\n        ip = int(str(nm))\n    except ValueError:\n        return False\n    if ip > 255 or ip < 0:\n        return False\n    return True\n\ndef is_ip_v4_nm(nm):\n    \"\"\"Return true if the netmask is in IP v4 notatation.\"\"\"\n    try:\n        ip = int(str(nm))\n    except ValueError:\n        return False\n    if ip > 255 or ip < 0:\n        return False\n    return True\n\ndef is_ip_v6_nm(nm):\n    \"\"\"Return true if the netmask is in IP v6 notatation.\"\"\"\n    try:\n        ip = int(str(nm))\n    except ValueError:\n        return False\n    if ip > 255 or ip < 0:\n        return False\n    return True\n\ndef is_ip_v6_v4_nm(nm):\n    \"\"\"Return true if the netmask is in IP v6 v4 notatation.\"\"\"\n    try:\n        ip = int(str(nm))\n    except ValueError:\n        return False\n    if ip > 255 or ip < 0:\n        return False\n    return True\n\ndef is_ip_",
        "\ndef _dot_to_dec(dot, check=False):\n    \"\"\"Convert a dotted string to a decimal number.\"\"\"\n    if check:\n        try:\n            dot = int(dot, 16)\n        except ValueError:\n            return 0\n    return dot\n\ndef _netmasks_values():\n    \"\"\"Return a list of all the netmasks in the system.\"\"\"\n    return [\n        _NETMASKS_VALUES[i] for i in range(0, 32)\n    ]\n\ndef _netmask_to_dot(netmask):\n    \"\"\"Convert a netmask to a dotted string.\"\"\"\n    return '.'.join([str(i) for i in netmask])\n\ndef _netmask_to_hex(netmask):\n    \"\"\"Convert a netmask to a hex string.\"\"\"\n    return hex(netmask)\n\ndef _netmask_to_oct(netmask):\n    \"\"\"Convert a netmask to a octal string.\"\"\"\n    return oct(netmask)\n\ndef _netmask_to_hex_oct(netmask):\n    \"\"\"Convert a netmask to a hex octal string.\"\"\"\n    return hex(netmask)\n\ndef _netmask_to_oct_hex(netmask):\n    \"\"\"Convert a netmask to a octal hex string.\"\"\"\n    return oct(netmask)\n\ndef _netmask",
        "\n\ndef _dec_to_dot(dec, check=True):\n    \"\"\"Decimal conversion to dotted decimal notation.\"\"\"\n    if check and not is_dec(dec):\n        raise ValueError('_dec_to_dot: invalid decimal: \"%s\"' % dec)\n    octets = str(dec).split('.')\n    return '.'.join(octets[:-1])\n\ndef is_dot(ip):\n    \"\"\"Check if the given IP is a dotted decimal notation.\"\"\"\n    return ip.startswith('.')\n\ndef is_dec(ip):\n    \"\"\"Check if the given IP is a decimal notation.\"\"\"\n    return ip.startswith('0x')\n\ndef is_ip(ip):\n    \"\"\"Check if the given IP is an IP address.\"\"\"\n    return ip.isdigit() or ip.isalpha() or ip.isupper() or ip.islower()\n\ndef is_valid_ip(ip):\n    \"\"\"Check if the given IP is valid.\"\"\"\n    return is_ip(ip) or is_dot(ip)\n\ndef is_valid_ip_v4(ip):\n    \"\"\"Check if the given IP is valid.\"\"\"\n    return is_valid_ip(ip) and is_ip(ip[0:4])\n\ndef is_valid_ip_v6(ip):\n   ",
        ".\n\ndef _dot_to_dec(ip):\n    \"\"\"Dot to decimal notation conversion.\"\"\"\n    return int(ip, 10)\n\ndef _hex_to_dec(ip):\n    \"\"\"Hex to decimal notation conversion.\"\"\"\n    return int(ip, 16)\n\ndef _dec_to_hex(ip):\n    \"\"\"Decimal to hexadecimal notation conversion.\"\"\"\n    return '%02x' % (ip,)\n\ndef _hex_to_dec(ip):\n    \"\"\"Hex to decimal notation conversion.\"\"\"\n    return '%02x' % (ip,)\n\ndef _dec_to_oct(ip):\n    \"\"\"Decimal to octal notation conversion.\"\"\"\n    return '%02o' % (ip,)\n\ndef _hex_to_oct(ip):\n    \"\"\"Hex to octal notation conversion.\"\"\"\n    return '%02o' % (ip,)\n\ndef _dec_to_bin(ip):\n    \"\"\"Decimal to binary notation conversion.\"\"\"\n    return '%02x' % (ip,)\n\ndef _hex_to_bin(ip):\n    \"\"\"Hex to binary notation conversion.\"\"\"\n    return '%02x' % (ip,)\n\ndef _dec_to_bin(ip):\n    \"\"\"Decimal to binary notation conversion.\"\"\"\n    return '%02x' % (ip,)\n\ndef _dec",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ")\n\ndef _dec_to_oct(ip, check=True):\n    \"\"\"Decimal to octal conversion.\"\"\"\n    if check and not is_dec(ip):\n        raise ValueError('_dec_to_oct: invalid IP: \"%s\"' % ip)\n    if isinstance(ip, int):\n        ip = dec(ip)\n    return int(str(ip), 8)\n\ndef is_oct(ip):\n    \"\"\"Check if IP is an octal.\"\"\"\n    return ip.isdigit()\n\ndef is_dec(ip):\n    \"\"\"Check if IP is a decimal.\"\"\"\n    return ip.isdigit()\n\ndef is_hex(ip):\n    \"\"\"Check if IP is a hex.\"\"\"\n    return ip.isdigit()\n\ndef is_hex_digit(ip):\n    \"\"\"Check if IP is a hex digit.\"\"\"\n    return is_hex(ip) and ip.isdigit()\n\ndef is_hex_digit_or_oct(ip):\n    \"\"\"Check if IP is a hex digit or octal.\"\"\"\n    return is_hex(ip) or is_oct(ip)\n\ndef is_hex_digit_or_dec(ip):\n    \"\"\"Check if IP is a hex digit or decimal.\"\"\"\n    return is_hex(ip) or is_dec(ip)\n\ndef is",
        ")\n\ndef _dec_to_bin(ip, check=True):\n    \"\"\"Decimal to binary conversion.\"\"\"\n    if check and not is_dec(ip):\n        raise ValueError('_dec_to_bin: invalid IP: \"%s\"' % ip)\n    if isinstance(ip, int):\n        ip = str(ip)\n    return int(ip, 2)\n\ndef _hex_to_bin(ip, check=True):\n    \"\"\"Hexadecimal to binary conversion.\"\"\"\n    if check and not is_hex(ip):\n        raise ValueError('_hex_to_bin: invalid IP: \"%s\"' % ip)\n    if isinstance(ip, int):\n        ip = str(ip)\n    return int(ip, 16)\n\ndef _hex_to_dec(ip, check=True):\n    \"\"\"Hexadecimal to decimal conversion.\"\"\"\n    if check and not is_hex(ip):\n        raise ValueError('_hex_to_dec: invalid IP: \"%s\"' % ip)\n    if isinstance(ip, int):\n        ip = str(ip)\n    return int(ip, 16)\n\ndef _hex_to_bin_dec(ip, check=True):\n    \"\"\"Hexadecimal to binary conversion.\"\"\"\n    if check and not is_hex(ip):\n        raise ValueError('_hex_",
        "\n\ndef _BITS_TO_BYTES():\n    \"\"\"Generate a table to convert a whole byte to binary.\n    This code was taken from the Python Cookbook, 2nd edition - O'Reilly.\"\"\"\n    the_table = 256*[None]\n    for n in range(256):\n        l = n\n        bits = 8*[None]\n        for i in range(7):\n            bits[i] = '01'[n & 1]\n            n >>= 1\n        the_table[l] = ''.join(bits)\n    return the_table\n\ndef _BYTES_TO_HEX():\n    \"\"\"Generate a table to convert a whole byte to hexadecimal.\n    This code was taken from the Python Cookbook, 2nd edition - O'Reilly.\"\"\"\n    the_table = 256*[None]\n    for n in range(256):\n        l = n\n        bits = 8*[None]\n        for i in range(7):\n            bits[i] = '0' + '01'[n & 1]\n            n >>= 1\n        the_table[l] = ''.join(bits)\n    return the_table\n\ndef _HEX_TO_BYTES():\n    \"\"\"Generate a table to convert a whole byte to binary.\n    This code was taken from the Python Cookbook,",
        "\n\ndef _dec_to_bin_long(ip):\n    \"\"\"Decimal to binary conversion.\"\"\"\n    bits = []\n    while ip:\n        bits.append(_BYTES_TO_BITS[ip & 255])\n        ip >>= 8\n    bits.reverse()\n    return ''.join(bits) or 32*'0'\n\ndef _dec_to_bin_short(ip):\n    \"\"\"Decimal to binary conversion.\"\"\"\n    bits = []\n    while ip:\n        bits.append(_BYTES_TO_BITS[ip & 255])\n        ip >>= 8\n    bits.reverse()\n    return ''.join(bits) or 16*'0'\n\ndef _dec_to_bin_long_short(ip):\n    \"\"\"Decimal to binary conversion.\"\"\"\n    bits = []\n    while ip:\n        bits.append(_BYTES_TO_BITS[ip & 255])\n        ip >>= 8\n    bits.reverse()\n    return ''.join(bits) or 32*'0'\n\ndef _dec_to_bin_long_long(ip):\n    \"\"\"Decimal to binary conversion.\"\"\"\n    bits = []\n    while ip:\n        bits.append(_BYTES_TO_BITS[ip & 255])\n        ip >>= 8\n    bits.reverse()\n    return ''.join(bits) or 64*'0'\n\ndef",
        "\n\ndef _dec_to_bits(dec, check=True):\n    \"\"\"Decimal to bits conversion.\"\"\"\n    if check and not is_dec_nm(dec):\n        raise ValueError('_dec_to_bits: invalid decimal: \"%s\"' % dec)\n    return VALID_DEC_NETMASKS[dec]\n\ndef _dec_to_hex(dec, check=True):\n    \"\"\"Decimal to hex conversion.\"\"\"\n    if check and not is_dec_nm(dec):\n        raise ValueError('_dec_to_hex: invalid decimal: \"%s\"' % dec)\n    return VALID_DEC_HEX_NETMASKS[dec]\n\ndef _hex_to_dec(hex, check=True):\n    \"\"\"Hex to decimal conversion.\"\"\"\n    if check and not is_hex_nm(hex):\n        raise ValueError('_hex_to_dec: invalid hex: \"%s\"' % hex)\n    return VALID_HEX_NETMASKS[hex]\n\ndef _hex_to_dec_with_prefix(hex, prefix, check=True):\n    \"\"\"Hex to decimal conversion with prefix.\"\"\"\n    if check and not is_hex_nm(hex):\n        raise ValueError('_hex_to_dec_with_prefix: invalid hex: \"%s\"' % hex)\n    return VALID_HEX_NET",
        ".to_int()\n\ndef _dot_to_dec(nm, check=False):\n    \"\"\"Dot bits to decimal conversion.\"\"\"\n    if check and not is_dot_nm(nm):\n        raise ValueError('_dot_to_dec: invalid netmask: \"%s\"' % nm)\n    return 0xFFFFFFFF - _wildcard_to_dec(nm, check)\n\ndef _wildcard_to_hex(nm, check=False):\n    \"\"\"Wildcard bits to hexadecimal conversion.\"\"\"\n    if check and not is_wildcard_nm(nm):\n        raise ValueError('_wildcard_to_hex: invalid netmask: \"%s\"' % nm)\n    return 0xFFFFFFFF - _dot_to_hex(nm, check)\n\ndef _dot_to_hex(nm, check=False):\n    \"\"\"Dot bits to hexadecimal conversion.\"\"\"\n    if check and not is_dot_nm(nm):\n        raise ValueError('_dot_to_hex: invalid netmask: \"%s\"' % nm)\n    return 0xFFFFFFFF - _wildcard_to_hex(nm, check)\n\ndef _wildcard_to_bin(nm, check=False):\n    \"\"\"Wildcard bits to binary conversion.\"\"\"\n    if check and not is_wildcard_nm(nm):\n        raise ValueError('_wildcard_to_bin: invalid netmask: \"%s\"' % nm)\n    return",
        "\n\ndef _is_ip(ip):\n    \"\"\"Function internally used to detect if the given IP is an IP or\n    netmask.\"\"\"\n    ip = str(ip)\n    if len(ip) > 1:\n        if ip[0:2] == '0x':\n            return True\n        elif ip[0] == '0':\n            return True\n    return False\n\ndef _is_netmask(ip):\n    \"\"\"Function internally used to detect if the given IP is a netmask.\"\"\"\n    ip = str(ip)\n    if len(ip) > 1:\n        if ip[0:2] == '0x':\n            return True\n        elif ip[0] == '0':\n            return True\n    return False\n\ndef _is_ip_dot(ip):\n    \"\"\"Function internally used to detect if the given IP is a dot notation.\"\"\"\n    ip = str(ip)\n    if len(ip) > 1:\n        if ip[0:2] == '0x':\n            return True\n        elif ip[0] == '0':\n            return True\n    return False\n\ndef _is_ip_dec(ip):\n    \"\"\"Function internally used to detect if the given IP is a dec notation.\"\"\"\n    ip = str(ip)\n    if len(ip) > 1:\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ")\n\ndef _convert(nm, notation, inotation, _check=True, _isnm=False):\n    \"\"\"Convert a netmask to another notation.\"\"\"\n    if _isnm:\n        return nm\n    if not _check:\n        return notation\n    if not inotation:\n        inotation = notation\n    if not notation:\n        notation = inotation\n    if not inotation:\n        inotation = notation\n    if not notation:\n        notation = inotation\n    if not inotation:\n        inotation = notation\n    if not inotation:\n        inotation = inotation\n    if not inotation:\n        inotation = inotation\n    if not inotation:\n        inotation = inotation\n    if not inotation:\n        inotation = inotation\n    if not inotation:\n        inotation = inotation\n    if not inotation:\n        inotation = inotation\n    if not inotation:\n        inotation = inotation\n    if not inotation:\n        inotation = inotation\n    if not inotation:\n        inotation = inotation\n    if not inotation:\n        inotation = inotation",
        "\n\ndef _sub(self, other):\n        \"\"\"Sum two IP addresses.\"\"\"\n        if isinstance(other, self.__class__):\n            sum_ = self._ip_dec - other._ip_dec\n        elif isinstance(other, int):\n            sum_ = self._ip_dec - other\n        else:\n            other = self.__class__(other)\n            sum_ = self._ip_dec - other._ip_dec\n        return sum_\n\ndef _mul(self, other):\n        \"\"\"Sum two IP addresses.\"\"\"\n        if isinstance(other, self.__class__):\n            sum_ = self._ip_dec * other._ip_dec\n        elif isinstance(other, int):\n            sum_ = self._ip_dec * other\n        else:\n            other = self.__class__(other)\n            sum_ = self._ip_dec * other._ip_dec\n        return sum_\n\ndef _div(self, other):\n        \"\"\"Sum two IP addresses.\"\"\"\n        if isinstance(other, self.__class__):\n            sum_ = self._ip_dec / other._ip_dec\n        elif isinstance(other, int):\n            sum_ = self._ip_dec / other\n        else:\n            other = self.__class__(other)\n            sum_ = self._ip_dec /",
        "\n\ndef _add(self, other):\n        \"\"\"Add two IP addresses.\"\"\"\n        if isinstance(other, self.__class__):\n            add = self._ip_dec + other._ip_dec\n        if isinstance(other, int):\n            add = self._ip_dec + other\n        else:\n            other = self.__class__(other)\n            add = self._ip_dec + other._ip_dec\n        return add\n\ndef _mul(self, other):\n        \"\"\"Multiply two IP addresses.\"\"\"\n        if isinstance(other, self.__class__):\n            mul = self._ip_dec * other._ip_dec\n        if isinstance(other, int):\n            mul = self._ip_dec * other\n        else:\n            other = self.__class__(other)\n            mul = self._ip_dec * other._ip_dec\n        return mul\n\ndef _div(self, other):\n        \"\"\"Divide two IP addresses.\"\"\"\n        if isinstance(other, self.__class__):\n            div = self._ip_dec / other._ip_dec\n        if isinstance(other, int):\n            div = self._ip_dec / other\n        else:\n            other = self.__class__(other)\n            div = self._ip_dec / other._ip_dec\n        return div\n",
        ")\n\ndef get_netmask(self):\n        \"\"\"Return the netmask notation of the netmask.\"\"\"\n        return _convert(self._ip, notation=NM_NETMASK,\n                        inotation=IP_DOT, _check=False, _isnm=self.isnm)\n\ndef get_netmask_bits(self):\n        \"\"\"Return the bits notation of the netmask.\"\"\"\n        return _convert(self._ip, notation=NM_NETMASK_BITS,\n                        inotation=IP_DOT, _check=False, _isnm=self.isnm)\n\ndef get_netmask_netmask(self):\n        \"\"\"Return the netmask notation of the netmask.\"\"\"\n        return _convert(self._ip, notation=NM_NETMASK_NETMASK,\n                        inotation=IP_DOT, _check=False, _isnm=self.isnm)\n\ndef get_netmask_netmask_bits(self):\n        \"\"\"Return the bits notation of the netmask.\"\"\"\n        return _convert(self._ip, notation=NM_NETMASK_NETMASK_BITS,\n                        inotation=IP_DOT, _check=False, _isnm=self.isnm)\n\ndef get_netmask_netmask_netmask(self):\n        \"\"\"Return the netmask notation of the netmask",
        ")\n\ndef get_wildcard_ip(self):\n        \"\"\"Return the wildcard bits notation of the netmask.\"\"\"\n        return _convert(self._ip, notation=NM_WILDCARD,\n                        inotation=IP_DOT, _check=False, _isnm=self._isnm)\n\ndef get_wildcard_ip_mask(self):\n        \"\"\"Return the wildcard bits notation of the netmask.\"\"\"\n        return _convert(self._ip, notation=NM_WILDCARD,\n                        inotation=IP_MASK, _check=False, _isnm=self._isnm)\n\ndef get_wildcard_ip_mask_ip(self):\n        \"\"\"Return the wildcard bits notation of the netmask.\"\"\"\n        return _convert(self._ip, notation=NM_WILDCARD,\n                        inotation=IP_MASK, _check=False, _isnm=self._isnm)\n\ndef get_wildcard_ip_mask_ip_mask(self):\n        \"\"\"Return the wildcard bits notation of the netmask.\"\"\"\n        return _convert(self._ip, notation=NM_WILDCARD,\n                        inotation=IP_MASK, _check=False, _isnm=self._isnm)\n\ndef get_wildcard_ip_mask_ip_mask(self):\n        \"\"\"Return the wildcard bits notation of",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "=ip)\n\ndef get_ip(self):\n        \"\"\"Return the current IP.\"\"\"\n        return self.get(ip=self.ip)\n\ndef get_netmask(self):\n        \"\"\"Return the current netmask.\"\"\"\n        return self.get(netmask=self.netmask)\n\ndef get_netmask_ip(self):\n        \"\"\"Return the current netmask IP.\"\"\"\n        return self.get(netmask=self.netmask_ip)\n\ndef get_netmask_ip_mask(self):\n        \"\"\"Return the current netmask IP mask.\"\"\"\n        return self.get(netmask=self.netmask_ip_mask)\n\ndef get_netmask_ip_mask_mask(self):\n        \"\"\"Return the current netmask IP mask mask.\"\"\"\n        return self.get(netmask=self.netmask_ip_mask_mask)\n\ndef get_netmask_ip_mask_mask_mask(self):\n        \"\"\"Return the current netmask IP mask mask mask mask.\"\"\"\n        return self.get(netmask=self.netmask_ip_mask_mask_mask)\n\ndef get_netmask_ip_mask_mask_mask(self):\n        \"\"\"Return the current netmask IP mask mask mask mask mask.\"\"\"\n        return self.get(netmask=self.netmask_ip_mask",
        ", netmask=netmask)\n\ndef get_netmask(self):\n        \"\"\"Return the current netmask.\"\"\"\n        return self.get(ip=self._ip, netmask=self._netmask)\n\ndef set_ip(self, ip):\n        \"\"\"Change the current IP.\"\"\"\n        self.set(ip=ip)\n\ndef get_ip(self):\n        \"\"\"Return the current IP.\"\"\"\n        return self.get(ip=self._ip)\n\ndef set_mac(self, mac):\n        \"\"\"Change the current MAC.\"\"\"\n        self.set(mac=mac)\n\ndef get_mac(self):\n        \"\"\"Return the current MAC.\"\"\"\n        return self.get(mac=self._mac)\n\ndef set_ip_address(self, ip):\n        \"\"\"Change the current IP address.\"\"\"\n        self.set(ip=ip)\n\ndef get_ip_address(self):\n        \"\"\"Return the current IP address.\"\"\"\n        return self.get(ip=self._ip)\n\ndef set_mac_address(self, mac):\n        \"\"\"Change the current MAC address.\"\"\"\n        self.set(mac=mac)\n\ndef get_mac_address(self):\n        \"\"\"Return the current MAC address.\"\"\"\n        return self.get(mac=self._mac)\n\ndef set_ip_",
        "\n\ndef is_valid_ip_range(self, ip_range):\n        \"\"\"Return true if the given IP range is valid, or if it is contained\n        in this one.\"\"\"\n        if not isinstance(ip_range, (IPv4Address, CIDR)):\n            if str(ip_range).find('/') == -1:\n                ip_range = IPv4Address(ip_range)\n            else:\n                # Support for CIDR strings/objects, an idea of Nicola Novello.\n                ip_range = CIDR(ip_range)\n        if isinstance(ip_range, IPv4Address):\n            if ip_range < self._first_ip or ip_range > self._last_ip:\n                return False\n        elif isinstance(ip_range, CIDR):\n            # NOTE: manage /31 networks; 127.0.0.1/31 is considered to\n            #       be included in 127.0.0.1/8.\n            if ip_range._nm._ip_dec == 0xFFFFFFFE \\\n                    and self._nm._ip_dec != 0xFFFFFFFE:\n                compare_to_first = self._net_ip._ip_dec\n                compare_to_last = self._bc_ip._ip_dec\n            else:\n                compare_to_first = self._first",
        "\n\nasync def _multipart(self, client, file, params):\n    \"\"\"Upload a file to S3 possibly using the multi-part uploader\n    Return the key uploaded\n    \"\"\"\n    if not params['ContentType']:\n        params['ContentType'] = 'application/octet-stream'\n\n    if not params['Body']:\n        params['Body'] = file\n\n    resp = await client.put_object(**params)\n    if 'Key' not in resp:\n        resp['Key'] = os.path.basename(file)\n    if 'Bucket' not in resp:\n        resp['Bucket'] = os.path.dirname(file)\n    return resp\n",
        "\n\nasync def _multipart_copy(self, client, source_bucket, source_key,\n                           bucket, key, size):\n        \"\"\"Copy a file from one bucket into another\n        \"\"\"\n        info = await self.head_object(Bucket=source_bucket, Key=source_key)\n        size = info['ContentLength']\n\n        if size > MULTI_PART_SIZE:\n            result = await self.copy_object(\n                Bucket=bucket, Key=key,\n                CopySource=_source_string(source_bucket, source_key)\n            )\n        else:\n            result = await self.copy_object(\n                Bucket=bucket, Key=key,\n                CopySource=_source_string(source_bucket, source_key)\n            )\n        return result\n\n\ndef _source_string(source_bucket, source_key):\n    \"\"\"Return a string representation of the source bucket and key\n    \"\"\"\n    return 's3://%s/%s' % (source_bucket, source_key)\n\n\ndef _source_string_with_prefix(source_bucket, source_key, prefix):\n    \"\"\"Return a string representation of the source bucket and key\n    with a prefix\n    \"\"\"\n    return 's3://%s/%s/%s' % (source_bucket, source_key",
        "\n\nclass FolderUploader(object):\n    \"\"\"Recursively upload a ``folder`` into a backet.\n\n    :param bucket: bucket where to upload the folder to\n    :param folder: the folder location in the local file system\n    :param key: Optional key where the folder is uploaded\n    :param skip: Optional list of files to skip\n    :param content_types: Optional dictionary mapping suffixes to\n            content types\n    :return: a coroutine\n    \"\"\"\n    def __init__(self, bucket, folder, key=None, skip=None,\n                 content_types=None):\n        self.bucket = bucket\n        self.folder = folder\n        self.key = key\n        self.skip = skip\n        self.content_types = content_types\n\n    def start(self):\n        \"\"\"Start the upload process.\n\n        :return: a coroutine\n        \"\"\"\n        return self.upload_folder(self.bucket, self.folder, self.key,\n                                  self.skip, self.content_types)\n\n    def stop(self):\n        \"\"\"Stop the upload process.\n\n        :return: a coroutine\n        \"\"\"\n        return self.upload_folder(self.bucket, self.folder, self.key,\n                                  self.skip, None)\n\n\nclass FileUploader(object):\n    \"\"\"Recursively",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n    async def send(self, event, data=None, socket_id=None):\n        '''Send an ``event`` to this channel\n        '''\n        json_data = json.dumps(data, cls=self.pusher.encoder)\n        signed_path = \"%s?%s\" % (self.path, self.signed_query(event, json_data, socket_id))\n        pusher = self.pusher\n        absolute_url = pusher.get_absolute_path(signed_path)\n        response = await pusher.http.post(\n            absolute_url, data=json_data,\n            headers=[('Content-Type', 'application/json')])\n        response.raise_for_status()\n        return response.status_code == 202\n\n    async def delete(self, event, data=None, socket_id=None):\n        '''Delete an ``event`` from this channel\n        '''\n        json_data = json.dumps(data, cls=self.pusher.encoder)\n        signed_path = \"%s?%s\" % (self.path, self.signed_query(event, json_data, socket_id))\n        pusher = self.pusher\n        absolute_url = pusher.get_absolute_path(signed_path)\n       ",
        "\n\n    async def disconnect(self):\n        '''Disconnect from a Pusher websocket\n        '''\n        if self._consumer:\n            await self.http.delete(self._websocket_host())\n            self._consumer = None\n\n    async def _websocket_host(self):\n        '''Return the websocket host\n        '''\n        return 'ws://%s' % self.host\n\n    async def _websocket_port(self):\n        '''Return the websocket port\n        '''\n        return self.port\n\n    async def _websocket_path(self):\n        '''Return the websocket path\n        '''\n        return '/pusher'\n\n    async def _websocket_message(self, message):\n        '''Return the websocket message\n        '''\n        return '{\"message\": \"%s\"}' % message\n\n    async def _websocket_close(self):\n        '''Return the websocket close\n        '''\n        return '{\"close\": true}'\n\n    async def _websocket_error(self, error):\n        '''Return the websocket error\n        '''\n        return '{\"error\": \"%s\"}' % error\n\n    async def _websocket_ping(self):\n        '''Return the websocket ping\n        '''\n        return '{\"ping\": true}'\n\n    async def _websocket_pong(self):\n        '''Return the websocket pong\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\ndef const_less(str_a, str_b):\n    '''Constant time string comparison'''\n\n    if len(str_a) != len(str_b):\n        return False\n\n    result = True\n    for i in range(len(str_a)):\n        result &= (str_a[i] < str_b[i])\n\n    return result\n\ndef const_greater(str_a, str_b):\n    '''Constant time string comparison'''\n\n    if len(str_a) != len(str_b):\n        return False\n\n    result = True\n    for i in range(len(str_a)):\n        result &= (str_a[i] > str_b[i])\n\n    return result\n\ndef const_less_equal(str_a, str_b):\n    '''Constant time string comparison'''\n\n    if len(str_a) != len(str_b):\n        return False\n\n    result = True\n    for i in range(len(str_a)):\n        result &= (str_a[i] <= str_b[i])\n\n    return result\n\ndef const_greater_equal(str_a, str_b):\n    '''Constant time string comparison'''\n\n    if len(str_a)",
        "\ndef html_entity_map:\n    \"\"\"\n    A mapping of HTML entities to their character codes.\n    \"\"\"\n    return {\n        'amp': '&',\n        'gt': '>',\n        'lt': '<',\n        'quot': '\"',\n        'apos': '\\'',\n        'ltquo': '\\'',\n        'raquo': '\\'',\n        'ltm': '\\'',\n        'raquo': '\\'',\n        'ltn': '\\'',\n        'raquo': '\\'',\n        'ltv': '\\'',\n        'raquo': '\\'',\n        'ltw': '\\'',\n        'raquo': '\\'',\n        'ltz': '\\'',\n        'raquo': '\\'',\n        'lt': '\\'',\n        'raquo': '\\'',\n        'ltz': '\\'',\n        'ltm': '\\'',\n        'raquo': '\\'',\n        'ltn': '\\'',\n        'raquo': '\\'',\n        'ltv': '\\'',\n        'raquo': '\\'',\n        'ltw': '\\'',\n        'raquo': '\\'',\n        'ltz': '\\'',\n        'raquo': '\\'',\n        'ltm': '\\'',\n        'raquo': '\\'',\n        'lt",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveMessageCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;",
        "\n\nclass Seal(object):\n    '''Base class for all sealing classes'''\n\n    def __init__(self, options=None):\n        '''Constructor for sealing classes'''\n        self.options = _set_options(options)\n\n    def set_magic(self, magic):\n        '''Set the magic number for the sealing'''\n        self.options['magic'] = magic\n\n    def set_flags(self, flags):\n        '''Set the flags for the sealing'''\n        self.options['flags'] = flags\n\n    def set_info(self, info):\n        '''Set the info for the sealing'''\n        self.options['info'] = info\n\n    def seal(self, data):\n        '''Seal the data'''\n        self.options['info'] = data\n        self.options['flags'].update(self.options['flags'])\n        self.options['flags'].update(self.options['flags'].copy())\n        self.options['flags'].update(self.options['flags'].copy())\n        self.options['flags'].update(self.options['flags'].copy())\n        self.options['flags'].update(self.options['flags'].copy())\n        self.options['flags'].update(self.options['flags'].copy())\n        self.options['flags'].update(",
        ".verify_signature(data)\n\n        return data\n\ndef sign_data(self, data, options):\n        '''Sign data'''\n\n        data = self._remove_magic(data)\n        data = urlsafe_nopadding_b64encode(data)\n        options = self._read_header(data)\n        data = self._add_magic(data)\n        self._sign_data(data, options)\n\n        return data\n\ndef sign_data_with_signature(self, data, signature):\n        '''Sign data with signature'''\n\n        data = self._remove_magic(data)\n        data = urlsafe_nopadding_b64encode(data)\n        options = self._read_header(data)\n        data = self._add_magic(data)\n        self._sign_data(data, options, signature)\n\n        return data\n\ndef sign_data_with_signature_with_options(self, data, signature, options):\n        '''Sign data with signature with options'''\n\n        data = self._remove_magic(data)\n        data = urlsafe_nopadding_b64encode(data)\n        options = self._read_header(data)\n        data = self._add_magic(data)\n        self._sign_data(data, options,",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _verify_data(self, data, signature, options):\n        '''Verify signature'''\n\n        if options['signature_algorithm_id'] not in self.signature_algorithms:\n            raise Exception('Unknown signature algorithm id: %d'\n                            % options['signature_algorithm_id'])\n\n        signature_algorithm = \\\n            self.signature_algorithms[options['signature_algorithm_id']]\n\n        algorithm = self._get_algorithm_info(signature_algorithm)\n\n        key_salt = get_random_bytes(algorithm['salt_size'])\n        key = self._generate_key(options['signature_passphrase_id'],\n                            self.signature_passphrases, key_salt, algorithm)\n\n        data = self._decode(data, algorithm, key)\n\n        return data == signature\n\ndef _generate_key(self, passphrase_id, passphrase_list, key_salt, algorithm):\n        '''Generate key'''\n\n        if passphrase_id not in passphrase_list:\n            raise Exception('Unknown passphrase id: %d'\n                            % passphrase_id)\n\n        if passphrase_id in passphrase_list:\n            passphrase = passphrase_list[passphrase_id]\n        else:\n            passphrase = passphrase_list[0]\n\n        key = get_random_bytes(algorithm",
        "\n\ndef _sign_data(self, data, options):\n        '''Sign data'''\n\n        if options['signature_algorithm_id'] not in self.signature_algorithms:\n            raise Exception('Unknown signature algorithm id: %d'\n                            % options['signature_algorithm_id'])\n\n        algorithm = self._get_algorithm_info(options['signature_algorithm_id'])\n\n        key_salt = ''\n        if algorithm['salt_size']:\n            key_salt = data[-algorithm['salt_size']:]\n            data = data[:-algorithm['salt_size']]\n\n        key = self._generate_key(options['signature_passphrase_id'],\n                            self.signature_passphrases, key_salt, algorithm)\n\n        data = self._encode(data, algorithm, key)\n\n        return data\n\ndef _get_algorithm_info(self, algorithm_id):\n        '''Get algorithm info'''\n\n        algorithm = self.algorithm_info[algorithm_id]\n\n        if algorithm['algorithm_id'] not in self.algorithm_info:\n            raise Exception('Unknown algorithm id: %d'\n                            % algorithm['algorithm_id'])\n\n        return algorithm\n\ndef _generate_key(self, passphrase_id, passphrase_passphrases,\n                    key_salt, algorithm):",
        "\ndef _remove_magic_from_data(self, data):\n        '''Verify and remove magic'''\n\n        if not self.magic:\n            return data\n\n        magic_size = len(self.magic)\n        magic = data[:magic_size]\n        if magic != self.magic:\n            raise Exception('Invalid magic')\n        data = data[magic_size:]\n\n        return data\n\ndef _remove_magic_from_string(self, data):\n        '''Verify and remove magic'''\n\n        if not self.magic:\n            return data\n\n        magic_size = len(self.magic)\n        magic = data[:magic_size]\n        if magic != self.magic:\n            raise Exception('Invalid magic')\n        data = data[magic_size:]\n\n        return data\n\ndef _remove_magic_from_list(self, data):\n        '''Verify and remove magic'''\n\n        if not self.magic:\n            return data\n\n        magic_size = len(self.magic)\n        magic = data[:magic_size]\n        if magic != self.magic:\n            raise Exception('Invalid magic')\n        data = data[magic_size:]\n\n        return data\n\ndef _remove_magic_from_dict(self, data):\n        '''Verify and remove magic'''",
        "\n\ndef _add_data(self, data, options):\n        '''Add data to data'''\n\n        # pylint: disable=W0142\n\n        version_info = self._get_version_info(options['version'])\n\n        flags = options['flags']\n\n        data_flags = dict(\n            (i, str(int(j))) for i, j in options['flags'].iteritems())\n        data_flags = ''.join(version_info['flags'](**data_flags))\n        data_flags = int(data_flags, 2)\n        options['flags'] = data_flags\n\n        data = version_info['data']\n        data = data(**options)\n        data = pack(version_info['data_format'], *data)\n\n        if 'timestamp' in flags and flags['timestamp']:\n            timestamp = long(time())\n            data = data + timestamp\n\n        return data + data\n\ndef _add_footer(self, data, options):\n        '''Add footer to data'''\n\n        # pylint: disable=W0142\n\n        version_info = self._get_version_info(options['version'])\n\n        flags = options['flags']\n\n        footer_flags = dict(\n            (i, str(int(j))) for i, j in",
        "\n\ndef _read_version(self, data):\n        '''Read version from data'''\n\n        # pylint: disable=W0212\n\n        version = data[:self._get_version_info(1)[0]['header_size']]\n        version = unpack(self._version_format, version)[0]\n        version = int(version)\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(version)[0]\n        version = self._get_version_info(",
        "\n\ndef _get_version_info(self, version):\n        '''Get version info'''\n\n        version_info = {}\n\n        if version == '1':\n                version_info['major'] = 1\n                version_info['minor'] = 0\n                version_info['patch'] = 0\n                version_info['micro'] = 0\n                version_info['pre'] = 0\n                version_info['post'] = 0\n                version_info['pre_release'] = 0\n                version_info['post_release'] = 0\n                version_info['pre_release_date'] = 0\n                version_info['post_release_date'] = 0\n                version_info['pre_release_date_time'] = 0\n                version_info['post_release_date_time'] = 0\n                version_info['pre_release_date_time_time'] = 0\n                version_info['post_release_date_time_time'] = 0\n                version_info['pre_release_date_time_time_time'] = 0\n                version_info['post_release_date_time_time_time'] = 0\n                version_info['pre_release_date_time_time_time'] = 0\n                version_info['post_release_date_time_time_time'] = 0\n",
        "\n        return version\n\n    def _read_header(self, data):\n        '''Read header from data'''\n\n        version = self._read_version(data)\n        if version not in self.VERSIONS:\n            raise Exception('Version not defined: %d' % version)\n\n        self.header_version = version\n\n        # Read header length\n        length = ord(data[1])\n        if length not in self.LENGTHS:\n            raise Exception('Length not defined: %d' % length)\n        self.header_length = length\n\n        # Read header type\n        type = ord(data[2])\n        if type not in self.TYPES:\n            raise Exception('Type not defined: %d' % type)\n        self.header_type = type\n\n        # Read header checksum\n        checksum = ord(data[3])\n        if checksum not in self.CHECKSUMS:\n            raise Exception('Checksum not defined: %d' % checksum)\n        self.header_checksum = checksum\n\n        # Read header checksum length\n        checksum_length = ord(data[4])\n        if checksum_length not in self.CHECKSUM_LENGTHS:\n            raise Exception('Checksum length not defined: %d' % checksum_length)\n        self.header_checksum_length = checksum_length\n\n",
        "\n\nclass Algorithm(object):\n    '''Algorithm class'''\n\n    def __init__(self, algorithm_name, algorithm_info):\n        '''Initialize algorithm'''\n\n        self.algorithm_name = algorithm_name\n        self.algorithm_info = algorithm_info\n\n    def get_algorithm_info(self):\n        '''Get algorithm info'''\n\n        return _get_algorithm_info(self.algorithm_info)\n\n    def get_algorithm_name(self):\n        '''Get algorithm name'''\n\n        return self.algorithm_name\n\n    def get_algorithm_type(self):\n        '''Get algorithm type'''\n\n        return self.algorithm_info['algorithm']\n\n    def get_algorithm_description(self):\n        '''Get algorithm description'''\n\n        return self.algorithm_info['description']\n\n    def get_algorithm_parameters(self):\n        '''Get algorithm parameters'''\n\n        return self.algorithm_info['parameters']\n\n    def get_algorithm_parameters_description(self):\n        '''Get algorithm parameters description'''\n\n        return self.algorithm_info['parameters_description']\n\n    def get_algorithm_parameters_type(self):\n        '''Get algorithm parameters type'''\n\n        return self.algorithm_info['parameters_type']\n\n    def get_algorithm_parameters_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _update_dict_from_dict(data, default_data, replace_data=False):\n        '''Update algorithm definition type dictionaries'''\n\n        if not data:\n            data = default_data.copy()\n            return data\n\n        if not isinstance(data, dict):\n            raise TypeError('Value not dict type')\n        if len(data) > 255:\n            raise ValueError('More than 255 values defined')\n        for i in data.keys():\n            if not isinstance(i, int):\n                raise TypeError('Index not int type')\n            if i < 0 or i > 255:\n                raise ValueError('Index value out of range')\n\n        if not replace_data:\n            data.update(default_data)\n\n        return data\n\ndef _update_dict_from_list(data, default_data, replace_data=False):\n        '''Update algorithm definition type dictionaries'''\n\n        if not data:\n            data = default_data.copy()\n            return data\n\n        if not isinstance(data, list):\n            raise TypeError('Value not list type')\n        if len(data) > 255:\n            raise ValueError('More than 255 values defined')\n        for i in data:\n            if not isinstance(i, int):\n                raise TypeError('Index not int type')\n            if i <",
        "\n\ndef getZipFileContents(self):\n        \"\"\"\n        This function populates the internal tableOfContents list with the contents\n        of the zip file TOC. If the server does not support ranged requests, this will raise\n        and exception. It will also throw an exception if the TOC cannot be found.\n        \"\"\"\n\n        self.directory_size = self.getDirectorySize()\n        if self.directory_size > 65536:\n            self.directory_size += 2\n            self.requestContentDirectory()\n\n        self.raw_bytes = self.raw_bytes\n        current_start = self.directory_start - self.start\n        filestart = 0\n        compressedsize = 0\n        uncompressedsize = 0\n        tableOfContents = []\n\n        try:\n            while True:\n                # get file name size (n), extra len (m) and comm len (k)\n                zip_n = unpack(\"H\", self.raw_bytes[current_start + 28: current_start + 28 + 2])[0]\n                zip_m = unpack(\"H\", self.raw_bytes[current_start + 30: current_start + 30 + 2])[0]\n                zip_k = unpack(\"H\", self.raw_bytes[current_start + 32: current_start + 32 + 2])[0]\n",
        "\n\ndef extractFiles(self, filenames):\n        \"\"\"\n        This function will extract a list of files from the remote zip without downloading\n        the entire zip file. The filenames argument should match whatever is in the 'filename'\n        key of the tableOfContents.\n        \"\"\"\n        files = []\n        for filename in filenames:\n            files.append(self.extractFile(filename))\n        return files\n\ndef extractFilesFromZip(self, zipURI):\n        \"\"\"\n        This function will extract a list of files from the remote zip without downloading\n        the entire zip file. The zipURI argument should match whatever is in the 'zipURI'\n        key of the tableOfContents.\n        \"\"\"\n        files = []\n        for filename in self.tableOfContents:\n            files.append(self.extractFile(filename))\n        return files\n\ndef extractFilesFromZipURI(self, zipURI):\n        \"\"\"\n        This function will extract a list of files from the remote zip without downloading\n        the entire zip file. The zipURI argument should match whatever is in the 'zipURI'\n        key of the tableOfContents.\n        \"\"\"\n        files = []\n        for filename in self.tableOfContents:\n            files.append(self.extractFile(filename))\n        return files\n\ndef extractFilesFromZipURIAndFilename(self,",
        "\n        self.flux_uncert = np.array(self.flux_uncert)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.flux_uncert = self.flux_uncert.reshape(self.qs.shape)\n        self.",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef define_fluxsignal(self):\n        \"\"\"\n        Identify the \"expected\" flux value at the time of each observation based on the Kepler long-cadence data, to ensure variations observed are not the effects of a single large starspot.\n        Only works if the target star was targeted for long or short cadence observations during the primary mission.\n        \"\"\"\n        client = kplr.API()\n        star = client.star(self.kic)\n\n        lcs = star.get_light_curves(short_cadence=False)\n        time, flux, ferr, qual = [], [], [], []\n        for lc in lcs:\n            with lc.open() as f:\n                hdu_data = f[1].data\n                time = time[np.isfinite(f)]\n                f = flux[np.isfinite(f)]\n                e = ferr[np.isfinite(f)]\n                f = f[np.isfinite(f)]\n\n                e /= np.median(f)\n                f /= np.median(f)\n                tout = np.append(tout, t[50:]+54833)\n                fout = np.append(fout, f[50:])\n                eout = np.append(eout, e[",
        "\n\ndef model_uncert_2(self):\n        \"\"\"\n        Estimate the photometric uncertainties on each data point following Equation A.2 of The Paper.\n        Based on the kepcal package of Dan Foreman-Mackey.\n        \"\"\"\n        Y = self.photometry_array.T\n        Y /= np.median(Y, axis=1)[:, None]\n        C = np.median(Y, axis=0)\n        \n        nstars, nobs = np.shape(Y)\n        \n        Z = np.empty((nstars, 4))\n        \n        qs = self.qs.astype(int)\n        \n        for s in range(4):\n            Z[:, s] = np.median((Y / C)[:, qs == s], axis=1)\n\n        resid2 = (Y - Z[:, qs] * C)**2\n        z = Z[:, qs]\n        trend = z * C[None, :]\n        \n        lnS = np.log(np.nanmedian(resid2, axis=0))\n        jitter = np.log(0.1*np.nanmedian(np.abs(np.diff(Y, axis=1))))\n\n        cal_ferr = np.sqrt",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef add_line_warning(self, line_data, error_info, log_level=logging.WARNING):\n        \"\"\"Helper function to record and log a warning message\n\n        :param line_data: dict\n        :param error_info: dict\n        :param logger:\n        :param log_level: int\n        :return:\n        \"\"\"\n        if not error_info: return\n        try:\n            line_data['line_warnings'].append(error_info)\n        except KeyError:\n            line_data['line_warnings'] = [error_info]\n        except TypeError: # no line_data\n            pass\n        try:\n            self.logger.log(log_level, Gff3.warning_format.format(current_line_num=line_data['line_index'] + 1, error_type=error_info['error_type'], message=error_info['message'], line=line_data['line_raw'].rstrip()))\n        except AttributeError: # no logger\n            pass\n\ndef add_line_info(self, line_data, error_info, log_level=logging.INFO):\n        \"\"\"Helper function to record and log a info message\n\n        :param line_data: dict\n        :param error_info: dict\n        :param logger:\n        :",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        return\n\ndef check_strand(self):\n        \"\"\"\n        1. get a list of CDS with the same parent\n        2. sort according to strand\n        3. calculate and validate strand\n        \"\"\"\n        plus_minus = set(['+', '-'])\n        for k, g in groupby(sorted([line for line in self.lines if  line['line_type'] == 'feature' and line['type'] == 'CDS' and 'Parent' in line['attributes']], key=lambda x: x['attributes']['Parent']), key=lambda x: x['attributes']['Parent']):\n            cds_list = list(g)\n            strand_set = list(set([line['strand'] for line in cds_list]))\n            if len(strand_set) != 1:\n                for line in cds_list:\n                    self.add_line_error(line, {'message': 'Inconsistent CDS strand with parent: {0:s}'.format(k), 'error_type': 'STRAND'})\n                continue\n            if len(cds_list) == 1:\n                if cds_list[0]['strand'] != '+':\n                    self.add_line_error(cds_list[0], {'message': 'Wrong strand {0:d}, should be {1:d",
        "\n\ndef adopt_all(self, old_parent, new_parent):\n        \"\"\"\n        Transfer children from old_parent to new_parent\n\n        :param old_parent: feature_id(str) or line_index(int) or line_data(dict) or feature\n        :param new_parent: feature_id(str) or line_index(int) or line_data(dict) or feature\n        :return: List of children transferred\n        \"\"\"\n        try: # assume line_data(dict)\n            old_id = old_parent['attributes']['ID']\n        except TypeError:\n            try: # assume line_index(int)\n                old_id = self.lines[old_parent]['attributes']['ID']\n            except TypeError: # assume feature_id(str)\n                old_id = old_parent\n        old_feature = self.features[old_id]\n        old_indexes = [ld['line_index'] for ld in old_feature]\n        try: # assume line_data(dict)\n            new_id = new_parent['attributes']['ID']\n        except TypeError:\n            try: # assume line_index(int)\n                new_id = self.lines[new_parent]['attributes']['ID']\n            except TypeError: # assume feature_id(str)\n",
        "\n                    root_ancestor['parents'] = []\n                    root_ancestor['children'] = []\n                    break\n        return roots\n\ndef write(self, line_data, root_type=None):\n        \"\"\"\n        Marks line_data and all of its associated feature's 'line_status' as 'removed', does not actually remove the line_data from the data structure.\n        The write function checks the 'line_status' when writing the gff file.\n        Find the root parent of line_data of type root_type, remove all of its descendants.\n        If the root parent has a parent with no children after the remove, remove the root parent's parent recursively.\n\n        :param line_data:\n        :param root_type:\n        :return:\n        \"\"\"\n        roots = [ld for ld in self.ancestors(line_data) if (root_type and ld['line_type'] == root_type) or (not root_type and not ld['parents'])] or [line_data]\n        for root in roots:\n            root['line_status'] = 'removed'\n            root_descendants = self.descendants(root)\n            for root_descendant in root_descendants:\n                root_descendant['line_status'] = 'removed'\n            root_ancestors = self.ancestors(",
        ".strip()\n\ndef abfIDfromFilename(fname):\n    \"\"\"given a filename, return the ABFs ID string.\"\"\"\n    fname=os.path.abspath(fname)\n    basename=os.path.basename(fname)\n    return os.path.splitext(basename)[0]\n\ndef abfIDfromFilename(fname):\n    \"\"\"given a filename, return the ABFs ID string.\"\"\"\n    fname=os.path.abspath(fname)\n    basename=os.path.basename(fname)\n    return os.path.splitext(basename)[0]\n\ndef abfIDfromFilename(fname):\n    \"\"\"given a filename, return the ABFs ID string.\"\"\"\n    fname=os.path.abspath(fname)\n    basename=os.path.basename(fname)\n    return os.path.splitext(basename)[0]\n\ndef abfIDfromFilename(fname):\n    \"\"\"given a filename, return the ABFs ID string.\"\"\"\n    fname=os.path.abspath(fname)\n    basename=os.path.basename(fname)\n    return os.path.splitext(basename)[0]\n\ndef abfIDfromFilename(fname):\n    \"\"\"given a filename, return the ABFs ID string.\"\"\"\n    fname=os.path.abspath(fname)\n   ",
        "\n\ndef abfProtocolID(fname):\n    \"\"\"Determine the protocol used to record an ABF file\"\"\"\n    f=open(fname,'rb')\n    raw=f.read(30*1000) #it should be in the first 30k of the file\n    f.close()\n    raw.decode(\"utf-8\",\"ignore\")\n    raw = raw.split(\"Clampex\")[1].split(\".pro\")[0]\n    protocol = os.path.basename(raw) # the whole protocol filename\n    protocolID = protocol.split(\" \")[0] # just the first number\n    return protocolID\n\ndef abfProtocolName(fname):\n    \"\"\"Determine the protocol used to record an ABF file\"\"\"\n    f=open(fname,'rb')\n    raw=f.read(30*1000) #it should be in the first 30k of the file\n    f.close()\n    raw.decode(\"utf-8\",\"ignore\")\n    raw = raw.split(\"Clampex\")[1].split(\".pro\")[0]\n    protocol = os.path.basename(raw) # the whole protocol filename\n    protocolID = protocol.split(\" \")[0] # just the first number\n    return protocolID\n\ndef abfProtocolVersion(fname):\n    \"\"\"Determine the protocol used to record an AB",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef setsweep(self, sweep):\n        \"\"\"set the sweep\"\"\"\n        self.sweeps = sweep\n        self.sweep_time = 0\n        self.sweep_time_last = 0\n        self.sweep_time_next = 0\n        self.sweep_time_last_next = 0\n        self.sweep_time_next_last = 0\n        self.sweep_time_next_next = 0\n        self.sweep_time_next_next_last = 0\n        self.sweep_time_next_next_next = 0\n        self.sweep_time_next_next_next_last = 0\n        self.sweep_time_next_next_next_next = 0\n        self.sweep_time_next_next_next_next_last = 0\n        self.sweep_time_next_next_next_next_next = 0\n        self.sweep_time_next_next_next_next_last = 0\n        self.sweep_time_next_next_next_next_next = 0\n        self.sweep_time_next_next_next_next_last = 0\n        self.sweep_time_next_next_next_next_next = 0\n        self.sweep_time_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\ndef average_by_time(self,t1=0,t2=None,setsweep=False):\n        \"\"\"return the average of part of the current sweep.\"\"\"\n        if setsweep:\n            self.setsweep(setsweep)\n        if t2 is None or t2>self.sweepLength:\n            t2=self.sweepLength\n            self.log.debug(\"resetting t2 to [%f]\",t2)\n        t1=max(t1,0)\n        if t1>t2:\n            self.log.error(\"t1 cannot be larger than t2\")\n            return False\n        I1,I2=int(t1*self.pointsPerSec),int(t2*self.pointsPerSec)\n        if I1==I2:\n            return np.nan\n        return np.average(self.sweepY[I1:I2])\n\ndef average_by_time_and_points(self,t1=0,t2=None,setsweep=False):\n        \"\"\"return the average of part of the current sweep.\"\"\"\n        if setsweep:\n            self.setsweep(setsweep)\n        if t2 is None or t2>self.sweepLength:\n            t2=self.sweepLength\n            self.log.",
        "\n\ndef averageSweep2(self,sweepFirst=0,sweepLast=None):\n        \"\"\"\n        Return a sweep which is the average of multiple sweeps.\n        For now, standard deviation is lost.\n        \"\"\"\n        if sweepLast is None:\n            sweepLast=self.sweeps-1\n        nSweeps=sweepLast-sweepFirst+1\n        runningSum=np.zeros(len(self.sweepY))\n        self.log.debug(\"averaging sweep %d to %d\",sweepFirst,sweepLast)\n        for sweep in np.arange(nSweeps)+sweepFirst:\n            self.setsweep(sweep)\n            runningSum+=self.sweepY.flatten()\n        average=runningSum/nSweeps\n        #TODO: standard deviation?\n        return average\n\ndef averageSweep3(self,sweepFirst=0,sweepLast=None):\n        \"\"\"\n        Return a sweep which is the average of multiple sweeps.\n        For now, standard deviation is lost.\n        \"\"\"\n        if sweepLast is None:\n            sweepLast=self.sweeps-1\n        nSweeps=sweepLast-sweepFirst+1\n        runningSum=np.zeros(len(self.sweep",
        "\n\ndef kernel_gaussian_2d(self, sizeMS, sigmaMS=None, forwardOnly=False):\n        \"\"\"create kernel based on this ABF info.\"\"\"\n        sigmaMS=sizeMS/10 if sigmaMS is None else sigmaMS\n        size,sigma=sizeMS*self.pointsPerMs,sigmaMS*self.pointsPerMs\n        self.kernel=swhlab.common.kernel_gaussian_2d(size,sigma,forwardOnly)\n        return self.kernel\n\ndef kernel_gaussian_3d(self, sizeMS, sigmaMS=None, forwardOnly=False):\n        \"\"\"create kernel based on this ABF info.\"\"\"\n        sigmaMS=sizeMS/10 if sigmaMS is None else sigmaMS\n        size,sigma=sizeMS*self.pointsPerMs,sigmaMS*self.pointsPerMs\n        self.kernel=swhlab.common.kernel_gaussian_3d(size,sigma,forwardOnly)\n        return self.kernel\n\ndef kernel_gaussian_4d(self, sizeMS, sigmaMS=None, forwardOnly=False):\n        \"\"\"create kernel based on this ABF info.\"\"\"\n        sigmaMS=sizeMS/10 if sigmaMS is None else sigmaMS\n        size,sigma=sizeMS*self.pointsPerMs,sigmaMS*self.pointsPer",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef dictFlat2(l):\n    \"\"\"Given a list of list of dicts, return just the dicts.\"\"\"\n    if type(l) is dict:\n        return [l]\n    if \"numpy\" in str(type(l)):\n        return l\n    dicts=[]\n    for item in l:\n        if type(item)==dict:\n            dicts.append(item)\n        elif type(item)==list:\n            for item2 in item:\n                dicts.append(item2)\n    return dicts\n\ndef dictFlat3(l):\n    \"\"\"Given a list of list of dicts, return just the dicts.\"\"\"\n    if type(l) is dict:\n        return [l]\n    if \"numpy\" in str(type(l)):\n        return l\n    dicts=[]\n    for item in l:\n        if type(item)==dict:\n            dicts.append(item)\n        elif type(item)==list:\n            for item2 in item:\n                dicts.append(item2)\n    return dicts\n\ndef dictFlat4(l):\n    \"\"\"Given a list of list of dicts, return just the dicts.\"\"\"\n    if type(l) is dict:\n        return [l]\n    if \"numpy\" in str(type(l)):\n        return l",
        "\n\ndef matrixValues2(matrix,key):\n    \"\"\"given a key, return a list of values from the matrix with that key.\"\"\"\n    assert key in matrix.dtype.names\n    col=matrix.dtype.names.index(key)\n    values=np.empty(len(matrix))*np.nan\n    for i in range(len(matrix)):\n        values[i]=matrix[i][col]\n    return values\n\ndef matrixValues3(matrix,key):\n    \"\"\"given a key, return a list of values from the matrix with that key.\"\"\"\n    assert key in matrix.dtype.names\n    col=matrix.dtype.names.index(key)\n    values=np.empty(len(matrix))*np.nan\n    for i in range(len(matrix)):\n        values[i]=matrix[i][col]\n    return values\n\ndef matrixValues4(matrix,key):\n    \"\"\"given a key, return a list of values from the matrix with that key.\"\"\"\n    assert key in matrix.dtype.names\n    col=matrix.dtype.names.index(key)\n    values=np.empty(len(matrix))*np.nan\n    for i in range(len(matrix)):\n        values[i]=matrix[i][col]\n    return values\n\n",
        "\n\ndef matrixToDicts2(data):\n    \"\"\"given a recarray, return it as a list of dicts.\"\"\"\n\n    # 1D array\n    if \"float\" in str(type(data[0])):\n        d={}\n        for x in range(len(data)):\n            d[data.dtype.names[x]]=data[x]\n        return d\n\n    # 2D array\n    l=[]\n    for y in range(len(data)):\n        d={}\n        for x in range(len(data[y])):\n            d[data.dtype.names[x]]=data[y][x]\n        l.append(d)\n    return l\n\ndef matrixToDicts3(data):\n    \"\"\"given a recarray, return it as a list of dicts.\"\"\"\n\n    # 1D array\n    if \"float\" in str(type(data[0])):\n        d={}\n        for x in range(len(data)):\n            d[data.dtype.names[x]]=data[x]\n        return d\n\n    # 2D array\n    l=[]\n    for y in range(len(data)):\n        d={}\n        for x in range(len(data[y])):\n            d[data.dtype.names[",
        "(fname)\n\ndef html_temp_launch_with_title(html, title):\n    \"\"\"given text, make it a temporary HTML file and launch it with a title.\"\"\"\n    fname = tempfile.gettempdir()+\"/swhlab/temp.html\"\n    with open(fname,'w') as f:\n        f.write(html)\n    webbrowser.open(fname,title)\n\ndef html_temp_launch_with_title_and_link(html, title, link):\n    \"\"\"given text, make it a temporary HTML file and launch it with a title and link.\"\"\"\n    fname = tempfile.gettempdir()+\"/swhlab/temp.html\"\n    with open(fname,'w') as f:\n        f.write(html)\n    webbrowser.open(fname,title,link)\n\ndef html_temp_launch_with_link(html, link):\n    \"\"\"given text, make it a temporary HTML file and launch it with a link.\"\"\"\n    fname = tempfile.gettempdir()+\"/swhlab/temp.html\"\n    with open(fname,'w') as f:\n        f.write(html)\n    webbrowser.open(fname,link)\n\ndef html_temp_launch_with_link_and_title(html, link, title):\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef htmlListToTR(list,trClass,tdClass):\n    \"\"\"Return a string with a table row for a given list of strings.\"\"\"\n    html=\"<tr>\"\n    for i in list:\n        html+=\"<td class='%s'>%s</td>\"%(trClass,i)\n    html+=\"</tr>\"\n    return html\n\ndef htmlListToHTML(list,names=None,units=None,bookName=None,sheetName=None,xCol=None):\n    \"\"\"Put 2d numpy data into a temporary HTML file.\"\"\"\n    if not names:\n        names=[\"\"]*len(list[0])\n    if not units:\n        units=[\"\"]*len(list[0])\n    for i in range(len(units)):\n        if names[i] in UNITS.keys():\n            units[i]=UNITS[names[i]]\n    if 'recarray' in str(type(data)): #make it a regular array\n        data=data.view(float).reshape(data.shape + (-1,))\n    if xCol and xCol in names:\n        names=names.index(names[xCol])\n    if names:\n        html=htmlListToTR(names,trClass='name',tdClass='name')\n    if units:",
        "\n    return xml.parse(xmlStr)\n\ndef XMLtoPython2(xmlStr=r\"C:\\Apps\\pythonModules\\GSTemp.xml\"):\n    \"\"\"\n    given a string or a path to an XML file, return an XML object.\n    \"\"\"\n    #TODO: this absolute file path crazy stuff needs to stop!\n    if os.path.exists(xmlStr):\n        with open(xmlStr) as f:\n            xmlStr=f.read()\n    print(xmlStr)\n    print(\"DONE\")\n    return\n\ndef XMLtoPython3(xmlStr=r\"C:\\Apps\\pythonModules\\GSTemp.xml\"):\n    \"\"\"\n    given a string or a path to an XML file, return an XML object.\n    \"\"\"\n    #TODO: this absolute file path crazy stuff needs to stop!\n    if os.path.exists(xmlStr):\n        with open(xmlStr) as f:\n            xmlStr=f.read()\n    print(xmlStr)\n    print(\"DONE\")\n    return\n\ndef XMLtoPython4(xmlStr=r\"C:\\Apps\\pythonModules\\GSTemp.xml\"):\n    \"\"\"\n    given a string or a path to an XML file, return an XML object.\n    \"\"\"\n    #TODO: this",
        ".exp(-t*x) + b\n\ndef algo_exp_b(x, m, t, b):\n    \"\"\"mono-exponential curve with b value.\"\"\"\n    return m*np.exp(-t*x) + b\n\ndef algo_exp_b_2(x, m, t, b):\n    \"\"\"mono-exponential curve with b value and 2nd order.\"\"\"\n    return m*np.exp(-t*x) + b*2\n\ndef algo_exp_b_3(x, m, t, b):\n    \"\"\"mono-exponential curve with b value and 3rd order.\"\"\"\n    return m*np.exp(-t*x) + b*3\n\ndef algo_exp_b_4(x, m, t, b):\n    \"\"\"mono-exponential curve with b value and 4th order.\"\"\"\n    return m*np.exp(-t*x) + b*4\n\ndef algo_exp_b_5(x, m, t, b):\n    \"\"\"mono-exponential curve with b value and 5th order.\"\"\"\n    return m*np.exp(-t*x) + b*5\n\ndef algo_exp_b_6(x, m, t, b):\n    \"\"\"mono-exponential curve with b value and 6",
        "\n\ndef where_cross_with_threshold(data,threshold):\n    \"\"\"return a list of Is where the data first crosses above threshold.\"\"\"\n    Is=np.where(data>threshold)[0]\n    Is=np.concatenate(([0],Is))\n    Ds=Is[:-1]-Is[1:]+1\n    return Is[np.where(Ds)[0]+1]\n\ndef where_cross_with_threshold_and_data(data,threshold):\n    \"\"\"return a list of Is where the data first crosses above threshold.\"\"\"\n    Is=np.where(data>threshold)[0]\n    Is=np.concatenate(([0],Is))\n    Ds=Is[:-1]-Is[1:]+1\n    return Is[np.where(Ds)[0]+1]\n\ndef where_cross_with_threshold_and_data_with_threshold(data,threshold):\n    \"\"\"return a list of Is where the data first crosses above threshold.\"\"\"\n    Is=np.where(data>threshold)[0]\n    Is=np.concatenate(([0],Is))\n    Ds=Is[:-1]-Is[1:]+1\n    return Is[np.where(Ds)[0]+1]\n\ndef where_cross_with",
        "\n\ndef originFormat_listOfDicts(thing):\n    \"\"\"Try to format anything as a 2D matrix with column names.\"\"\"\n    if type(thing) is list and type(thing[0]) is dict:\n        return originFormat_listOfDicts_flat(thing)\n    if type(thing) is list and type(thing[0]) is list:\n        return originFormat_listOfDicts_flat(dictFlat(thing))\n    else:\n        print(\" !! I don't know how to format this object!\")\n        print(thing)\n\ndef originFormat_listOfDicts_flat(thing):\n    \"\"\"Try to format anything as a 2D matrix with column names.\"\"\"\n    if type(thing) is list and type(thing[0]) is dict:\n        return originFormat_listOfDicts_flat_flat(thing)\n    if type(thing) is list and type(thing[0]) is list:\n        return originFormat_listOfDicts_flat_flat(dictFlat(thing))\n    else:\n        print(\" !! I don't know how to format this object!\")\n        print(thing)\n\ndef originFormat_listOfDicts_flat_flat(thing):\n    \"\"\"Try to format anything as a 2D matrix with column names.\"\"\"\n    if type(thing",
        "\n\ndef pickle_load(fname):\n    \"\"\"load something from a pickle file\"\"\"\n    thing = pickle.load(open(fname,\"rb\"))\n    return thing\n\ndef pickle_load_all(fname):\n    \"\"\"load all things from a pickle file\"\"\"\n    thing = pickle.loadall(open(fname,\"rb\"))\n    return thing\n\ndef pickle_load_all_with_prefix(fname,prefix):\n    \"\"\"load all things from a pickle file with a prefix\"\"\"\n    thing = pickle.loadall(open(fname,\"rb\"),prefix=prefix)\n    return thing\n\ndef pickle_load_all_with_suffix(fname,suffix):\n    \"\"\"load all things from a pickle file with a suffix\"\"\"\n    thing = pickle.loadall(open(fname,\"rb\"),suffix=suffix)\n    return thing\n\ndef pickle_load_all_with_prefix_and_suffix(fname,prefix,suffix):\n    \"\"\"load all things from a pickle file with a prefix and suffix\"\"\"\n    thing = pickle.loadall(open(fname,\"rb\"),prefix=prefix,suffix=suffix)\n    return thing\n\ndef pickle_load_all_with_prefix_and_suffix_and_prefix(fname,prefix,suffix,prefix2):\n    \"\"\"load all things from a pickle file with a",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef determineProtocolName(fname):\n    \"\"\"determine the name of the protocol.\"\"\"\n    f=open(fname,'rb')\n    raw=f.read(5000) #it should be in the first 5k of the file\n    f.close()\n    protoComment=\"unknown\"\n    if b\"SWHLab4[\" in raw:\n        protoComment=raw.split(b\"SWHLab4[\")[1].split(b\"]\",1)[0]\n    elif b\"SWH[\" in raw:\n        protoComment=raw.split(b\"SWH[\")[1].split(b\"]\",1)[0]\n    else:\n        protoComment=\"?\"\n    if not type(protoComment) is str:\n        protoComment=protoComment.decode(\"utf-8\")\n    return protoComment\n\ndef determineProtocolVersion(fname):\n    \"\"\"determine the version of the protocol.\"\"\"\n    f=open(fname,'rb')\n    raw=f.read(5000) #it should be in the first 5k of the file\n    f.close()\n    protoComment=\"unknown\"\n    if b\"SWHLab4[\" in raw:\n        protoComment=raw.split(b\"SWHLab4[\")[1].split(b\"]\",1)[0]\n    elif b\"S",
        "\n\ndef getABFgroups(files):\n    \"\"\"\n    get the groups of files in the ABF directory.\n    \"\"\"\n    groups=[]\n    for file in files:\n        if file.endswith(\".abf\"):\n            groups.append(file[:-4])\n    return groups\n\ndef forwardSlash(files):\n    \"\"\"\n    return a list of files with a slash in between.\n    \"\"\"\n    return [f for f in files if f.startswith(\"/\")]\n\ndef getABFfiles(files):\n    \"\"\"\n    return a list of files with a slash in between.\n    \"\"\"\n    return [f for f in files if f.endswith(\".abf\")]\n\ndef getABFfilesSWH(files):\n    \"\"\"\n    return a list of files with a slash in between.\n    \"\"\"\n    return [f for f in files if f.endswith(\".swhlab4\")]\n\ndef getABFfilesSWHlab(files):\n    \"\"\"\n    return a list of files with a slash in between.\n    \"\"\"\n    return [f for f in files if f.endswith(\".swhlab4.abf\")]\n\ndef getABFfilesSWHlab4(files):\n    \"\"\"\n    return a list of files with a slash",
        "\n\ndef getABF(abfFname):\n    \"\"\"given an ABF file name, return the ABF of its parent.\"\"\"\n    parentID=getParent(abfFname)\n    return os.path.basename(parentID)\n\ndef getABFName(abfFname):\n    \"\"\"given an ABF file name, return the ABF name.\"\"\"\n    return os.path.basename(abfFname)\n\ndef getABFPath(abfFname):\n    \"\"\"given an ABF file name, return the ABF path.\"\"\"\n    return os.path.dirname(abfFname)\n\ndef getABFPath2(abfFname):\n    \"\"\"given an ABF file name, return the ABF path.\"\"\"\n    return os.path.dirname(abfFname)\n\ndef getABFPath3(abfFname):\n    \"\"\"given an ABF file name, return the ABF path.\"\"\"\n    return os.path.dirname(abfFname)\n\ndef getABFPath4(abfFname):\n    \"\"\"given an ABF file name, return the ABF path.\"\"\"\n    return os.path.dirname(abfFname)\n\ndef getABFPath5(abfFname):\n    \"\"\"given an ABF file name, return the",
        "\n\ndef getParent(abfFname,groups):\n    \"\"\"given an ABF and the groups dict, return the ID of its parent.\"\"\"\n    if \".abf\" in abfFname:\n        abfFname=os.path.basename(abfFname).replace(\".abf\",\"\")\n    for parentID in groups.keys():\n        if abfFname in groups[parentID]:\n            return parentID\n    return abfFname\n\ndef getParent2(abfFname,groups):\n    \"\"\"given an ABF and the groups dict, return the ID of its parent.\"\"\"\n    if \".abf\" in abfFname:\n        abfFname=os.path.basename(abfFname).replace(\".abf\",\"\")\n    for parentID in groups.keys():\n        if abfFname in groups[parentID]:\n            return parentID\n    return abfFname\n\ndef getParent(abfFname,groups):\n    \"\"\"given an ABF and the groups dict, return the ID of its parent.\"\"\"\n    if \".abf\" in abfFname:\n        abfFname=os.path.basename(abfFname).replace(\".abf\",\"\")\n    for parentID in groups.keys():\n        if abfFname in",
        ".replace(\".abf\",\"\")\n\ndef getParent(abfFile):\n    \"\"\"given an ABF, return the parent directory\"\"\"\n    parent=os.path.dirname(abfFile)\n    while os.path.exists(parent):\n        parent=os.path.dirname(parent)\n    return parent\n\ndef getNotesForFile(file):\n    \"\"\"given a file, return the notes for the file\"\"\"\n    with open(file) as f:\n        raw=f.readlines()\n    for line in raw:\n        if line[0]=='~':\n            line=line[1:].strip()\n            if line.startswith(\"# \"):\n                while \"\\t\\t\" in line:\n                    line=line.replace(\"\\t\\t\",\"\\t\")\n                line=line.replace(\"\\t\",\"\\n\")\n                return line\n    return \"no notes found for %s\"%file\n\ndef getNotesForFileWithNotes(file, notes):\n    \"\"\"given a file, return the notes for the file\"\"\"\n    with open(file) as f:\n        raw=f.readlines()\n    for line in raw:\n        if line[0]=='~':\n            line=line[1:].strip()\n            if line.startswith(\"# \"):\n                while \"\\",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        " pylab.close('all')\n\ndef main():\n    \"\"\"Main function.\"\"\"\n    import sys\n    import os\n    import argparse\n    import numpy as np\n    import matplotlib.pyplot as plt\n    import swhlab\n    import swhlab.plot as swhplot\n    import swhlab.plot.sweep as swhplotsweep\n    import swhlab.plot.comments as swhplotcomments\n    import swhlab.plot.annotate as swhplotannotate\n    import swhlab.plot.sweep as swhplotsweep\n    import swhlab.plot.comments as swhplotcomments\n    import swhlab.plot.annotate as swhplotannotate\n    import swhlab.plot.sweep as swhplotsweep\n    import swhlab.plot.comments as swhplotcomments\n    import swhlab.plot.annotate as swhplotannotate\n    import swhlab.plot.sweep as swhplotsweep\n    import swhlab.plot.comments as swhplotcomments\n    import swhlab.plot.annotate as swhplotannotate\n    import swhlab.plot.sweep as swhplotsweep\n    import swhlab.plot.comments as swhplotcomments\n    import swhlab.plot",
        "\n\ndef ftp_logout():\n    \"\"\"logout from FTP.\"\"\"\n    ftp = ftp_login()\n    if ftp:\n        ftp.quit()\n        ftp.close()\n\ndef ftp_mkdir(folder):\n    \"\"\"create a folder in FTP.\"\"\"\n    ftp = ftp_login()\n    if ftp:\n        ftp.cwd(folder)\n        ftp.mkdir(folder)\n        ftp.quit()\n\ndef ftp_rmdir(folder):\n    \"\"\"delete a folder in FTP.\"\"\"\n    ftp = ftp_login()\n    if ftp:\n        ftp.cwd(folder)\n        ftp.rmdir(folder)\n        ftp.quit()\n\ndef ftp_chdir(folder):\n    \"\"\"change the current folder in FTP.\"\"\"\n    ftp = ftp_login()\n    if ftp:\n        ftp.cwd(folder)\n        ftp.quit()\n\ndef ftp_chmod(folder,mode):\n    \"\"\"change the mode of a folder in FTP.\"\"\"\n    ftp = ftp_login()\n    if ftp:\n        ftp.cwd(folder)\n        ftp.chmod(folder,mode)\n        ftp.quit()\n\ndef ftp_chown(folder,user,group):\n    \"\"\"change the owner of a folder in FTP.\"\"\"\n    ftp = ftp_login()\n    if ftp:\n        ftp.",
        ",deleteStuff=True):\n        if deleteStuff:\n            ftp.delete(localFolder)\n        else:\n            ftp.mkdir(localFolder)\n        ftp_folder_match(ftp,localFolder,deleteStuff=deleteStuff)\n\ndef ftp_upload(ftp,fname):\n    \"\"\"upload a file from localFolder to the current FTP folder.\"\"\"\n    ftp.put(fname,fname)\n\ndef ftp_delete(ftp,fname):\n    \"\"\"delete a file from localFolder to the current FTP folder.\"\"\"\n    ftp.delete(fname)\n\ndef ftp_list(ftp,localFolder):\n    \"\"\"list all files in localFolder.\"\"\"\n    return ftp.list(localFolder)\n\ndef ftp_list_files(ftp,localFolder,deleteStuff=True):\n    \"\"\"list all files in localFolder, including deleted files.\"\"\"\n    return ftp.list(localFolder,deleteStuff=deleteStuff)\n\ndef ftp_list_files_recursive(ftp,localFolder,deleteStuff=True):\n    \"\"\"list all files in localFolder, including deleted files, recursively.\"\"\"\n    return ftp.list(localFolder,deleteStuff=deleteStuff,recursive=True)\n\ndef ftp_list_files_recursive_recursive(ftp,localFolder,deleteStuff=True):\n    \"\"\"list",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef TK_askPassword2(title=\"input\",msg=\"type here:\"):\n    \"\"\"use the GUI to ask for a string.\"\"\"\n    root = tkinter.Tk()\n    root.withdraw() #hide tk window\n    root.attributes(\"-topmost\", True) #always on top\n    root.lift() #bring to top\n    value=tkinter.simpledialog.askstring(title,msg)\n    root.destroy()\n    return value\n\ndef TK_askPassword3(title=\"input\",msg=\"type here:\"):\n    \"\"\"use the GUI to ask for a string.\"\"\"\n    root = tkinter.Tk()\n    root.withdraw() #hide tk window\n    root.attributes(\"-topmost\", True) #always on top\n    root.lift() #bring to top\n    value=tkinter.simpledialog.askstring(title,msg)\n    root.destroy()\n    return value\n\ndef TK_askPassword4(title=\"input\",msg=\"type here:\"):\n    \"\"\"use the GUI to ask for a string.\"\"\"\n    root = tkinter.Tk()\n    root.withdraw() #hide tk window\n    root.attributes(\"-topmost\", True) #always on top\n    root.lift() #bring",
        "\n    root.mainloop()\n\ndef TK_message_box(title,msg):\n    \"\"\"use the GUI to pop up a message box.\"\"\"\n    root = tkinter.Tk()\n    root.withdraw() #hide tk window\n    root.attributes(\"-topmost\", True) #always on top\n    root.lift() #bring to top\n    tkinter.messagebox.showwarning(title, msg)\n    root.destroy()\n\ndef TK_message_box_ok(title,msg):\n    \"\"\"use the GUI to pop up a message box and return True.\"\"\"\n    root = tkinter.Tk()\n    root.withdraw() #hide tk window\n    root.attributes(\"-topmost\", True) #always on top\n    root.lift() #bring to top\n    tkinter.messagebox.showwarning(title, msg)\n    return tkinter.messagebox.askyesno(title)\n\ndef TK_message_box_cancel(title,msg):\n    \"\"\"use the GUI to pop up a message box and return False.\"\"\"\n    root = tkinter.Tk()\n    root.withdraw() #hide tk window\n    root.attributes(\"-topmost\", True) #always on top\n    root.lift() #bring to top\n    return",
        "\n\ndef TK_askyesno(title,msg):\n    \"\"\"use the GUI to ask YES or NO.\"\"\"\n    root = tkinter.Tk()\n    root.attributes(\"-topmost\", True) #always on top\n    root.withdraw() #hide tk window\n    result=tkinter.messagebox.askyesno(title,msg)\n    root.destroy()\n    return result\n\ndef TK_askyesno_default(title,msg):\n    \"\"\"use the GUI to ask YES or NO.\"\"\"\n    root = tkinter.Tk()\n    root.attributes(\"-topmost\", True) #always on top\n    root.withdraw() #hide tk window\n    result=tkinter.messagebox.askyesno_default(title,msg)\n    root.destroy()\n    return result\n\ndef TK_askyesno_default_default(title,msg):\n    \"\"\"use the GUI to ask YES or NO.\"\"\"\n    root = tkinter.Tk()\n    root.attributes(\"-topmost\", True) #always on top\n    root.withdraw() #hide tk window\n    result=tkinter.messagebox.askyesno_default_default(title,msg)\n    root.destroy()\n    return result\n\ndef TK_askyesno_default",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n    return msg\n\ndef stats_second(abf):\n    \"\"\"provide all stats on the second AP.\"\"\"\n    msg=\"\"\n    for sweep in range(abf.sweeps):\n        for AP in abf.APs[sweep]:\n            for key in sorted(AP.keys()):\n                if key[-1] is \"I\" or key[-2:] in [\"I1\",\"I2\"]:\n                    continue\n                msg+=\"%s = %s\\n\"%(key,AP[key])\n            return msg\n    return msg\n\ndef stats_third(abf):\n    \"\"\"provide all stats on the third AP.\"\"\"\n    msg=\"\"\n    for sweep in range(abf.sweeps):\n        for AP in abf.APs[sweep]:\n            for key in sorted(AP.keys()):\n                if key[-1] is \"I\" or key[-2:] in [\"I1\",\"I2\"]:\n                    continue\n                msg+=\"%s = %s\\n\"%(key,AP[key])\n            return msg\n    return msg\n\ndef stats_fourth(abf):\n    \"\"\"provide all stats on the fourth AP.\"\"\"\n    msg=\"\"\n    for sweep in range(abf.sweeps):\n        for AP in ab",
        "\n\ndef getAvgByFeature(abf,feature,T0=None,T1=None):\n    \"\"\"return average of a feature divided by sweep.\"\"\"\n    if T1 is None:\n        T1=abf.sweepLength\n    if T0 is None:\n        T0=0\n    data = [np.empty((0))]*abf.sweeps\n    for AP in cm.dictFlat(cm.matrixToDicts(abf.APs)):\n        if T0<AP['sweepT']<T1:\n            val=AP[feature]\n            data[int(AP['sweep'])]=np.concatenate((data[int(AP['sweep'])],[val]))\n    for sweep in range(abf.sweeps):\n        if len(data[sweep])>1 and np.any(data[sweep]):\n            data[sweep]=np.nanmean(data[sweep])\n        elif len(data[sweep])==1:\n            data[sweep]=data[sweep][0]\n        else:\n            data[sweep]=np.nan\n    return data\n\ndef getAvgByFeatureAndSweep(abf,feature,T0=None,T1=None):\n    \"\"\"return average",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef annotate(abf):\n    \"\"\"\n    Annotate the ABF with the given tag.\n    \"\"\"\n    if tag:\n        fname = abf.outpath+abf.ID+\"_\"+tag+\".png\"\n    else:\n        fname = abf.outpath+abf.ID+\".png\"\n    pylab.annotate(abf.ID,abf.X,abf.Y,text=abf.ID,fontsize=12,facecolor='w',\n                  ha='center',va='center',fontsize=12,facecolor='w',\n                  bbox_to_anchor=(0.5,0.5),\n                  bbox_inches='tight')\n    pylab.annotate(abf.X,abf.Y,text=abf.X,fontsize=12,facecolor='w',\n                  ha='center',va='center',fontsize=12,facecolor='w',\n                  bbox_to_anchor=(0.5,0.5),\n                  bbox_inches='tight')\n    pylab.annotate(abf.X,abf.Y,text=abf.X,fontsize=12,facecolor='w',\n                  ha='center',va='center',fontsize=12,facecolor='w',\n                  bbox_to_anchor=(0",
        " True\n\ndef loadModule(moduleName):\n    \"\"\"load a module from the local folder.\"\"\"\n    tryLoadingFrom(os.path.dirname(__file__),moduleName)\n    return getattr(swhlab,moduleName)\n\ndef loadModuleFrom(moduleName):\n    \"\"\"load a module from a given path.\"\"\"\n    tryLoadingFrom(os.path.dirname(__file__),moduleName)\n    return getattr(swhlab,moduleName)\n\ndef loadModuleFromPath(moduleName):\n    \"\"\"load a module from a given path.\"\"\"\n    tryLoadingFrom(os.path.dirname(__file__),moduleName)\n    return getattr(swhlab,moduleName)\n\ndef loadModuleFromPackage(moduleName):\n    \"\"\"load a module from a given package.\"\"\"\n    tryLoadingFrom(os.path.dirname(__file__),moduleName)\n    return getattr(swhlab,moduleName)\n\ndef loadModuleFromPackagePath(moduleName):\n    \"\"\"load a module from a given package path.\"\"\"\n    tryLoadingFrom(os.path.dirname(__file__),moduleName)\n    return getattr(swhlab,moduleName)\n\ndef loadModuleFromPackagePackage(moduleName):\n    \"\"\"load a module from a given package package.\"\"\"\n    tryLoadingFrom(os.path.",
        "\n            self.trace.append((outputs, self._next_val))\n\ndef _update_state(self, outputs):\n    \"\"\"\n    This method is called by the iterator to determine the next\n    desired point in the parameter space.  It is called by the\n    output_extractor to parse the output values and return\n    them as a tuple.\n    \"\"\"\n    return tuple(self.output_extractor(contents))\n\ndef _trace(self, outputs, next_val):\n    \"\"\"\n    This method is called by the iterator to trace the output\n    values and return them as a tuple.\n    \"\"\"\n    return tuple(outputs)\n\ndef _trace_all(self, outputs, next_val):\n    \"\"\"\n    This method is called by the iterator to trace the output\n    values and return them as a tuple.\n    \"\"\"\n    return tuple(outputs)\n\ndef _trace_all_all(self, outputs, next_val):\n    \"\"\"\n    This method is called by the iterator to trace the output\n    values and return them as a tuple.\n    \"\"\"\n    return tuple(outputs)\n\ndef _trace_all_none(self, outputs, next_val):\n    \"\"\"\n    This method is called by the iterator to trace the output\n    values and return them as a tuple.\n    \"\"\"\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        else:\n            plt.close()\n\ndef save_all(self,callit=\"misc\",closeToo=True,fullpath=False):\n        \"\"\"save all the existing figures. does not close them.\"\"\"\n        if fullpath is False:\n            fname=self.abf.outPre+\"plot_\"+callit+\".jpg\"\n        else:\n            fname=callit\n        if not os.path.exists(os.path.dirname(fname)):\n            os.mkdir(os.path.dirname(fname))\n        plt.savefig(fname)\n        self.log.info(\"saved [%s]\",os.path.basename(fname))\n        if closeToo:\n            plt.close()\n        else:\n            plt.close()\n\ndef save_all_all(self,callit=\"misc\",closeToo=True,fullpath=False):\n        \"\"\"save all the existing figures. does not close them.\"\"\"\n        if fullpath is False:\n            fname=self.abf.outPre+\"plot_\"+callit+\".jpg\"\n        else:\n            fname=callit\n        if not os.path.exists(os.path.dirname(fname)):\n            os.mkdir(os.path.dirname(fname))\n        plt.savefig(fname)\n        self.log.",
        "\n        self.log.debug(\"creating overlayed sweeps plot\")\n        self.figure()\n        for sweep in range(self.abf.sweeps):\n            self.abf.setsweep(sweep)\n            self.setColorBySweep()\n            plt.plot(self.abf.sweepX2+sweep*offsetX,\n                     self.abf.sweepY+sweep*offsetY,\n                     **self.kwargs)\n        if offsetX:\n            self.marginX=.05\n        self.decorate()\n        self.log.debug(\"creating overlayed sweeps plot\")\n        self.figure()\n        for sweep in range(self.abf.sweeps):\n            self.abf.setsweep(sweep)\n            self.setColorBySweep()\n            plt.plot(self.abf.sweepX2+sweep*offsetX,\n                     self.abf.sweepY+sweep*offsetY,\n                     **self.kwargs)\n        if offsetX:\n            self.marginX=.05\n        self.decorate()\n        self.log.debug(\"creating overlayed sweeps plot\")\n        self.figure()\n        for sweep in range(self.abf.sweeps):\n            self.abf.sets",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef clampfit_rename_all(path,char):\n    \"\"\"\n    Given ABFs and TIFs formatted long style, rename each of them to prefix their number with a different number.\n\n    Example: 2017_10_11_0011.abf\n    Becomes: 2017_10_11_?011.abf\n    where ? can be any character.\n    \"\"\"\n    assert len(char)==1 and type(char)==str, \"replacement character must be a single character\"\n    assert os.path.exists(path), \"path doesn't exist\"\n    files = sorted(os.listdir(path))\n    files = [x for x in files if len(x)>18 and x[4]+x[7]+x[10]=='___']\n    for fname in files:\n        fname2 = list(fname)\n        fname2[11]=char\n        fname2=\"\".join(fname2)\n\n        if fname==fname2:\n            print(fname, \"==\", fname2)\n        else:\n            print(fname, \"->\", fname2)\n#            fname=os.path.join(path,fname)\n#            fname2=os.path.join(path,fname2)\n#            if not os.path.exists(fname2):\n#",
        "\n\ndef filesByExtension2(fnames):\n    \"\"\"given a list of files, return a dict organized by extension.\"\"\"\n    byExt={\"abf\":[],\"jpg\":[],\"tif\":[]} # prime it with empties\n    for fname in fnames:\n        ext = os.path.splitext(fname)[1].replace(\".\",'').lower()\n        if not ext in byExt.keys():\n            byExt[ext]=[]\n        byExt[ext]=byExt[ext]+[fname]\n    return byExt\n\ndef filesByExtension3(fnames):\n    \"\"\"given a list of files, return a dict organized by extension.\"\"\"\n    byExt={\"abf\":[],\"jpg\":[],\"tif\":[]} # prime it with empties\n    for fname in fnames:\n        ext = os.path.splitext(fname)[1].replace(\".\",'').lower()\n        if not ext in byExt.keys():\n            byExt[ext]=[]\n        byExt[ext]=byExt[ext]+[fname]\n    return byExt\n\ndef filesByExtension4(fnames):\n    \"\"\"given a list of files, return a dict organized by extension.\"\"\"\n    byExt={\"abf\":[],\"jpg\":[],\"",
        "\n\ndef filesByCell2(fnames,cells):\n    \"\"\"given files and cells, return a dict of files grouped by cell.\"\"\"\n    byCell={}\n    fnames=smartSort(fnames)\n    days = list(set([elem[:5] for elem in fnames if elem.endswith(\".abf\")])) # so pythonic!\n    for day in smartSort(days):\n        parent=None\n        for i,fname in enumerate([elem for elem in fnames if elem.startswith(day) and elem.endswith(\".abf\")]):\n            ID=os.path.splitext(fname)[0]\n            if len([x for x in fnames if x.startswith(ID)])-1:\n                parent=ID\n            if not parent in byCell:\n                byCell[parent]=[]\n            byCell[parent]=byCell[parent]+[fname]\n    return byCell\n\ndef filesByCell3(fnames,cells):\n    \"\"\"given files and cells, return a dict of files grouped by cell.\"\"\"\n    byCell={}\n    fnames=smartSort(fnames)\n    days = list(set([elem[:5] for elem in fnames if elem.endswith(\".abf\")])) # so pythonic!\n    for day in smartSort(days):\n        parent=None",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef html_single_fixed(self,fname):\n        \"\"\"generate a data view for a fixed ABF in the project folder.\"\"\"\n        self.html_single_basic(fname)\n\ndef html_single_basic(self,fname):\n        \"\"\"generate a data view for a basic ABF in the project folder.\"\"\"\n        self.html_single_basic_fixed(fname)\n\ndef html_single_basic_fixed(self,fname):\n        \"\"\"generate a data view for a basic ABF in the project folder.\"\"\"\n        self.html_single_basic_basic(fname)\n\ndef html_single_basic_basic(self,fname):\n        \"\"\"generate a data view for a basic ABF in the project folder.\"\"\"\n        self.html_single_basic_basic_fixed(fname)\n\ndef html_single_basic_basic_fixed(self,fname):\n        \"\"\"generate a data view for a basic ABF in the project folder.\"\"\"\n        self.html_single_basic_basic_basic(fname)\n\ndef html_single_basic_basic_basic(self,fname):\n        \"\"\"generate a data view for a basic ABF in the project folder.\"\"\"\n        self.html_single_basic_basic_basic_fixed(fname)\n\ndef html_single_basic_basic_basic_fixed(self,",
        "(abf)\n    return abf\n\ndef proto_01_01_HP011(abf=exampleABF):\n    \"\"\"hyperpolarization step. Use to calculate tau and stuff.\"\"\"\n    swhlab.plot.save(abf,tag=\"tau\")\n    return abf\n\ndef proto_01_01_HP012(abf=exampleABF):\n    \"\"\"hyperpolarization step. Use to calculate tau and stuff.\"\"\"\n    swhlab.plot.save(abf,tag=\"tau\")\n    return abf\n\ndef proto_01_01_HP013(abf=exampleABF):\n    \"\"\"hyperpolarization step. Use to calculate tau and stuff.\"\"\"\n    swhlab.plot.save(abf,tag=\"tau\")\n    return abf\n\ndef proto_01_01_HP014(abf=exampleABF):\n    \"\"\"hyperpolarization step. Use to calculate tau and stuff.\"\"\"\n    swhlab.plot.save(abf,tag=\"tau\")\n    return abf\n\ndef proto_01_01_HP015(abf=exampleABF):\n    \"\"\"hyperpolarization step. Use to calculate tau and stuff.\"\"\"\n    swhlab.plot.save(abf,tag=\"tau\")\n    return abf",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        ".save(abf,tag='gain_dual')\n\n    # plot the gain function\n    Xs=abf.clampValues(abf.dataX[int(abf.protoSeqX[1]+.01)])\n    swhlab.plot.new(abf,title=\"gain function\",xlabel=\"command current (pA)\",\n                    ylabel=\"average inst. freq. (Hz)\")\n    pylab.plot(Xs,f1,'.-',ms=20,alpha=.5,label=\"step 1\",color='b')\n    pylab.plot(Xs,f2,'.-',ms=20,alpha=.5,label=\"step 2\",color='r')\n    pylab.legend(loc='upper left')\n    pylab.axis([Xs[0],Xs[-1],None,None])\n    swhlab.plot.save(abf,tag='gain')\n\n    # plot the gain function\n    Xs=abf.clampValues(abf.dataX[int(abf.protoSeqX[1]+.01)])\n    swhlab.plot.new(abf,title=\"gain function\",xlabel=\"command current (pA)\",\n                    ylabel=\"average inst. freq. (Hz)\")\n    pylab.plot",
        "(abf)\n    swhlab.memtest.memtest(abf)\n    swhlab.memtest.checkSweep(abf)\n    swhlab.plot.save(abf,tag='check',resize=False)\n\ndef proto_02_01_MT80(abf=exampleABF):\n    \"\"\"repeated membrane tests.\"\"\"\n    standard_overlayWithAverage(abf)\n    swhlab.memtest.memtest(abf)\n    swhlab.memtest.checkSweep(abf)\n    swhlab.plot.save(abf,tag='check',resize=False)\n\ndef proto_02_01_MT90(abf=exampleABF):\n    \"\"\"repeated membrane tests.\"\"\"\n    standard_overlayWithAverage(abf)\n    swhlab.memtest.memtest(abf)\n    swhlab.memtest.checkSweep(abf)\n    swhlab.plot.save(abf,tag='check',resize=False)\n\ndef proto_02_01_MT100(abf=exampleABF):\n    \"\"\"repeated membrane tests.\"\"\"\n    standard_overlayWithAverage(abf)\n    swhlab.memtest.memtest(abf)\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\nclass BaseActivatableModel(models.Model):\n    \"\"\"\n    A base class for all activatable models.\n    \"\"\"\n    ACTIVATABLE_FIELD_NAME = 'is_active'\n    ACTIVATABLE_FIELD_UPDATED = 'activatable_field_updated'\n\n    def __init__(self, *args, **kwargs):\n        super(BaseActivatableModel, self).__init__(*args, **kwargs)\n        self.activatable_field_updated = False\n\n    def save(self, *args, **kwargs):\n        \"\"\"\n        A custom save method that handles figuring out when something is activated or deactivated.\n        \"\"\"\n        current_activable_value = getattr(self, self.ACTIVATABLE_FIELD_NAME)\n        is_active_changed = self.id is None or self.__original_activatable_value != current_activable_value\n        self.__original_activable_value = current_activable_value\n\n        ret_val = super(BaseActivatableModel, self).save(*args, **kwargs)\n\n        # Emit the signals for when the is_active flag is changed\n        if is_active_changed:\n            model_activations_changed.send(self.__class__, instance_ids=[self.id], is_active=current_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        for key, value in info.items():\n            full_string += '%s: %s\\n' % (key, value)\n        return full_string\n\ndef main(args):\n    \"\"\"\n    Main function\n    \"\"\"\n    if args.help:\n        print(show(args))\n        return\n    if args.version:\n        print(__version__)\n        return\n    if args.version_check:\n        print(__version_check__)\n        return\n    if args.version_check_all:\n        print(__version_check_all__)\n        return\n    if args.version_check_all_all:\n        print(__version_check_all_all__)\n        return\n    if args.version_check_all_all_all:\n        print(__version_check_all_all_all__)\n        return\n    if args.version_check_all_all_all:\n        print(__version_check_all_all_all__)\n        return\n    if args.version_check_all_all_all_all:\n        print(__version_check_all_all_all_all__)\n        return\n    if args.version_check_all_all_all_all:\n        print(__version_check",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".append)\n\ndef _get_spec_log(self):\n        \"\"\"\n        Returns a list of tuples (tids, specs) where each tuple is a tuple\n        (tid, spec) where the spec is a dict with the following keys:\n            - tids: The tids of the specs\n            - specs: The specs of the specs\n        \"\"\"\n        return self._spec_log\n\ndef _get_spec_specs(self):\n        \"\"\"\n        Returns a list of tuples (tids, specs) where each tuple is a tuple\n        (tid, spec) where the spec is a dict with the following keys:\n            - tids: The tids of the specs\n            - specs: The specs of the specs\n        \"\"\"\n        return [(tid, spec) for (tid, spec) in self._spec_log]\n\ndef _get_spec_specs_by_tids(self, tids):\n        \"\"\"\n        Returns a list of tuples (tids, specs) where each tuple is a tuple\n        (tid, spec) where the spec is a dict with the following keys:\n            - tids: The tids of the specs\n            - specs: The specs of the specs\n        \"\"\"\n        return [(tid, spec) for (tid, spec) in self._spec_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n            else:\n                break\n\n        # Wait for all processes to complete\n        while len(processes) > 0:\n            if not check_complete_processes(True):\n                time.sleep(0.1)\n            else:\n                break\n\n        return processes\n\ndef _launch_process_group_with_timeout(self, process_commands, streams_path, timeout):\n        \"\"\"\n        Launches processes defined by process_commands, but only\n        executes max_concurrency processes at a time; if a process\n        completes and there are still outstanding processes to be\n        executed, the next processes are run until max_concurrency is\n        reached again.\n        \"\"\"\n        processes = {}\n        def check_complete_processes(wait=False):\n            \"\"\"\n            Returns True if a process completed, False otherwise.\n            Optionally allows waiting for better performance (avoids\n            sleep-poll cycle if possible).\n            \"\"\"\n            result = False\n            # list creates copy of keys, as dict is modified in loop\n            for proc in list(processes):\n                if wait: proc.wait()\n                if proc.poll() is not None:\n                    # process is done, free up slot\n                    self.debug(\"Process %d exited with code %d.\"\n                               % (processes[proc]['tid'], proc.poll()))\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _qsub_args(self, overrides, cmd_args):\n        \"\"\"\n        The method that actually runs qsub to invoke the python\n        process with the necessary commands to trigger the next\n        collation step and next block of jobs.\n        \"\"\"\n\n        cmd_args = [self.command.executable,\n                    '-c', ';'.join(cmd_args)]\n        popen_args = self._qsub_args_override(overrides, cmd_args)\n\n        return popen_args\n\ndef _qsub_args_override(self, overrides, cmd_args):\n        \"\"\"\n        The method that actually runs qsub to invoke the python\n        process with the necessary commands to trigger the next\n        collation step and next block of jobs.\n        \"\"\"\n\n        cmd_args = [self.command.executable,\n                    '-c', ';'.join(cmd_args)]\n        popen_args = self._qsub_args(overrides, cmd_args)\n\n        return popen_args\n\ndef _qsub_args(self, overrides, cmd_args):\n        \"\"\"\n        The method that actually runs qsub to invoke the python\n        process with the necessary commands to trigger the next\n        collation step and next block of jobs.\n        \"\"\"\n\n        cmd_args = [self.command.executable,\n                    '-c",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n        return processes\n\ndef _launch_process_group_with_streams(self, process_commands, streams_path):\n        \"\"\"\n        Aggregates all process_commands and the designated output files into a\n        list, and outputs it as JSON, after which the wrapper script is called.\n        \"\"\"\n        processes = []\n        for cmd, tid in process_commands:\n            job_timestamp = time.strftime('%H%M%S')\n            basename = \"%s_%s_tid_%d\" % (self.batch_name, job_timestamp, tid)\n            stdout_path = os.path.join(streams_path, \"%s.o.%d\" % (basename, tid))\n            stderr_path = os.path.join(streams_path, \"%s.e.%d\" % (basename, tid))\n            process = { 'tid' : tid,\n                        'cmd' : cmd,\n                        'stdout' : stdout_path,\n                        'stderr' : stderr_path }\n            processes.append(process)\n\n        p = subprocess.Popen([self.script_path, json_path, self.batch_name,\n                              str(len(processes)), str(self.max_concurrency)])\n        if p.wait() != 0:\n            raise EnvironmentError(\"Script command exit with code",
        "\n\n        for launcher in launchers:\n            command = launcher.command\n            args = launcher.args\n            command.verify(args)\n            root_directory = launcher.get_root_directory()\n            if os.path.isdir(root_directory):\n                raise Exception(\"Root directory already exists: %r\" % root_directory)\n            if root_directory not in root_directories:\n                raise Exception(\"Each launcher requires a unique root directory\")\n            root_directories.append(root_directory)\n\n        for launcher in launchers:\n            command = launcher.command\n            args = launcher.args\n            command.verify(args)\n            root_directory = launcher.get_root_directory()\n            if os.path.isdir(root_directory):\n                raise Exception(\"Root directory already exists: %r\" % root_directory)\n            if root_directory not in root_directories:\n                raise Exception(\"Each launcher requires a unique root directory\")\n            root_directories.append(root_directory)\n\n        for launcher in launchers:\n            command = launcher.command\n            args = launcher.args\n            command.verify(args)\n            root_directory = launcher.get_root_directory()\n            if os.path.isdir(root_directory):\n                raise Exception(\"Root directory already exists: %r",
        "\n\ndef _launch_all_with_args(self, args):\n        \"\"\"\n        Launches all available launchers with the given arguments.\n        \"\"\"\n        for launcher in args:\n            print(\"== Launching  %s ==\" % launcher.batch_name)\n            launcher()\n        return\n\ndef _launch_all_with_args_and_args(self, args, args2):\n        \"\"\"\n        Launches all available launchers with the given arguments and\n        arguments2.\n        \"\"\"\n        for launcher in args:\n            print(\"== Launching  %s ==\" % launcher.batch_name)\n            launcher()\n        return\n\ndef _launch_all_with_args_and_args2(self, args, args2, args3):\n        \"\"\"\n        Launches all available launchers with the given arguments and\n        arguments2 and arguments3.\n        \"\"\"\n        for launcher in args:\n            print(\"== Launching  %s ==\" % launcher.batch_name)\n            launcher()\n        return\n\ndef _launch_all_with_args_and_args3(self, args, args2, args3, args4):\n        \"\"\"\n        Launches all available launchers with the given arguments and\n        arguments2 and arguments3 and arguments4.\n        \"\"\"\n        for launcher",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support",
        ")\n        return self.save_metadata(filename, metadata, **data)\n\ndef load(self, filename,  metadata={}, **data):\n        \"\"\"\n        The implementation in the base class simply checks there is no\n        clash between the metadata and data keys.\n        \"\"\"\n        intersection = set(metadata.keys()) & set(data.keys())\n        if intersection:\n            msg = 'Key(s) overlap between data and metadata: %s'\n            raise Exception(msg  % ','.join(intersection))\n        return self.load_metadata(filename, metadata, **data)\n\ndef save_metadata(self, filename, metadata, **data):\n        \"\"\"\n        Save the given metadata to the given filename.\n        \"\"\"\n        with open(filename, 'wb') as f:\n            f.write(json.dumps(metadata, indent=2))\n\ndef load_metadata(self, filename, metadata, **data):\n        \"\"\"\n        Load the given metadata from the given filename.\n        \"\"\"\n        with open(filename, 'rb') as f:\n            return json.loads(f.read())\n\ndef save_data(self, filename, data, **metadata):\n        \"\"\"\n        Save the given data to the given filename.\n        \"\"\"\n        with open(filename, 'wb') as f:\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        return True\n\nclass File(object):\n    \"\"\"\n    A class that can be used to store files.\n    \"\"\"\n    def __init__(self, filename):\n        self.filename = filename\n        self.extensions = []\n\n    def __str__(self):\n        return self.filename\n\n    def __repr__(self):\n        return \"<File %r>\" % self.filename\n\n    def __eq__(self, other):\n        return self.filename == other.filename\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __len__(self):\n        return len(self.extensions)\n\n    def __getitem__(self, index):\n        return self.extensions[index]\n\n    def __setitem__(self, index, value):\n        self.extensions[index] = value\n\n    def __delitem__(self, index):\n        del self.extensions[index]\n\n    def __iter__(self):\n        return iter(self.extensions)\n\n    def __len__(self):\n        return len(self.extensions)\n\n    def __contains__(self, value):\n        return value in self.extensions\n\n    def __contains_key(self, key):\n        return key",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        ".strftime('%Y-%m-%d', time.localtime(modifiedTime))\r\n\r\ndef fileLastModified(fname):\r\n    \"\"\"return \"YYYY-MM-DD\" when the file was modified.\"\"\"\r\n    modifiedTime=os.path.getmtime(fname)\r\n    stamp=time.strftime('%Y-%m-%d', time.localtime(modifiedTime))\r\n    return stamp\r\n\r\ndef fileLastModifiedTimestamp(fname):\r\n    \"\"\"return \"YYYY-MM-DD\" when the file was modified.\"\"\"\r\n    modifiedTime=os.path.getmtime(fname)\r\n    stamp=time.strftime('%Y-%m-%d', time.localtime(modifiedTime))\r\n    return stamp\r\n\r\ndef fileLastModifiedTimestamp(fname):\r\n    \"\"\"return \"YYYY-MM-DD\" when the file was modified.\"\"\"\r\n    modifiedTime=os.path.getmtime(fname)\r\n    stamp=time.strftime('%Y-%m-%d', time.localtime(modifiedTime))\r\n    return stamp\r\n\r\ndef fileLastModifiedTimestamp(fname):\r\n    \"\"\"return \"YYYY-MM-DD\" when the file was modified.\"\"\"\r\n    modifiedTime=os.path.getmtime(fname)\r\n    stamp=time.strftime('%Y-%m-%d', time.local",
        "\r\n\r\ndef saveResults(resultsFile,foldersByDay):\r\n    \"\"\"saves a dict of active folders with days as keys.\"\"\"\r\n    with open(resultsFile, \"w\") as f:\r\n        f.write(\"# Active folders\\n\")\r\n        for day in sorted(foldersByDay.keys()):\r\n            f.write(\"# %s\\n\"%(day))\r\n            for folder in foldersByDay[day]:\r\n                f.write(\"# %s\\n\"%(folder))\r\n        f.write(\"#\\n\")\r\n\r\ndef main():\r\n    \"\"\"main function.\"\"\"\r\n    if len(sys.argv)<2:\r\n        print(\"Usage: %s <results file>\"%(sys.argv[0]))\r\n        sys.exit(1)\r\n    resultsFile=sys.argv[1]\r\n    foldersByDay=loadResults(resultsFile)\r\n    saveResults(resultsFile,foldersByDay)\r\n\r\nif __name__==\"__main__\":\r\n    main()\r\n",
        "\n\ndef ndist_hist(data,Xs):\n    \"\"\"\n    given some data and a list of X posistions, return the normal\n    distribution curve as a Y point at each of those Xs.\n    \"\"\"\n    sigma=np.sqrt(np.var(data))\n    center=np.average(data)\n    curve=mlab.normpdf(Xs,center,sigma)\n    curve*=len(data)*HIST_RESOLUTION\n    return curve\n\ndef ndist_hist_hist(data,Xs):\n    \"\"\"\n    given some data and a list of X posistions, return the normal\n    distribution curve as a Y point at each of those Xs.\n    \"\"\"\n    sigma=np.sqrt(np.var(data))\n    center=np.average(data)\n    curve=mlab.normpdf(Xs,center,sigma,hist=True)\n    curve*=len(data)*HIST_RESOLUTION\n    return curve\n\ndef ndist_hist_hist_hist(data,Xs):\n    \"\"\"\n    given some data and a list of X posistions, return the normal\n    distribution curve as a Y point at each of those Xs.\n    \"\"\"\n    sigma=np.sqrt(np.var(data))\n    center=",
        "\n\ndef abfinfo(self,printToo=False,returnDict=False):\n        \"\"\"show basic info about ABF class variables.\"\"\"\n        info=\"\\n### ABF INFO ###\\n\"\n        d={}\n        for thingName in sorted(dir(self)):\n            if thingName in ['cm','evIs','colormap','dataX','dataY',\n                             'protoX','protoY']:\n                continue\n            if \"_\" in thingName:\n                continue\n            thing=getattr(self,thingName)\n            if type(thing) is list and len(thing)>5:\n                continue\n            thingType=str(type(thing)).split(\"'\")[1]\n            if \"method\" in thingType or \"neo.\" in thingType:\n                continue\n            if thingName in [\"header\",\"MT\"]:\n                continue\n            info+=\"%s <%s> %s\\n\"%(thingName,thingType,thing)\n            d[thingName]=thing\n        if printToo:\n            print()\n            for line in info.split(\"\\n\"):\n                if len(line)<3:\n                    continue\n                print(\"   \",line)\n            print()\n        if returnDict:\n            return d\n        return info\n\ndef abfinfo2(self,printToo=",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef generate_colors(self,colors=None,reverse=False):\n        \"\"\"use 1 color for the whole abf. You can change it!.\"\"\"\n        if colors is None:\n            colors = pylab.cm.Dark2\n        self.colors=colors\n        if reverse:\n            self.colors.reverse()\n\ndef generate_colors_from_array(self,colors=None,reverse=False):\n        \"\"\"use 1 color for the whole abf. You can change it!.\"\"\"\n        if colors is None:\n            colors = pylab.cm.Dark2\n        self.colors=colors\n        if reverse:\n            self.colors.reverse()\n\ndef generate_colors_from_array_with_colors(self,colors=None,reverse=False):\n        \"\"\"use 1 color for the whole abf. You can change it!.\"\"\"\n        if colors is None:\n            colors = pylab.cm.Dark2\n        self.colors=colors\n        if reverse:\n            self.colors.reverse()\n\ndef generate_colors_from_array_with_colors_and_colors(self,colors=None,reverse=False):\n        \"\"\"use 1 color for the whole abf. You can change it!.\"\"\"\n        if colors is None:\n            colors = pylab.cm.Dark",
        "\n\ndef get_data_around_time(self,timePoints,thisSweep=False,padding=0.02,msDeriv=0):\n        \"\"\"\n        return self.dataY around a time point. All units are seconds.\n        if thisSweep==False, the time point is considered to be experiment time\n            and an appropriate sweep may be selected. i.e., with 10 second\n            sweeps and timePint=35, will select the 5s mark of the third sweep\n        \"\"\"\n        if not np.array(timePoints).shape:\n            timePoints=[float(timePoints)]\n        data=None\n        for timePoint in timePoints:\n            if thisSweep:\n                sweep=self.currentSweep\n            else:\n                sweep=int(timePoint/self.sweepInterval)\n                timePoint=timePoint-sweep*self.sweepInterval\n            self.setSweep(sweep)\n            if msDeriv:\n                dx=int(msDeriv*self.rate/1000) #points per ms\n                newData=(self.dataY[dx:]-self.dataY[:-dx])*self.rate/1000/dx\n            else:\n                newData=self.dataY\n            padPoints=int(padding*self.rate)\n            pad=np.empty(padPoints",
        "\n\ndef filter_gaussian_mean(self,sigmaMs=100,applyFiltered=False,applyBaseline=False):\n        \"\"\"RETURNS filtered trace. Desn't filter it in place.\"\"\"\n        if sigmaMs==0:\n            return self.dataY\n        filtered=cm.filter_gaussian_mean(self.dataY,sigmaMs)\n        if applyBaseline:\n            self.dataY=self.dataY-filtered\n        elif applyFiltered:\n            self.dataY=filtered\n        else:\n            return filtered\n\ndef filter_gaussian_std(self,sigmaMs=100,applyFiltered=False,applyBaseline=False):\n        \"\"\"RETURNS filtered trace. Desn't filter it in place.\"\"\"\n        if sigmaMs==0:\n            return self.dataY\n        filtered=cm.filter_gaussian_std(self.dataY,sigmaMs)\n        if applyBaseline:\n            self.dataY=self.dataY-filtered\n        elif applyFiltered:\n            self.dataY=filtered\n        else:\n            return filtered\n\ndef filter_gaussian_var(self,sigmaMs=100,applyFiltered=False,applyBaseline=False):\n        \"\"\"RETURNS filtered trace. Desn't filter it in place.\"\"\"\n        if sigmaMs==0:\n            return self.dataY\n",
        "\n\n        # Ensure all foreign keys and onetoone fields will not result in cascading deletes if not cascade deletable\n        if not model.ALLOW_CASCADE_DELETE:\n            for field in model._meta.fields:\n                if field.__class__ in (models.ForeignKey, models.OneToOneField):\n                    if field.remote_field.on_delete == models.CASCADE:\n                        raise ValidationError((\n                            'Model {0} is an activatable model. All ForeignKey and OneToOneFields '\n                            'must set on_delete methods to something other than CASCADE (the default). '\n                            'If you want to explicitely allow cascade deletes, then you must set the '\n                            'ALLOW_CASCADE_DELETE=True class variable on your model.'\n                        ).format(model))\n\n        # Ensure all foreign keys and onetoone fields will not result in cascading deletes if not cascade deletable\n        if not model.ALLOW_CASCADE_DELETE:\n            for field in model._meta.fields:\n                if field.__class__ in (models.ForeignKey, models.OneToOneField):\n                    if field.remote_field.on_delete == models.CASCADE:\n                        raise ValidationError((\n                            'Model {0} is an activatable model. All ForeignKey and OneToOneFields '\n                            'must set on_delete methods to something other than",
        ".keys()]\n\ndef to_table_with_vdims(args, vdims=[]):\n    \"Helper function to convet an Args object to a HoloViews Table\"\n    if not Table:\n        return \"HoloViews Table not available\"\n    kdims = [dim for dim in args.constant_keys + args.varying_keys\n             if dim not in vdims]\n    items = [tuple([spec[k] for k in kdims+vdims])\n             for spec in args.specs]\n    return Table(items, kdims=kdims, vdims=vdims)\n\ndef to_table_with_vdims_and_specs(args, vdims=[]):\n    \"Helper function to convet an Args object to a HoloViews Table\"\n    if not Table:\n        return \"HoloViews Table not available\"\n    kdims = [dim for dim in args.constant_keys + args.varying_keys\n             if dim not in vdims]\n    items = [tuple([spec[k] for k in kdims+vdims])\n             for spec in args.specs]\n    return Table(items, kdims=kdims, vdims=vdims)\n\ndef to_table_with_vdims_and_specs_and_specs(args, v",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ")\n\ndef spec_formatter_list(cls, spec):\n        \" Formats the elements of an argument set appropriately\"\n        return type(spec)((k, str(v)) for (k,v) in spec.items())\n\ndef spec_formatter_dict(cls, spec):\n        \" Formats the elements of an argument set appropriately\"\n        return type(spec)((k, str(v)) for (k,v) in spec.items())\n\ndef spec_formatter_tuple(cls, spec):\n        \" Formats the elements of an argument set appropriately\"\n        return type(spec)((k, str(v)) for (k,v) in spec.items())\n\ndef spec_formatter_list_dict(cls, spec):\n        \" Formats the elements of an argument set appropriately\"\n        return type(spec)((k, str(v)) for (k,v) in spec.items())\n\ndef spec_formatter_tuple_dict(cls, spec):\n        \" Formats the elements of an argument set appropriately\"\n        return type(spec)((k, str(v)) for (k,v) in spec.items())\n\ndef spec_formatter_list_tuple(cls, spec):\n        \" Formats the elements of an argument set appropriately\"\n        return type(spec)((k, str",
        "\n\ndef _collect_by_value(self,specs):\n        \"\"\"\n        Returns a dictionary like object with the lists of values\n        collapsed by their respective value. Useful to find varying vs\n        constant values and to find how fast values vary.\n        \"\"\"\n        # Collect (key, value) tuples as list of lists, flatten with chain\n        allvalues = itertools.chain.from_iterable(\n            [[(k, run[k]) for k in run] for run in specs])\n        collection = defaultdict(list)\n        for (k,v) in allvalues: collection[v].append(run[k])\n        return collection\n\ndef _collect_by_key_and_value(self,specs):\n        \"\"\"\n        Returns a dictionary like object with the lists of values\n        collapsed by their respective key and value. Useful to find varying vs\n        constant keys and to find how fast keys vary.\n        \"\"\"\n        # Collect (key, value) tuples as list of lists, flatten with chain\n        allkeys = itertools.chain.from_iterable(\n            [[(k, run[k]) for k in run] for run in specs])\n        collection = defaultdict(list)\n        for (k,v) in allkeys: collection[k].append(v)\n        return collection\n\ndef _collect_by_key",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _build_kwargs(self, specs, kwargs, fp_precision):\n        \"\"\"\n        Returns the specs, the remaining kwargs and whether or not the\n        constructor was called with kwarg or explicit specs.\n        \"\"\"\n        if specs is None:\n            overrides = param.ParamOverrides(self, kwargs,\n                                             allow_extra_keywords=True)\n            extra_kwargs = overrides.extra_keywords()\n            kwargs = dict([(k,v) for (k,v) in kwargs.items()\n                           if k not in extra_kwargs])\n            rounded_specs = list(self.round_floats([extra_kwargs],\n                                                   fp_precision))\n\n            if extra_kwargs=={}: return [], kwargs, True\n            else:                return rounded_specs, kwargs, False\n\n        return list(self.round_floats(specs, fp_precision)), kwargs, True\n\ndef _build_specs_and_kwargs(self, specs, kwargs, fp_precision):\n        \"\"\"\n        Returns the specs, the remaining kwargs and whether or not the\n        constructor was called with kwarg or explicit specs.\n        \"\"\"\n        if specs is None:\n            overrides = param.ParamOverrides(self, kwargs,\n                                             allow_extra_keywords=True)\n            extra_kwargs = overrides.extra_keywords()\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef lexsorted_specs(self, order):\n        \"\"\"\n        Returns a list of specs that are lexical sorted.\n        \"\"\"\n        specs = []\n        for el in order:\n            if el[0] == '+':\n                specs.append(self.lexsort_spec(el[1:]))\n            elif el[0] == '-':\n                specs.append(self.lexsort_spec(el[1:]))\n            else:\n                specs.append(self.lexsort_spec(el))\n        return specs\n\ndef lexsort_spec(self, el):\n        \"\"\"\n        Returns a spec that is lexical sorted.\n        \"\"\"\n        if el[0] == '+':\n            return self.lexsort_spec(el[1:])\n        elif el[0] == '-':\n            return self.lexsort_spec(el[1:])\n        else:\n            return self.lexsort_spec(el)\n\ndef lexsort_args(self, *order):\n        \"\"\"\n        Returns a list of lexical sort arguments.\n        \"\"\"\n        args = copy.deepcopy(self)\n        args.specs = self._lexsorted_specs(order)\n        args._lexorder = order\n        return args\n\ndef lexsort_args_spec(self, el):",
        ", L\n\ndef linspace2(self, start, stop, n):\n        \"\"\" Simple replacement for numpy linspace2\"\"\"\n        if n == 1: return [start]\n        L = [0.0] * n\n        nm1 = n - 1\n        nm1inv = 1.0 / nm1\n        for i in range(n):\n            L[i] = nm1inv * (start*(nm1 - i) + stop*i)\n        return L\n\ndef linspace3(self, start, stop, n):\n        \"\"\" Simple replacement for numpy linspace3\"\"\"\n        if n == 1: return [start]\n        L = [0.0] * n\n        nm1 = n - 1\n        nm1inv = 1.0 / nm1\n        for i in range(n):\n            L[i] = nm1inv * (start*(nm1 - i) + stop*i)\n        return L\n\ndef linspace4(self, start, stop, n):\n        \"\"\" Simple replacement for numpy linspace4\"\"\"\n        if n == 1: return [start]\n        L = [0.0] * n\n        nm1 = n - 1\n        nm1inv = 1.0 / nm1\n        for i in range(n):\n            L[i] = nm1inv * (start*(nm1",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ".split('.')[-1]\n\ndef file(cls, filename, root=None, extension=None, **kwargs):\n        \"\"\"\n        Load a single file. The given kwargs are passed through to the normal constructor.\n        \"\"\"\n        root = os.getcwd() if root is None else root\n        suffix = '' if extension is None else '.' + extension.rsplit('.')[-1]\n        pattern = filename + os.sep + '*' + suffix\n        key = os.path.join(root, filename,'*').rsplit(os.sep)[-2]\n        format_parse = list(string.Formatter().parse(key))\n        if not all([el is None for el in zip(*format_parse)[1]]):\n            raise Exception('File cannot contain format field specifications')\n        return cls(key, pattern, root, **kwargs)\n\ndef directory_list(cls, directory, root=None, extension=None, **kwargs):\n        \"\"\"\n        Load all the files in a given directory selecting only files\n        with the given extension if specified. The given kwargs are\n        passed through to the normal constructor.\n        \"\"\"\n        root = os.getcwd() if root is None else root\n        suffix = '' if extension is None else '.' + extension.rsplit('.')[-1]\n        pattern = directory + os.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _decompose_pattern(self, pattern):\n        \"\"\"\n        Given a pattern, returns the (globpattern, regexp, fields, types)\n        tuple.\n        \"\"\"\n        (globpattern, regexp, fields, types) = pattern.split('.')\n        return (globpattern, regexp, fields, types)\n\ndef _expand_path(self, path):\n        \"\"\"\n        Given a path, returns the absolute path.\n        \"\"\"\n        return os.path.abspath(path)\n\ndef _expand_path_list(self, path_list):\n        \"\"\"\n        Given a list of paths, returns the absolute paths.\n        \"\"\"\n        return [os.path.abspath(p) for p in path_list]\n\ndef _expand_path_dict(self, path_dict):\n        \"\"\"\n        Given a dictionary of paths, returns the absolute paths.\n        \"\"\"\n        return {os.path.abspath(p): p for p in path_dict.values()}\n\ndef _expand_path_list_dict(self, path_list_dict):\n        \"\"\"\n        Given a dictionary of paths, returns the absolute paths.\n        \"\"\"\n        return {os.path.abspath(p): p for p in path_list_dict.values()}\n\ndef _expand_path_",
        ")\n\nclass FileInfo(object):\n    \"\"\"\n    A class that represents a file or directory.\n\n    This class is used to represent a file or directory.\n    \"\"\"\n    def __init__(self, filepattern, key, filetype, ignore=[]):\n        self.filepattern = filepattern\n        self.key = key\n        self.filetype = filetype\n        self.ignore = ignore\n\n    def __str__(self):\n        return \"FileInfo(%s, %s, %s, %s)\" % (self.filepattern, self.key, self.filetype, self.ignore)\n\n    def __repr__(self):\n        return \"<FileInfo(%s, %s, %s, %s)>\" % (self.filepattern, self.key, self.filetype, self.ignore)\n\n    def __eq__(self, other):\n        return isinstance(other, FileInfo) and self.filepattern == other.filepattern and self.key == other.key and self.filetype == other.filetype and self.ignore == other.ignore\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.filepattern) ^ hash(self.key) ^ hash(self.filetype",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef save_dframe(self, dframe, filename):\n        \"\"\"\n        Save the supplied dataframe using the specified key and filetype.\n        \"\"\"\n        filename_series = dframe[self.key]\n        loaded_data = filename_series.map(self.filetype.data)\n        keys = [list(el.keys()) for el in loaded_data.values]\n        for key in set().union(*keys):\n            key_exists = key in dframe.columns\n            if key_exists:\n                self.warning(\"Appending '_data' suffix to data key %r to avoid\"\n                             \"overwriting existing metadata with the same name.\" % key)\n            suffix = '_data' if key_exists else ''\n            dframe[key+suffix] = loaded_data.map(lambda x: x.get(key, np.nan))\n        return dframe\n\ndef load_dframe_from_file(self, filename):\n        \"\"\"\n        Load the supplied dataframe using the specified key and filetype.\n        \"\"\"\n        dframe = pd.read_csv(filename, sep='\\t', header=None, names=['key', 'filetype'])\n        return load_dframe(dframe)\n\ndef save_dframe_to_file(self, dframe, filename):\n        \"\"\"\n       ",
        ", mdata\n\ndef _info_from_file(self, source, key, filetype, ignore):\n        \"\"\"\n        Generates the union of the source.specs and the metadata\n        dictionary loaded by the filetype object.\n        \"\"\"\n        specs, mdata = [], {}\n        mdata_clashes  = set()\n\n        for spec in source.specs:\n            if key not in spec:\n                raise Exception(\"Key %r not available in 'source'.\" % key)\n\n            mdata = dict((k,v) for (k,v) in filetype.metadata(spec[key]).items()\n                         if k not in ignore)\n            mdata_spec = {}\n            mdata_spec.update(spec)\n            specs.append(mdata_spec)\n            mdata_clashes = mdata_clashes | (set(spec.keys()) & set(mdata.keys()))\n        # Metadata clashes can be avoided by using the ignore list.\n        if mdata_clashes:\n            self.warning(\"Loaded metadata keys overriding source keys.\")\n        return specs, mdata\n\ndef _info_from_file_with_ignore(self, source, key, filetype, ignore):\n        \"\"\"\n        Generates the union of the source.specs and the metadata\n        dictionary loaded by the filetype",
        "\n\n    async def _pause(self):\n        \"\"\"Pause the buffer. Resume looping if paused.\"\"\"\n        if self._future is not None:\n            future, self._future = self._future, None\n            future.set_result(False)\n\n    async def _resume(self):\n        \"\"\"Resume the buffer. Resume looping if paused.\"\"\"\n        if self._future is not None:\n            future, self._future = self._future, None\n            future.set_result(True)\n\n    async def _stop(self):\n        \"\"\"Stop the buffer. Resume looping if paused.\"\"\"\n        if self._future is not None:\n            future, self._future = self._future, None\n            future.set_result(None)\n\n    async def _pause_loop(self):\n        \"\"\"Pause the buffer. Resume looping if paused.\"\"\"\n        if self._future is not None:\n            future, self._future = self._future, None\n            future.set_result(False)\n\n    async def _resume_loop(self):\n        \"\"\"Resume the buffer. Resume looping if paused.\"\"\"\n        if self._future is not None:\n            future, self._future = self._future, None\n            future.set_result(True)\n\n    async def _stop_loop(self):\n        \"\"\"",
        " plt.show()\n\ndef figureSweep(abf,sweeps=[0]):\n    \"\"\"\n    Create a plot of one area of interest of a single sweep.\n    \"\"\"\n\n    sweeps=[0]\n    for sweep in sweeps:\n        abf.setsweep(sweep)\n        for stimulus in stimuli:\n            S1=int(abf.pointsPerSec*stimulus)\n            S2=int(abf.pointsPerSec*(stimulus+0.001)) # 1ms of blanking\n            abf.sweepY[S1:S2]=np.nan # blank out the stimulus area\n            I1=int(abf.pointsPerSec*2.2) # time point (sec) to start\n            I2=int(abf.pointsPerSec*2.6) # time point (sec) to end\n            baseline=np.average(abf.sweepY[int(abf.pointsPerSec*2.0):int(abf.pointsPerSec*2.2)])\n            Ys=lowPassFilter(abf.sweepY[I1:I2])-baseline\n            Xs=abf.sweepX2[I1:I1+len(Ys)].flatten()\n            plt.",
        ",OUT=OUT(ABFfolder)\n    if index:\n        IN.indexAll()\n    if overwrite:\n        OUT.overwriteAll()\n    if launch:\n        IN.launchAll()\n    return IN,OUT\n\ndef INDEX(ABFfolder):\n    \"\"\"Returns an index object for the given folder.\"\"\"\n    return Index(ABFfolder)\n\ndef INDEX(ABFfolder):\n    \"\"\"Returns an index object for the given folder.\"\"\"\n    return Index(ABFfolder)\n\ndef INDEX(ABFfolder):\n    \"\"\"Returns an index object for the given folder.\"\"\"\n    return Index(ABFfolder)\n\ndef INDEX(ABFfolder):\n    \"\"\"Returns an index object for the given folder.\"\"\"\n    return Index(ABFfolder)\n\ndef INDEX(ABFfolder):\n    \"\"\"Returns an index object for the given folder.\"\"\"\n    return Index(ABFfolder)\n\ndef INDEX(ABFfolder):\n    \"\"\"Returns an index object for the given folder.\"\"\"\n    return Index(ABFfolder)\n\ndef INDEX(ABFfolder):\n    \"\"\"Returns an index object for the given folder.\"\"\"\n    return Index(ABFfolder)\n\ndef INDEX(ABFfolder):\n    \"\"\"Returns an index object for the given folder.\"\"\"\n    return Index(ABFfolder)\n\ndef INDEX(ABFfolder",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef htmlFor_(self,fname):\n        \"\"\"return appropriate HTML determined by file extension.\"\"\"\n        if os.path.splitext(fname)[1].lower() in ['.jpg','.png']:\n            html='<a href=\"%s\"><img src=\"%s\"></a>'%(fname,fname)\n            if \"_tif_\" in fname:\n                html=html.replace('<img ','<img class=\"datapic micrograph\"')\n            if \"_plot_\" in fname:\n                html=html.replace('<img ','<img class=\"datapic intrinsic\" ')\n            if \"_experiment_\" in fname:\n                html=html.replace('<img ','<img class=\"datapic experiment\" ')\n        elif os.path.splitext(fname)[1].lower() in ['.html','.htm']:\n            html='LINK: %s'%fname\n        else:\n            html='<br>Not sure how to show: [%s]</br>'%fname\n        return html\n\ndef htmlFor_(self,fname):\n        \"\"\"return appropriate HTML determined by file extension.\"\"\"\n        if os.path.splitext(fname)[1].lower() in ['.jpg','.png']:\n            html='<a href=\"%s\"><img src=\"%s\"></a>'%(fname,fname)\n            if \"_tif_\" in fname",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ".title)\n\ndef html_single_plot_all(self,abfID,launch=False,overwrite=False):\n        \"\"\"create ID_plot.html of all intrinsic properties.\"\"\"\n        if type(abfID) is str:\n            abfID=[abfID]\n        for thisABFid in cm.abfSort(abfID):\n            parentID=cm.parent(self.groups,thisABFid)\n            saveAs=os.path.abspath(\"%s/%s_plot.html\"%(self.folder2,parentID))\n            if overwrite is False and os.path.basename(saveAs) in self.files2:\n                continue\n            filesByType=cm.filesByType(self.groupFiles[parentID])\n            html=\"\"\n            html+='<div style=\"background-color: #DDDDFF;\">'\n            html+='<span class=\"title\">intrinsic properties for: %s</span></br>'%parentID\n            html+='<code>%s</code>'%os.path.abspath(self.folder1+\"/\"+parentID+\".abf\")\n            html+='</div>'\n            for fname in filesByType['plot']:\n                html+=self.htmlFor(fname)\n            print(\"creating\",saveAs,'...')\n",
        "\n\ndef convolve_2d(signal,kernel):\n    \"\"\"\n    This applies a kernel to a signal through convolution and returns the result.\n\n    Some magic is done at the edges so the result doesn't apprach zero:\n        1. extend the signal's edges with len(kernel)/2 duplicated values\n        2. perform the convolution ('same' mode)\n        3. slice-off the ends we added\n        4. return the same number of points as the original\n    \"\"\"\n    pad=np.ones(len(kernel)/2)\n    signal=np.concatenate((pad*signal[0],signal,pad*signal[-1]))\n    signal=np.convolve(signal,kernel,mode='same')\n    signal=signal[len(pad):-len(pad)]\n    return signal\n\ndef convolve_3d(signal,kernel):\n    \"\"\"\n    This applies a kernel to a signal through convolution and returns the result.\n\n    Some magic is done at the edges so the result doesn't apprach zero:\n        1. extend the signal's edges with len(kernel)/2 duplicated values\n        2. perform the convolution ('same' mode)\n        3. slice-off the ends we added\n        4. return the same number of points as the original\n    \"\"\"\n    pad=np.ones(len",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n    return l\n\ndef list_move_to_back(l,value='other'):\n    \"\"\"if the value is in the list, move it to the back and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.insert(0,value)\n    return l\n\ndef list_remove_value(l,value):\n    \"\"\"if the value is in the list, remove it and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n    return l\n\ndef list_remove_value_from_list(l,value):\n    \"\"\"if the value is in the list, remove it from the list and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.append(value)\n    return l\n\ndef list_remove_value_from_list_reverse(l,value):\n    \"\"\"if the value is in the list, remove it from the list and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.reverse()\n    return l\n\ndef list_remove_value_from_list_reverse_and_return(",
        "\n    return l\n\ndef list_remove_from_back(l,value='other'):\n    \"\"\"if the value is in the list, remove it from the back and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.append(value)\n    return l\n\ndef list_remove_from_front(l,value='other'):\n    \"\"\"if the value is in the list, remove it from the front and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.append(value)\n    return l\n\ndef list_remove_from_end(l,value='other'):\n    \"\"\"if the value is in the list, remove it from the end and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.append(value)\n    return l\n\ndef list_remove_from_start(l,value='other'):\n    \"\"\"if the value is in the list, remove it from the start and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.append(value)\n    return l\n\ndef",
        "\ndef list_order_by_reverse(l,firstItems):\n    \"\"\"given a list and a list of items to be first, return the list in the\n    same order except that it begins with each of the first items.\"\"\"\n    l=list(l)\n    for item in firstItems[::-1]: #backwards\n        if item in l:\n            l.remove(item)\n    return l\n\ndef list_order_by_reverse_reverse(l,firstItems):\n    \"\"\"given a list and a list of items to be first, return the list in the\n    same order except that it begins with each of the first items.\"\"\"\n    l=list(l)\n    for item in firstItems[::-1]: #backwards\n        if item in l:\n            l.remove(item)\n    return l\n\ndef list_order_by_reverse_reverse_reverse(l,firstItems):\n    \"\"\"given a list and a list of items to be first, return the list in the\n    same order except that it begins with each of the first items.\"\"\"\n    l=list(l)\n    for item in firstItems[::-1]: #backwards\n        if item in l:\n            l.remove(item)\n    return l\n\ndef list_order_by_reverse_reverse_reverse(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef abfGroupFiles2(groups,folder):\n    \"\"\"\n    when given a dictionary where every key contains a list of IDs, replace\n    the keys with the list of files matching those IDs. This is how you get a\n    list of files belonging to each child for each parent.\n    \"\"\"\n    assert os.path.exists(folder)\n    files=os.listdir(folder)\n    group2={}\n    for parent in groups.keys():\n        if not parent in group2.keys():\n            group2[parent]=[]\n        for ID in groups[parent]:\n            for fname in [x.lower() for x in files if ID in x.lower()]:\n                group2[parent].extend([fname])\n    return group2\n\ndef abfGroupFiles3(groups,folder):\n    \"\"\"\n    when given a dictionary where every key contains a list of IDs, replace\n    the keys with the list of files matching those IDs. This is how you get a\n    list of files belonging to each child for each parent.\n    \"\"\"\n    assert os.path.exists(folder)\n    files=os.listdir(folder)\n    group2={}\n    for parent in groups.keys():\n        if not parent in group2.keys():\n            group2[parent]=[]\n        for ID in groups",
        "\ndef parent_id(groups,ID):\n    \"\"\"given a groups dictionary and an ID, return its actual parent ID.\"\"\"\n    if ID in groups.keys():\n        return groups[ID]\n    if not ID in groups.keys():\n        for actualParent in groups.keys():\n            if ID in groups[actualParent]:\n                return actualParent\n    return None\n\ndef parent_id_and_name(groups,ID):\n    \"\"\"given a groups dictionary and an ID, return its actual parent ID and its name.\"\"\"\n    if ID in groups.keys():\n        return groups[ID],ID\n    if not ID in groups.keys():\n        for actualParent in groups.keys():\n            if ID in groups[actualParent]:\n                return actualParent,ID\n    return None\n\ndef parent_id_and_name_and_parent(groups,ID):\n    \"\"\"given a groups dictionary and an ID, return its actual parent ID and its name and its parent ID.\"\"\"\n    if ID in groups.keys():\n        return groups[ID],ID,ID\n    if not ID in groups.keys():\n        for actualParent in groups.keys():\n            if ID in groups[actualParent]:\n                return actualParent,ID,ID\n    return None\n\ndef parent_id_and_name_and_parent_and_name(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        return\n\n    def __call__(self, event):\n        \"\"\"Call the listener for the event.\"\"\"\n        _check_limit(event)\n        self.emit(event)\n\n    def add_listener(self, event, callback):\n        \"\"\"Add a listener for the event.\"\"\"\n        _check_limit(event)\n        self.listeners[event] = callback\n\n    def remove_listener(self, event, callback):\n        \"\"\"Remove a listener for the event.\"\"\"\n        _check_limit(event)\n        del self.listeners[event]\n\n    def emit(self, event):\n        \"\"\"Emit the event.\"\"\"\n        for listener in self.listeners.values():\n            listener(event)\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the listener.\"\"\"\n        return ' '.join(\n            [\n                'Listener: {}'.format(listener)\n                for listener in self.listeners.values()\n            ]\n        )\n\n    def __str__(self):\n        \"\"\"Return a string representation of the listener.\"\"\"\n        return self.__repr__()\n\n    def __eq__(self, other):\n        \"\"\"Return true if the listeners are equal.\"\"\"\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other):\n        \"\"\"",
        "\n\ndef remove_listener(self, event, listener):\n        \"\"\"Remove a listener from a particular event.\n\n        Args:\n            event (str): The name of the event to listen for. This may be any\n                string value.\n            listener (def or async def): The callback to execute when the event\n                fires. This may be a sync or async function.\n        \"\"\"\n        self.emit('remove_listener', event, listener)\n        self._listeners[event].remove(listener)\n        self._check_limit(event)\n        return self\n\ndef emit(self, event, *args, **kwargs):\n        \"\"\"Emit an event to all listeners.\n\n        Args:\n            event (str): The name of the event to listen for. This may be any\n                string value.\n            *args (list): The arguments to pass to the listeners.\n            **kwargs (dict): The keyword arguments to pass to the listeners.\n        \"\"\"\n        for listener in self._listeners[event]:\n                listener(*args, **kwargs)\n\ndef emit_once(self, event, *args, **kwargs):\n        \"\"\"Emit an event once.\n\n        Args:\n            event (str): The name of the event to listen for. This may be any\n                string value.\n            *args (list): The arguments to pass to",
        "\n\ndef once_once(self, event, listener):\n        \"\"\"Add a listener that is only called once.\"\"\"\n        self.once(event, listener)\n        self.once(event, listener)\n\ndef once_once_once(self, event, listener):\n        \"\"\"Add a listener that is only called once.\"\"\"\n        self.once(event, listener)\n        self.once(event, listener)\n\ndef once_once_once(self, event, listener):\n        \"\"\"Add a listener that is only called once.\"\"\"\n        self.once(event, listener)\n        self.once(event, listener)\n\ndef once_once_once_once(self, event, listener):\n        \"\"\"Add a listener that is only called once.\"\"\"\n        self.once(event, listener)\n        self.once(event, listener)\n\ndef once_once_once_once(self, event, listener):\n        \"\"\"Add a listener that is only called once.\"\"\"\n        self.once(event, listener)\n        self.once(event, listener)\n\ndef once_once_once_once(self, event, listener):\n        \"\"\"Add a listener that is only called once.\"\"\"\n        self.once(event, listener)\n        self.once(event, listener)\n\ndef once_once_once_once(self,",
        "\n\ndef add_listener(self, event, listener):\n        \"\"\"Add a listener to the emitter.\n\n        Args:\n            event (str): The event name on which the listener is bound.\n            listener: A reference to the same object given to add_listener.\n\n        Returns:\n            bool: True if a listener was added else False.\n\n        This method only adds one listener at a time. If a listener is\n        attached multiple times then this method must be called repeatedly.\n        Additionally, this method adds listeners first from the those\n        registered with 'on' or 'add_listener'. If none are found it continue\n        to add afterwards from those added with 'once'.\n        \"\"\"\n        with contextlib.suppress(ValueError):\n\n            self._listeners[event].append(listener)\n            return True\n\n        with contextlib.suppress(ValueError):\n\n            self._once[event].append(listener)\n            return True\n\n        return False\n\ndef emit(self, event, *args, **kwargs):\n        \"\"\"Emit an event.\n\n        Args:\n            event (str): The event name on which the event is bound.\n            *args (list): The arguments to pass to the event.\n            **kwargs (dict): The keyword arguments to pass to the event.\n\n        Returns:\n            bool: True if",
        "\n\n\ndef _try_catch_coro(self, emitter, event, listener, coro):\n    \"\"\"Try to catch a coroutine and return a future.\n\n    Args:\n        emitter (Emitter): The emitter that triggered the coroutine.\n        event (str): The name of the event that triggered the coroutine.\n        listener (async def): The async def that needs to be executed.\n        coro (asyncio.Future): The coroutine that needs to be caught.\n\n    Returns:\n        asyncio.Future: The future that will be caught.\n    \"\"\"\n    try:\n        return listener(*coro)\n    except Exception as exc:\n        return emitter.emit(event, event, listener, exc)\n\n\ndef _dispatch_event(self, event, listener, *args, **kwargs):\n    \"\"\"Schedule an event for execution.\n\n    Args:\n        event (str): The name of the event that triggered this call.\n        listener (async def): The async def that needs to be executed.\n        *args: Any number of positional arguments.\n        **kwargs: Any number of keyword arguments.\n\n    The values of *args and **kwargs are passed, unaltered, to the async\n    def when generating the coro. If there is an exception generating the\n    coro, such as the wrong number of arguments, the emitter's error event",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n    def _dispatch_coroutine(self, event, listener, *args, **kwargs):\n        \"\"\"Dispatch an event to a coroutine.\n\n        Args:\n            event (str): The name of the event that triggered this call.\n            listener (def or async def): The coroutine to trigger.\n            *args: Any number of positional arguments.\n            **kwargs: Any number of keyword arguments.\n\n        This method inspects the listener. If it is a def it dispatches the\n        listener to a method that will execute that def. If it is an async def\n        it dispatches it to a method that will schedule the resulting coro with\n        the event loop.\n        \"\"\"\n        if (\n            asyncio.iscoroutinefunction(listener) or\n            isinstance(listener, functools.partial) and\n            asyncio.iscoroutinefunction(listener.func)\n        ):\n\n            return self._dispatch_coroutine_function(event, listener, *args, **kwargs)\n\n        return self._dispatch_coroutine_coroutine(event, listener, *args, **kwargs)\n\n    def _dispatch_coroutine_function(self, event, listener, *args, **kwargs):\n        \"\"\"Dispatch an event to a coroutine function.\n\n        Args:\n            event (str): The name of the event that triggered this call.\n           ",
        "\n\ndef listen(self, event, *args, **kwargs):\n        \"\"\"Call each listener for the event with the given arguments.\n\n        Args:\n            event (str): The event to trigger listeners on.\n            *args: Any number of positional arguments.\n            **kwargs: Any number of keyword arguments.\n\n        This method passes all arguments other than the event name directly\n        to the listeners. If a listener raises an exception for any reason the\n        'listener-error', or current value of LISTENER_ERROR_EVENT, is emitted.\n        Listeners to this event are given the event name, listener object, and\n        the exception raised. If an error listener fails it does so silently.\n\n        All event listeners are fired in a deferred way so this method returns\n        immediately. The calling coro must yield at some point for the event\n        to propagate to the listeners.\n        \"\"\"\n        listeners = self._listeners[event]\n        listeners = itertools.chain(listeners, self._once[event])\n        for listener in listeners:\n\n            self._loop.call_soon(\n                functools.partial(\n                    self._dispatch,\n                    event,\n                    listener,\n                    *args,\n                    **kwargs,\n                )\n            )\n\n        return self\n\ndef listen_once(self, event, *args, **kwargs):\n",
        "\n\n    def on(self, event, callback):\n        \"\"\"Add a listener to the event.\n\n        Args:\n            event (str): The event for which to add the listener.\n            callback (callable): The callback to call when the event is triggered.\n\n        The resulting count is a combination of listeners added using\n        'on'/'add_listener' and 'once'.\n        \"\"\"\n        self._listeners[event].append(callback)\n        self._once[event] = True\n\n    def add_listener(self, event, callback):\n        \"\"\"Add a listener to the event.\n\n        Args:\n            event (str): The event for which to add the listener.\n            callback (callable): The callback to call when the event is triggered.\n\n        The resulting count is a combination of listeners added using\n        'on'/'add_listener' and 'once'.\n        \"\"\"\n        self._listeners[event].append(callback)\n\n    def once(self, event, callback):\n        \"\"\"Add a listener to the event.\n\n        Args:\n            event (str): The event for which to add the listener.\n            callback (callable): The callback to call when the event is triggered.\n\n        The resulting count is a combination of listeners added using\n        'on'/'add_listener' and 'once'.\n       ",
        "\n\ndef genTIFs(folder,files=None):\n    \"\"\"Convert each TIF to PNG. Return filenames of new PNGs.\"\"\"\n    if files is None:\n        files=glob.glob(folder+\"/*.*\")\n    new=[]\n    for fname in files:\n        ext=os.path.basename(fname).split(\".\")[-1].lower()\n        if ext in ['tif','tiff']:\n            if not os.path.exists(fname+\".png\"):\n                print(\" -- converting %s to PNG...\"%os.path.basename(fname))\n                cm.image_convert(fname)\n                new.append(fname) #fancy burn-in of image data\n            else:\n                pass\n                #print(\" -- already converted %s to PNG...\"%os.path.basename(fname))\n    return new\n\ndef genPNGs_with_tiff(folder,files=None):\n    \"\"\"Convert each TIF to PNG. Return filenames of new PNGs.\"\"\"\n    if files is None:\n        files=glob.glob(folder+\"/*.*\")\n    new=[]\n    for fname in files:\n        ext=os.path.basename(fname).split(\".\")[-1].lower()\n        if ext in ['tif','tiff']:\n            if not os.path",
        "\ndef htmlABFcontent(ID,group,d):\n    \"\"\"generate a static html for an abf, given a dict of files.\"\"\"\n    html=TEMPLATES['abf']\n    html=html.replace(\"~ID~\",ID)\n    html=html.replace(\"~GROUP~\",group)\n    html=html.replace(\"~CONTENT~\",htmlABFcontent(ID,group,d))\n    return html\n\ndef htmlABFcontent(ID,group,d):\n    \"\"\"generate a static html for an abf, given a dict of files.\"\"\"\n    html=TEMPLATES['abf']\n    html=html.replace(\"~ID~\",ID)\n    html=html.replace(\"~GROUP~\",group)\n    html=html.replace(\"~CONTENT~\",htmlABFcontent(ID,group,d))\n    return html\n\ndef htmlABFcontent2(ID,group,d):\n    \"\"\"generate a static html for an abf, given a dict of files.\"\"\"\n    html=TEMPLATES['abf']\n    html=html.replace(\"~ID~\",ID)\n    html=html.replace(\"~GROUP~\",group)\n    html=html.replace(\"~CONTENT~\",htmlABFcontent2(ID,group,d))\n    return html\n\ndef htmlABFcontent",
        ".save(folder+\"/swhlab4/menu.png\",format=\"png\")\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash(menu,folder)\n    makeMenu(menu,folder)\n    makeSplash",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".detect()\n        else:\n            self.log.debug(\"analysis already attempted before event detection...\")\n\ndef detect(self):\n        \"\"\"\n        run this after analysis. Checks if event detection occured.\n        If not, runs AP detection on all sweeps.\n        \"\"\"\n        if self.APs==False:\n            self.log.debug(\"analysis attempted after event detection...\")\n            self.detect()\n        else:\n            self.log.debug(\"analysis already attempted after event detection...\")\n\ndef detectAll(self):\n        \"\"\"\n        run this after analysis. Checks if event detection occured.\n        If not, runs AP detection on all sweeps.\n        \"\"\"\n        if self.APs==False:\n            self.log.debug(\"analysis attempted after event detection...\")\n            self.detect()\n        else:\n            self.log.debug(\"analysis already attempted after event detection...\")\n\ndef detectAll(self):\n        \"\"\"\n        run this after analysis. Checks if event detection occured.\n        If not, runs AP detection on all sweeps.\n        \"\"\"\n        if self.APs==False:\n            self.log.debug(\"analysis attempted after event detection...\")\n            self.detect()\n        else:\n            self.log.debug(\"analysis already attempted after event detection...\")\n\ndef detect",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_package_version(package):\n    \"\"\"\n    Return package version as listed in `init.py`.\n    \"\"\"\n    init_py = open(os.path.join(package, '__init__.py')).read()\n    version = re.search(\"__version__ = ['\\\"]([^'\\\"]+)['\\\"]\", init_py).group(1)\n    return version\n\ndef get_package_description(package):\n    \"\"\"\n    Return package description as listed in `init.py`.\n    \"\"\"\n    init_py = open(os.path.join(package, '__init__.py')).read()\n    description = re.search(\"__description__ = ['\\\"]([^'\\\"]+)['\\\"]\", init_py).group(1)\n    return description\n\ndef get_package_license(package):\n    \"\"\"\n    Return package license as listed in `init.py`.\n    \"\"\"\n    init_py = open(os.path.join(package, '__init__.py')).read()\n    license = re.search(\"__license__ = ['\\\"]([^'\\\"]+)['\\\"]\", init_py).group(1)\n    return license\n\ndef get_package_url(package):\n    \"\"\"\n    Return package URL as listed in `init.py`.\n    \"\"\"\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\n\ndef get_method_name(cls, method):\n        \"\"\"Get the name of a given method.\n\n        Arguments:\n          method (:py:class:`str`): The name of the method.\n\n        Returns:\n          :py:class:`str`: The name of the method.\n\n        \"\"\"\n        return cls.API_METHODS.get(method, method)\n\ndef get_method_signature(cls, method):\n        \"\"\"Get the signature of a given method.\n\n        Arguments:\n          method (:py:class:`str`): The name of the method.\n\n        Returns:\n          :py:class:`str`: The signature of the method.\n\n        \"\"\"\n        return cls.API_METHODS.get(method, method)\n\ndef get_method_doc(cls, method):\n        \"\"\"Get the docstring of a given method.\n\n        Arguments:\n          method (:py:class:`str`): The name of the method.\n\n        Returns:\n          :py:class:`str`: The docstring of the method.\n\n        \"\"\"\n        return cls.API_METHODS.get(method, method)\n\ndef get_method_doc_string(cls, method):\n        \"\"\"Get the docstring of a given method.\n\n        Arguments:\n          method (:py:class:`str`",
        "\n\ndef _add_parslepy_ns(cls, namespace_dict):\n        \"\"\"\n        Extend XPath evaluation with Parslepy extensions' namespace\n        \"\"\"\n\n        namespace_dict.update({\n            'parslepy' : cls.LOCAL_NAMESPACE,\n            'parsley' : cls.LOCAL_NAMESPACE,\n        })\n        return namespace_dict\n\ndef _add_parsley_ns_for_xpath(cls, namespace_dict):\n        \"\"\"\n        Extend XPath evaluation with Parsley extensions' namespace\n        \"\"\"\n\n        namespace_dict.update({\n            'parslepy' : cls.LOCAL_NAMESPACE,\n            'parsley' : cls.LOCAL_NAMESPACE,\n        })\n        return namespace_dict\n\ndef _add_parslepy_ns_for_xpath(cls, namespace_dict):\n        \"\"\"\n        Extend XPath evaluation with Parslepy extensions' namespace\n        \"\"\"\n\n        namespace_dict.update({\n            'parslepy' : cls.LOCAL_NAMESPACE,\n            'parsley' : cls.LOCAL_NAMESPACE,\n        })\n        return namespace_dict\n\ndef _add_parsley_ns_for_xpath(cls, namespace_dict):\n        \"\"\"\n        Extend XPath evaluation with Parsley extensions' namespace\n        \"\"\"\n\n        namespace_",
        "\n\ndef _extract_single(self, m):\n        \"\"\"\n        Try and convert matching Elements to unicode strings.\n\n        If this fails, the selector evaluation probably already\n        returned some string(s) of some sort, or boolean value,\n        or int/float, so return that instead.\n        \"\"\"\n        if isinstance(m, (list, tuple)):\n            return [self._extract_single(m) for m in m]\n        else:\n            return self._extract_single(m)\n\ndef _extract_list(self, m):\n        \"\"\"\n        Try and convert matching Elements to unicode strings.\n\n        If this fails, the selector evaluation probably already\n        returned some string(s) of some sort, or boolean value,\n        or int/float, so return that instead.\n        \"\"\"\n        if isinstance(m, (list, tuple)):\n            return [self._extract_list(m) for m in m]\n        else:\n            return self._extract_list(m)\n\ndef _extract_dict(self, m):\n        \"\"\"\n        Try and convert matching Elements to unicode strings.\n\n        If this fails, the selector evaluation probably already\n        returned some string(s) of some sort, or boolean value,\n        or int/float, so return that instead.\n        \"\"\"\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.",
        "\n                break\n        return\n\n    async def _respond(self, channel, text):\n        \"\"\"Respond to a message.\n\n        Arguments:\n          channel (:py:class:`str`): The channel to respond to.\n          text (:py:class:`str`): The text to respond to.\n\n        \"\"\"\n        await self.send_message(channel, text)\n\n    async def _instruction_list(self, filters):\n        \"\"\"Return a list of instructions for the user.\n\n        Arguments:\n          filters (:py:class:`list`): The filters to apply to incoming\n            messages.\n\n        \"\"\"\n        instructions = []\n        for _filter in filters:\n            instructions.extend(_filter.instructions)\n        return instructions\n\n    async def message_is_to_me(self, data):\n        \"\"\"Return True if the message is to me.\n\n        Arguments:\n          data (:py:class:`dict`): The message to check.\n\n        \"\"\"\n        return data['text'] == self.address_as\n\n    async def _unpack_message(self, message):\n        \"\"\"Unpack a message into a dictionary.\n\n        Arguments:\n          message (:py:class:`aiohttp.websocket.Message`): The incoming\n            message to unpack.\n\n        \"\"\"\n        data = {}\n       ",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Http\\Requests;\nuse App\\Http\\Requests\\Admin\\CreateUserRequest;\nuse App\\Http\\Requests\\Admin\\UpdateUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;\nuse App\\Http\\Requests\\Admin\\DeleteUserRequest;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\nasync def _get_socket_name(self):\n        \"\"\"Get the name of the WebSocket socket.\n\n        Returns:\n          :py:class:`str`: The name of the socket.\n\n        \"\"\"\n        return self.api.execute_method(\n            self.RTM_START_ENDPOINT,\n            simple_latest=True,\n            no_unreads=True,\n        )['name']\n\nasync def _get_socket_port(self):\n        \"\"\"Get the port of the WebSocket socket.\n\n        Returns:\n          :py:class:`int`: The port of the socket.\n\n        \"\"\"\n        return self.api.execute_method(\n            self.RTM_START_ENDPOINT,\n            simple_latest=True,\n            no_unreads=True,\n        )['port']\n\nasync def _get_socket_host(self):\n        \"\"\"Get the host of the WebSocket socket.\n\n        Returns:\n          :py:class:`str`: The host of the socket.\n\n        \"\"\"\n        return self.api.execute_method(\n            self.RTM_START_ENDPOINT,\n            simple_latest=True,\n            no_unreads=True,\n        )['host']\n\nasync def _get_socket_type(self):\n        \"\"\"Get",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_task_class(task_path):\n    \"\"\"Get the task class for the given task path\"\"\"\n    task_classes = get_tasks()\n    for task_class in task_classes:\n        if task_class.task_path == task_path:\n            return task_class\n    raise ImproperlyConfigured('Task class \"%s\" does not exist' % task_path)\n\ndef get_task_module(task_path):\n    \"\"\"Get the module for the given task path\"\"\"\n    task_classes = get_tasks()\n    for task_class in task_classes:\n        if task_class.task_path == task_path:\n            return task_class.module\n    raise ImproperlyConfigured('Task module \"%s\" does not exist' % task_path)\n\ndef get_task_class_from_module(module):\n    \"\"\"Get the task class for the given module\"\"\"\n    task_classes = get_tasks()\n    for task_class in task_classes:\n        if task_class.module == module:\n            return task_class\n    raise ImproperlyConfigured('Task class \"%s\" does not exist' % module)\n\ndef get_task_class_from_class(classname):\n    \"\"\"Get the task class for the given class\"\"\"\n    task_classes = get_tasks",
        "\n    return options\n\ndef get_tasks():\n    \"\"\"Get the list of task classes\"\"\"\n    task_classes = []\n\n    for task_name in os.listdir(os.path.join(os.path.dirname(__file__), 'tasks')):\n        if task_name.endswith('.py'):\n            task_name = task_name[:-3]\n            task_name = task_name.replace('.py', '')\n            task_name = task_name.replace('_', ' ')\n            task_name = task_name.replace('.', ' ')\n            task_name = task_name.replace('_', ' ')\n            task_name = task_name.replace('_', ' ')\n            task_name = task_name.replace('_', ' ')\n            task_name = task_name.replace('_', ' ')\n            task_name = task_name.replace('_', ' ')\n            task_name = task_name.replace('_', ' ')\n            task_name = task_name.replace('_', ' ')\n            task_name = task_name.replace('_', ' ')\n            task_name = task_name.replace('_', ' ')\n            task_name = task_name.replace('_', ' ')\n            task",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef usage(self):\n        \"\"\"A user-friendly usage of the handler.\n\n        Returns:\n          :py:class:`str`: The handler's usage.\n\n        \"\"\"\n        return self._usage\n\ndef usage_description(self):\n        \"\"\"A user-friendly usage description of the handler.\n\n        Returns:\n          :py:class:`str`: The handler's usage description.\n\n        \"\"\"\n        return self._usage_description\n\ndef usage_description_short(self):\n        \"\"\"A user-friendly usage description short name of the handler.\n\n        Returns:\n          :py:class:`str`: The handler's usage description short name.\n\n        \"\"\"\n        return self._usage_description_short\n\ndef usage_description_long(self):\n        \"\"\"A user-friendly usage description long name of the handler.\n\n        Returns:\n          :py:class:`str`: The handler's usage description long name.\n\n        \"\"\"\n        return self._usage_description_long\n\ndef usage_description_short_long(self):\n        \"\"\"A user-friendly usage description short name long name of the handler.\n\n        Returns:\n          :py:class:`str`: The handler's usage description short name long name.\n\n        \"\"\"\n        return self._usage_description_short",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\nclass ParsleyNode(object):\n    \"\"\"\n    A tree of Parsley nodes\n\n    Arguments:\n    key (str) -- key of the node\n    operator (str) -- operator of the node\n    scope (str) -- scope of the node\n    \"\"\"\n\n    def __init__(self, key=None, operator=None, scope=None, iterate=True):\n        self.key = key\n        self.operator = operator\n        self.scope = scope\n        self.iterate = iterate\n\n    def __repr__(self):\n        return \"<ParsleyNode %s %s %s %s>\" % (\n            self.key, self.operator, self.scope, self.iterate)\n\n    def __eq__(self, other):\n        return isinstance(other, ParsleyNode) and self.key == other.key and \\\n               self.operator == other.operator and self.scope == other.scope and \\\n               self.iterate == other.iterate\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.key) + hash(self.operator) + hash(self.scope) + hash(self.iterate)\n\n    def __str__(self",
        "\n\ndef _auto_foreign_keys(self, table, component=None, table_type=None):\n    \"\"\"\n    Add foreign keys to the given table.\n\n    :param table: A Table object.\n    :param component: A Table object or `None`.\n    :param table_type: A Table object or `None`.\n    \"\"\"\n    if not table:\n        return\n\n    if not table.tableSchema.foreignKey:\n        return\n\n    if not table_type:\n        table_type = self.get_tabletype(table)\n\n    for column in table.tableSchema.foreignKey:\n        if not column.name in component.tableSchema.primaryKey:\n            continue\n\n        if table_type == 'table':\n            # Add foreign key to the table:\n            self.add_foreign_key(table, column.name, component.tableSchema.primaryKey[column.name])\n        else:\n            # Add foreign key to the component:\n            self.add_foreign_key(component, column.name, table_type)\n\ndef add_foreign_key(self, table, column, table_type):\n    \"\"\"\n    Add a foreign key to the given table.\n\n    :param table: A Table object.\n    :param column: A Column object.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "\n    raise web_exceptions.HTTPException(response.status, response.reason)\n",
        "\n",
        "\n\ndef _add_entries(self, entry):\n        \"\"\"\n        Add a source, either specified by glottolog reference id, or as bibtex record.\n        \"\"\"\n        if entry.reference_id:\n            self.add_reference(entry.reference_id)\n        else:\n            self.add_bibtex(entry)\n\ndef add_reference(self, reference_id):\n        \"\"\"\n        Add a source, either specified by glottolog reference id, or as bibtex record.\n        \"\"\"\n        self.add_source(reference_id)\n\ndef add_bibtex(self, entry):\n        \"\"\"\n        Add a source, either specified by glottolog reference id, or as bibtex record.\n        \"\"\"\n        self.add_source(entry, bib_format='bibtex')\n\ndef add_source(self, entry, bib_format='bibtex'):\n        \"\"\"\n        Add a source, either specified by glottolog reference id, or as bibtex record.\n        \"\"\"\n        self.sources.append(entry)\n        self.sources.sort(key=lambda s: s.reference_id)\n        self.sources.insert(0, entry)\n        self.sources.sort(key=lambda s: s.reference_id)",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.internal.management.impl;\n\nimport com.hazelcast.internal.management.ManagementService;\nimport com.hazelcast.internal.management.ManagementServiceContext;\nimport com.hazelcast.internal.management.ManagementServiceContextImpl;\nimport com.hazelcast.internal.management.ManagementServiceContextImpl.ManagementServiceContextListener;\nimport com.hazelcast.internal.management.ManagementServiceContextImpl.ManagementServiceContextListenerAdapter;\nimport com.hazelcast.internal.management.ManagementServiceContextImpl.ManagementServiceContextListenerAdapter.",
        "\n",
        ", prefix)\n\ndef get_cache_key(user, size, prefix):\n    \"\"\"\n    Returns a cache key for a user's avatar.\n    \"\"\"\n    return '%s_%s_%s' % (prefix, user.id, size)\n\ndef get_cached_funcs():\n    \"\"\"\n    Returns a list of cached functions.\n    \"\"\"\n    return cached_funcs\n\ndef set_cached_funcs(funcs):\n    \"\"\"\n    Sets a list of cached functions.\n    \"\"\"\n    cached_funcs = funcs\n\ndef get_avatar_size(avatar):\n    \"\"\"\n    Returns the size of an avatar.\n    \"\"\"\n    return avatar.size\n\ndef get_avatar_url(avatar):\n    \"\"\"\n    Returns the URL of an avatar.\n    \"\"\"\n    return avatar.url\n\ndef get_avatar_url_for_user(user):\n    \"\"\"\n    Returns the URL of an avatar for a user.\n    \"\"\"\n    return get_avatar_url(avatar.user)\n\ndef get_avatar_url_for_avatar(avatar):\n    \"\"\"\n    Returns the URL of an avatar for a avatar.\n    \"\"\"\n    return get_avatar_url(avatar)\n\ndef get_avatar_url_for_avatar_size(avatar, size):\n    \"\"\"\n    Returns the",
        "\n\ndef update_field_from_proxy(field, pref_proxy):\n    \"\"\"Updates a field object instance for a given PrefProxy object.\n\n    :param field:\n\n    :param pref_proxy:\n\n    \"\"\"\n    field.default = pref_proxy.default\n    field.max_length = pref_proxy.max_length\n    field.min_length = pref_proxy.min_length\n    field.max_length_hint = pref_proxy.max_length_hint\n    field.min_length_hint = pref_proxy.min_length_hint\n    field.max_length_hint_length = pref_proxy.max_length_hint_length\n    field.min_length_hint_length = pref_proxy.min_length_hint_length\n    field.max_length_hint_length_length = pref_proxy.max_length_hint_length_length\n    field.max_length_hint_length_length_digits = pref_proxy.max_length_hint_length_length_digits\n    field.min_length_hint_length_digits = pref_proxy.min_length_hint_length_digits\n    field.min_length_hint_length_digits_digits = pref_proxy.min_length_hint_length_digits_digits\n    field.max_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;",
        " model\n",
        "(locals_dict)\n\n\ndef get_frame_locals_dict(stepback=0):\n    \"\"\"Returns locals dictionary from a given frame.\n\n    :param int stepback:\n\n    :rtype: dict\n\n    \"\"\"\n    with Frame(stepback=stepback) as frame:\n        locals_dict = frame.f_locals\n\n    return locals_dict\n\n\ndef get_frame_locals_dict_with_frame(stepback=0):\n    \"\"\"Returns locals dictionary from a given frame.\n\n    :param int stepback:\n\n    :rtype: dict\n\n    \"\"\"\n    with Frame(stepback=stepback) as frame:\n        locals_dict = frame.f_locals\n\n    return locals_dict\n\n\ndef get_frame_locals_dict_with_frame_locals(stepback=0):\n    \"\"\"Returns locals dictionary from a given frame.\n\n    :param int stepback:\n\n    :rtype: dict\n\n    \"\"\"\n    with Frame(stepback=stepback) as frame:\n        locals_dict = frame.f_locals\n\n    return locals_dict\n\n\ndef get_frame_locals_dict_with_frame_locals_dict(stepback=0):\n    \"\"\"Returns locals dictionary from a given frame.\n\n    :param",
        "\n\ndef get_frame_locals(stepback=0):\n    \"\"\"Generator to walk through variables considered as preferences\n    in locals dict of a given frame.\n\n    :param int stepback:\n\n    :rtype: dict\n\n    \"\"\"\n    locals_dict = {}\n    for k in locals:\n        if not k.startswith('_') and k.upper() == k:\n            locals_dict[k] = locals[k]\n    return locals_dict\n\ndef get_frame_locals_dict(stepback=0):\n    \"\"\"Generator to walk through variables considered as preferences\n    in locals dict of a given frame.\n\n    :param int stepback:\n\n    :rtype: dict\n\n    \"\"\"\n    locals_dict = {}\n    for k in locals:\n        if not k.startswith('_') and k.upper() == k:\n            locals_dict[k] = locals[k]\n    return locals_dict\n\ndef get_frame_locals_dict_with_prefs(stepback=0):\n    \"\"\"Generator to walk through variables considered as preferences\n    in locals dict of a given frame.\n\n    :param int stepback:\n\n    :rtype: dict\n\n    \"\"\"\n    locals_dict = {}\n    for k in locals:\n        if not",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "\n\ndef _bind_kwargs(sig, param_matchers, kwargs):\n        '''\n        Attempt to bind the kwargs to the type signature. First try to just bind\n        to the signature, then ensure that all arguments match the parameter\n        types.\n        '''\n        #Bind to signature. May throw its own TypeError\n        bound = sig.bind(*kwargs, **kwargs)\n\n        if not all(param_matcher(bound.arguments[param_name])\n                for param_name, param_matcher in param_matchers):\n            raise TypeError\n\n        return bound\n\ndef _bind_args_kwargs(sig, param_matchers, args, kwargs):\n        '''\n        Attempt to bind the args and kwargs to the type signature. First try to\n        just bind to the signature, then ensure that all arguments match the\n        parameter types.\n        '''\n        #Bind to signature. May throw its own TypeError\n        bound = sig.bind(*args, **kwargs)\n\n        if not all(param_matcher(bound.arguments[param_name])\n                for param_name, param_matcher in param_matchers):\n            raise TypeError\n\n        return bound\n\ndef _bind_kwargs_args(sig, param_matchers, kwargs, args):\n        '''\n        Attempt to bind the kwargs and args to the type signature. First",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "\n\nclass DispatchGroup(object):\n    '''\n    A dispatch group that executes dispatch calls for a given function.\n    '''\n\n    def __init__(self, func):\n        self.func = func\n        self.dispatch = []\n        self.dispatch_first = []\n        self.lookup = {}\n\n    def execute(self, *args, **kwargs):\n        '''\n        Executes the dispatch call for the given function.\n        '''\n        return self.func(*args, **kwargs)\n\n    def dispatch(self, func):\n        '''\n        Adds a dispatch call to the dispatch group.\n        '''\n        self.dispatch.append(func)\n\n    def dispatch_first(self, func):\n        '''\n        Adds a dispatch call to the dispatch group.\n        '''\n        self.dispatch_first.append(func)\n\n    def lookup(self, key):\n        '''\n        Returns the value associated with the given key.\n        '''\n        return self.lookup[key]\n\n    def __call__(self, func):\n        '''\n        Wraps the given function in a wrapper that executes the dispatch call for\n        func.\n        '''\n        return _make_wrapper(self, func)\n\n    def __call__(self, func):\n        '''\n        Wraps the given",
        "(func)\n\ndef _make_dispatch(func):\n        '''\n        Creates a dispatch object that will be used to call the decorated function.\n        '''\n        def wrapper(*args, **kwargs):\n                '''\n                Decorates the function and returns the result of the function.\n                '''\n                return func(*args, **kwargs)\n        return wrapper\n\ndef _make_wrapper(func):\n        '''\n        Creates a wrapper function that will be used to call the decorated function.\n        '''\n        def wrapper(*args, **kwargs):\n                '''\n                Decorates the function and returns the result of the function.\n                '''\n                return func(*args, **kwargs)\n        return wrapper\n\ndef _make_decorator(func):\n        '''\n        Creates a decorator function that will be used to call the decorated function.\n        '''\n        def wrapper(*args, **kwargs):\n                '''\n                Decorates the function and returns the result of the function.\n                '''\n                return func(*args, **kwargs)\n        return wrapper\n\ndef _make_decorator_decorator(func):\n        '''\n        Creates a decorator function that will be used to call the decorated function.\n        '''\n        def wrapper(*args, **kwargs):\n                '''\n                Decorates the function and returns the result of the function.\n                '''",
        "(func)\n\ndef dispatch_last(self, func):\n        '''\n        Adds the decorated function to this dispatch, at the BACK of the order.\n        Useful for allowing third parties to add overloaded functionality\n        to be executed after default functionality.\n        '''\n        self.callees.append(self._make_dispatch(func))\n        return self.make_wrapper(func)\n\ndef dispatch_middle(self, func):\n        '''\n        Adds the decorated function to this dispatch, at the MIDDLE of the order.\n        Useful for allowing third parties to add overloaded functionality\n        to be executed before default functionality.\n        '''\n        self.callees.append(self._make_dispatch(func))\n        return self.make_wrapper(func)\n\ndef dispatch_last_middle(self, func):\n        '''\n        Adds the decorated function to this dispatch, at the BACK of the order.\n        Useful for allowing third parties to add overloaded functionality\n        to be executed after default functionality.\n        '''\n        self.callees.append(self._make_dispatch(func))\n        return self.make_wrapper(func)\n\ndef dispatch_first_middle(self, func):\n        '''\n        Adds the decorated function to this dispatch, at the FRONT of the order.\n        Useful for",
        "(args, kwargs)\n\ndef lookup_explicit(args, kwargs):\n    '''\n    Lookup a function by type signature.\n    '''\n    for func in self.functions:\n        if func.signature == args and func.kwargs == kwargs:\n            return func\n    return None\n\ndef lookup_explicit_by_name(name):\n    '''\n    Lookup a function by name.\n    '''\n    for func in self.functions:\n        if func.name == name:\n            return func\n    return None\n\ndef lookup_explicit_by_signature(signature):\n    '''\n    Lookup a function by signature.\n    '''\n    for func in self.functions:\n        if func.signature == signature:\n            return func\n    return None\n\ndef lookup_explicit_by_kwargs(kwargs):\n    '''\n    Lookup a function by kwargs.\n    '''\n    for func in self.functions:\n        if func.kwargs == kwargs:\n            return func\n    return None\n\ndef lookup_explicit_by_args(args):\n    '''\n    Lookup a function by args.\n    '''\n    for func in self.functions:\n        if func.args == args:\n            return func\n    return None\n\ndef lookup_explicit_by_kwargs_by_name(name):\n    '''\n    Lookup a",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "(args, kwargs))\n\ndef on_pref_delete(*args, **kwargs):\n    \"\"\"Triggered on dynamic preferences model delete.\n     Issues DB delete and reread.\n\n    \"\"\"\n    Preference.delete_prefs(*args, **kwargs)\n    Preference.read_prefs(get_prefs())\n\ndef on_pref_clear(*args, **kwargs):\n    \"\"\"Triggered on dynamic preferences model clear.\n     Issues DB clear and reread.\n\n    \"\"\"\n    Preference.clear_prefs(*args, **kwargs)\n    Preference.read_prefs(get_prefs())\n\ndef on_pref_clear_all(*args, **kwargs):\n    \"\"\"Triggered on dynamic preferences model clear all.\n     Issues DB clear and reread.\n\n    \"\"\"\n    Preference.clear_all_prefs(*args, **kwargs)\n    Preference.read_prefs(get_prefs())\n\ndef on_pref_clear_all_all(*args, **kwargs):\n    \"\"\"Triggered on dynamic preferences model clear all all.\n     Issues DB clear all and reread.\n\n    \"\"\"\n    Preference.clear_all_all_prefs(*args, **kwargs)\n    Preference.read_prefs(get_prefs())\n\ndef on_pref",
        "\n\ndef get_prefs():\n    \"\"\"Returns a dictionary of preference values.\n\n    :rtype: dict\n\n    \"\"\"\n    return get_frame_locals()\n\ndef get_frame_locals():\n    \"\"\"Returns a dictionary of preference values.\n\n    :rtype: dict\n\n    \"\"\"\n    return locals()\n\ndef get_frame_locals_dict():\n    \"\"\"Returns a dictionary of preference values.\n\n    :rtype: dict\n\n    \"\"\"\n    return locals_dict()\n\ndef get_frame_locals_dict_copy():\n    \"\"\"Returns a dictionary of preference values.\n\n    :rtype: dict\n\n    \"\"\"\n    return locals_dict.copy()\n\ndef get_frame_locals_dict_copy_copy():\n    \"\"\"Returns a dictionary of preference values.\n\n    :rtype: dict\n\n    \"\"\"\n    return locals_dict.copy()\n\ndef get_frame_locals_dict_copy_copy_copy():\n    \"\"\"Returns a dictionary of preference values.\n\n    :rtype: dict\n\n    \"\"\"\n    return locals_dict.copy()\n\ndef get_frame_locals_dict_copy_copy_copy_copy():\n    \"\"\"Returns a dictionary of preference values.\n\n    :rtype: dict\n\n    \"\"\"\n    return locals_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef import_prefs():\n    \"\"\"Import all preferences available in all apps.\n\n    \"\"\"\n    from django.conf import settings\n    from django.conf.local import settings as local_settings\n    from django.conf.global import settings as global_settings\n    from django.conf.urls import patterns, url\n\n    # Import all apps.\n    for app_label, app_module in local_settings.INSTALLED_APPS.items():\n        try:\n            app_module.load_prefs()\n        except ImportError:\n            pass\n\n    # Import all apps.\n    for app_label, app_module in global_settings.INSTALLED_APPS.items():\n        try:\n            app_module.load_prefs()\n        except ImportError:\n            pass\n\n    # Import all apps.\n    for app_label, app_module in patterns.urlpatterns.items():\n        try:\n            app_module.load_prefs()\n        except ImportError:\n            pass\n\n    # Import all apps.\n    for app_label, app_module in url.patterns.urlpatterns.items():\n        try:\n            app_module.load_prefs()\n        except ImportError:\n            pass\n\n    # Import all apps.\n    for app_label, app_module in patterns",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "\n\ndef get_frame_locals(depth):\n    \"\"\"Returns a tuple of the frame name and the locals dict.\n\n    :param int depth: Frame count to go backward.\n\n    \"\"\"\n    frame_name = sys.modules[sys.modules['__name__']]['__name__']\n    frame_locals = sys.modules[frame_name]['__locals__']\n\n    for name, locals_dict in traverse_local_prefs(depth):\n        frame_locals[name] = locals_dict[name]\n\n    return frame_name, frame_locals\n\ndef traverse_local_prefs(depth):\n    \"\"\"Returns a tuple of the frame name and the locals dict.\n\n    :param int depth: Frame count to go backward.\n\n    \"\"\"\n    frame_name = sys.modules[sys.modules['__name__']]['__name__']\n    frame_locals = sys.modules[frame_name]['__locals__']\n\n    for name, locals_dict in traverse_local_prefs(depth + 1):\n        frame_locals[name] = locals_dict[name]\n\n    return frame_name, frame_locals\n\ndef traverse_local_prefs_depth(depth):\n    \"\"\"Returns a tuple of the frame name and the locals dict.\n\n    :param int depth",
        "\n\n\ndef bind_proxy(*args, **kwargs):\n    \"\"\"Bind preferences to the current site.\n\n    Expects preferences as *args.\n\n    Use keyword arguments to batch apply params supported by\n    ``PrefProxy`` to all preferences not constructed by ``pref`` and ``pref_group``.\n\n    Batch kwargs:\n\n        :param str|unicode help_text: Field help text.\n\n        :param bool static: Leave this preference static (do not store in DB).\n\n        :param bool readonly: Make this field read only.\n\n    \"\"\"\n    bind_proxy_with_kwargs(args, kwargs)\n\n\ndef bind_proxy_with_kwargs(*args, **kwargs):\n    \"\"\"Bind preferences to the current site.\n\n    Expects preferences as *args.\n\n    Use keyword arguments to batch apply params supported by\n    ``PrefProxy`` to all preferences not constructed by ``pref`` and ``pref_group``.\n\n    Batch kwargs:\n\n        :param str|unicode help_text: Field help text.\n\n        :param bool static: Leave this preference static (do not store in DB).\n\n        :param bool readonly: Make this field read only.\n\n    \"\"\"\n    bind_proxy_with_kwargs_with_kwargs(args, kwargs)\n\n\ndef bind_proxy_with_kwargs",
        "\n            proxy.category_help_text = help_text\n            proxy.category_static = static\n            proxy.category_readonly = readonly\n            break\n\n\ndef bind_proxy(prefs, title, help_text='', static=True, readonly=False):\n    \"\"\"Marks preferences group.\n\n    :param list|tuple prefs: Preferences to group.\n\n    :param str|unicode title: Group title\n\n    :param str|unicode help_text: Field help text.\n\n    :param bool static: Leave this preference static (do not store in DB).\n\n    :param bool readonly: Make this field read only.\n\n    \"\"\"\n    for proxy in prefs:  # For preferences already marked by pref().\n        if isinstance(proxy, PrefProxy):\n            proxy.category = title\n            proxy.category_help_text = help_text\n            proxy.category_static = static\n            proxy.category_readonly = readonly\n            break\n\n\ndef pref(title, help_text='', static=True, readonly=False):\n    \"\"\"Marks preferences.\n\n    :param str|unicode title: Group title\n\n    :param str|unicode help_text: Field help text.\n\n    :param bool static: Leave this preference static (do not store in DB).\n\n    :param bool readonly: Make this field read",
        " None\n\n\ndef bind_proxy(preference, field=None, verbose_name=None, help_text='', static=True, readonly=False):\n    \"\"\"Marks a preference as a proxy.\n\n    :param preference: Preference variable.\n\n    :param Field field: Django model field to represent this preference.\n\n    :param str|unicode verbose_name: Field verbose name.\n\n    :param str|unicode help_text: Field help text.\n\n    :param bool static: Leave this preference static (do not store in DB).\n\n    :param bool readonly: Make this field read only.\n\n    :rtype: PrefProxy|None\n    \"\"\"\n    if field is None:\n        field = preference\n\n    if static:\n        field.static = True\n\n    if readonly:\n        field.readonly = True\n\n    return PrefProxy(preference, field, verbose_name, help_text)\n\n\nclass PrefProxy(object):\n    \"\"\"A proxy for a preference.\n\n    :param preference: Preference variable.\n\n    :param Field field: Django model field to represent this preference.\n\n    :param str|unicode verbose_name: Field verbose name.\n\n    :param str|unicode help_text: Field help text.\n\n    :rtype: PrefProxy\n    \"\"\"\n    def __init",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef objective_function(param_scales=(1, 1), xstar=None, seed=None):\n    \"\"\"Gives objective functions a number of dimensions and parameter range\n\n    Parameters\n    ----------\n    param_scales : (int, int)\n        Scale (std. dev.) for choosing each parameter\n\n    xstar : array_like\n        Optimal parameters\n    \"\"\"\n    ndim = len(param_scales)\n\n    def decorator(func):\n\n        @wraps(func)\n        def wrapper(theta):\n            return func(theta)\n\n        def param_init():\n            return np.random.randn(ndim,) * np.array(param_scales)\n\n        wrapper.ndim = ndim\n        wrapper.param_init = param_init\n        wrapper.xstar = xstar\n\n        return wrapper\n\n    return decorator\n\ndef objective_function_with_seed(param_scales=(1, 1), xstar=None, seed=None):\n    \"\"\"Gives objective functions a number of dimensions and parameter range\n\n    Parameters\n    ----------\n    param_scales : (int, int)\n        Scale (std. dev.) for choosing each parameter\n\n    xstar : array_like\n        Optimal parameters\n    \"\"\"\n    ndim = len(",
        "\n\ndef quadratic(theta):\n    \"\"\"Pointwise minimum of two quadratic bowls\"\"\"\n    k0, k1, depth = 0.01, 100, 0.5\n    shallow = 0.5 * k0 * theta ** 2 + depth\n    deep = 0.5 * k1 * theta ** 2\n    obj = float(np.minimum(shallow, deep))\n    grad = np.where(deep < shallow, k1 * theta, k0 * theta)\n    return obj, grad\n\ndef quadratic_gradient(theta):\n    \"\"\"Pointwise minimum of two quadratic bowls\"\"\"\n    k0, k1, depth = 0.01, 100, 0.5\n    shallow = 0.5 * k0 * theta ** 2 + depth\n    deep = 0.5 * k1 * theta ** 2\n    obj = float(np.minimum(shallow, deep))\n    grad = np.where(deep < shallow, k1 * theta, k0 * theta)\n    return obj, grad\n\ndef quadratic_gradient_gradient(theta):\n    \"\"\"Pointwise minimum of two quadratic bowls\"\"\"\n    k0, k1, depth = 0.01, 100, 0.5\n    shallow = 0.5 * k0 * theta ** 2 + depth\n    deep = 0.5 * k1 * theta ** 2",
        "\n\ndef rosenbrock_gradient(theta):\n    \"\"\"Objective and gradient for the rosenbrock function\"\"\"\n    x, y = theta\n    obj = (1 - x)**2 + 100 * (y - x**2)**2\n\n    grad = np.zeros(2)\n    grad[0] = 2 * x - 400 * (x * y - x**3) - 2\n    grad[1] = 200 * (y - x**2)\n    return obj, grad\n\ndef rosenbrock_gradient_gradient(theta):\n    \"\"\"Objective and gradient for the rosenbrock function\"\"\"\n    x, y = theta\n    obj = (1 - x)**2 + 100 * (y - x**2)**2\n\n    grad = np.zeros(2)\n    grad[0] = 2 * x - 400 * (x * y - x**3) - 2\n    grad[1] = 200 * (y - x**2)\n    return obj, grad\n\ndef rosenbrock_gradient_gradient_gradient(theta):\n    \"\"\"Objective and gradient for the rosenbrock function\"\"\"\n    x, y = theta\n    obj = (1 - x)**2 + 100 * (y - x**2)**2\n\n",
        "\n\ndef beach(theta):\n    \"\"\"Beach's function\"\"\"\n    x, y = theta\n    A = 1.5 - x + x * y\n    B = 2.25 - x + x * y**2\n    C = 2.625 - x + x * y**3\n    obj = A ** 2 + B ** 2 + C ** 2\n    grad = np.array([\n        2 * A * (y - 1) + 2 * B * (y ** 2 - 1) + 2 * C * (y ** 3 - 1),\n        2 * A * x + 4 * B * x * y + 6 * C * x * y ** 2\n    ])\n    return obj, grad\n\ndef beach2(theta):\n    \"\"\"Beach's function\"\"\"\n    x, y = theta\n    A = 1.5 - x + x * y\n    B = 2.25 - x + x * y**2\n    C = 2.625 - x + x * y**3\n    obj = A ** 2 + B ** 2 + C ** 2\n    grad = np.array([\n        2 * A * (y - 1) + 2 * B * (y ** 2 - 1) + 2 * C * (y ** 3 - 1),\n        2 * A * x + 4 * B * x",
        "\n\ndef smooth(theta):\n    \"\"\"Smooth's function\"\"\"\n    x, y = theta\n\n    A = x + 2 * y - 7\n    B = 2 * x + y - 5\n    obj = A**2 + B**2\n    grad = np.array([2 * A + 4 * B, 4 * A + 2 * B])\n    return obj, grad\n\ndef smooth_smooth(theta):\n    \"\"\"Smooth's function\"\"\"\n    x, y = theta\n\n    A = x + 2 * y - 7\n    B = 2 * x + y - 5\n    obj = A**2 + B**2\n    grad = np.array([2 * A + 4 * B, 4 * A + 2 * B])\n    return obj, grad\n\ndef smooth_smooth_smooth(theta):\n    \"\"\"Smooth's function\"\"\"\n    x, y = theta\n\n    A = x + 2 * y - 7\n    B = 2 * x + y - 5\n    obj = A**2 + B**2\n    grad = np.array([2 * A + 4 * B, 4 * A + 2 * B])\n    return obj, grad\n\ndef smooth_smooth_smooth_smooth(theta):\n    \"\"\"Smooth's function\"\"\"\n    x, y = theta\n\n    A = x +",
        "\n\ndef camel_grad(theta):\n    \"\"\"Three-hump camel function\"\"\"\n    x, y = theta\n    obj = 2 * x ** 2 - 1.05 * x ** 4 + x ** 6 / 6 + x * y + y ** 2\n    grad = np.array([\n        4 * x - 4.2 * x ** 3 + x ** 5 + y,\n        x + 2 * y\n    ])\n    return obj, grad\n\ndef camel_grad_grad(theta):\n    \"\"\"Three-hump camel function\"\"\"\n    x, y = theta\n    obj = 2 * x ** 2 - 1.05 * x ** 4 + x ** 6 / 6 + x * y + y ** 2\n    grad = np.array([\n        4 * x - 4.2 * x ** 3 + x ** 5 + y,\n        x + 2 * y\n    ])\n    return obj, grad\n\ndef camel_grad_grad_grad(theta):\n    \"\"\"Three-hump camel function\"\"\"\n    x, y = theta\n    obj = 2 * x ** 2 - 1.05 * x ** 4 + x ** 6 / 6 + x * y + y ** 2\n    grad = np.array([\n        4 * x - 4.2 * x ** 3 + x ** 5 + y,\n        x +",
        "\n\ndef bohachevsky2(theta):\n    \"\"\"Two of the Bohachevsky functions\"\"\"\n    x, y = theta\n    obj = x ** 2 + 2 * y ** 2 - 0.3 * np.cos(3 * np.pi * x) - 0.4 * np.cos(4 * np.pi * y) + 0.7\n    grad = np.array([\n        2 * x + 0.3 * np.sin(3 * np.pi * x) * 3 * np.pi,\n        4 * y + 0.4 * np.sin(4 * np.pi * y) * 4 * np.pi,\n    ])\n    return obj, grad\n\ndef bohachevsky3(theta):\n    \"\"\"Three of the Bohachevsky functions\"\"\"\n    x, y = theta\n    obj = x ** 2 + 2 * y ** 2 - 0.3 * np.cos(3 * np.pi * x) - 0.4 * np.cos(4 * np.pi * y) + 0.7\n    grad = np.array([\n        2 * x + 0.3 * np.sin(3 * np.pi * x) * 3 * np.pi,\n        4 * y + 0.4 * np.sin(4 * np.pi *",
        "\n\ndef dixon_price_grad(theta):\n    \"\"\"Dixon-Price gradient function\"\"\"\n    x, y = theta\n    obj = (x - 1) ** 2 + 2 * (2 * y ** 2 - x) ** 2\n    grad = np.array([\n        2 * x - 2 - 4 * (2 * y ** 2 - x),\n        16 * (2 * y ** 2 - x) * y,\n    ])\n    return obj, grad\n\ndef dixon_price_grad_grad(theta):\n    \"\"\"Dixon-Price gradient gradient function\"\"\"\n    x, y = theta\n    obj = (x - 1) ** 2 + 2 * (2 * y ** 2 - x) ** 2\n    grad = np.array([\n        2 * x - 2 - 4 * (2 * y ** 2 - x),\n        16 * (2 * y ** 2 - x) * y,\n    ])\n    return obj, grad\n\ndef dixon_price_grad_grad_grad(theta):\n    \"\"\"Dixon-Price gradient gradient gradient function\"\"\"\n    x, y = theta\n    obj = (x - 1) ** 2 + 2 * (2 * y ** 2 - x) ** 2\n    grad = np.array([\n        2 * x - 2 -",
        "\n\ndef stblinski_tang_grad(theta):\n    \"\"\"Styblinski-Tang gradient function\"\"\"\n    x, y = theta\n    obj = 0.5 * (x ** 4 - 16 * x ** 2 + 5 * x + y ** 4 - 16 * y ** 2 + 5 * y)\n    grad = np.array([\n        2 * x ** 3 - 16 * x + 2.5,\n        2 * y ** 3 - 16 * y + 2.5,\n    ])\n    return obj, grad\n\ndef stblinski_tang_grad_grad(theta):\n    \"\"\"Styblinski-Tang gradient gradient function\"\"\"\n    x, y = theta\n    obj = 0.5 * (x ** 4 - 16 * x ** 2 + 5 * x + y ** 4 - 16 * y ** 2 + 5 * y)\n    grad = np.array([\n        2 * x ** 3 - 16 * x + 2.5,\n        2 * y ** 3 - 16 * y + 2.5,\n    ])\n    return obj, grad\n\ndef stblinski_tang_grad_grad_grad(theta):\n    \"\"\"Styblinski-Tang gradient gradient gradient function\"\"\"\n    x, y = theta\n    obj = 0.5 * (x **",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef delete_bucket(self, *args, **kwargs):\n        \"\"\"Remove the bucket from MimicDB after successful deletion.\n        \"\"\"\n        bucket = super(S3Connection, self).delete_bucket(*args, **kwargs)\n\n        if bucket:\n            mimicdb.backend.srem(tpl.connection, bucket.name)\n\n        return bucket\n\ndef get_bucket(self, *args, **kwargs):\n        \"\"\"Get the bucket from MimicDB after successful retrieval.\n        \"\"\"\n        bucket = super(S3Connection, self).get_bucket(*args, **kwargs)\n\n        if bucket:\n            mimicdb.backend.sget(tpl.connection, bucket.name)\n\n        return bucket\n\ndef list_buckets(self, *args, **kwargs):\n        \"\"\"List all buckets in MimicDB after successful retrieval.\n        \"\"\"\n        buckets = super(S3Connection, self).list_buckets(*args, **kwargs)\n\n        if buckets:\n            mimicdb.backend.smembers(tpl.connection, bucket.name)\n\n        return buckets\n\ndef list_objects(self, *args, **kwargs):\n        \"\"\"List all objects in MimicDB after successful retrieval.\n        \"\"\"\n        objects = super(S3Connection, self).list_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\nclass Bucket(object):\n    \"\"\"\n    A bucket is a collection of objects.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Create a new bucket.\n\n        :param string name: The name of the bucket.\n        :param string bucket_type: The type of bucket.\n        :param string bucket_location: The location of the bucket.\n        :param string bucket_acl: The ACL of the bucket.\n        :param string bucket_acl_description: The description of the ACL.\n        :param string bucket_acl_description_description: The description of the ACL.\n        :param string bucket_acl_description_description_description: The description of the ACL.\n        :param string bucket_acl_description_description_description: The description of the ACL.\n        :param string bucket_acl_description_description_description: The description of the ACL.\n        :param string bucket_acl_description_description_description: The description of the ACL.\n        :param string bucket_acl_description_description_description: The description of the ACL.\n        :param string bucket_acl_description_description_description: The description of the ACL.\n        :param string bucket_acl_description_description_description: The description of the ACL.\n        :param string bucket_acl_",
        "\n\nclass Key(object):\n    \"\"\"A key in a bucket.\n\n    This class is used to store the metadata and key for a bucket.\n    \"\"\"\n    def __init__(self, bucket):\n        self.bucket = bucket\n        self.name = None\n        self.size = 0\n        self.etag = None\n\n    def __repr__(self):\n        return '<Key %r>' % self.name\n\n    def __str__(self):\n        return '<Key %r>' % self.name\n\n    def __eq__(self, other):\n        return self.name == other.name\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.name)\n\n    def __eq__(self, other):\n        return self.name == other.name\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __str__(self):\n        return '<Key %r>' % self.name\n\n    def __repr__(self):\n        return '<Key %r>' % self.name\n\n    def __str__(self):\n        return '<Key %r>' % self.name\n\n    def __",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "(keys=ikeys)\n\n\nclass Bucket(object):\n    \"\"\"A bucket is a set of keys.\n\n    A bucket is a set of keys.  It is a set of keys.  It is a set of keys.\n    It is a set of keys.  It is a set of keys.  It is a set of keys.\n    It is a set of keys.  It is a set of keys.  It is a set of keys.\n    It is a set of keys.  It is a set of keys.  It is a set of keys.\n    It is a set of keys.  It is a set of keys.  It is a set of keys.\n    It is a set of keys.  It is a set of keys.  It is a set of keys.\n    It is a set of keys.  It is a set of keys.  It is a set of keys.\n    It is a set of keys.  It is a set of keys.  It is a set of keys.\n    It is a set of keys.  It is a set of keys.  It is a set of keys.\n    It is a set of keys.  It is a set of keys.  It is a set of keys.\n    It is a set of keys.  It is a set of keys.  It is a set",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\nclass Key(object):\n    \"\"\"A key in a bucket.\n\n    :param Bucket bucket: The bucket to which this key belongs\n    :param string key: The key to be stored\n    \"\"\"\n    def __init__(self, bucket, key):\n        self.bucket = bucket\n        self.key = key\n\n    def _load_meta(self, size, md5):\n        \"\"\"Load the key's metadata.\n\n        :param int size: The size of the key in bytes\n        :param str md5: The MD5 hash of the key in hex\n        \"\"\"\n        self.size = size\n        self.md5 = md5\n\n    def __repr__(self):\n        return '<Key %r>' % self.key\n\n    def __str__(self):\n        return '<Key %r>' % self.key\n\n    def __eq__(self, other):\n        return self.key == other.key\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.key)\n\n    def __str__(self):\n        return '<Key %r>' % self.key\n\n    def __repr__(self):\n        return '<Key %r>' %",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\n\ndef lbfgs_b(x, rho, f_df, maxiter=20):\n    \"\"\"\n    Minimize the proximal operator of a given objective using L-BFGS-B\n\n    Parameters\n    ----------\n    f_df : function\n        Returns the objective and gradient of the function to minimize\n\n    maxiter : int\n        Maximum number of L-BFGS-B iterations\n    \"\"\"\n\n    def f_df_augmented(theta):\n        f, df = f_df(theta)\n        obj = f + (rho / 2.) * np.linalg.norm(theta - x) ** 2\n        grad = df + rho * (theta - x)\n        return obj, grad\n\n    res = scipy_minimize(f_df_augmented, x, jac=True, method='L-BFGS-B',\n                         options={'maxiter': maxiter, 'disp': False})\n\n    return res.x\n\n\ndef lbfgs_c(x, rho, f_df, maxiter=20):\n    \"\"\"\n    Minimize the proximal operator of a given objective using L-BFGS-C\n\n    Parameters\n    ----------\n    f_df : function\n        Returns the objective and gradient of the function to minimize\n\n    maxiter : int\n        Maximum number of L-",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "(np.maximum(U, 0)).dot(np.diag(np.maximum(U, 0)).dot(rho)))\n\ndef sdcone_2(x, rho):\n    \"\"\"Projection onto the semidefinite cone\"\"\"\n    U, V = np.linalg.eigh(x)\n    return V.dot(np.diag(np.maximum(U, 0)).dot(np.diag(np.maximum(U, 0)).dot(rho)))\n\ndef sdcone_3(x, rho):\n    \"\"\"Projection onto the semidefinite cone\"\"\"\n    U, V = np.linalg.eigh(x)\n    return V.dot(np.diag(np.maximum(U, 0)).dot(np.diag(np.maximum(U, 0)).dot(rho)))\n\ndef sdcone_4(x, rho):\n    \"\"\"Projection onto the semidefinite cone\"\"\"\n    U, V = np.linalg.eigh(x)\n    return V.dot(np.diag(np.maximum(U, 0)).dot(np.diag(np.maximum(U, 0)).dot(rho)))\n\ndef sdcone_5(x, rho):\n    \"\"\"Projection onto the semidefinite cone\"\"\"\n    U, V",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\ndef rows(x, rho, proxop):\n    \"\"\"Applies a proximal operator to the rows of a matrix\"\"\"\n\n    xnext = np.zeros_like(x)\n\n    for ix in range(x.shape[0]):\n        xnext[:, ix] = proxop(x[:, ix], rho)\n\n    return xnext\n\ndef diagonal(x, rho, proxop):\n    \"\"\"Applies a proximal operator to the diagonal of a matrix\"\"\"\n\n    xnext = np.zeros_like(x)\n\n    for ix in range(x.shape[0]):\n        xnext[:, ix] = proxop(x[:, ix], rho)\n\n    return xnext\n\ndef diagonal_diagonal(x, rho, proxop):\n    \"\"\"Applies a proximal operator to the diagonal of a matrix\"\"\"\n\n    xnext = np.zeros_like(x)\n\n    for ix in range(x.shape[0]):\n        xnext[:, ix] = proxop(x[:, ix], rho)\n\n    return xnext\n\ndef diagonal_diagonal_diagonal(x, rho, proxop):\n    \"\"\"Applies a proximal operator to the diagonal of a matrix\"\"\"\n\n    xnext = np.zeros_like(x)\n\n    for ix in range(x.",
        "\n",
        "\n\ndef add_operator(self, operator, *args):\n        \"\"\"Adds a proximal operator to the list of operators\"\"\"\n\n        if isinstance(operator, str):\n            op = getattr(proxops, operator)(*args)\n        elif isinstance(operator, proxops.ProximalOperatorBaseClass):\n            op = operator\n        else:\n            raise ValueError(\"operator must be a string or a subclass of ProximalOperator\")\n\n        self.operators.append(op)\n        return self\n\ndef add_operator_list(self, operators):\n        \"\"\"Adds a list of proximal operators to the list of operators\"\"\"\n\n        self.operators.extend(operators)\n        return self\n\ndef add_operator_list_with_args(self, operators, *args):\n        \"\"\"Adds a list of proximal operators to the list of operators\"\"\"\n\n        self.operators.extend(operators)\n        return self\n\ndef add_operator_list_with_args_with_default(self, operators, *args, default=None):\n        \"\"\"Adds a list of proximal operators to the list of operators\"\"\"\n\n        self.operators.extend(operators)\n        return self\n\ndef add_operator_list_with_default(self, operators, default=None):\n        \"\"\"Adds a list of proximal operators to the list",
        "\n\ndef _load_meta_from_file(self, path):\n        \"\"\"Load metadata from a file.\n        \"\"\"\n        with open(path, 'rb') as f:\n            _load_meta(self, f.tell(), f.read())\n\ndef _load_meta_from_string(self, s):\n        \"\"\"Load metadata from a string.\n        \"\"\"\n        s = s.strip()\n        if s.startswith('#'):\n            s = s[1:]\n        if s.startswith('#'):\n            s = s[1:]\n        s = s.strip()\n        if s.startswith('#'):\n            s = s[1:]\n        s = s.strip()\n        if s.startswith('#'):\n            s = s[1:]\n        s = s.strip()\n        if s.startswith('#'):\n            s = s[1:]\n        s = s.strip()\n        if s.startswith('#'):\n            s = s[1:]\n        s = s.strip()\n        if s.startswith('#'):\n            s = s[1:]\n        s = s.strip()\n        if s.startswith('#'):\n            s = s[1:]\n        s = s.strip()\n        if s",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef first(x):\n    return x\n\ndef second(x):\n    return x\n\ndef destruct(x, xref):\n    return xref[x]\n\ndef lrucache(f, size=1):\n    \"\"\"\n    A cache that can be used to reduce the number of calls to the\n    function.\n\n    Parameters\n    ----------\n    f : function\n        Must be unary (takes a single argument)\n\n    size : int, optional\n        Size of the cache (Default=1)\n    \"\"\"\n    def wrapper(x):\n        return f(x)\n    return wrapper\n",
        "\n",
        "\n\ndef wrap(f_df, xref, size=0):\n    \"\"\"\n    Wrap a function with a gradient function\n\n    Parameters\n    ----------\n    f_df : function\n        The analytic objective and gradient function to wrap\n\n    xref : array_like\n        Parameter values to wrap the function with\n\n    size : int, optional\n        Number of parameters to wrap the function with\n\n    Returns\n    -------\n    obj : function\n        The wrapped function\n\n    grad : function\n        The wrapped gradient function\n    \"\"\"\n    obj = f_df(xref)\n    grad = f_df(xref + size)\n    return obj, grad\n\ndef destruct(xref):\n    \"\"\"\n    Destructively wrap a function with a gradient function\n\n    Parameters\n    ----------\n    xref : array_like\n        Parameter values to wrap the function with\n\n    Returns\n    -------\n    obj : function\n        The wrapped function\n\n    grad : function\n        The wrapped gradient function\n    \"\"\"\n    obj = f_df(xref)\n    grad = f_df(xref + size)\n    return obj, grad\n",
        "\n\ndef validate(self, repo, spec, args):\n        \"\"\"\n        Validate the files identified for checksum.\n        \"\"\"\n\n        status = []\n\n        # Do we have to any thing at all? \n        if len(spec['files']) == 0: \n            return status \n\n        with cd(repo.rootdir):\n            \n            rules = None \n            if 'rules-files' in spec and len(spec['rules-files']) > 0: \n                rulesfiles = spec['rules-files']\n                rules = {} \n                for f in rulesfiles:\n                    d = json.loads(open(f).read())\n                    rules.update(d)\n            elif 'rules' in spec: \n                rules = {\n                    'inline': spec['rules'] \n                }\n                \n            if rules is None or len(rules) == 0:\n                print(\"Regression quality validation has been enabled but no rules file has been specified\")\n                print(\"Example: { 'min-r2': 0.25 }. Put this either in file or in dgit.json\")\n                raise InvalidParameters(\"Regression quality checking rules missing\")\n\n            files = dict([(f, open(f).read()) for f in spec['files']])\n\n            for r in rules:\n                if 'min-r2' not in rules[r",
        "\n\ndef compute_sha256(f):\n    \"\"\"\n    Compute the SHA256 of a file\n    \"\"\"\n    with cd(f):\n        with open(f, 'rb') as f:\n            return hashlib.sha256(f.read()).hexdigest()\n\ndef cd(f):\n    \"\"\"\n    Change the current working directory to the given path\n    \"\"\"\n    os.chdir(f)\n\ndef cd_to_root(f):\n    \"\"\"\n    Change the current working directory to the root directory\n    \"\"\"\n    os.chdir(os.getcwd())\n\ndef cd_to_repo(f):\n    \"\"\"\n    Change the current working directory to the repo root directory\n    \"\"\"\n    os.chdir(repo.rootdir)\n\ndef cd_to_repo_root(f):\n    \"\"\"\n    Change the current working directory to the repo root directory\n    \"\"\"\n    os.chdir(repo.rootdir)\n\ndef cd_to_repo_root_to_repo(f):\n    \"\"\"\n    Change the current working directory to the repo root directory\n    \"\"\"\n    os.chdir(repo.rootdir)\n\ndef cd_to_repo_root_to_repo_root(f):\n    \"\"\"\n    Change the current working directory to the repo root directory",
        "\n\ndef any_tableset(self, fh):\n        \"\"\"\n        Guess the filetype and read the file into row sets\n        \"\"\"\n        #print(\"Reading file\", fh)\n\n        try:\n            table_set = any_tableset(fh)\n        except:\n            #traceback.print_exc()\n            # Cannot find the schema.\n            table_set = None\n\n        return table_set\n\ndef any_tableset(self, fh):\n        \"\"\"\n        Guess the filetype and read the file into row sets\n        \"\"\"\n        #print(\"Reading file\", fh)\n\n        try:\n            table_set = any_tableset(fh)\n        except:\n            #traceback.print_exc()\n            # Cannot find the schema.\n            table_set = None\n\n        return table_set\n\ndef any_tableset(self, fh):\n        \"\"\"\n        Guess the filetype and read the file into row sets\n        \"\"\"\n        #print(\"Reading file\", fh)\n\n        try:\n            table_set = any_tableset(fh)\n        except:\n            #traceback.print_exc()\n            # Cannot find the schema.\n            table_set = None\n\n        return table_set\n\ndef any_tableset(self, fh):\n        \"\"\"\n        Guess the filetype",
        "\n\ndef headers_guess(sample):\n        \"\"\"\n        Guess headers using messytables\n        \"\"\"\n        headers = []\n        for row in sample:\n            headers.append(row.header)\n        return len(headers), headers\n\ndef type_guess(sample, strict=False):\n        \"\"\"\n        Guess types using messytables\n        \"\"\"\n        types = []\n        for row in sample:\n            types.append(row.type)\n        return types, types\n\ndef offset_processor(offset):\n        \"\"\"\n        Guess offsets using messytables\n        \"\"\"\n        return lambda v: v + offset\n\ndef headers_processor(headers):\n        \"\"\"\n        Guess headers using messytables\n        \"\"\"\n        return lambda v: v.split(',')\n\ndef type_guess(sample, strict=False):\n        \"\"\"\n        Guess types using messytables\n        \"\"\"\n        types = []\n        for row in sample:\n            types.append(row.type)\n        return types, types\n\ndef read_file(filename):\n        \"\"\"\n        Read a file using messytables\n        \"\"\"\n        with open(filename, 'r') as f:\n            table_set = messytables.read(f)\n        return table_set\n\ndef write_file(filename, schema):\n",
        "\n\ndef fin_reference2int(n):\n    \"\"\"Calculates a checksum for a Finnish national reference number\"\"\"\n    checksum = sum([int(c) * i for c, i in zip(str(n)[::-1], it.cycle((7, 3, 1)))]) % 10\n    if checksum == 10:\n        checksum = 0\n    return n + checksum\n\ndef fin_reference_to_int(n):\n    \"\"\"Calculates a checksum for a Finnish national reference number\"\"\"\n    checksum = sum([int(c) * i for c, i in zip(str(n)[::-1], it.cycle((7, 3, 1)))]) % 10\n    if checksum == 10:\n        checksum = 0\n    return n + checksum\n\ndef fin_reference_to_fin_reference(n):\n    \"\"\"Calculates a checksum for a Finnish national reference number\"\"\"\n    checksum = sum([int(c) * i for c, i in zip(str(n)[::-1], it.cycle((7, 3, 1)))]) % 10\n    if checksum == 10:\n        checksum = 0\n    return n + checksum\n\ndef fin_reference_to_fin_reference_2(n):\n    \"\"\"Calculates a checksum for a Finnish national reference number\"\"\"\n    checksum = sum([int(c",
        "\n\ndef iso_reference_valid_number(n, raise_error=True):\n    \"\"\"Helper to make sure the given number is valid for a reference number\"\"\"\n    if n in ISO_REFERENCE_VALID:\n        return True\n    if raise_error:\n        raise ValueError(\"'%s' is not in '%s'\" % (n, ISO_REFERENCE_VALID))\n    return False\n\ndef iso_reference_valid_number_with_prefix(n, prefix, raise_error=True):\n    \"\"\"Helper to make sure the given number is valid for a reference number\"\"\"\n    if n in ISO_REFERENCE_VALID_WITH_PREFIX:\n        return True\n    if raise_error:\n        raise ValueError(\"'%s' is not in '%s'\" % (n, ISO_REFERENCE_VALID_WITH_PREFIX))\n    return False\n\ndef iso_reference_valid_number_with_suffix(n, suffix, raise_error=True):\n    \"\"\"Helper to make sure the given number is valid for a reference number\"\"\"\n    if n in ISO_REFERENCE_VALID_WITH_SUFFIX:\n        return True\n    if raise_error:\n        raise ValueError(\"'%s' is not in '%s'\" % (n, ISO_REFERENCE_VALID_WITH_SUFFIX))\n    return False\n\ndef iso_reference_valid_number_with_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef iso_reference_str2int(ref):\n    \"\"\"Converts ISO reference number to integer\"\"\"\n    ref = str(ref)\n    cs_source = ref[4:] + ref[:4]\n    return int(cs_source)\n\ndef iso_reference_str2hex(ref):\n    \"\"\"Converts ISO reference number to hexadecimal\"\"\"\n    ref = str(ref)\n    cs_source = ref[4:] + ref[:4]\n    return hex(cs_source)\n\ndef iso_reference_str2hex_int(ref):\n    \"\"\"Converts ISO reference number to hexadecimal integer\"\"\"\n    ref = str(ref)\n    cs_source = ref[4:] + ref[:4]\n    return int(cs_source)\n\ndef iso_reference_str2hex_hex(ref):\n    \"\"\"Converts ISO reference number to hexadecimal string\"\"\"\n    ref = str(ref)\n    cs_source = ref[4:] + ref[:4]\n    return hex(cs_source)\n\ndef iso_reference_str2hex_hex_int(ref):\n    \"\"\"Converts ISO reference number to hexadecimal string integer\"\"\"\n    ref = str(ref)\n    cs_source = ref[4:] + ref[:4]\n    return int(cs_source)\n\ndef iso_reference_str2hex_hex",
        "\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef find_executable_commitpath(repo, args):\n    \"\"\"\n    Find the commit path for the executable\n    \"\"\"\n    executable = args[0]\n    commiturl = args[1]\n\n    # Get the commit path\n    repo_path = repo.get_path()\n    repo_path = repo_path.split('/')[-1]\n    repo_path = repo_path.split('/')[-2]\n    repo_path = repo_path.split('/')[-3]\n\n    # Get the commit path\n    commitpath = repo_path + '/' + commiturl\n\n    # Get the commit path\n    commitpath = commitpath.split('/')[-1]\n    commitpath = commitpath.split('/')[-2]\n    commitpath = commitpath.split('/')[-3]\n\n    return (executable, commitpath)\n\ndef extract_files(filename, includes):\n    \"\"\"\n    Extract the files from the strace output\n    \"\"\"\n    # Create a local directory\n    tmpdir = tempfile.mkdtemp()\n\n    # Construct the strace command\n    print(\"Running the command\")\n    strace_filename = os.path.join(tmpdir,'strace.out.txt')\n    cmd = [\"strace.py\", \"-f\", \"-",
        "\n\ndef add_files(args, targetdir,\n        source=None,\n        script=False,\n        generator=False):\n    \"\"\"\n    Add files to the repository by explicitly specifying them or by\n    specifying a pattern over files accessed during execution of an\n    executable.\n\n    Parameters\n    ----------\n\n    repo: Repository\n\n    args: files or command line\n         (a) If simply adding files, then the list of files that must\n         be added (including any additional arguments to be passed to\n         git)\n         (b) If files to be added are an output of a command line, then\n         args is the command lined\n    targetdir: Target directory to store the files\n    script: Is this a script?\n    generator: Is this a generator\n\n    \"\"\"\n\n    # Gather the files...\n    if not execute:\n        files = run_executable(repo, args, includes)\n\n    if files is None or len(files) == 0:\n        return repo\n\n    # Update the repo package but with only those that have changed.\n\n    filtered_files = []\n    package = repo.package\n    for h in files:\n        found = False\n        for i, r in  enumerate(package['resources']):\n            if h['relativepath'] == r['relativepath']:\n               ",
        "\n\ndef find_matching_files_with_extensions(self, includes):\n        \"\"\"\n        For various actions we need files that match patterns\n        \"\"\"\n\n        if len(includes) == 0: \n            return [] \n\n        files = [f['relativepath'] for f in self.package['resources']]\n        includes = r'|'.join([fnmatch.translate(x) for x in includes])\n\n        # Match both the file name as well the path..\n        files = [f for f in files if re.match(includes, os.path.basename(f))] + \\\n                [f for f in files if re.match(includes, f)]\n        files = list(set(files))\n\n        return files\n\ndef find_matching_files_with_extensions_and_directories(self, includes):\n        \"\"\"\n        For various actions we need files that match patterns\n        \"\"\"\n\n        if len(includes) == 0: \n            return [] \n\n        files = [f['relativepath'] for f in self.package['resources']]\n        includes = r'|'.join([fnmatch.translate(x) for x in includes])\n\n        # Match both the file name as well the path..\n        files = [f for f in files if re.match(includes, os.path.basename(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_resource_list(self, p):\n        \"\"\"\n        Get metadata for a given file\n        \"\"\"\n        for r in self.package['resources']:\n            if r['relativepath'] == p:\n                r['localfullpath'] = os.path.join(self.rootdir, p)\n                return r\n\n        raise Exception(\"Invalid path\")\n\ndef get_resource_list_by_name(self, p):\n        \"\"\"\n        Get metadata for a given file\n        \"\"\"\n        for r in self.package['resources']:\n            if r['name'] == p:\n                r['localfullpath'] = os.path.join(self.rootdir, p)\n                return r\n\n        raise Exception(\"Invalid path\")\n\ndef get_resource_list_by_name_and_type(self, p, t):\n        \"\"\"\n        Get metadata for a given file\n        \"\"\"\n        for r in self.package['resources']:\n            if r['name'] == p and r['type'] == t:\n                r['localfullpath'] = os.path.join(self.rootdir, p)\n                return r\n\n        raise Exception(\"Invalid path\")\n\ndef get_resource_list_by_name_and_type_and_size(self, p,",
        "\ndef key(self, username=None, reponame=None):\n        \"\"\"\n        Return a key for a repository\n        \"\"\"\n        if username is None:\n            username = self.username\n        if reponame is None:\n            reponame = self.reponame\n        return '%s/%s' % (username, reponame)\n\nclass UnknownRepository(Exception):\n        \"\"\"\n        Raised when a repository is not found\n        \"\"\"\n        pass\n\nclass Repository(object):\n        \"\"\"\n        A repository is a collection of repositories\n        \"\"\"\n        def __init__(self, username=None, reponame=None):\n                \"\"\"\n                Initialize a repository\n                \"\"\"\n                self.username = username\n                self.reponame = reponame\n                self.repos = {}\n\n        def add(self, username, reponame, repo):\n                \"\"\"\n                Add a repository\n                \"\"\"\n                self.repos[self.key(username, reponame)] = repo\n\n        def lookup(self, username, reponame):\n                \"\"\"\n                Lookup a repository\n                \"\"\"\n                return self.repos[self.key(username, reponame)]\n\n        def remove(self, username, reponame):\n                \"\"\"\n                Remove a repository\n                \"\"\"\n                del",
        "\n        return path\n\ndef rootdir_with_username(self, username, reponame, create=True):\n        \"\"\"\n        Working directory for the repo\n        \"\"\"\n        path = os.path.join(self.workspace,\n                            'datasets',\n                            username,\n                            reponame,\n                            create=create)\n        if create:\n            try:\n                os.makedirs(path)\n            except:\n                pass\n\n        return path\n\ndef rootdir_with_reponame(self, reponame, create=True):\n        \"\"\"\n        Working directory for the repo\n        \"\"\"\n        path = os.path.join(self.workspace,\n                            'datasets',\n                            reponame,\n                            create=create)\n        if create:\n            try:\n                os.makedirs(path)\n            except:\n                pass\n\n        return path\n\ndef rootdir_with_username_and_reponame(self, username, reponame, create=True):\n        \"\"\"\n        Working directory for the repo\n        \"\"\"\n        path = os.path.join(self.workspace,\n                            'datasets',\n                            username,\n                            reponame,\n                            create=create)\n        if create:\n            try:\n                os.makedirs(path)\n           ",
        "\n\ndef remove(self, repo):\n        \"\"\"\n        Remove repo from the internal lookup table...\n        \"\"\"\n        key = self.key(repo.username, repo.reponame)\n        self.repos.pop(key, None)\n        return key\n\ndef get(self, username, reponame):\n        \"\"\"\n        Return the repo for the given username and reponame...\n        \"\"\"\n        key = self.key(username, reponame)\n        return self.repos[key]\n\ndef keys(self):\n        \"\"\"\n        Return a list of all keys in the lookup table...\n        \"\"\"\n        return self.repos.keys()\n\ndef keys_sorted(self):\n        \"\"\"\n        Return a list of all keys in the lookup table sorted by their\n        values...\n        \"\"\"\n        return sorted(self.repos.keys())\n\ndef keys_sorted_by_value(self):\n        \"\"\"\n        Return a list of all keys in the lookup table sorted by their\n        values sorted by their values...\n        \"\"\"\n        return sorted(self.repos.keys(), key=lambda k: self.repos[k].value)\n\ndef keys_sorted_by_value_sorted(self):\n        \"\"\"\n        Return a list of all keys in the lookup table sorted by their\n        values sorted by",
        "\n\ndef lookup_by_name(username, reponame):\n    \"\"\"\n    Lookup a repo based on username reponame\n    \"\"\"\n\n    mgr = plugins_get_mgr()\n\n    # XXX This should be generalized to all repo managers.\n    repomgr = mgr.get(what='repomanager', name='git')\n    repo =  repomgr.lookup_by_name(username=username,\n                                 reponame=reponame)\n    return repo\n\ndef lookup_by_url(url):\n    \"\"\"\n    Lookup a repo based on url\n    \"\"\"\n\n    mgr = plugins_get_mgr()\n\n    # XXX This should be generalized to all repo managers.\n    repomgr = mgr.get(what='repomanager', name='git')\n    repo =  repomgr.lookup_by_url(url=url)\n    return repo\n\ndef lookup_by_url_and_name(url, name):\n    \"\"\"\n    Lookup a repo based on url and name\n    \"\"\"\n\n    mgr = plugins_get_mgr()\n\n    # XXX This should be generalized to all repo managers.\n    repomgr = mgr.get(what='repomanager', name='git')\n    repo =  repomgr.lookup_by_url_",
        "\n\ndef run(args):\n    \"\"\"\n    Run a shell command within the repo's context\n\n    Parameters\n    ----------\n\n    repo: Repository object\n    args: Shell command\n    \"\"\"\n    try:\n        return subprocess.check_output(args, shell=True)\n    except subprocess.CalledProcessError as e:\n        raise CommandError(e.output)\n\n\ndef cd(path):\n    \"\"\"\n    Change the current working directory to a new path\n\n    Parameters\n    ----------\n\n    path: Path to change to\n    \"\"\"\n    os.chdir(path)\n\n\ndef cd_to_root(path):\n    \"\"\"\n    Change the current working directory to the root directory\n\n    Parameters\n    ----------\n\n    path: Path to change to\n    \"\"\"\n    os.chdir(os.getcwd())\n\n\ndef cd_to_repo(path):\n    \"\"\"\n    Change the current working directory to the repo's root directory\n\n    Parameters\n    ----------\n\n    path: Path to change to\n    \"\"\"\n    os.chdir(repo.rootdir)\n\n\ndef cd_to_repo_root(path):\n    \"\"\"\n    Change the current working directory to the repo's root directory\n\n    Parameters\n    ----------\n\n    path: Path to change to\n    \"\"\"\n",
        "\n\ndef datapackage_exists_with_version(repo, version):\n    \"\"\"\n    Check if the datapackage exists with a specific version...\n    \"\"\"\n    datapath = os.path.join(repo.rootdir, \"datapackage.json\")\n    return os.path.exists(datapath) and os.path.getsize(datapath) == version\n\ndef datapackage_exists_with_version_and_name(repo, version, name):\n    \"\"\"\n    Check if the datapackage exists with a specific version and name...\n    \"\"\"\n    datapath = os.path.join(repo.rootdir, \"datapackage.json\")\n    return os.path.exists(datapath) and os.path.getsize(datapath) == version and os.path.basename(datapath) == name\n\ndef datapackage_exists_with_name(repo, name):\n    \"\"\"\n    Check if the datapackage exists with a specific name...\n    \"\"\"\n    datapath = os.path.join(repo.rootdir, \"datapackage.json\")\n    return os.path.exists(datapath) and os.path.basename(datapath) == name\n\ndef datapackage_exists_with_name_and_version(repo, name, version):\n    \"\"\"\n    Check if the datapackage exists with a specific name",
        "\n\ndef get_datapackage(repo, force=False,\n                   options=None, noinput=False):\n    \"\"\"\n    Get the datapackage file..\n    \"\"\"\n\n    print(\"Getting datapackage\")\n\n    # get the directory\n    tsprefix = datetime.now().date().isoformat()\n\n    # Initial data package json\n    package = OrderedDict([\n        ('title', ''),\n        ('description', ''),\n        ('username', repo.username),\n        ('reponame', repo.reponame),\n        ('name', str(repo)),\n        ('title', \"\"),\n        ('description', \"\"),\n        ('keywords', []),\n        ('resources', []),\n        ('creator', getpass.getuser()),\n        ('createdat', datetime.now().isoformat()),\n        ('remote-url', repo.remoteurl)\n    ])\n\n    if options is not None:\n        package['title'] = options['title']\n        package['description'] = options['description']\n    else:\n        if noinput:\n            raise IncompleteParameters(\"Option field with title and description\")\n\n    for var in ['title', 'description']:\n        value = ''\n        while value in ['',None]:\n            value = input('Your Repo ' + var.title() + \": \")",
        "\n\ndef bootstrap_datapackage(repo, force=False, options=None, noinput=False):\n    \"\"\"\n    Bootstrap the datapackage.json metadata file and copy it in...\n\n    Parameters\n    ----------\n\n    repo: Repository object\n    force: Force creation of the files\n    options: Dictionary with content of dgit.json, if available.\n    noinput: Automatic operation with no human interaction\n    \"\"\"\n\n    mgr = plugins_get_mgr()\n    repomgr = mgr.get(what='repomanager', name='git')\n\n    backendmgr = None\n    if setup == 'git+s3':\n        backendmgr = mgr.get(what='backend', name='s3')\n\n    repo.run('add_files',\n             [\n                 {\n                     'relativepath': 'datapackage.json',\n                     'localfullpath': 'datapackage.json',\n                 },\n                 {\n                     'relativepath': '.dgit',\n                     'localfullpath': '.dgit',\n                 },\n             ])\n\n    # Now bootstrap the datapackage.json metadata file and copy it in...\n\n    # Insert a gitignore with .dgit directory in the repo. This\n    # directory will be used to store partial results\n    (handle, gitignore) = tempfile.mk",
        "\n            elif task == 'schema_preview':\n                for r in representations: \n                    if r.can_process(path): \n                        print(\"Adding schema preview for \", path)\n                        f['schema_preview'] = r.get_schema_preview(path)\n                        break\n            elif task == 'schema_schema':\n                for r in representations: \n                    if r.can_process(path): \n                        print(\"Adding schema schema for \", path)\n                        f['schema_schema'] = r.get_schema_schema(path)\n                        break\n            elif task == 'schema_preview_schema':\n                for r in representations: \n                    if r.can_process(path): \n                        print(\"Adding schema preview schema for \", path)\n                        f['schema_preview_schema'] = r.get_schema_preview_schema(path)\n                        break\n            elif task == 'schema_schema_preview':\n                for r in representations: \n                    if r.can_process(path): \n                        print(\"Adding schema preview schema for \", path)\n                        f['schema_preview_schema'] = r.get_schema_preview_schema(path)\n                        break\n            elif task == 'schema_preview_schema_preview':\n                for r in representations: \n                    if r.can_process(path): \n                        print(\"Adding schema preview schema preview",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n            print(\"Updated history of actions\")\n        else:\n            print(\"No history of actions\")\n\n    print(\"Updating metadata\")\n    with cd(repo.rootdir): \n        package['actions'] = package['actions'].sort()\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['actions'] = package['actions'].sort(key=lambda x: x['code'])\n        package['",
        "\n    print(\"Updated platform information\")\n\ndef annotate_metadata_os(repo):\n    \"\"\"\n    Update metadata host information\n    \"\"\"\n\n    print(\"Added OS information\")\n    package = repo.package\n    mgr = plugins_get_mgr()\n    repomgr = mgr.get(what='instrumentation', name='os')\n    package['os'] = repomgr.get_metadata()\n    print(\"Updated OS information\")\n\ndef annotate_metadata_arch(repo):\n    \"\"\"\n    Update metadata host information\n    \"\"\"\n\n    print(\"Added architecture information\")\n    package = repo.package\n    mgr = plugins_get_mgr()\n    repomgr = mgr.get(what='instrumentation', name='arch')\n    package['arch'] = repomgr.get_metadata()\n    print(\"Updated architecture information\")\n\ndef annotate_metadata_version(repo):\n    \"\"\"\n    Update metadata host information\n    \"\"\"\n\n    print(\"Added version information\")\n    package = repo.package\n    mgr = plugins_get_mgr()\n    repomgr = mgr.get(what='instrumentation', name='version')\n    package['version'] = repomgr.get_metadata()\n    print(\"Updated version information\")\n\ndef annotate_metadata_build(repo):\n    \"\"\"\n    Update metadata",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n    return\n\ndef get_history(rootdir):\n    \"\"\"\n    Get the history for a given directory\n\n    Parameters\n    ----------\n\n    rootdir: string\n    \"\"\"\n\n    mgr = plugins_get_mgr()\n    keys = mgr.search(what='history')\n    keys = keys['history']\n\n    if len(keys) == 0:\n        return\n\n    # Incorporate pipeline information...\n    if 'pipeline' in repo.options:\n        for name, details in repo.options['pipeline'].items():\n            patterns = details['files']\n            matching_files = repo.find_matching_files(patterns)\n            matching_files.sort()\n            details['files'] = matching_files\n            for i, f in enumerate(matching_files):\n                r = repo.get_resource(f)\n                if 'history' not in r:\n                    r['history'] = []\n                r['history'].append(name + \" [Step {}]\".format(i))\n\n    # Add data repo history\n    if 'include-data-history' in repo.options:\n        annotate_metadata_data(repo,\n                                   task='preview',\n                                   patterns=repo.options['include-data-history']['files'],\n                                   size=repo.options['include-data",
        "\n\ndef plugins_list():\n    \"\"\"\n    List available plugins\n\n    Returns\n    -------\n    list of plugins\n\n    \"\"\"\n    global pluginmgr\n    return pluginmgr.list()\n\ndef plugins_show_all():\n    \"\"\"\n    Show all available plugins\n\n    Returns\n    -------\n    list of plugins\n\n    \"\"\"\n    global pluginmgr\n    return pluginmgr.show_all()\n\ndef plugins_show_by_name(name):\n    \"\"\"\n    Show all available plugins by name\n\n    Parameters\n    ----------\n    name: Name of the plugin\n\n    Returns\n    -------\n    list of plugins\n\n    \"\"\"\n    global pluginmgr\n    return pluginmgr.show_by_name(name)\n\ndef plugins_show_by_version(version):\n    \"\"\"\n    Show all available plugins by version\n\n    Parameters\n    ----------\n    version: Version of the plugin\n\n    Returns\n    -------\n    list of plugins\n\n    \"\"\"\n    global pluginmgr\n    return pluginmgr.show_by_version(version)\n\ndef plugins_show_by_class(what):\n    \"\"\"\n    Show all available plugins by class\n\n    Parameters\n    ----------\n    what: Class of plugins e.g., backend\n\n    Returns\n    -------\n    list of plugins\n\n   ",
        "\n        return\n\ndef load_plugin(plugin_name):\n        \"\"\"\n        Load plugin from dgit extension\n        \"\"\"\n        try:\n            m = pkg_resources.get_entry_point(plugin_name)\n            m.setup(self)\n        except pkg_resources.DistributionNotFound:\n            raise PluginNotFound(plugin_name)\n        return\n\ndef load_plugins(plugins):\n        \"\"\"\n        Load plugins from dgit extension\n        \"\"\"\n        for p in plugins:\n            load_plugin(p)\n        return\n\ndef load_plugin_from_path(plugin_path):\n        \"\"\"\n        Load plugin from dgit extension\n        \"\"\"\n        try:\n            m = pkg_resources.get_entry_point(plugin_path)\n            m.setup(self)\n        except pkg_resources.DistributionNotFound:\n            raise PluginNotFound(plugin_path)\n        return\n\ndef load_plugins_from_path(plugins_path):\n        \"\"\"\n        Load plugins from dgit extension\n        \"\"\"\n        for p in plugins_path:\n            load_plugin_from_path(p)\n        return\n\ndef load_plugin_from_name(plugin_name):\n        \"\"\"\n        Load plugin from dgit extension\n        \"\"\"\n        try:\n            m = pkg_resources.get",
        "\n        # print(\"Registered plugin\", name, version, pattern)\n\ndef unregister(self, what, obj):\n        \"\"\"\n        Unregistering a plugin\n\n        Params\n        ------\n        what: Nature of the plugin (backend, instrumentation, repo)\n        obj: Instance of the plugin\n        \"\"\"\n        # print(\"Unregistering pattern\", name, pattern)\n        name = obj.name\n        version = obj.version\n        key = Key(name, version)\n        self.plugins[what][key] = None\n\ndef get(self, what, obj):\n        \"\"\"\n        Getting a plugin\n\n        Params\n        ------\n        what: Nature of the plugin (backend, instrumentation, repo)\n        obj: Instance of the plugin\n        \"\"\"\n        # print(\"Getting pattern\", name, pattern)\n        name = obj.name\n        version = obj.version\n        key = Key(name, version)\n        return self.plugins[what][key]\n\ndef get_all(self):\n        \"\"\"\n        Getting all plugins\n\n        Returns\n        -------\n        list of plugin instances\n        \"\"\"\n        return self.plugins.values()\n\ndef get_all_plugins(self):\n        \"\"\"\n        Getting all plugins\n\n        Returns\n        -------\n        list of plugin instances\n        \"\"\"\n        return self",
        "\n\ndef get_plugin(what, name=None, version=None):\n        \"\"\"\n        Get a plugin\n        \"\"\"\n        if what is None:\n            return self.plugins[what]\n        else:\n            return self.plugins[what][name]\n\ndef get_plugin_version(what, name=None, version=None):\n        \"\"\"\n        Get a plugin version\n        \"\"\"\n        if what is None:\n            return self.plugins[what][name]\n        else:\n            return self.plugins[what][name][version]\n\ndef get_plugin_name(what, name=None, version=None):\n        \"\"\"\n        Get a plugin name\n        \"\"\"\n        if what is None:\n            return self.plugins[what][name]\n        else:\n            return self.plugins[what][name][version]\n\ndef get_plugin_description(what, name=None, version=None):\n        \"\"\"\n        Get a plugin description\n        \"\"\"\n        if what is None:\n            return self.plugins[what][name]\n        else:\n            return self.plugins[what][name][version]\n\ndef get_plugin_description_with_version(what, name=None, version=None):\n        \"\"\"\n        Get a plugin description with version\n        \"\"\"\n        if what is",
        "\n",
        "\n\ndef instantiate(repo, \n                validator_name=None, \n                filename=None, \n                rulesfiles=None,\n                args=[]):\n    \"\"\"\n    Instantiate a validator specification.\n\n    Parameters\n    ----------\n\n    repo: Repository object\n    validator_name: Name of validator, if any. If none, then all validators specified in dgit.json will be included.\n    filename: Pattern that specifies files that must be processed by the validators selected. If none, then the default specification in dgit.json is used.\n    rulesfiles: Pattern specifying the files that have rules that validators will use\n    args: Arguments to pass to the validator\n\n    Returns\n    -------\n\n    validator_specs: A dictionary of dictionaries, each with target file processed, rules file applied, status of the validation and any error  message\n    \"\"\"\n\n    if validator_name is None:\n        validator_name = 'all'\n\n    if filename is None:\n        filename = '*.dgit'\n\n    if rulesfiles is None:\n        rulesfiles = '*.dgit'\n\n    if args is None:\n        args = []\n\n    if validator_name in repo.validators:\n        validator_specs = repo.validators[validator_name]\n    else:\n        raise ValueError('Validator %s not found' % validator_name",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get(self, repo):\n        \"\"\"\n        Get from the metadata server\n\n        Parameters\n        ----------\n\n        repo\n        \"\"\"\n\n        url = self.url\n        token = self.token\n        headers = {\n            'Authorization': 'Token {}'.format(token),\n            'Content-Type': 'application/json'\n        }\n\n        try:\n            r = requests.get(url,\n                              headers=headers)\n\n            return r\n        except Exception as e: \n            #print(e)\n            #traceback.print_exc()\n            raise NetworkError()\n        return \"\"\n\ndef put(self, repo):\n        \"\"\"\n        Put to the metadata server\n\n        Parameters\n        ----------\n\n        repo\n        \"\"\"\n\n        datapackage = repo.package\n\n        url = self.url\n        token = self.token\n        headers = {\n            'Authorization': 'Token {}'.format(token),\n            'Content-Type': 'application/json'\n        }\n\n        try:\n            r = requests.put(url,\n                              data = json.dumps(datapackage),\n                              headers=headers)\n\n            return r\n        except Exception as e: \n            #print(e)\n            #traceback.print_exc()\n            raise NetworkError()\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef find_executable_files_with_permissions(permissions):\n    \"\"\"\n    Find max 5 executables that are responsible for this repo.\n    \"\"\"\n    executable = stat.S_IEXEC | stat.S_IXGRP | stat.S_IXOTH\n    final = []\n    for filename in find_executable_files():\n        if os.path.isfile(filename):\n            st = os.stat(filename)\n            mode = st.st_mode\n            if mode & executable:\n                final.append(filename)\n                if len(final) > 5:\n                    break\n    return final\n\ndef find_executable_files_with_permissions_and_permissions(permissions, permissions_and_permissions):\n    \"\"\"\n    Find max 5 executables that are responsible for this repo.\n    \"\"\"\n    executable = stat.S_IEXEC | stat.S_IXGRP | stat.S_IXOTH\n    final = []\n    for filename in find_executable_files():\n        if os.path.isfile(filename):\n            st = os.stat(filename)\n            mode = st.st_mode\n            if mode & executable:\n                final.append(filename)\n                if len(final) > 5:\n                    break\n    return final\n\ndef find_executable_files_with_",
        "\n\ndef common_init(username, reponame, setup, force=False, options=None):\n    \"\"\"\n    Init a repo\n\n    Parameters\n    ----------\n\n    username: str\n        The username of the repo\n\n    reponame: str\n        The name of the repo\n\n    setup: str\n        The setup of the repo\n\n    force: bool\n        Force the init of the repo\n\n    options: dict\n        The options of the repo\n\n    \"\"\"\n\n    # plugin manager\n    pluginmgr = plugins_get_mgr()\n\n    # get the repo manager\n    repomgr = pluginmgr.get(what='repomanager', name='git')\n\n    # get the repo\n    repo = repomgr.lookup(username=username,\n                              reponame=reponame)\n\n    if not repo:\n        # Create the repo\n        repo = common_create(username=username,\n                               reponame=reponame,\n                               setup=setup,\n                               force=force,\n                               options=options)\n\n    return repo\n\ndef common_clone(url):\n    \"\"\"\n    Clone a repo\n\n    Parameters\n    ----------\n\n    url: str\n        The url of the repo\n\n    \"\"\"\n\n    # plugin manager\n    plugin",
        "\n\ndef get_files_to_commit_with_changes(autooptions):\n    \"\"\"\n    Look through the local directory to pick up files to check\n    \"\"\"\n    workingdir = autooptions['working-directory']\n    includes = autooptions['track']['includes']\n    excludes = autooptions['track']['excludes']\n\n    matched_files = []\n    for root, dirs, files in os.walk(workingdir):\n\n        # exclude dirs\n        dirs[:] = [d for d in dirs if not re.match(excludes, d)]\n\n        # exclude/include files\n        files = [f for f in files if not re.match(excludes, f)]\n        #print(\"Files after excludes\", files)\n        #print(includes) \n        files = [f for f in files if re.match(includes, f)]\n        #print(\"Files after includes\", files) \n        files = [os.path.join(root, f) for f in files]\n\n        matched_files.extend(files)\n\n    return matched_files\n\ndef get_files_to_commit_with_changes_with_changes(autooptions):\n    \"\"\"\n    Look through the local directory to pick up files to check\n    \"\"\"\n    workingdir = autooptions['working-directory']\n    includes = autooptions",
        "\n\ndef auto_remove(repo, autooptions, files):\n    \"\"\"\n    Cleanup the paths and remove\n    \"\"\"\n    # Get the mappings and keys.\n    mapping = { \".\": \"\" }\n    if (('import' in autooptions) and\n        ('directory-mapping' in autooptions['import'])):\n        mapping = autooptions['import']['directory-mapping']\n\n    # Apply the longest prefix first...\n    keys = mapping.keys()\n    keys = sorted(keys, key=lambda k: len(k), reverse=True)\n\n    count = 0\n    params = []\n    for f in files:\n\n        # Find the destination\n        relativepath = f\n        for k in keys:\n            v = mapping[k]\n            if f.startswith(k + \"/\"):\n                #print(\"Replacing \", k)\n                relativepath = f.replace(k + \"/\", v)\n                break\n\n        # Now remove from repository\n        count += files_remove(repo=repo,\n                           args=[f],\n                           targetdir=os.path.dirname(relativepath))\n\n    return count\n\ndef auto_rename(repo, autooptions, files):\n    \"\"\"\n    Cleanup the paths and rename\n    \"\"\"\n    # Get the mappings and keys.\n    mapping = { \".\": \"\"",
        "\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef transform(repo, name, filename, files):\n    \"\"\"\n    Transform the generator and filename specification\n    \"\"\"\n\n    default_transformers = repo.options.get('transformer', {})\n\n    # If a name is specified, then lookup the options from dgit.json\n    # if specfied. Otherwise it is initialized to an empty list of\n    # files.\n    transformers = {}\n    if name is not None:\n        # Handle the case generator is specified..\n        if name in default_transformers:\n            transformers = default_transformers[name]\n        else:\n            transformers = {\n                name : {\n                    'files': [],\n                }\n            }\n    else:\n        transformers = default_transformers\n\n    #=========================================\n    # Map the filename patterns to list of files\n    #=========================================\n    # Instantiate the files from the patterns specified\n    input_matching_files = None\n    if filename is not None:\n        input_matching_files = repo.find_matching_files([filename])\n\n    for t in transformers:\n        for k in transformers[t]:\n            if \"files\" not in k:\n                continue\n            if k == \"files\" and input_matching_files is not None:\n                # Use the files specified on the command line..\n",
        "\n\ndef _get_git_version():\n    \"\"\"\n    Helper function to get the git version\n    \"\"\"\n    cmd = [\"git\", \"rev-parse\", \"--show-toplevel\"]\n    output = _run(cmd)\n    return output.strip()\n\ndef _get_git_committer_email():\n    \"\"\"\n    Helper function to get the git committer email\n    \"\"\"\n    cmd = [\"git\", \"rev-parse\", \"--show-toplevel\", \"--name-only\"]\n    output = _run(cmd)\n    return output.strip()\n\ndef _get_git_author_email():\n    \"\"\"\n    Helper function to get the git author email\n    \"\"\"\n    cmd = [\"git\", \"rev-parse\", \"--show-toplevel\", \"--name-only\", \"--email-only\"]\n    output = _run(cmd)\n    return output.strip()\n\ndef _get_git_commit_date():\n    \"\"\"\n    Helper function to get the git commit date\n    \"\"\"\n    cmd = [\"git\", \"rev-parse\", \"--show-toplevel\", \"--date\"]\n    output = _run(cmd)\n    return output.strip()\n\ndef _get_git_commit_message():\n    \"\"\"\n    Helper function to get the git commit message\n    \"\"\"\n    cmd = [\"git",
        "\n\ndef _run_command(self, repo, cmd):\n        \"\"\"\n        Run a command within the repo. Assumes that you are\n        in the repo's root directory\n        \"\"\"\n        \n        result = None\n        with cd(repo.rootdir):\n            output = self._run(cmd)\n            try:\n                result = {\n                    'cmd': cmd,\n                    'status': 'success',\n                    'message': output,\n                }\n            except Exception as e:\n                result = {\n                    'cmd': cmd,\n                    'status': 'error',\n                    'message': str(e)\n                }\n\n        return result\n\ndef _run_command_with_output(self, repo, cmd, output):\n        \"\"\"\n        Run a command within the repo. Assumes that you are\n        in the repo's root directory\n        \"\"\"\n        \n        result = None\n        with cd(repo.rootdir):\n            output = self._run(cmd)\n            try:\n                result = {\n                    'cmd': cmd,\n                    'status': 'success',\n                    'message': output,\n                }\n            except Exception as e:\n                result = {\n                    'cmd': cmd,\n                    'status': 'error',\n                    'message': str(e)\n                }\n\n        return result\n",
        "\n\ndef init_repo(self, username, reponame, force, backend=None):\n        \"\"\"\n        Initialize a Git repo\n\n        Parameters\n        ----------\n\n        username, reponame : Repo name is tuple (name, reponame)\n        force: force initialization of the repo even if exists\n        backend: backend that must be used for this (e.g. s3)\n        \"\"\"\n        key = self.key(username, reponame)\n\n        # In local filesystem-based server, add a repo\n        server_repodir = self.server_rootdir(username,\n                                             reponame,\n                                             create=False)\n\n        # Force cleanup if needed\n        if os.path.exists(server_repodir) and not force:\n            raise RepositoryExists()\n\n        if os.path.exists(server_repodir):\n            shutil.rmtree(server_repodir)\n        os.makedirs(server_repodir)\n\n        # Initialize the repo\n        with cd(server_repodir):\n            git.init(\".\", \"--bare\")\n\n        if backend is not None:\n            backend.init_repo(server_repodir)\n\n        # Now clone the filesystem-based repo\n        repodir = self.root",
        "\n\ndef copy(self, repo, args=[]):\n        \"\"\"\n        Copy files from the repo\n        \"\"\"\n\n        result = None\n        with cd(repo.rootdir):\n            try:\n                cmd = ['cp'] + list(args)\n                result = {\n                    'status': 'success',\n                    'message': self._run(cmd)\n                }\n            except Exception as e:\n                result = {\n                    'status': 'error',\n                    'message': str(e)\n                }\n\n            # print(result)\n            return result\n\ndef move(self, repo, args=[]):\n        \"\"\"\n        Move files from the repo\n        \"\"\"\n\n        result = None\n        with cd(repo.rootdir):\n            try:\n                cmd = ['mv'] + list(args)\n                result = {\n                    'status': 'success',\n                    'message': self._run(cmd)\n                }\n            except Exception as e:\n                result = {\n                    'status': 'error',\n                    'message': str(e)\n                }\n\n            # print(result)\n            return result\n\ndef mkdir(self, repo, args=[]):\n        \"\"\"\n        Create a directory in the repo\n        \"\"\"\n\n        result = None\n        with cd(repo.root",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef api_call_action_with_kwargs(func, **kwargs): \n    \"\"\"\n    API wrapper documentation\n    \"\"\"\n    def _inner(*args, **kwargs):\n        return func(*args, **kwargs)\n    _inner.__name__ = func.__name__\n    _inner.__doc__ = func.__doc__\n    return _inner\n\ndef api_call_action_with_kwargs_with_kwargs(func, **kwargs): \n    \"\"\"\n    API wrapper documentation\n    \"\"\"\n    def _inner(*args, **kwargs):\n        return func(*args, **kwargs)\n    _inner.__name__ = func.__name__\n    _inner.__doc__ = func.__doc__\n    return _inner\n\ndef api_call_action_with_kwargs_with_kwargs_with_kwargs(func, **kwargs): \n    \"\"\"\n    API wrapper documentation\n    \"\"\"\n    def _inner(*args, **kwargs):\n        return func(*args, **kwargs)\n    _inner.__name__ = func.__name__\n    _inner.__doc__ = func.__doc__\n    return _inner\n\ndef api_call_action_with_kwargs_with_kwargs_with_kwargs(func, **kwargs): \n    \"\"\"\n    API wrapper documentation\n    \"\"\"\n    def _inner(*args, **kwargs):\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef tokenize(text):\n    \"\"\"Return source code based on tokens.\n\n    This is like tokenize.tokenize(), but it preserves spacing between\n    tokens. So if the original soure code had multiple spaces between\n    some tokens or if escaped newlines were used, those things will be\n    reflected by tokenize().\n\n    \"\"\"\n    text = text.replace('\\n', '\\n\\n')\n    text = text.replace('\\r', '\\n\\r')\n    text = text.replace('\\t', '\\n\\t')\n\n    tokens = []\n    for token_type, token_string, start, end, line in text.split('\\n'):\n        if TOKENIZE_HAS_ENCODING and token_type == tokenize.ENCODING:\n            continue\n\n        (start_row, start_column) = start\n        (end_row, end_column) = end\n\n        # Preserve escaped newlines.\n        if (\n            last_non_whitespace_token_type != tokenize.COMMENT and\n            start_row > last_row and\n            previous_line.endswith(('\\\\\\n', '\\\\\\r\\n', '\\\\\\r'))\n        ):\n            text += previous_line[len(previous_line.rstrip(' \\t\\n\\r\\\\')):]\n\n        tokens.append",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef getprofileini():\n    \"\"\"\n    Get the profile ini file\n    \"\"\"\n    return os.path.join(os.path.dirname(__file__), 'profile.ini')\n\ndef getconfig():\n    \"\"\"\n    Get the profile config\n    \"\"\"\n    return config\n\ndef getplugins():\n    \"\"\"\n    Get the plugins\n    \"\"\"\n    return plugins_get_mgr().get_plugins()\n\ndef plugins_get_mgr():\n    \"\"\"\n    Get the plugins manager\n    \"\"\"\n    return plugins_get_mgr()\n\ndef plugins_get_mgr():\n    \"\"\"\n    Get the plugins manager\n    \"\"\"\n    return plugins_get_mgr()\n\ndef plugins_get_mgr():\n    \"\"\"\n    Get the plugins manager\n    \"\"\"\n    return plugins_get_mgr()\n\ndef plugins_get_mgr():\n    \"\"\"\n    Get the plugins manager\n    \"\"\"\n    return plugins_get_mgr()\n\ndef plugins_get_mgr():\n    \"\"\"\n    Get the plugins manager\n    \"\"\"\n    return plugins_get_mgr()\n\ndef plugins_get_mgr():\n    \"\"\"\n    Get the plugins manager\n    \"\"\"\n    return plugins_get_mgr()\n\ndef plugins_get_mgr():\n    \"\"\"\n    Get the plugins manager\n    \"\"\"\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef run_cmd(cmd):\n    \"\"\"\n    Run a shell command\n    \"\"\"\n    output = run(cmd)\n    return output\n\ndef run_cmd_with_output(cmd):\n    \"\"\"\n    Run a shell command with output\n    \"\"\"\n    output = run(cmd)\n    return output\n\ndef run_cmd_with_output_and_error(cmd):\n    \"\"\"\n    Run a shell command with output and error\n    \"\"\"\n    output = run(cmd)\n    return output, output\n\ndef run_cmd_with_output_and_error_and_exit(cmd):\n    \"\"\"\n    Run a shell command with output and error and exit\n    \"\"\"\n    output = run(cmd)\n    return output, output, output\n\ndef run_cmd_with_output_and_error_and_exit_and_stdout(cmd):\n    \"\"\"\n    Run a shell command with output and error and exit and stdout\n    \"\"\"\n    output = run(cmd)\n    return output, output, output, output\n\ndef run_cmd_with_output_and_error_and_exit_and_stdout_and_stderr(cmd):\n    \"\"\"\n    Run a shell command with output and error and exit and stdout and stderr\n    \"\"\"\n    output = run(cmd)\n    return",
        "\n\ndef get_change():\n    \"\"\"\n    Get the changes for a given dataset\n    \"\"\"\n\n    cmd = [\"git\", \"log\", \"--all\", \"--branches\", '--pretty=format:{  \"commit\": \"%H\",  \"abbreviated_commit\": \"%h\",  \"tree\": \"%T\",  \"abbreviated_tree\": \"%t\",  \"parent\": \"%P\",  \"abbreviated_parent\": \"%p\",  \"refs\": \"%d\",  \"encoding\": \"%e\",  \"subject\": \"%s\", \"sanitized_subject_line\": \"%f\",  \"commit_notes\": \"\",  \"author\": {    \"name\": \"%aN\",    \"email\": \"%aE\",    \"date\": \"%ai\"  },  \"commiter\": {    \"name\": \"%cN\",    \"email\": \"%cE\",    \"date\": \"%ci\"  }},']\n\n    output = run(cmd)\n    lines = output.split(\"\\n\")\n\n    content = \"\"\n    history = []\n    for l in lines:\n        try:\n            revisedcontent = content + l\n            if revisedcontent.count('\"') % 2 == 0:\n                j = json.loads(revisedcontent[:-1])\n                if \"Notes added by\" in j['subject']:\n                    content = \"\"\n                   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef wait_until_exit(self, cmd, timeout=10, raise_on_error=True):\n        \"\"\"\n        Execute command and wait for it to finish. Proceed with caution because\n        if you run a command that causes a prompt this will hang\n        \"\"\"\n        _, stdout, stderr = self.exec_command(cmd)\n        stdout.channel.recv_exit_status()\n        if raise_on_error:\n            raise ValueError(stderr.read())\n        if timeout > 0:\n            time.sleep(timeout)\n        return stdout.read()\n\ndef wait_until_exit_with_output(self, cmd, timeout=10, raise_on_error=True):\n        \"\"\"\n        Execute command and wait for it to finish. Proceed with caution because\n        if you run a command that causes a prompt this will hang\n        \"\"\"\n        _, stdout, stderr = self.exec_command(cmd)\n        stdout.channel.recv_exit_status()\n        if raise_on_error:\n            raise ValueError(stderr.read())\n        if timeout > 0:\n            time.sleep(timeout)\n        return stdout.read()\n\ndef wait_until_exit_with_error(self, cmd, timeout=10, raise_on_error=True):\n        \"\"\"\n        Execute",
        "\n        return self\n\ndef sudo_with_password(self, password=None):\n        \"\"\"\n        Enter sudo mode with password\n        \"\"\"\n        if self.username == 'root':\n            raise ValueError('Already root user')\n        password = self.validate_password(password)\n        stdin, stdout, stderr = self.exec_command('sudo su -p %s' % password)\n        stdin.write(\"%s\\n\" % password)\n        stdin.flush()\n        errors = stderr.read()\n        if errors:\n            raise ValueError(errors)\n        return self\n\ndef sudo_with_password_and_exit(self, password=None):\n        \"\"\"\n        Enter sudo mode with password and exit\n        \"\"\"\n        if self.username == 'root':\n            raise ValueError('Already root user')\n        password = self.validate_password(password)\n        stdin, stdout, stderr = self.exec_command('sudo su -p %s -e' % password)\n        stdin.write(\"%s\\n\" % password)\n        stdin.flush()\n        errors = stderr.read()\n        if errors:\n            raise ValueError(errors)\n        return self\n\ndef sudo_with_password_and_exit_with_password(self, password=None):\n        \"\"\"\n        Enter sudo mode with password and exit",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef decompress_blocking(image, delete_tif=False, folder=None, force=False):\n    \"\"\"Lossless decompression. Save image as PNG and TIFF tags to json. Process\n    can be reversed with `compress`.\n\n    Parameters\n    ----------\n    image : string\n        TIF-image which should be compressed lossless.\n    delete_tif : bool\n        Wheter to delete original images.\n    force : bool\n        Wheter to compress even if .png already exists.\n\n    Returns\n    -------\n    string\n        Filename of uncompressed image, or empty string if decompress failed.\n    \"\"\"\n\n    debug('decompressing {}'.format(image))\n    try:\n        new_filename, extension = os.path.splitext(image)\n        # remove last occurrence of .ome\n        new_filename = new_filename.rsplit('.ome', 1)[0]\n\n        # if compressed file should be put in specified folder\n        if folder:\n            basename = os.path.basename(new_filename)\n            new_filename = os.path.join(folder, basename + '.png')\n        else:\n            new_filename = new_filename + '.png'\n\n        # check if png exists\n        if os.path.isfile(new_filename) and not force:\n           ",
        "\n\ndef _get_path(self):\n    \"Return self.path, self.dirname and self.basename.\"\n    return self.path, self.dirname, self.basename\n\ndef _set_dirname(self, dirname):\n    \"Set self.dirname.\"\n    import os\n    self.dirname = dirname\n\ndef _get_dirname(self):\n    \"Return self.dirname.\"\n    return self.dirname\n\ndef _set_basename(self, basename):\n    \"Set self.basename.\"\n    import os\n    self.basename = basename\n\ndef _get_basename(self):\n    \"Return self.basename.\"\n    return self.basename\n\ndef _set_basename(self, basename):\n    \"Set self.basename.\"\n    import os\n    self.basename = basename\n\ndef _set_dirname(self, dirname):\n    \"Set self.dirname.\"\n    import os\n    self.dirname = dirname\n\ndef _get_dirname(self):\n    \"Return self.dirname.\"\n    return self.dirname\n\ndef _set_basename(self, basename):\n    \"Set self.basename.\"\n    import os\n    self.basename = basename\n\ndef _get_basename(self):\n    \"Return self.basename.\"\n    return self.basename\n\ndef _set_basename(",
        "\n\ndef images_list(self):\n        \"List of paths to images.\"\n        return self.images()\n\ndef images_list_by_extension(self, extension):\n        \"List of paths to images.\"\n        return self.images()[_pattern(self._image_path, extension)]\n\ndef images_list_by_extension_and_type(self, extension, type):\n        \"List of paths to images.\"\n        return self.images()[_pattern(self._image_path, extension, type)]\n\ndef images_list_by_extension_and_type_and_size(self, extension, type, size):\n        \"List of paths to images.\"\n        return self.images()[_pattern(self._image_path, extension, type, size)]\n\ndef images_list_by_extension_and_type_and_size_and_type(self, extension, type, size, type):\n        \"List of paths to images.\"\n        return self.images()[_pattern(self._image_path, extension, type, size, type)]\n\ndef images_list_by_extension_and_type_and_size_and_type_and_size(self, extension, type, size, type, size):\n        \"List of paths to images.\"\n        return self.images",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        else:\n            return None\n\ndef field_metadata_by_name(self, name):\n    \"\"\"Get OME-XML metadata of given field.\n\n    Parameters\n    ----------\n    name : str\n        Name of field.\n\n    Returns\n    -------\n    lxml.objectify.ObjectifiedElement\n        lxml object of OME-XML found in slide/chamber/field/metadata.\n    \"\"\"\n    field = [f for f in self.fields if f.name == name]\n\n    if field:\n        field = field[0]\n        filename = _pattern(field, 'metadata',\n                                _image, extension='*.ome.xml')\n        filename = glob(filename)[0] # resolve, assume found\n        return objectify.parse(filename).getroot()\n    else:\n        return None\n\ndef field_metadata_by_name_and_row(self, name, row):\n    \"\"\"Get OME-XML metadata of given field.\n\n    Parameters\n    ----------\n    name : str\n        Name of field.\n    row : int\n        Row of field.\n\n    Returns\n    -------\n    lxml.objectify.ObjectifiedElement\n        lxml object of OME-XML found in slide/chamber/field/metadata.\n    \"\"\"\n    field",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef delete(self, droplet_id):\n        \"\"\"\n        Delete a droplet\n\n        Parameters\n        ----------\n        droplet_id: str\n            id of droplet to delete\n        \"\"\"\n        self.delete(droplet_id)\n\ndef get(self, droplet_id):\n        \"\"\"\n        Get a droplet\n\n        Parameters\n        ----------\n        droplet_id: str\n            id of droplet to get\n        \"\"\"\n        return self.get(droplet_id)\n\ndef list(self, filters=None, sort_key=None, sort_dir=None,\n         limit=None, marker=None, wait=True):\n        \"\"\"\n        List droplets\n\n        Parameters\n        ----------\n        filters: dict\n            filters to apply to the list\n        sort_key: str\n            sort key to apply to the list\n        sort_dir: str\n            sort direction to apply to the list\n        limit: int\n            maximum number of items to return\n        marker: str\n            marker to apply to the list\n        wait: bool, default True\n            if True then block until list is complete\n        \"\"\"\n        return self.list(filters=filters, sort_key=sort_key, sort_dir=sort_dir,\n                         limit=limit, marker=marker, wait",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef delete(self, wait=True):\n        \"\"\"\n        Delete this droplet\n\n        Parameters\n        ----------\n        wait: bool, default True\n            Whether to block until the pending action is completed\n        \"\"\"\n        return self._action('delete', wait=wait)\n\ndef delete_image(self, image, wait=True):\n        \"\"\"\n        Delete this droplet with given image id\n\n        Parameters\n        ----------\n        image: int or str\n            int for image id and str for image slug\n        wait: bool, default True\n            Whether to block until the pending action is completed\n        \"\"\"\n        return self._action('delete_image', image=image, wait=wait)\n\ndef delete_image_by_name(self, name, wait=True):\n        \"\"\"\n        Delete this droplet with given image name\n\n        Parameters\n        ----------\n        name: str\n            Name of the image to delete\n        wait: bool, default True\n            Whether to block until the pending action is completed\n        \"\"\"\n        return self._action('delete_image_by_name', name=name, wait=wait)\n\ndef delete_image_by_slug(self, slug, wait=True):\n        \"\"\"\n        Delete this droplet with given image slug\n\n        Parameters\n        ----------\n        slug: str\n           ",
        "\n\ndef create(self, name, wait=True):\n        \"\"\"\n        Create a new droplet\n\n        Parameters\n        ----------\n        name: str\n            New name for the droplet\n        wait: bool, default True\n            Whether to block until the pending action is completed\n\n        Raises\n        ------\n        APIError if region does not support private networking\n        \"\"\"\n        return self._action('create', name=name, wait=wait)\n\ndef delete(self, name, wait=True):\n        \"\"\"\n        Delete a droplet\n\n        Parameters\n        ----------\n        name: str\n            New name for the droplet\n        wait: bool, default True\n            Whether to block until the pending action is completed\n\n        Raises\n        ------\n        APIError if region does not support private networking\n        \"\"\"\n        return self._action('delete', name=name, wait=wait)\n\ndef update(self, name, wait=True):\n        \"\"\"\n        Update a droplet\n\n        Parameters\n        ----------\n        name: str\n            New name for the droplet\n        wait: bool, default True\n            Whether to block until the pending action is completed\n\n        Raises\n        ------\n        APIError if region does not support private networking\n        \"\"\"\n        return self._action('update', name=name, wait=wait)\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.internal.nio.Connection;\nimport com.hazelcast.internal.nio.ConnectionState;\nimport com.hazelcast.internal.protocol.ClientMessage;\nimport com.hazelcast.internal.protocol.codec.MapRemove",
        "\n        return resp\n\n    def delete_instance(self, wait=True):\n        \"\"\"\n        Delete this instance\n\n        Parameters\n        ----------\n        wait: bool, default True\n            Whether to block until the pending action is completed\n        \"\"\"\n        resp = self.parent.delete_instance(self.id)\n        if wait:\n            self.wait()\n        return resp\n\n    def delete_volume(self, wait=True):\n        \"\"\"\n        Delete this volume\n\n        Parameters\n        ----------\n        wait: bool, default True\n            Whether to block until the pending action is completed\n        \"\"\"\n        resp = self.parent.delete_volume(self.id)\n        if wait:\n            self.wait()\n        return resp\n\n    def delete_volume_snapshot(self, wait=True):\n        \"\"\"\n        Delete this volume snapshot\n\n        Parameters\n        ----------\n        wait: bool, default True\n            Whether to block until the pending action is completed\n        \"\"\"\n        resp = self.parent.delete_volume_snapshot(self.id)\n        if wait:\n            self.wait()\n        return resp\n\n    def delete_volume_snapshot_list(self, wait=True):\n        \"\"\"\n        Delete this volume snapshot list\n\n        Parameters\n        ----------\n        wait: bool, default True\n",
        "\n            interval_seconds *= 2\n        return\n\ndef wait_for_action(self, action_id):\n        \"\"\"\n        wait for an action to complete on a droplet\n        \"\"\"\n        interval_seconds = 5\n        while True:\n            actions = self.actions()\n            slept = False\n            for a in actions:\n                if a['id'] == action_id:\n                    # n.b. gevent will monkey patch\n                    time.sleep(interval_seconds)\n                    slept = True\n                    break\n            if not slept:\n                break\n            if not actions:\n                break\n            if not actions[0]['id'] == action_id:\n                break\n            if not actions[0]['status'] == 'in-progress':\n                break\n            if not actions[0]['progress'] == 0:\n                break\n            if not actions[0]['duration'] == 0:\n                break\n            if not actions[0]['duration'] == actions[0]['duration']:\n                break\n            if not actions[0]['duration'] == actions[0]['duration'] + 1:\n                break\n            if not actions[0]['duration'] == actions[0]['duration'] + 2:\n                break\n            if not actions[0]['duration'] == actions[0]['duration'] + 3:\n",
        "\n        from poseidon.ssh import SSHClient\n        rs = SSHClient(self.ip_address, interactive=interactive)\n        return rs\n\ndef disconnect(self):\n        \"\"\"\n        Close SSH connection to droplet\n        \"\"\"\n        from poseidon.ssh import SSHClient\n        rs = SSHClient(self.ip_address)\n        return rs\n\ndef get_ssh_client(self):\n        \"\"\"\n        Get SSH client to droplet\n        \"\"\"\n        from poseidon.ssh import SSHClient\n        rs = SSHClient(self.ip_address)\n        return rs\n\ndef get_ssh_client_with_password(self, password):\n        \"\"\"\n        Get SSH client to droplet with password\n        \"\"\"\n        from poseidon.ssh import SSHClient\n        rs = SSHClient(self.ip_address, password=password)\n        return rs\n\ndef get_ssh_client_with_password_and_port(self, password, port):\n        \"\"\"\n        Get SSH client to droplet with password and port\n        \"\"\"\n        from poseidon.ssh import SSHClient\n        rs = SSHClient(self.ip_address, password=password, port=port)\n        return rs\n\ndef get_ssh_client_with_password_and_port_and_username(self,",
        "\n\ndef get_request(self, kind, resource, url_components, **kwargs):\n        \"\"\"\n        Send a request to the REST API\n\n        Parameters\n        ----------\n        kind: str, {get, delete, put, post, head}\n        resource: str\n        url_components: list or tuple to be appended to the request URL\n\n        Notes\n        -----\n        kwargs contain request parameters to be sent as request data\n        \"\"\"\n        return self.send_request(kind, resource, *url_components, **kwargs)\n\ndef get_response(self, response):\n        \"\"\"\n        Get the response from the REST API\n\n        Parameters\n        ----------\n        response: requests.Response\n        \"\"\"\n        return response.json()\n\ndef get_response_json(self, response):\n        \"\"\"\n        Get the response from the REST API\n\n        Parameters\n        ----------\n        response: requests.Response\n        \"\"\"\n        return response.json()\n\ndef get_response_text(self, response):\n        \"\"\"\n        Get the response from the REST API\n\n        Parameters\n        ----------\n        response: requests.Response\n        \"\"\"\n        return response.text()\n\ndef get_response_text_json(self, response):\n        \"\"\"\n        Get the response from the REST API\n\n        Parameters\n        ----------",
        "\n\nclass Base(object):\n    \"\"\"\n    Base class for all API classes\n    \"\"\"\n    def __init__(self, **kwargs):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.format_parameters = format_parameters\n\n    def get_response(self, **kwargs):\n        \"\"\"\n        Method to get the response from the API\n        \"\"\"\n        return self.format_parameters(**kwargs)\n\n    def get_response_json(self, **kwargs):\n        \"\"\"\n        Method to get the response from the API\n        \"\"\"\n        return self.format_parameters(**kwargs)\n\n    def get_response_xml(self, **kwargs):\n        \"\"\"\n        Method to get the response from the API\n        \"\"\"\n        return self.format_parameters(**kwargs)\n\n    def get_response_json_xml(self, **kwargs):\n        \"\"\"\n        Method to get the response from the API\n        \"\"\"\n        return self.format_parameters(**kwargs)\n\n    def get_response_xml_xml(self, **kwargs):\n        \"\"\"\n        Method to get the response from the API\n        \"\"\"\n        return self.format_parameters(**kwargs)\n\n    def get_response_json_xml_xml(self, **kwargs):\n        \"\"\"\n        Method to get the response",
        ")\n\ndef format_response(self, response):\n        \"\"\"create response from api response\"\"\"\n        return response\n\ndef format_error(self, error):\n        \"\"\"create error from api response\"\"\"\n        return error\n\ndef format_exception(self, exception):\n        \"\"\"create exception from api response\"\"\"\n        return exception\n\ndef format_client_error(self, error):\n        \"\"\"create client error from api response\"\"\"\n        return error\n\ndef format_server_error(self, error):\n        \"\"\"create server error from api response\"\"\"\n        return error\n\ndef format_client_error_response(self, error):\n        \"\"\"create client error response from api response\"\"\"\n        return format_client_error(error)\n\ndef format_server_error_response(self, error):\n        \"\"\"create server error response from api response\"\"\"\n        return format_server_error(error)\n\ndef format_client_error_response_with_data(self, error):\n        \"\"\"create client error response with data from api response\"\"\"\n        return format_client_error(error, data=error.data)\n\ndef format_server_error_response_with_data(self, error):\n        \"\"\"create server error response with data from api response\"\"\"\n        return format_server_error(error, data=error.data)",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".get(self.result_key, [])\n\ndef get(self, url_components=()):\n        \"\"\"\n        Send get request for a single member of a collection\n        \"\"\"\n        resp = self.get(url_components)\n        return resp.get(self.result_key, [])\n\ndef put(self, url_components=()):\n        \"\"\"\n        Send put request for a single member of a collection\n        \"\"\"\n        resp = self.put(url_components)\n        return resp.get(self.result_key, [])\n\ndef delete(self, url_components=()):\n        \"\"\"\n        Send delete request for a single member of a collection\n        \"\"\"\n        resp = self.delete(url_components)\n        return resp.get(self.result_key, [])\n\ndef update(self, url_components=()):\n        \"\"\"\n        Send update request for a single member of a collection\n        \"\"\"\n        resp = self.update(url_components)\n        return resp.get(self.result_key, [])\n\ndef get_all(self, url_components=()):\n        \"\"\"\n        Send get_all request for all members of a collection\n        \"\"\"\n        resp = self.get_all(url_components)\n        return resp.get(self",
        ")\n\ndef get_or_create(self, id, **kwargs):\n        \"\"\"\n        Get single unit of collection or create it\n        \"\"\"\n        return (super(MutableCollection, self).get((id,), **kwargs)\n                .get(self.singular, None))\n\ndef get_or_update(self, id, **kwargs):\n        \"\"\"\n        Get single unit of collection or update it\n        \"\"\"\n        return (super(MutableCollection, self).get((id,), **kwargs)\n                .get(self.singular, None))\n\ndef get_or_delete(self, id, **kwargs):\n        \"\"\"\n        Get single unit of collection or delete it\n        \"\"\"\n        return (super(MutableCollection, self).get((id,), **kwargs)\n                .get(self.singular, None))\n\ndef get_or_create_or_update(self, id, **kwargs):\n        \"\"\"\n        Get single unit of collection or create it or update it\n        \"\"\"\n        return (super(MutableCollection, self).get((id,), **kwargs)\n                .get(self.singular, None))\n\ndef get_or_delete_or_create_or_update(self, id, **kwargs):\n        \"\"\"\n        Get single unit of collection or delete it or create it or update it",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        ".api, info=info)\n\ndef get_list(self, id):\n        \"\"\"id or slug\"\"\"\n        info = super(Images, self).get_list(id)\n        return ImageActions(self.api, parent=self, **info)\n\ndef get_list_by_category(self, category):\n        \"\"\"id or slug\"\"\"\n        info = super(Images, self).get_list_by_category(category)\n        return ImageActions(self.api, parent=self, **info)\n\ndef get_list_by_category_and_user(self, category, user):\n        \"\"\"id or slug\"\"\"\n        info = super(Images, self).get_list_by_category_and_user(category, user)\n        return ImageActions(self.api, parent=self, **info)\n\ndef get_list_by_category_and_user_and_image(self, category, user, image):\n        \"\"\"id or slug\"\"\"\n        info = super(Images, self).get_list_by_category_and_user_and_image(category, user, image)\n        return ImageActions(self.api, parent=self, **info)\n\ndef get_list_by_category_and_user_and_image_and_category(self, category, user",
        "(id, name)\n\ndef create(self, id, name):\n        \"\"\"id or fingerprint\"\"\"\n        return super(Keys, self).create(id, name)\n\ndef delete(self, id):\n        \"\"\"id or fingerprint\"\"\"\n        return super(Keys, self).delete(id)\n\ndef get(self, id):\n        \"\"\"id or fingerprint\"\"\"\n        return super(Keys, self).get(id)\n\ndef list(self):\n        \"\"\"id or fingerprint\"\"\"\n        return super(Keys, self).list()\n\ndef keys(self):\n        \"\"\"id or fingerprint\"\"\"\n        return super(Keys, self).keys()\n\ndef keys_by_name(self, name):\n        \"\"\"id or fingerprint\"\"\"\n        return super(Keys, self).keys_by_name(name)\n\ndef keys_by_id(self, id):\n        \"\"\"id or fingerprint\"\"\"\n        return super(Keys, self).keys_by_id(id)\n\ndef keys_by_fingerprint(self, fingerprint):\n        \"\"\"id or fingerprint\"\"\"\n        return super(Keys, self).keys_by_fingerprint(fingerprint)\n\ndef keys_by_fingerprint_and_name(self, fingerprint, name):\n        \"\"\"id or fingerprint\"\"\"\n        return super(Keys, self).keys_by_fingerprint_and",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        raise DomainDoesNotExist(name)\n\n    def get(self, name):\n        \"\"\"\n        Get a list of all domain records for the given domain name\n\n        Parameters\n        ----------\n        name: str\n            domain name\n        \"\"\"\n        return DomainRecords(self.api, name)\n\n    def create(self, name, data):\n        \"\"\"\n        Create a new domain record\n\n        Parameters\n        ----------\n        name: str\n            domain name\n        data: dict\n            record data\n        \"\"\"\n        return DomainRecord(self.api, name, data)\n\n    def update(self, name, data):\n        \"\"\"\n        Update a domain record\n\n        Parameters\n        ----------\n        name: str\n            domain name\n        data: dict\n            record data\n        \"\"\"\n        return DomainRecord(self.api, name, data)\n\n    def delete(self, name):\n        \"\"\"\n        Delete a domain record\n\n        Parameters\n        ----------\n        name: str\n            domain name\n        \"\"\"\n        return DomainRecord(self.api, name)\n\n    def get_records(self, name):\n        \"\"\"\n        Get a list of all domain records for the given domain name\n\n        Parameters\n        ----------\n        name: str\n            domain name\n        \"\"\"\n        return DomainRecords(self.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_all(self, **kwargs):\n        \"\"\"\n        Retrieve all domain records\n        \"\"\"\n        return super(DomainRecords, self).get_all(**kwargs)\n\ndef create(self, domain_record, **kwargs):\n        \"\"\"\n        Create a new domain record\n        \"\"\"\n        return super(DomainRecords, self).create(domain_record, **kwargs)\n\ndef update(self, id, domain_record, **kwargs):\n        \"\"\"\n        Update a single domain record given the id\n        \"\"\"\n        return super(DomainRecords, self).update(id, domain_record, **kwargs)\n\ndef delete(self, id, **kwargs):\n        \"\"\"\n        Delete a single domain record given the id\n        \"\"\"\n        return super(DomainRecords, self).delete(id, **kwargs)\n\ndef get_all_by_domain(self, domain, **kwargs):\n        \"\"\"\n        Retrieve all domain records for a given domain\n        \"\"\"\n        return super(DomainRecords, self).get_all_by_domain(domain, **kwargs)\n\ndef get_all_by_domain_id(self, domain_id, **kwargs):\n        \"\"\"\n        Retrieve all domain records for a given domain id\n        \"\"\"\n        return super(DomainRecords, self).get_all_by_domain_",
        "\n        return self._token\n\ndef logoff(self):\n        \"\"\"\n        Logs the user off from FogBugz.\n        \"\"\"\n        if self._token:\n                self.__makerequest('logoff')\n                self._token = None\n\ndef __makerequest(method, *args, **kwargs):\n        \"\"\"\n        Makes a request to FogBugz.\n\n        Returns a response object.\n        \"\"\"\n        return self.__request(method, *args, **kwargs)\n\ndef __request(method, *args, **kwargs):\n        \"\"\"\n        Makes a request to FogBugz.\n\n        Returns a response object.\n        \"\"\"\n        return self.__client.request(method, *args, **kwargs)\n\nclass FogBugzAPIError(Exception):\n        \"\"\"\n        Raised when an error occurs in FogBugz.\n        \"\"\"\n        pass\n\nclass FogBugzLogonError(FogBugzAPIError):\n        \"\"\"\n        Raised when an error occurs in FogBugz.\n        \"\"\"\n        pass\n\nclass FogBugzLogoffError(FogBugzAPIError):\n        \"\"\"\n        Raised when an error occurs in FogBugz.\n        \"\"\"\n        pass\n\nclass FogBugzAPI(object):\n",
        "\n\ndef shuffle(list_):\n    \"Shuffle list_.\"\n    # could look into itertools also, might be implemented there\n    size = len(list_)\n    each = size // 2\n    if each == 0:\n        return list_\n    shuffle_list = []\n    for i in range(size):\n        shuffle_list.append(list_[i:i+each])\n    return shuffle_list\n\ndef shuffle_list(list_):\n    \"Shuffle list_.\"\n    # could look into itertools also, might be implemented there\n    size = len(list_)\n    each = size // 2\n    if each == 0:\n        return list_\n    shuffle_list = []\n    for i in range(size):\n        shuffle_list.append(list_[i:i+each])\n    return shuffle_list\n\ndef shuffle_list_sorted(list_):\n    \"Shuffle list_ sorted by length.\"\n    # could look into itertools also, might be implemented there\n    size = len(list_)\n    each = size // 2\n    if each == 0:\n        return list_\n    shuffle_list = []\n    for i in range(size):\n        shuffle_list.append(list_[i:i+each])\n    return shuffle_list\n\n",
        "\n\ndef get_all():\n    \"\"\"\n    return all droplets\n    \"\"\"\n    client = po.connect() # this depends on the DIGITALOCEAN_API_KEY envvar\n    all_droplets = client.droplets.list()\n    return all_droplets\n\ndef get_droplet(id):\n    \"\"\"\n    return droplet\n    \"\"\"\n    client = po.connect() # this depends on the DIGITALOCEAN_API_KEY envvar\n    return client.droplets.get(id)\n\ndef get_droplets():\n    \"\"\"\n    return all droplets\n    \"\"\"\n    client = po.connect() # this depends on the DIGITALOCEAN_API_KEY envvar\n    return client.droplets.list()\n\ndef get_droplet_by_name(name):\n    \"\"\"\n    return droplet by name\n    \"\"\"\n    client = po.connect() # this depends on the DIGITALOCEAN_API_KEY envvar\n    return client.droplets.get(name)\n\ndef get_droplet_by_id(id):\n    \"\"\"\n    return droplet by id\n    \"\"\"\n    client = po.connect() # this depends on the DIGITALOCEAN_API_KEY envvar\n    return client.",
        "\n    print \"powering on\"\n    droplet.power_on()\n    droplet.wait() # wait for pending actions to complete\n    print \"taking snapshot\"\n    droplet.take_snapshot(name)\n    droplet.wait()\n    snapshots = droplet.snapshots()\n    print \"Current snapshots\"\n    print snapshots\n\ndef take_snapshot_from_image(droplet, image_name):\n    \"\"\"\n    Take a snapshot of a droplet from an image\n\n    Parameters\n    ----------\n    image_name: str\n        name of the image\n    \"\"\"\n    print \"powering off\"\n    droplet.power_off()\n    droplet.wait() # wait for pending actions to complete\n    print \"taking snapshot\"\n    droplet.take_snapshot_from_image(image_name)\n    droplet.wait()\n    snapshots = droplet.snapshots()\n    print \"Current snapshots\"\n    print snapshots\n\ndef take_snapshot_from_image_with_name(droplet, image_name, name):\n    \"\"\"\n    Take a snapshot of a droplet from an image with a name\n\n    Parameters\n    ----------\n    image_name: str\n        name of the image\n    name: str\n        name of the snapshot\n    \"\"\"\n    print \"powering off",
        "\n\ndef get_allowed_operations(self):\n        \"\"\"Retrieves the allowed operations for this request.\"\"\"\n        return self.allowed_operations()\n\ndef get_allowed_operations_for_user(self, user):\n        \"\"\"Retrieves the allowed operations for this request for a given user.\"\"\"\n        return self.allowed_operations(user=user)\n\ndef get_allowed_operations_for_user_and_group(self, user, group):\n        \"\"\"Retrieves the allowed operations for this request for a given user and group.\"\"\"\n        return self.allowed_operations(user=user, group=group)\n\ndef get_allowed_operations_for_user_and_group_and_user(self, user, group, user):\n        \"\"\"Retrieves the allowed operations for this request for a given user and group and user.\"\"\"\n        return self.allowed_operations(user=user, group=group, user=user)\n\ndef get_allowed_operations_for_user_and_group_and_user_and_group(self, user, group, user, group):\n        \"\"\"Retrieves the allowed operations for this request for a given user and group and user and group.\"\"\"\n        return self.allowed_operations(user=user, group=group, user=user, group=group)\n\ndef get_allowed_operations_for_user_and_group",
        "(args)\n\ndef assert_not_operations(self, *args):\n        \"\"\"Assets if the requested operations are not allowed in this context.\"\"\"\n        if set(args).issubset(self.allowed_operations):\n            raise http.exceptions.Forbidden()\n\ndef assert_not_allowed_operations(self, *args):\n        \"\"\"Assets if the requested operations are not allowed in this context.\"\"\"\n        if set(args).issubset(self.allowed_operations):\n            raise http.exceptions.Forbidden()\n\ndef assert_not_allowed_operations_in_context(self, *args):\n        \"\"\"Assets if the requested operations are not allowed in this context.\"\"\"\n        if set(args).issubset(self.allowed_operations):\n            raise http.exceptions.Forbidden()\n\ndef assert_not_allowed_operations_in_context_and_user(self, *args):\n        \"\"\"Assets if the requested operations are not allowed in this context.\"\"\"\n        if set(args).issubset(self.allowed_operations):\n            raise http.exceptions.Forbidden()\n\ndef assert_not_allowed_operations_in_context_and_user_and_group(self, *args):\n        \"\"\"Assets if the requested operations are not allowed in this context.\"\"\"\n        if set(args).issubset(self.allowed_",
        "\n        return self.response\n\ndef make_error(self, code=500, message=None):\n        \"\"\"Fills the error object from the passed code and message.\"\"\"\n        if message is not None:\n            self.error = Error(code, message)\n        else:\n            self.error = Error(code)\n        return self.error\n\ndef make_error_response(self, code=500, message=None):\n        \"\"\"Fills the error response object from the passed code and message.\"\"\"\n        if message is not None:\n            self.error_response = ErrorResponse(code, message)\n        else:\n            self.error_response = ErrorResponse(code)\n        return self.error_response\n\ndef make_error_response_with_data(self, code=500, message=None, data=None):\n        \"\"\"Fills the error response object from the passed code and message and data.\"\"\"\n        if message is not None:\n            self.error_response = ErrorResponse(code, message, data)\n        else:\n            self.error_response = ErrorResponse(code, data)\n        return self.error_response\n\ndef make_error_response_with_data_with_headers(self, code=500, message=None, data=None, headers=None):\n        \"\"\"Fills the error response object from",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef create_project_with_py(self, py):\n        '''\n        Creates a base Django project with a given Python interpreter\n        '''\n        if os.path.exists(py):\n            prj_dir = os.path.join(self._app_dir, self._project_name)\n            if os.path.exists(prj_dir):\n                if self._force:\n                    logging.warn('Removing existing project')\n                    shutil.rmtree(prj_dir)\n                else:\n                    logging.warn('Found existing project; not creating (use --force to overwrite)')\n                    return\n            logging.info('Creating project with Python interpreter')\n            p = subprocess.Popen('cd {0} ; {1} startproject {2} > /dev/null'.format(self._app_dir, self._ve_dir + os.sep + self._project_name + \\\n            os.sep + 'bin' + os.sep + 'django-admin.py', self._project_name), \\\n            shell=True)\n            os.waitpid(p.pid, 0)\n        else:\n            logging.error('Unable to find Python interpreter in virtualenv')\n            return\n\ndef create_project_with_py_and_ve(self, py, ve):\n        '''\n        Creates a",
        "\n\n\ndef ilike(x, y):\n    \"\"\"\n    Returns a query that uses an `ilike` query if a string value is passed,\n    otherwise the normal default operation.\n    \"\"\"\n    return ilike_helper(default)\n\n\ndef ilike_or(x, y):\n    \"\"\"\n    Returns a query that uses an `ilike` query if a string value is passed,\n    otherwise the normal default operation.\n    \"\"\"\n    return ilike_helper(or_)\n\n\ndef ilike_and(x, y):\n    \"\"\"\n    Returns a query that uses an `ilike` query if a string value is passed,\n    otherwise the normal default operation.\n    \"\"\"\n    return ilike_helper(and_)\n\n\ndef ilike_not(x, y):\n    \"\"\"\n    Returns a query that uses an `ilike` query if a string value is passed,\n    otherwise the normal default operation.\n    \"\"\"\n    return ilike_helper(not_)\n\n\ndef ilike_or_not(x, y):\n    \"\"\"\n    Returns a query that uses an `ilike` query if a string value is passed,\n    otherwise the normal default operation.\n    \"\"\"\n    return ilike_or_not_helper(or_not)\n\n\ndef i",
        ")\n\n\ndef split_segments(text):\n    \"\"\"Split the querystring into segments.\"\"\"\n    segments = []\n    for segment in text.split('&'):\n        segments.append(segment.strip())\n    return segments\n\n\nclass Query(object):\n    \"\"\"A query string.\"\"\"\n\n    def __init__(self, text, segments):\n        \"\"\"Initialize the query string.\"\"\"\n        self.text = text\n        self.segments = segments\n\n    def __str__(self):\n        \"\"\"Return a string representation of the query string.\"\"\"\n        return '?' + '&'.join(self.segments)\n\n    def __eq__(self, other):\n        \"\"\"Return true if the query string is equal to another.\"\"\"\n        return self.text == other.text\n\n    def __ne__(self, other):\n        \"\"\"Return true if the query string is not equal to another.\"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        \"\"\"Return a hash value for the query string.\"\"\"\n        return hash(self.text)\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the query string.\"\"\"\n        return '<Query: %s>' % self.text\n\n    def __str__(self):\n        \"\"\"Return a string representation of the query string.\"\"\"\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.security.permission.ActionConstants;\nimport com.hazelcast.security.permission.MapPermission;",
        "\n\ndef parse_directive(text):\n    \"\"\"\n    Parse a directive string into a key and a directive.\n    \"\"\"\n    if not text:\n        return None, None\n\n    key, directive = text.split(constants.SEP_KEY, 1)\n    if not key:\n        return None, None\n\n    return key, directive\n\ndef parse_query(text):\n    \"\"\"\n    Parse a query string into a QuerySegment.\n    \"\"\"\n    return parse_segment(text)\n\ndef parse_query_directive(text):\n    \"\"\"\n    Parse a query directive string into a QuerySegment.\n    \"\"\"\n    return parse_directive(text)\n\ndef parse_query_values(text):\n    \"\"\"\n    Parse a query values string into a QuerySegment.\n    \"\"\"\n    return parse_segment(text)\n\ndef parse_query_negation(text):\n    \"\"\"\n    Parse a query negation string into a QuerySegment.\n    \"\"\"\n    return parse_segment(text)\n\ndef parse_query_path(text):\n    \"\"\"\n    Parse a query path string into a QuerySegment.\n    \"\"\"\n    return parse_segment(text)\n\ndef parse_query_operator(text):\n    \"\"\"\n    Parse a query operator string into a QuerySegment.\n    \"\"\"\n    return",
        "\n\ndef get(self, target):\n        \"\"\"Get the value of this attribute for the passed object.\n        \"\"\"\n\n        if not self._get:\n            return\n\n        if self.path is None:\n            # There is no path defined on this resource.\n            # We can do no magic to get the value.\n            self.get = lambda *a: None\n            return None\n\n        if self._segments[target.__class__]:\n            # Attempt to resolve access to this attribute.\n            self.get(target)\n\n        if self._segments[target.__class__]:\n            # Attribute is not fully resolved; an interim segment is null.\n            return\n\n        # Resolve access to the parent object.\n        # For a single-segment path this will effectively be a no-op.\n        parent_getter = compose(*self._getters[target.__class__][:-1])\n        target = parent_getter(target)\n\n        # Make the getter.\n        func = self._make_getter(self.path.split('.')[-1], target.__class__)\n\n        # Apply the getter now.\n        func(target)\n\n        # Replace this function with the constructed getter.\n        def getter(target):\n            func(parent_getter(target))\n\n        self.get = getter",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef parse(header):\n    \"\"\"Parse a range header.\n\n    This is a bit of a hack, but it's a bit of a hack.\n    \"\"\"\n    parts = header.split('-')\n    if len(parts) != 2:\n        raise exceptions.InvalidRangeHeader(\n            'Invalid range header: %s' % header)\n    start, end = parts\n    return start, end\n\ndef RANGE_SPECIFIER = 'bytes='\n",
        ".add(f.__name__)\n    return f\n\ndef indexes(f):\n    \"\"\"Decorate test methods with this if you don't require strict index checking\"\"\"\n    stack = inspect.stack()\n    _NO_INDEX_CHECK_NEEDED.add('%s.%s.%s' % (f.__module__, stack[1][3], f.__name__))\n    del stack\n    return f\n\ndef indexesOptional(f):\n    \"\"\"Decorate test methods with this if you don't require strict index checking\"\"\"\n    stack = inspect.stack()\n    _NO_INDEX_CHECK_NEEDED.add('%s.%s.%s' % (f.__module__, stack[1][3], f.__name__))\n    del stack\n    return f\n\ndef indexes(f):\n    \"\"\"Decorate test methods with this if you don't require strict index checking\"\"\"\n    stack = inspect.stack()\n    _NO_INDEX_CHECK_NEEDED.add('%s.%s.%s' % (f.__module__, stack[1][3], f.__name__))\n    del stack\n    return f\n\ndef indexesOptional(f):\n    \"\"\"Decorate test methods with this if you don't require strict index checking\"\"\"\n    stack = inspect.stack()\n    _NO_INDEX_CHECK_NEEDED.add('%s",
        "\n\ndef write(self, data, format=None):\n        \"\"\"Write the request data.\n\n        @param[in] data\n            The data to write.\n\n        @param[in] format\n            A specific format to serialize in; if provided, no detection is\n            done.\n        \"\"\"\n\n        if format:\n            data, _ = self.serialize(format=format)\n\n        self._write(data)\n\ndef _read(self):\n        \"\"\"Read the request data.\n\n        @return: The request data.\n        \"\"\"\n\n        return self.request.read()\n\ndef _write(self, data):\n        \"\"\"Write the request data.\n\n        @param[in] data\n            The data to write.\n        \"\"\"\n\n        self.request.write(data)\n\ndef _write_binary(self, data):\n        \"\"\"Write the request data.\n\n        @param[in] data\n            The data to write.\n        \"\"\"\n\n        self.request.write(data)\n\ndef _write_text(self, data):\n        \"\"\"Write the request data.\n\n        @param[in] data\n            The data to write.\n        \"\"\"\n\n        self.request.write(data)\n\ndef _write_json(self, data):\n        \"\"\"",
        ".update(kwargs)\n    return config\n\n\ndef get_config():\n    \"\"\"\n    Returns the active resource configuration.\n\n    @returns\n        The active resource configuration.\n    \"\"\"\n    return use.config\n\n\ndef set_config(config):\n    \"\"\"\n    Sets the active resource configuration.\n\n    @param config\n        The new active resource configuration.\n    \"\"\"\n    use.config = config\n\n\ndef get_active_resource():\n    \"\"\"\n    Returns the active resource.\n\n    @returns\n        The active resource.\n    \"\"\"\n    return use.active_resource\n\n\ndef set_active_resource(resource):\n    \"\"\"\n    Sets the active resource.\n\n    @param resource\n        The new active resource.\n    \"\"\"\n    use.active_resource = resource\n\n\ndef get_active_resource_name():\n    \"\"\"\n    Returns the active resource name.\n\n    @returns\n        The active resource name.\n    \"\"\"\n    return use.active_resource_name\n\n\ndef set_active_resource_name(name):\n    \"\"\"\n    Sets the active resource name.\n\n    @param name\n        The new active resource name.\n    \"\"\"\n    use.active_resource_name = name\n\n\ndef get_active_resource_type():\n    \"\"\"",
        "\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ", name = mro_type.__name__\n        yield name\n\ndef gen_method_names(self, *args, **kwargs):\n        '''Given a node, return a generator of the names of the matching\n        visitor methodnames. Can also be a generator of strings.\n        '''\n        token = args[0]\n        for mro_type in type(token).__mro__[:-1]:\n            name = mro_type.__name__\n            yield name\n\ndef gen_method_names_with_args(self, *args, **kwargs):\n        '''Given a node, return a generator of the names of the matching\n        visitor methodnames with the given arguments. Can also be a generator of\n        strings.\n        '''\n        token = args[0]\n        for mro_type in type(token).__mro__[:-1]:\n            name = mro_type.__name__\n            yield name, args[1]\n\ndef gen_method_names_with_kwargs(self, *args, **kwargs):\n        '''Given a node, return a generator of the names of the matching\n        visitor methodnames with the given keyword arguments. Can also be a\n        generator of strings.\n        '''\n        token = args[0]\n        for mro_type in type(token).__mro",
        "\n\ndef gen_method_keys(self, *args, **kwargs):\n        '''Find all method keys this input dispatches to.\n        '''\n        token = args[0]\n        inst = self.inst\n        prefix = self._method_prefix\n        for method_key in self.gen_method_keys(*args, **kwargs):\n            method = getattr(inst, prefix + method_key, None)\n            if method is not None:\n                yield method_key\n\ndef gen_method_names(self, *args, **kwargs):\n        '''Find all method names this input dispatches to.\n        '''\n        token = args[0]\n        inst = self.inst\n        prefix = self._method_prefix\n        for method_name in self.gen_method_names(*args, **kwargs):\n            method = getattr(inst, prefix + method_name, None)\n            if method is not None:\n                yield method_name\n\ndef gen_method_types(self, *args, **kwargs):\n        '''Find all method types this input dispatches to.\n        '''\n        token = args[0]\n        inst = self.inst\n        prefix = self._method_prefix\n        for method_type in self.gen_method_types(*args, **kwargs):\n            method = getattr(inst,",
        "\n\ndef filter(cls, req, required=False):\n        \"\"\"\n          Create an instance with a requirement that is fulfilled\n\n          :param Requirement req: Requirement to filter\n          :param bool required: Is this requirement required to be fulfilled? If not, then it is a filter.\n        \"\"\"\n        return cls(req, required=required)\n\ndef filter_all(cls, req, required=False):\n        \"\"\"\n          Create an instance with a requirement that is fulfilled\n\n          :param Requirement req: Requirement to filter\n          :param bool required: Is this requirement required to be fulfilled? If not, then it is a filter.\n        \"\"\"\n        return cls(req, required=required, all=True)\n\ndef filter_none(cls, req, required=False):\n        \"\"\"\n          Create an instance with a requirement that is fulfilled\n\n          :param Requirement req: Requirement to filter\n          :param bool required: Is this requirement required to be fulfilled? If not, then it is a filter.\n        \"\"\"\n        return cls(req, required=required, none=True)\n\ndef filter_all_none(cls, req, required=False):\n        \"\"\"\n          Create an instance with a requirement that is fulfilled\n\n          :param Requirement req: Requirement to filter\n          :param bool required: Is this requirement",
        "\n\ndef remove(self, requirements):\n        \"\"\"\n        Remove requirements from be managed\n\n        :param list/Requirement requirements: List of :class:`BumpRequirement` or :class:`pkg_resources.Requirement`\n        \"\"\"\n        if isinstance(requirements, RequirementsManager):\n            requirements = list(requirements)\n        elif not isinstance(requirements, list):\n            requirements = [requirements]\n\n        for req in requirements:\n            name = req.project_name\n\n            if name in self.requirements:\n                self.requirements[name].remove(req)\n\ndef update(self, requirements, required=None):\n        \"\"\"\n        Update requirements to be managed\n\n        :param list/Requirement requirements: List of :class:`BumpRequirement` or :class:`pkg_resources.Requirement`\n        :param bool required: Set required flag for each requirement if provided.\n        \"\"\"\n        if isinstance(requirements, RequirementsManager):\n            requirements = list(requirements)\n        elif not isinstance(requirements, list):\n            requirements = [requirements]\n\n        for req in requirements:\n            name = req.project_name\n\n            if name in self.requirements:\n                for existing_req in self.requirements[name]:\n                    if req == existing_req:\n                        add = False\n                        break\n\n                    # Need to replace existing as the new",
        ")\n\n\nclass RequirementsManager(object):\n    \"\"\"\n    A manager for requirements\n    \"\"\"\n\n    def __init__(self, requirements):\n        \"\"\"\n        Initialize requirements manager\n\n        :param list requirements: List of requirements\n        \"\"\"\n        self.requirements = requirements\n\n    def check(self, req):\n        \"\"\"\n        Check if requirement is already satisfied by what was previously checked\n\n        :param Requirement req: Requirement to check\n        \"\"\"\n        for requirement in self.requirements:\n            if requirement.check(*req):\n                return True\n        return False\n\n    def check_all(self):\n        \"\"\"\n        Check all requirements\n        \"\"\"\n        for requirement in self.requirements:\n            requirement.check_all()\n\n    def check_all_by_name(self, name):\n        \"\"\"\n        Check all requirements by name\n        \"\"\"\n        for requirement in self.requirements:\n            if requirement.check_by_name(name):\n                return True\n        return False\n\n    def check_by_name(self, name):\n        \"\"\"\n        Check all requirements by name\n        \"\"\"\n        for requirement in self.requirements:\n            if requirement.check_by_name(name):\n                return True\n        return False\n\n    def check_by_name_and_type(self,",
        "\n\ndef require_all(self, reqs):\n        \"\"\" Add new requirements that must be fulfilled for all bumps to occur \"\"\"\n        reqs = reqs if isinstance(reqs, list) else [reqs]\n\n        for req in reqs:\n            if not isinstance(req, BumpRequirement):\n                req = BumpRequirement(req)\n            req.required = True\n            req.required_by = self\n            self.requirements.append(req)\n\ndef require_none(self, reqs):\n        \"\"\" Add new requirements that must be fulfilled for none bumps to occur \"\"\"\n        reqs = reqs if isinstance(reqs, list) else [reqs]\n\n        for req in reqs:\n            if not isinstance(req, BumpRequirement):\n                req = BumpRequirement(req)\n            req.required = False\n            req.required_by = self\n            self.requirements.append(req)\n\ndef require_all_none(self, reqs):\n        \"\"\" Add new requirements that must be fulfilled for all bumps to occur \"\"\"\n        reqs = reqs if isinstance(reqs, list) else [reqs]\n\n        for req in reqs:\n            if not isinstance(req, BumpRequirement):\n                req = BumpRequirement(req)\n            req.required = False\n            req.required_by = self\n            self.",
        "\n\ndef requirements_for_changes_with_version(self, changes, version):\n        \"\"\"\n        Parse changes for requirements\n\n        :param list changes:\n        :param str version:\n        \"\"\"\n        requirements = []\n        reqs_set = set()\n\n        if isinstance(changes, str):\n            changes = changes.split('\\n')\n\n        if not changes or changes[0].startswith('-'):\n            return requirements\n\n        for line in changes:\n            line = line.strip(' -+*')\n\n            if not line:\n                continue\n\n            match = IS_REQUIREMENTS_RE2.search(line)  # or  IS_REQUIREMENTS_RE.match(line)\n            if match:\n                for match in REQUIREMENTS_RE.findall(match.group(1)):\n                    if match[1]:\n                        version = '==' + match[2] if match[1].startswith(' to ') else match[1]\n                        req_str = match[0] + version\n                    else:\n                        req_str = match[0]\n\n                    if req_str not in reqs_set:\n                        reqs_set.add(req_str)\n                        try:\n                            requirements.append(pkg_resources.Requirement.parse(req_str))\n",
        "\n\n    def _bump(self, existing_req, bump_reqs):\n        \"\"\"\n          Bump dependencies using given requirements.\n\n          :param Requirement existing_req: Requirement to bump\n          :param Requirement bump_reqs: Bump requirements manager\n          :return: Bump object\n        \"\"\"\n\n        if existing_req.project_name not in bump_reqs:\n            return None\n\n        if bump_reqs and existing_req.project_name not in bump_reqs:\n            return None\n\n        try:\n            bump = self._bump_requirement(existing_req, bump_reqs)\n\n            if bump:\n                return bump\n\n        except Exception as e:\n            if bump_reqs and existing_req.project_name not in bump_reqs:\n                return None\n\n            log.warn(e)\n\n        return None\n\n    def _bump_requirement(self, existing_req, bump_reqs):\n        \"\"\"\n          Bump requirements using given requirements.\n\n          :param Requirement existing_req: Requirement to bump\n          :param Requirement bump_reqs: Bump requirements manager\n          :return: Bump object\n        \"\"\"\n\n        if existing_req.project_name not in bump_reqs:\n            return None\n\n        if bump_reqs and existing_req.project_name not",
        ".target_content)\n            self._original_target_content = None\n        return self\n\n    def save(self):\n        \"\"\" Save the current state of the object to the target file \"\"\"\n        with open(self.target, 'w') as fp:\n            fp.write(self.content)\n        return self\n\n    def __str__(self):\n        \"\"\" Return a string representation of the object \"\"\"\n        return self.content\n\n    def __repr__(self):\n        \"\"\" Return a string representation of the object \"\"\"\n        return self.__str__()\n\n    def __eq__(self, other):\n        \"\"\" Return true if the objects are equal \"\"\"\n        return self.content == other.content\n\n    def __ne__(self, other):\n        \"\"\" Return true if the objects are not equal \"\"\"\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        \"\"\" Return true if the objects are less than \"\"\"\n        return self.content < other.content\n\n    def __le__(self, other):\n        \"\"\" Return true if the objects are less than or equal to \"\"\"\n        return self.__eq__(other)\n\n    def __gt__(self, other):\n        \"\"\" Return true if the objects are greater than \"\"\"\n        return self.content > other",
        "\n\n        raise ValueError('This serializer does not support the encoding of the '\n                         'specified object.')\n\n\nclass JSONSerializer(Serializer):\n    \"\"\"\n    A serializer that serializes objects to JSON.\n    \"\"\"\n    media_types = ['application/json']\n\n    def serialize(self, data=None):\n        \"\"\"\n        Transforms the object into an acceptable format for transmission.\n\n        @throws ValueError\n            To indicate this serializer does not support the encoding of the\n            specified object.\n        \"\"\"\n        if data is not None and self.response is not None:\n            # Set the content type.\n            self.response['Content-Type'] = self.media_types[0]\n\n            # Write the encoded and prepared data to the response.\n            self.response.write(json.dumps(data))\n\n        # Return the serialized data.\n        # This has normally been transformed by a base class.\n        return data\n\n\nclass XMLSerializer(Serializer):\n    \"\"\"\n    A serializer that serializes objects to XML.\n    \"\"\"\n    media_types = ['application/xml']\n\n    def serialize(self, data=None):\n        \"\"\"\n        Transforms the object into an acceptable format for transmission.\n\n        @throws ValueError\n            To indicate this serializer does not support the encoding of the\n            specified object.",
        "\n\ndef map(collection, func):\n    \"\"\"Maps a collection to a function.\"\"\"\n    if isinstance(func, collections.Function):\n        return cons(collection, func())\n\n    if isinstance(func, collections.Mapping):\n        return cons(collection, func.copy())\n\n    if isinstance(func, collections.Iterable):\n        return cons(collection, func)\n\n    return cons(collection, func)\n\ndef filter(collection, func):\n    \"\"\"Filters a collection to a function.\"\"\"\n    if isinstance(func, collections.Function):\n        return cons(collection, func())\n\n    if isinstance(func, collections.Mapping):\n        return cons(collection, func.copy())\n\n    if isinstance(func, collections.Iterable):\n        return cons(collection, func)\n\n    return cons(collection, func)\n\ndef reduce(collection, func):\n    \"\"\"Reduces a collection to a function.\"\"\"\n    if isinstance(func, collections.Function):\n        return cons(collection, func())\n\n    if isinstance(func, collections.Mapping):\n        return cons(collection, func.copy())\n\n    if isinstance(func, collections.Iterable):\n        return cons(collection, func)\n\n    return cons(collection, func)\n\ndef reduce_key(collection, func):\n    \"\"\"Reduces a collection to",
        "\n\ndef _merge_list(options, name, bases, default=None):\n    \"\"\"Merges a named option collection.\"\"\"\n    result = None\n    for base in bases:\n        if base is None:\n            continue\n\n        value = getattr(base, name, None)\n        if value is None:\n            continue\n\n        result = utils.cons(result, value)\n\n    value = options.get(name)\n    if value is not None:\n        result = utils.cons(result, value)\n\n    return result or default\n\ndef _merge_dict(options, name, bases, default=None):\n    \"\"\"Merges a named option collection.\"\"\"\n    result = None\n    for base in bases:\n        if base is None:\n            continue\n\n        value = getattr(base, name, None)\n        if value is None:\n            continue\n\n        result = utils.cons(result, value)\n\n    value = options.get(name)\n    if value is not None:\n        result = utils.cons(result, value)\n\n    return result or default\n\ndef _merge_dict_list(options, name, bases, default=None):\n    \"\"\"Merges a named option collection.\"\"\"\n    result = None\n    for base in bases:\n        if base is None:\n            continue\n\n",
        "\n\n    @classmethod\n    def get_package_info_cache(cls):\n        \"\"\" Cache for package info \"\"\"\n\n        if cls.package_info_cache is None:\n            cls.package_info_cache = {}\n\n        return cls.package_info_cache\n\n    @classmethod\n    def get_package_info(cls, package):\n        \"\"\" Get package info \"\"\"\n\n        return cls.package_info(package)\n\n    @classmethod\n    def get_package_info_by_name(cls, package_name):\n        \"\"\" Get package info by name \"\"\"\n\n        return cls.package_info(package_name)\n\n    @classmethod\n    def get_package_info_by_version(cls, package_version):\n        \"\"\" Get package info by version \"\"\"\n\n        return cls.package_info(package_version)\n\n    @classmethod\n    def get_package_info_by_version_and_name(cls, package_version, package_name):\n        \"\"\" Get package info by version and name \"\"\"\n\n        return cls.package_info(package_version, package_name)\n\n    @classmethod\n    def get_package_info_by_version_and_name_and_version(cls, package_version, package_name, package_version",
        "\n\ndef all_package_versions_for_package(package):\n        \"\"\" All versions for package \"\"\"\n        return all_package_versions(package)\n\ndef all_package_versions_for_package_with_version(package, version):\n        \"\"\" All versions for package with version \"\"\"\n        return all_package_versions(package) + [version]\n\ndef all_package_versions_for_package_with_version_and_package(package, version, package):\n        \"\"\" All versions for package with version and package \"\"\"\n        return all_package_versions(package) + [version, package]\n\ndef all_package_versions_for_package_with_version_and_package_with_version(package, version, package, version):\n        \"\"\" All versions for package with version and package with version \"\"\"\n        return all_package_versions(package) + [version, package, version]\n\ndef all_package_versions_for_package_with_version_and_package_with_version(package, version, package, package, version):\n        \"\"\" All versions for package with version and package with version \"\"\"\n        return all_package_versions(package) + [version, package, package, version]\n\ndef all_package_versions_for_package_with_version_and_package_with_version_and_",
        "\n\n        # Tell the HTTP connector to close the response stream.\n        self.connector.close_response(self)\n\n        # Tell the HTTP connector to close the request stream.\n        self.connector.close_request(self)\n\n        # Tell the HTTP connector to close the connection.\n        self.connector.close_connection(self)\n\n        # Tell the HTTP connector to close the connection.\n        self.connector.close_connection()\n\n        # Tell the HTTP connector to close the connection.\n        self.connector.close_connection()\n\n        # Tell the HTTP connector to close the connection.\n        self.connector.close_connection()\n\n        # Tell the HTTP connector to close the connection.\n        self.connector.close_connection()\n\n        # Tell the HTTP connector to close the connection.\n        self.connector.close_connection()\n\n        # Tell the HTTP connector to close the connection.\n        self.connector.close_connection()\n\n        # Tell the HTTP connector to close the connection.\n        self.connector.close_connection()\n\n        # Tell the HTTP connector to close the connection.\n        self.connector.close_connection()\n\n        # Tell the HTTP connector to close the connection.\n        self.connector.close_connection()\n\n        # Tell the HTTP connector to close the connection.\n       ",
        "\n\n\ndef serialize(self, chunk, format=None):\n        \"\"\"Serializes the given chunk to the output buffer.\n\n        @param[in] chunk\n            Either a byte array, a unicode string, or a generator. If `chunk`\n            is a generator then calling `self.serialize(<generator>)` is\n            equivalent to:\n\n            @code\n                for x in <generator>:\n                    self.serialize(x)\n                    self.flush()\n            @endcode\n\n        @param[in] format\n            A specific format to serialize in; if provided, no detection is\n            done. If not provided, the accept header (as well as the URL\n            extension) is looked at to determine an appropriate serializer.\n        \"\"\"\n\n        # Ensure we're not closed.\n        self.require_not_closed()\n\n        if chunk is None:\n            # There is nothing here.\n            return\n\n        if format is not None:\n            # If passed a specific format, we can encode it for the user.\n            chunk = chunk.encode(format)\n\n        # Update the stream length.\n        self._length += len(chunk)\n\n        # Write the encoded data into the byte stream.\n        self._stream.write(chunk)\n\n\ndef flush(self):\n        \"\"\"Flushes the output buffer.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n        # If the `Content-Length` header is not given then the chunked\n        # `Transfer-Encoding` is applied.\n        if not self.headers.get('Content-Length'):\n            self.headers['Transfer-Encoding'] = 'chunked'\n\n        # Send the response.\n        self.send_response(200)\n\n        # Close the connection.\n        self.close()\n\n        # Return the stream.\n        return self._stream\n\n    def close(self):\n        \"\"\"Close the stream.\n\n        This closes the underlying transport layer, and closes the HTTP/1.1\n        response.\n        \"\"\"\n\n        # Ensure we're not closed.\n        self.require_not_closed()\n\n        # Close the underlying transport layer.\n        self._stream.close()\n\n        # Close the HTTP/1.1 response.\n        self.send_response(204)\n\n        # Return the stream.\n        return self._stream\n\n    def require_not_closed(self):\n        \"\"\"Ensure we're not closed.\n\n        This ensures that the stream is not closed if it is not closed\n        before the call to `flush`.\n        \"\"\"\n\n        if self._stream is not None:\n            raise RuntimeError('Stream is already closed.')\n\n    def send_response(",
        "\n\ndef recv(self, *args, **kwargs):\n        \"\"\"Reads the passed chunk and returns it to the client.\"\"\"\n        return self.read(*args, **kwargs)\n\ndef send_chunk(self, *args, **kwargs):\n        \"\"\"Writes the passed chunk and flushes it to the client.\"\"\"\n        self.write(*args, **kwargs)\n        self.flush()\n\ndef recv_chunk(self, *args, **kwargs):\n        \"\"\"Reads the passed chunk and returns it to the client.\"\"\"\n        return self.read(*args, **kwargs)\n\ndef send_message(self, *args, **kwargs):\n        \"\"\"Writes the passed message and flushes it to the client.\"\"\"\n        self.write(*args, **kwargs)\n        self.flush()\n\ndef recv_message(self, *args, **kwargs):\n        \"\"\"Reads the passed message and returns it to the client.\"\"\"\n        return self.read(*args, **kwargs)\n\ndef send_message_chunk(self, *args, **kwargs):\n        \"\"\"Writes the passed message and flushes it to the client.\"\"\"\n        self.write(*args, **kwargs)\n        self.flush()\n\ndef recv_message_chunk(self, *args, **kwargs):\n        \"\"\"Reads the passed message and returns it to the client.\"\"\"\n        return self",
        "\n\ndef send(self, *args, **kwargs):\n        \"\"\"\n        Writes the passed chunk, flushes it to the client,\n        and terminates the connection.\n        \"\"\"\n        self.send(*args, **kwargs)\n        self.close()\n\ndef close(self):\n        \"\"\"\n        Closes the connection.\n        \"\"\"\n        self.close()\n\ndef close_all(self):\n        \"\"\"\n        Closes all connections.\n        \"\"\"\n        for c in self.connections:\n                c.close()\n\ndef close_all_with_timeout(self, timeout):\n        \"\"\"\n        Closes all connections with a timeout.\n        \"\"\"\n        for c in self.connections:\n                c.close(timeout)\n\ndef close_all_with_timeout_and_close(self, timeout, close):\n        \"\"\"\n        Closes all connections with a timeout and closes the connection.\n        \"\"\"\n        for c in self.connections:\n                c.close(timeout, close)\n\ndef close_all_with_timeout_and_close_all(self, timeout, close_all):\n        \"\"\"\n        Closes all connections with a timeout and closes all connections.\n        \"\"\"\n        for c in self.connections:\n                c.close(timeout, close_all)\n\ndef close_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef capture_stderr():\n    \"\"\"This ``Context Manager`` redirects STDERR to a ``StringIO`` objects\n    which is returned from the ``Context``.  On exit STDERR is restored.\n\n    Example:\n\n    .. code-block:: python\n\n        with capture_stderr() as capture:\n            print('foo')\n\n    # got here? => capture.getvalue() will now have \"foo\\\\n\"\n    \"\"\"\n    stderr = sys.stderr\n    try:\n        capture_out = StringIO()\n        sys.stderr = capture_out\n        yield capture_out\n    finally:\n        sys.stderr = stderr\n\ndef capture_stdout_and_stderr():\n    \"\"\"This ``Context Manager`` redirects STDOUT to a ``StringIO`` objects\n    which is returned from the ``Context``.  On exit STDOUT is restored.\n\n    Example:\n\n    .. code-block:: python\n\n        with capture_stdout_and_stderr() as capture:\n            print('foo')\n\n    # got here? => capture.getvalue() will now have \"foo\\\\n\"\n    \"\"\"\n    stdout = sys.stdout\n    try:\n        capture_out = StringIO()\n        sys.stdout = capture_out\n        yield capture_out\n    finally:\n        sys.stdout = stdout\n\ndef capture_stdout_",
        "\n        sys.stderr = stderr\n\n\ndef capture_stdout():\n    \"\"\"This ``Context Manager`` redirects STDOUT to a ``StringIO`` objects\n    which is returned from the ``Context``.  On exit STDOUT is restored.\n\n    Example:\n\n    .. code-block:: python\n\n        with capture_stdout() as capture:\n            print('foo')\n\n        # got here? => capture.getvalue() will now have \"foo\\\\n\"\n    \"\"\"\n    stdout = sys.stdout\n    try:\n        capture_out = StringIO()\n        sys.stdout = capture_out\n        yield capture_out\n    finally:\n        sys.stdout = stdout\n        sys.stdout = stdout\n\n\ndef capture_stdout_and_stderr():\n    \"\"\"This ``Context Manager`` redirects STDOUT and STDERR to a\n    ``StringIO`` objects which is returned from the ``Context``.  On exit\n    STDOUT and STDERR are restored.\n\n    Example:\n\n    .. code-block:: python\n\n        with capture_stdout_and_stderr() as capture:\n            print('foo')\n\n        # got here? => capture.getvalue() will now have \"foo\\\\n\"\n    \"\"\"\n    stdout = sys.stdout\n    try:\n        capture_out = StringIO()\n        sys.stdout = capture_out\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;",
        "\n\ndef load(fp, startindex=1, separator=DEFAULT, index_separator=DEFAULT):\n    '''Load an object from req format to the fp given.\n\n    :param Mapping obj: The object to deserialize.  Must have a keys method.\n    :param fp: A readable that can accept all the types given.\n    :param separator: The separator between key and value.  Defaults to u'|' or b'|', depending on the types.\n    :param index_separator: The separator between key and index.  Defaults to u'_' or b'_', depending on the types.\n    '''\n\n    if startindex < 1:\n        raise ValueError('startindex must be non-negative, but was {}'.format(startindex))\n\n    try:\n        firstkey = next(iter(obj.keys()))\n    except StopIteration:\n        return\n\n    if isinstance(firstkey, six.text_type):\n        converter = six.u\n    else:\n        converter = six.b\n\n    default_separator = converter('|')\n    default_index_separator = converter('_')\n    newline = converter('\\n')\n\n    if separator is DEFAULT:\n        separator = default_separator\n    if index_separator is DEFAULT:\n        index_separator = default_index_separator\n\n    for key,",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef save(fp, output, separator=DEFAULT, index_separator=DEFAULT, cls=dict, list_cls=list):\n    '''Save an object to the file pointer.\n\n    :param fp: A writable filehandle.\n    :param output: A Mapping that is filled with pairs.  The most common alternate option would be OrderedDict.\n    :param separator: The separator between key and value.  Defaults to u'|' or b'|', depending on the types.\n    :param index_separator: The separator between key and index.  Defaults to u'_' or b'_', depending on the types.\n    :param cls: A callable that returns a Mapping that is filled with pairs.  The most common alternate option would be OrderedDict.\n    :param list_cls: A callable that takes an iterable and returns a sequence.\n    '''\n\n    converter = None\n\n    for key, value in output.items():\n        if converter is None:\n            if isinstance(value, six.text_type):\n                converter = six.u\n            else:\n                converter = six.b\n            default_separator = converter('|')\n            default_index_separator = converter('_')\n            newline = converter('\\n')\n\n            if separator is DEFAULT:\n                separator = default_separator\n            if index_separator is DEFAULT:\n               ",
        "\n    :returns: A dictionary or list of dictionaries.\n    '''\n    if isinstance(s, six.text_type):\n        return loads(s, separator=separator, index_separator=index_separator, cls=cls, list_cls=list_cls)\n    else:\n        return loads(s, separator=separator, index_separator=index_separator, cls=cls, list_cls=list_cls)\n\ndef loads_list(s, cls=list, list_cls=list):\n    '''Loads an object from a string.\n\n    :param s: An object to parse\n    :type s: bytes or str\n    :param cls: A callable that returns a list of dictionaries.\n    :type cls: callable\n    :param list_cls: A callable that takes an iterable and returns a sequence.\n    '''\n    return loads(s, cls=cls, list_cls=list_cls)\n\ndef loads_dict(s, cls=dict, list_cls=list):\n    '''Loads an object from a string.\n\n    :param s: An object to parse\n    :type s: bytes or str\n    :param cls: A callable that returns a dict of dictionaries.\n    :type cls: callable\n    :param list_cls: A callable that takes an iterable and returns a sequence.\n    '''",
        "\n        return self\n\nclass Bumper(object):\n    \"\"\" A bumper is a class that can be used to move a drive.\n\n    It is a subclass of the drive class.\n    \"\"\"\n    def __init__(self, drive, bump_type, bump_speed, bump_angle, bump_speed_angle, bump_angle_angle, bump_speed_angle_angle, bump_speed_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_angle, bump_speed_angle_angle_angle_",
        "\n\n    def _expand_targets_from_args(self, args, base_dir=None):\n        \"\"\" Expand targets by looking for '-r' in targets. \"\"\"\n        all_targets = []\n\n        for target in args:\n            target_dirs = [p for p in [base_dir, os.path.dirname(target)] if p]\n            target_dir = target_dirs and os.path.join(*target_dirs) or ''\n            target = os.path.basename(target)\n            target_path = os.path.join(target_dir, target)\n\n            if os.path.exists(target_path):\n                all_targets.append(target_path)\n\n                with open(target_path) as fp:\n                    for line in fp:\n                        if line.startswith('-r '):\n                            _, new_target = line.split(' ', 1)\n                            all_targets.extend(self._expand_targets([new_target.strip()], base_dir=target_dir))\n\n        return all_targets\n\n    def _expand_targets_from_args_with_base_dir(self, args, base_dir=None):\n        \"\"\" Expand targets by looking for '-r' in targets. \"\"\"\n        all_targets = []\n\n        for target in args",
        "\n\ndef get_nginx_config_file(self):\n        \"\"\"\n        Gets the Nginx config file for the project\n\n        \"\"\"\n        if os.path.exists(self._nginx_config_file):\n            return open(self._nginx_config_file, 'r')\n        else:\n            return None\n\ndef get_nginx_config_file_path(self):\n        \"\"\"\n        Gets the Nginx config file path for the project\n\n        \"\"\"\n        if os.path.exists(self._nginx_config_file_path):\n            return os.path.join(self._nginx_config_file_path, 'nginx.conf')\n        else:\n            return None\n\ndef get_nginx_config_file_path_with_prefix(self, prefix):\n        \"\"\"\n        Gets the Nginx config file path for the project with a prefix\n\n        \"\"\"\n        if os.path.exists(self._nginx_config_file_path_with_prefix):\n            return os.path.join(self._nginx_config_file_path_with_prefix, prefix, 'nginx.conf')\n        else:\n            return None\n\ndef get_nginx_config_file_path_with_suffix(self, suffix):\n        \"\"\"\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef delete_nginx_config(self):\n        \"\"\"\n        Deletes the Nginx configuration for the project\n\n        \"\"\"\n        if os.path.exists(self._nginx_config):\n            os.remove(self._nginx_config)\n\ndef get_nginx_config(self):\n        \"\"\"\n        Returns the Nginx configuration for the project\n\n        \"\"\"\n        return open(self._nginx_config).read()\n\ndef get_nginx_pid(self):\n        \"\"\"\n        Returns the Nginx PID for the project\n\n        \"\"\"\n        return open(self._nginx_pid).read()\n\ndef get_nginx_user(self):\n        \"\"\"\n        Returns the Nginx user for the project\n\n        \"\"\"\n        return open(self._nginx_user).read()\n\ndef get_nginx_port(self):\n        \"\"\"\n        Returns the Nginx port for the project\n\n        \"\"\"\n        return open(self._nginx_port).read()\n\ndef get_nginx_server_name(self):\n        \"\"\"\n        Returns the Nginx server name for the project\n\n        \"\"\"\n        return open(self._nginx_server_name).read()\n\ndef get_nginx_log_dir(self):\n        \"\"\"\n        Returns the",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef underscore(value):\n    \"\"\"Underscoreizes the passed value.\"\"\"\n    value = value.strip()\n    value = re.sub(r'([A-Z])', r'_\\1', value)\n    value = re.sub(r'[-_\\s]+', r'_', value)\n    value = re.sub(r'^_', r'', value)\n    value = value.lower()\n    return value\n\ndef camelcase(value):\n    \"\"\"Camelizes the passed value.\"\"\"\n    value = value.strip()\n    value = re.sub(r'([a-z])', r'\\1', value)\n    value = re.sub(r'[-_\\s]+', r'', value)\n    value = re.sub(r'^_', r'', value)\n    value = value.lower()\n    return value\n\ndef camelcase_underscore(value):\n    \"\"\"Camelizes the passed value.\"\"\"\n    value = value.strip()\n    value = re.sub(r'([A-Z])', r'\\1_\\2', value)\n    value = re.sub(r'[-_\\s]+', r'', value)\n    value = re.sub(r'^_', r'', value)\n    value = value.lower()\n    return value\n\ndef camelcase",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef parse_path(cls, path):\n        \"\"\"Parses out parameters and separates them out of the path.\n\n        This uses one of the many defined patterns on the options class. But,\n        it defaults to a no-op if there are no defined patterns.\n        \"\"\"\n        # Iterate through the available patterns.\n        for resource, pattern in cls.meta.patterns:\n            # Attempt to match the path.\n            match = re.match(pattern, path)\n            if match is not None:\n                # Found something.\n                return resource, match.groupdict(), match.string[match.end():]\n\n        # No patterns at all; return unsuccessful.\n        return None if not cls.meta.patterns else False\n\ndef parse_path_with_defaults(cls, path):\n        \"\"\"Parses out parameters and separates them out of the path.\n\n        This uses one of the many defined patterns on the options class. But,\n        it defaults to a no-op if there are no defined patterns.\n        \"\"\"\n        # Iterate through the available patterns.\n        for resource, pattern in cls.meta.patterns:\n            # Attempt to match the path.\n            match = re.match(pattern, path)\n            if match is not None:\n                # Found something.\n                return resource, match.groupdict(), match",
        ", data\n\n\nclass Pattern(object):\n    \"\"\"A pattern is a class that defines a set of methods that can be used to\n    traverse through a path.\n\n    This class is used to define the methods that can be used to traverse\n    through a path.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.args = args\n        self.kwargs = kwargs\n\n    def parse(self, path):\n        \"\"\"Parses a path and returns a tuple of (resource, data, rest).\n\n        This method is used to parse a path and return a tuple of (resource, data, rest).\n        \"\"\"\n        raise NotImplementedError\n\n    def traverse(self, request, params=None):\n        \"\"\"Traverses through the path and determines the accessed resource.\n\n        This method is used to traverse through the path and return a tuple of\n        (resource, data, rest).\n        \"\"\"\n        raise NotImplementedError\n\n\nclass Resource(object):\n    \"\"\"A resource is a class that defines a set of methods that can be used to\n    traverse through a path.\n\n    This class is used to define the methods that can be used to traverse\n    through a path.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.args = args\n        self.kwargs = kwargs",
        "\n\n\nclass Response(object):\n    \"\"\"\n    A class that encapsulates the response object for the view handler.\n    \"\"\"\n    def __init__(self, status_code=200, headers=None, body=None):\n        \"\"\"\n        Create a new Response object.\n\n        :param status_code: The HTTP status code to use for the response.\n        :param headers: A dictionary of headers to use for the response.\n        :param body: The response body.\n        \"\"\"\n        self.status_code = status_code\n        self.headers = headers\n        self.body = body\n\n    def send(self, data):\n        \"\"\"\n        Send the given data to the client.\n\n        :param data: The data to send.\n        \"\"\"\n        self.body = data\n        self.status_code = 200\n\n    def close(self):\n        \"\"\"\n        Close the response.\n        \"\"\"\n        self.status_code = 204\n\n    def as_json(self):\n        \"\"\"\n        Return a JSON representation of the response.\n        \"\"\"\n        return {'status_code': self.status_code,\n                'headers': self.headers,\n                'body': self.body}\n\n    def as_text(self):\n        \"\"\"\n        Return a text representation of the response",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n        # Authentication protocol determined the user is indeed\n        # authenticated (or not); Store the user for later reference.\n        request.user = user\n\n\nclass AuthenticationMiddleware(object):\n    \"\"\"\n    Middleware that requires authentication.\n    \"\"\"\n\n    def __init__(self, meta, app):\n        self.meta = meta\n        self.app = app\n\n    def process_request(self, request):\n        require_authentication(self, request)\n        return self.app(request)\n\n\nclass AuthenticationMiddlewareFactory(object):\n    \"\"\"\n    Factory for creating AuthenticationMiddleware instances.\n    \"\"\"\n\n    def __init__(self, meta, app):\n        self.meta = meta\n        self.app = app\n\n    def __call__(self, request):\n        require_authentication(self, request)\n        return AuthenticationMiddleware(self.meta, self.app(request))\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef require_http_method(cls, request):\n        \"\"\"Ensure that we're allowed to use this HTTP method.\"\"\"\n        allowed = cls.meta.http_allowed_methods\n        if request.method not in allowed:\n            # The specified method is not allowed for the resource\n            # identified by the request URI.\n            # RFC 2616 \u00a7 10.4.6 \u2014 405 Method Not Allowed\n            raise http.exceptions.MethodNotAllowed(allowed)\n\ndef require_http_accept(cls, request):\n        \"\"\"Ensure that we're allowed to use this HTTP accept.\"\"\"\n        allowed = cls.meta.http_accepts\n        if request.accept not in allowed:\n            # The specified accept is not allowed for the resource\n            # identified by the request URI.\n            # RFC 2616 \u00a7 10.4.6 \u2014 405 Method Not Allowed\n            raise http.exceptions.MethodNotAllowed(allowed)\n\ndef require_http_accept_charset(cls, request):\n        \"\"\"Ensure that we're allowed to use this HTTP accept charset.\"\"\"\n        allowed = cls.meta.http_accept_charset\n        if request.accept_charset not in allowed:\n            # The specified accept charset is not allowed for the resource\n            # identified by the request URI.\n            # RFC 2616 \u00a7 10.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ".code\n        return\n\n\ndef get_options(self, request, response):\n        \"\"\"Process an `OPTIONS` request.\n\n        Used to initiate a cross-origin request. All handling specific to\n        CORS requests is done on every request however this method also\n        returns a list of available methods.\n        \"\"\"\n        # Gather a list available HTTP/1.1 methods for this URI.\n        response['Allowed'] = ', '.join(self.meta.http_allowed_methods)\n\n        # All CORS handling is done for every HTTP/1.1 method.\n        # No more handling is neccesary; set the response to 200 and return.\n        response.status = http.client.OK.code\n        return\n\n\ndef post_options(self, request, response):\n        \"\"\"Process an `OPTIONS` request.\n\n        Used to initiate a cross-origin request. All handling specific to\n        CORS requests is done on every request however this method also\n        returns a list of available methods.\n        \"\"\"\n        # Gather a list available HTTP/1.1 methods for this URI.\n        response['Allowed'] = ', '.join(self.meta.http_allowed_methods)\n\n        # All CORS handling is done for every HTTP/1.1 method.\n        # No more handling is neccesary; set the response to",
        "\n",
        "\n        return values\n\ndef render_to_json(self):\n        \"\"\"Render to JSON.\n        \"\"\"\n        return json.dumps(self)\n\ndef render_to_file(self):\n        \"\"\"Render to file.\n        \"\"\"\n        return open(self, 'w').write(render_to_string())\n\ndef render_to_file_with_header(self, header):\n        \"\"\"Render to file with header.\n        \"\"\"\n        return open(self, 'w').write(render_to_string(), header)\n\ndef render_to_file_with_header_and_content(self, header, content):\n        \"\"\"Render to file with header and content.\n        \"\"\"\n        return open(self, 'w').write(render_to_string(), header, content)\n\ndef render_to_file_with_content(self, content):\n        \"\"\"Render to file with content.\n        \"\"\"\n        return open(self, 'w').write(content)\n\ndef render_to_file_with_content_and_header(self, content, header):\n        \"\"\"Render to file with content and header.\n        \"\"\"\n        return open(self, 'w').write(content, header)\n\ndef render_to_file_with_content_and_header_and_content(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "\n\ndef _get_effect_statement_with_conditions(self, effect, methods):\n        \"\"\"\n        This function loops over an array of objects containing\n        a resourceArn and conditions statement and generates\n        the array of statements for the policy.\n        \"\"\"\n        statements = []\n\n        if len(methods) > 0:\n            statement = self._get_empty_statement(effect)\n\n            for method in methods:\n                if (method['conditions'] is None or\n                        len(method['conditions']) == 0):\n                    statement['Resource'].append(method['resource_arn'])\n                else:\n                    cond_statement = self._get_empty_statement(effect)\n                    cond_statement['Resource'].append(method['resource_arn'])\n                    cond_statement['Condition'] = method['conditions']\n                    statements.append(cond_statement)\n            statements.append(statement)\n\n        return statements\n\ndef _get_effect_statement_with_conditions_and_resource_arns(self, effect, methods):\n        \"\"\"\n        This function loops over an array of objects containing\n        a resourceArn and conditions statement and generates\n        the array of statements for the policy.\n        \"\"\"\n        statements = []\n\n        if len(methods) > 0:\n            statement = self._get_empty_statement(effect)\n\n",
        "\n\ndef validate(self, data):\n        \"\"\"AWS doesn't quite have Swagger 2.0 validation right and will fail\n        on some refs. So, we need to convert to deref before\n        upload.\"\"\"\n\n        # We have to make a deepcopy here to create a proper JSON\n        # compatible object, otherwise `json.dumps` fails when it\n        # hits jsonref.JsonRef objects.\n        deref = copy.copy(jsonref.JsonRef.replace_refs(data))\n\n        # Write out JSON version because we might want this.\n        self.write_template(deref, filename='swagger.json')\n\n        return deref\n\ndef validate_schema(self, data):\n        \"\"\"AWS doesn't quite have Swagger 2.0 validation right and will fail\n        on some refs. So, we need to convert to deref before\n        upload.\"\"\"\n\n        # We have to make a deepcopy here to create a proper JSON\n        # compatible object, otherwise `json.dumps` fails when it\n        # hits jsonref.JsonRef objects.\n        deref = copy.copy(jsonref.JsonRef.replace_refs(data))\n\n        # Write out JSON version because we might want this.\n        self.write_template(deref, filename='swagger.json')\n\n        return deref\n\ndef",
        "\n\n\ndef check_requirements(requirements):\n    \"\"\"Check all necessary system requirements to exist.\n\n    :param requirements:\n        Sequence of requirements to check by running\n        ``where <requirement>`` on Windows and ``which ...`` elsewhere.\n    \"\"\"\n    requirements = set(requirements or [])\n    requirements.add('virtualenv')\n\n    for requirement in requirements:\n        if not which(requirement):\n            print_error('Requirement {0!r} is not found in system'.\n                        format(requirement))\n            return False\n\n    return True\n\n\ndef check_python_version(python_version):\n    \"\"\"Check that the python version is valid.\n\n    :param python_version:\n        Python version to check.\n    \"\"\"\n    if not which('python'):\n        print_error('Python is not found in system')\n        return False\n\n    if not which('python'):\n        print_error('Python is not found in system')\n        return False\n\n    if not which('python'):\n        print_error('Python is not found in system')\n        return False\n\n    if not which('python'):\n        print_error('Python is not found in system')\n        return False\n\n    if not which('python'):\n        print_error('Python is not found in system')",
        "\n\ndef get_config(args):\n    \"\"\"Get config from arguments.\n\n    :param args: Arguments list.\n    \"\"\"\n    config = {}\n\n    for arg in args:\n        key, value = arg.split('=', 1)\n        config[key.strip()] = smart_str(value)\n\n    return config\n\n\ndef get_config_from_file(filename):\n    \"\"\"Get config from file.\n\n    :param filename: File path.\n    \"\"\"\n    with open(filename, 'r') as f:\n        config = get_config(f.read())\n\n    return config\n\n\ndef get_config_from_env(env_name):\n    \"\"\"Get config from environment.\n\n    :param env_name: Environment name.\n    \"\"\"\n    config = get_config(get_config_from_file(env_name))\n\n    return config\n\n\ndef get_config_from_env_file(env_name):\n    \"\"\"Get config from environment file.\n\n    :param env_name: Environment name.\n    \"\"\"\n    config = get_config_from_file(env_name)\n\n    return config\n\n\ndef get_config_from_env_dict(env_dict):\n    \"\"\"Get config from environment dict.\n\n",
        "\n\n\ndef activate_env(env, quiet=False):\n    \"\"\"Activate virtual environment.\n\n    :param env: Virtual environment name.\n    :param quiet: Do not output messages into terminal. By default: False\n    \"\"\"\n    cmd = ('virtualenv', ) + (env, )\n\n    if not quiet:\n        print_message('== Step 2. Activate virtual environment ==')\n\n    if run_cmd(cmd, echo=not quiet):\n        print_message('Virtual environment {0!r} activated, done...'.format(env))\n\n\ndef deactivate_env(env, quiet=False):\n    \"\"\"Deactivate virtual environment.\n\n    :param env: Virtual environment name.\n    :param quiet: Do not output messages into terminal. By default: False\n    \"\"\"\n    cmd = ('virtualenv', ) + (env, )\n\n    if not quiet:\n        print_message('== Step 3. Deactivate virtual environment ==')\n\n    if run_cmd(cmd, echo=not quiet):\n        print_message('Virtual environment {0!r} deactivated, done...'.format(env))\n\n\ndef list_envs(quiet=False):\n    \"\"\"List virtual environments.\n\n    :param quiet: Do not output messages into terminal. By default: False\n    \"\"\"\n    cmd = ('virtual",
        "\n\ndef save_traceback(err):\n    \"\"\"Save traceback to log file.\"\"\"\n    if not os.environ.get('DEBUG'):\n        return True\n    with open(LOG_FILE, 'a') as f:\n        f.write(traceback.format_exc())\n    return False\n\ndef get_config():\n    \"\"\"Get config from environment.\"\"\"\n    return os.environ.get('CONFIG')\n\ndef get_config_file():\n    \"\"\"Get config file from environment.\"\"\"\n    return os.environ.get('CONFIG_FILE')\n\ndef get_config_file_path():\n    \"\"\"Get config file path from environment.\"\"\"\n    return os.environ.get('CONFIG_FILE_PATH')\n\ndef get_config_file_path_with_prefix():\n    \"\"\"Get config file path with prefix from environment.\"\"\"\n    return os.environ.get('CONFIG_FILE_PATH_WITH_PREFIX')\n\ndef get_config_file_path_with_suffix():\n    \"\"\"Get config file path with suffix from environment.\"\"\"\n    return os.environ.get('CONFIG_FILE_PATH_WITH_SUFFIX')\n\ndef get_config_file_path_with_prefix_and_suffix():\n    \"\"\"Get config file path with prefix and suffix from environment.\"\"\"\n    return os.environ.get('CONFIG_FILE_PATH_",
        "\n\ndef uninstall(env, requirements, args, quiet=False):\n    \"\"\"Uninstall library or project from virtual environment.\n\n    :param env: Use given virtual environment name.\n    :param requirements: Use given requirements file for pip.\n    :param args: Pass given arguments to pip script.\n    :param quiet: Do not output message to terminal. By default: False\n    \"\"\"\n    if not quiet:\n        print_message('== Step 3. Uninstall {0} =='.format(requirements))\n\n    result = not pip_cmd(env,\n                         ('uninstall', ) + args,\n                         quiet,\n                         echo=not quiet)\n\n    if not quiet:\n        print_message()\n\n    return result\n\ndef pip_cmd(env, cmd, quiet=False, echo=False):\n    \"\"\"Run pip command.\n\n    :param env: Use given virtual environment name.\n    :param cmd: Use given pip command.\n    :param quiet: Do not output message to terminal. By default: False\n    :param echo: Do not output message to terminal. By default: False\n    \"\"\"\n    if not quiet:\n        print_message('== Step 4. {0} =='.format(cmd))\n\n    result = not pip_cmd_with_output(env, cmd, quiet, echo)\n\n   ",
        "\n\ndef iteritems_with_index(data, **kwargs):\n    \"\"\"Iterate over dict items.\"\"\"\n    return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems(**kwargs)\n\ndef iteritems_with_index_with_index(data, **kwargs):\n    \"\"\"Iterate over dict items.\"\"\"\n    return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems(**kwargs)\n\ndef iteritems_with_index_with_index_with_index(data, **kwargs):\n    \"\"\"Iterate over dict items.\"\"\"\n    return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems(**kwargs)\n\ndef iteritems_with_index_with_index_with_index(data, **kwargs):\n    \"\"\"Iterate over dict items.\"\"\"\n    return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems(**kwargs)\n\ndef iteritems_with_index_with_index_with_index_with_index(data, **kwargs):\n    \"\"\"Iterate over dict items.\"\"\"\n    return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems(**kwargs)\n\ndef iteritems_with_index_with_index_with_index_with_index(data, **kwargs):\n",
        "\n\ndef itervalues(data, **kwargs):\n    \"\"\"Iterate over dict values.\"\"\"\n    return iter(data.values(**kwargs)) if IS_PY3 else data.itervalues(**kwargs)\n\ndef iteritems(data, **kwargs):\n    \"\"\"Iterate over dict items.\"\"\"\n    return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems(**kwargs)\n\ndef iteritems_with_index(data, **kwargs):\n    \"\"\"Iterate over dict items with index.\"\"\"\n    return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems_with_index(**kwargs)\n\ndef iteritems_with_index_with_index(data, **kwargs):\n    \"\"\"Iterate over dict items with index and index.\"\"\"\n    return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems_with_index_with_index(**kwargs)\n\ndef iteritems_with_index_with_index_with_index(data, **kwargs):\n    \"\"\"Iterate over dict items with index and index and index.\"\"\"\n    return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems_with_index_with_index_with_index(**kwargs)\n\ndef iteritems_with_index_with_index_with_index(data,",
        "\n\n\nif __name__ == '__main__':\n    main()\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        " None\n\n\ndef write_config(filename, config):\n    \"\"\"\n    Write config to given filename.\n\n    :param filename: Write config to given filename.\n    :param config: Config to write.\n    \"\"\"\n    # Initial vars\n    with open(filename, 'w') as f:\n        f.write(json.dumps(config, indent=2))\n\n\ndef safe_path(path):\n    \"\"\"\n    Safe path to a file.\n\n    :param path: Path to a file.\n    :return: Safe path to a file.\n    \"\"\"\n    return os.path.abspath(path)\n\n\ndef print_error(msg):\n    \"\"\"\n    Print error message to stderr.\n\n    :param msg: Error message.\n    \"\"\"\n    print('\\n'.join(msg.splitlines()))\n\n\ndef iteritems(dict):\n    \"\"\"\n    Iterate over a dictionary.\n\n    :param dict: Dictionary to iterate over.\n    :return: Iterator of items.\n    \"\"\"\n    for key, value in dict.items():\n        yield key, value\n\n\ndef default_config():\n    \"\"\"\n    Default config file.\n\n    :return: Default config file.\n    \"\"\"\n    return os.path.join(os.path.dirname(__file",
        "\n\n\ndef get_temp_streams():\n    r\"\"\"Return temporary streams for use in ``subprocess.call`` function.\n\n    :return:\n        A tuple of ``(out, err)`` streams.\n    :rtype: tuple\n    \"\"\"\n    return (sys.stdout, sys.stderr)\n\n\ndef print_message(msg):\n    r\"\"\"Print message to stdout.\n\n    :param msg: Message to print.\n    :type msg: str\n    \"\"\"\n    sys.stdout.write(msg + '\\n')\n\n\ndef print_error(msg):\n    r\"\"\"Print error to stderr.\n\n    :param msg: Message to print.\n    :type msg: str\n    \"\"\"\n    sys.stderr.write(msg + '\\n')\n\n\ndef print_info(msg):\n    r\"\"\"Print info to stdout.\n\n    :param msg: Message to print.\n    :type msg: str\n    \"\"\"\n    sys.stdout.write(msg + '\\n')\n\n\ndef print_success(msg):\n    r\"\"\"Print success to stdout.\n\n    :param msg: Message to print.\n    :type msg: str\n    \"\"\"\n    sys.stdout.write(msg + '\\n')\n\n\ndef print_warning(msg):\n    r\"\"\"Print warning to",
        "\n\ndef prepare_args(hook, config):\n    \"\"\"Prepare arguments for post-bootstrap hook.\n\n    :param hook: Hook to run.\n    :param config: Configuration dict.\n    :return: Arguments to run.\n    \"\"\"\n    args = ['--hook', hook]\n    args.extend(config.get('args', []))\n    args.extend(hook.get('args', []))\n    return args\n\ndef print_message():\n    \"\"\"Print message to STDOUT/STDERR.\n\n    :return: None\n    \"\"\"\n    print('== Step 4. Print message ==')\n\n    print('\\n'.join(sys.stdout.readlines()))\n    print('\\n'.join(sys.stderr.readlines()))\n\ndef run_cmd(cmd, echo=False, fail_silently=True, shell=True):\n    \"\"\"Run command.\n\n    :param cmd: Command to run.\n    :param echo: Do not output messages to STDOUT/STDERR. By default: False\n    :param fail_silently: Do not fail silently if command fails. By default: True\n    :param shell: Do not run command in shell mode. By default: True\n    :return: True if command succeeded, False otherwise.\n    \"\"\"\n    try:\n        return not run_cmd_",
        "\n\n\ndef print_error(message, color=True):\n    \"\"\"Print error message to bootstrapper log file.\n\n    :param message: Error message.\n    :param color: If True, colorize message.\n    \"\"\"\n    print('{0} {1}'.format(message, color))\n\n\ndef safe_path(path):\n    \"\"\"Safe path to bootstrapper directory.\n\n    :param path: Path to bootstrapper directory.\n    \"\"\"\n    return os.path.expanduser(os.path.join('~', path))\n",
        "\n\ndef smart_unicode(value, encoding='utf-8', errors='strict'):\n    \"\"\"Convert Python object to unicode.\n\n    :param value: Python object to convert.\n    :param encoding: Encoding to use if in Python 2 given object is unicode.\n    :param errors: Errors mode to use if in Python 2 given object is unicode.\n    \"\"\"\n    if not IS_PY3 and isinstance(value, unicode):  # noqa\n        return value.encode(encoding, errors)\n    return unicode(value)\n\ndef smart_unicode_str(value, encoding='utf-8', errors='strict'):\n    \"\"\"Convert Python object to unicode string.\n\n    :param value: Python object to convert.\n    :param encoding: Encoding to use if in Python 2 given object is unicode.\n    :param errors: Errors mode to use if in Python 2 given object is unicode.\n    \"\"\"\n    if not IS_PY3 and isinstance(value, unicode):  # noqa\n        return value.encode(encoding, errors)\n    return str(value)\n\ndef smart_unicode_str_with_errors(value, encoding='utf-8', errors='strict'):\n    \"\"\"Convert Python object to unicode string with errors.\n\n    :param value: Python object to convert.\n    :param encoding: Encoding to use if in Python",
        "\n\ndef copy_w_minus(src, dst):\n    \"\"\"Copy file from `src` path to `dst` path. If `dst` already exists, will add '-' characters\n    to the end of the basename without extension.\n\n    Parameters\n    ----------\n    src: str\n\n    dst: str\n\n    Returns\n    -------\n    dstpath: str\n    \"\"\"\n    dst_ext = get_extension(dst)\n    dst_pre = remove_ext   (dst)\n\n    while op.exists(dst_pre + dst_ext):\n        dst_pre += '-'\n\n    shutil.copy(src, dst_pre + dst_ext)\n\n    return dst_pre + dst_ext\n\ndef copy_w_dot(src, dst):\n    \"\"\"Copy file from `src` path to `dst` path. If `dst` already exists, will add '.' characters\n    to the end of the basename without extension.\n\n    Parameters\n    ----------\n    src: str\n\n    dst: str\n\n    Returns\n    -------\n    dstpath: str\n    \"\"\"\n    dst_ext = get_extension(dst)\n    dst_pre = remove_ext   (dst)\n\n    while op.exists(dst_pre + dst_ext):\n        dst_pre += '.'\n\n    shutil.",
        "\n\ndef get_folder_path(folderpath):\n    \"\"\"Returns the folder path of folderpath.\n    If the path does not exist, will raise IOError.\n    \"\"\"\n    if not op.exists(folderpath):\n        raise FolderNotFound(folderpath)\n\n    return op.join(folderpath, 'data')\n\ndef get_folder_path_with_extension(folderpath, extension):\n    \"\"\"Returns the folder path of folderpath with extension.\n    If the path does not exist, will raise IOError.\n    \"\"\"\n    if not op.exists(folderpath):\n        raise FolderNotFound(folderpath)\n\n    return op.join(folderpath, extension)\n\ndef get_folder_path_with_extension_and_name(folderpath, extension, name):\n    \"\"\"Returns the folder path of folderpath with extension and name.\n    If the path does not exist, will raise IOError.\n    \"\"\"\n    if not op.exists(folderpath):\n        raise FolderNotFound(folderpath)\n\n    return op.join(folderpath, extension, name)\n\ndef get_folder_path_with_extension_and_name_and_extension(folderpath, extension, name, extension):\n    \"\"\"Returns the folder path of folderpath with extension and name and extension.\n    If the path does not exist,",
        "\n\nALLOWED_EXTS = {\n    '.nii': ['.nii', '.nii.gz', '.nii.gz.gz', '.nii.gz.gz.gz', '.nii.gz.gz.gz.gz', '.nii.gz.gz.gz.gz.gz',\n             '.nii.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.",
        "\n\n\ndef remove_extension_if_needed(filepath, ext, check_if_exists=False):\n    \"\"\"Remove the extension ext from fpath if it doesn't have it.\n\n    Parameters\n    ----------\n    filepath: str\n    File name or path\n\n    ext: str\n    File extension\n\n    check_if_exists: bool\n\n    Returns\n    -------\n    File name or path with extension removed, if needed.\n    \"\"\"\n    if not filepath.endswith(ext):\n        filepath += ext\n\n    if check_if_exists:\n        if not op.exists(filepath):\n            raise IOError('File not found: ' + filepath)\n\n    return filepath\n\n\ndef get_extension_from_path(filepath):\n    \"\"\"Get the extension from the filepath.\n\n    Parameters\n    ----------\n    filepath: str\n    File name or path\n\n    Returns\n    -------\n    str\n    File extension\n    \"\"\"\n    return filepath.rsplit('.', 1)[1]\n\n\ndef get_extension_from_name(name):\n    \"\"\"Get the extension from the name.\n\n    Parameters\n    ----------\n    name: str\n    File name\n\n    Returns\n    -------\n    str\n    File extension\n    \"\"\"\n    return name.rsplit('.', 1)[1]",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef ux_file_get_contents(filepath):\n    \"\"\"Returns the contents of the file using the 'r' GNU command\n\n    Parameters\n    ----------\n    filepath: str\n\n    Returns\n    -------\n    str\n    \"\"\"\n    p = subprocess.Popen(['r', '-l', filepath], stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE)\n    result, err = p.communicate()\n\n    if p.returncode != 0:\n        raise IOError(err)\n\n    return result.strip()\n\ndef ux_file_get_contents_with_encoding(filepath, encoding):\n    \"\"\"Returns the contents of the file using the 'r' GNU command\n\n    Parameters\n    ----------\n    filepath: str\n    encoding: str\n\n    Returns\n    -------\n    str\n    \"\"\"\n    p = subprocess.Popen(['r', '-l', filepath], stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE, encoding=encoding)\n    result, err = p.communicate()\n\n    if p.returncode != 0:\n        raise IOError(err)\n\n    return result.strip()\n\ndef ux_file_get_contents_with_encoding_with_encoding(filepath, encoding,\n                                                   encoding",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\ndef rcfile(app_name, section_name=None):\n    \"\"\"Return a dictionary of rcfile settings.\n\n    Parameters\n    ----------\n    app_name: str\n        Name of the application to look for rcfile configuration files.\n\n    section_name: str\n        Name of a section in the app_name rcfile to look exclusively there for\n        variable names.\n\n    Returns\n    -------\n    settings: dict\n        A dictionary of rcfile settings.\n\n    Raises\n    ------\n    IOError if the proposed settings do not exist.\n    \"\"\"\n    settings = {}\n    try:\n        settings = rcfile(app_name, section_name)\n    except:\n        raise\n\n    return settings\n\n\ndef rcfile_settings(app_name, section_name=None):\n    \"\"\"Return a dictionary of rcfile settings.\n\n    Parameters\n    ----------\n    app_name: str\n        Name of the application to look for rcfile configuration files.\n\n    section_name: str\n        Name of a section in the app_name rcfile to look exclusively there for\n        variable names.\n\n    Returns\n    -------\n    settings: dict\n        A dictionary of rcfile settings.\n\n    Raises\n    ------\n    IOError if the proposed settings do not exist.\n   ",
        " dict(args=args, strip_dashes=strip_dashes)\n\n\ndef get_environment(appname, section=None, config=None, path=None):\n    \"\"\"Read environment variables and config files and return them merged with\n    predefined list of arguments.\n\n    Parameters\n    ----------\n    appname: str\n        Application name, used for config files and environment variable\n        names.\n\n    section: str\n        Name of the section to be read. If this is not set: appname.\n\n    config:\n        config file found in 'path' folder variable in args,\n        config file provided by 'config' variable in args.\n\n    path: str\n        path of config file found in 'path' folder variable in args,\n        config file provided by 'config' variable in args.\n\n    Returns\n    --------\n    dict\n        containing the merged variables of environment variables, config\n        files and args.\n\n    Raises\n    ------\n    IOError\n        In case the return value is empty.\n\n    Notes\n    -----\n    Environment variables are read if they start with appname in uppercase\n    with underscore, for example:\n\n        TEST_VAR=1\n\n    Config files compatible with ConfigParser are read and the section name\n    appname is read, example:\n\n        [appname]\n        var=1\n\n   ",
        "\n\ndef rcfile(app_name, section_name):\n    \"\"\" Return the dictionary containing the rcfile section configuration\n    variables.\n\n    Parameters\n    ----------\n    section_name: str\n        Name of the section in the rcfiles.\n\n    app_name: str\n        Name of the application to look for its rcfiles.\n\n    Returns\n    -------\n    settings: dict\n        Dict with variable values\n    \"\"\"\n    try:\n        settings = os.environ['RCFILE_SETTINGS']\n    except KeyError:\n        raise KeyError('No rcfile settings found in {} rcfiles.'.format(app_name))\n    else:\n        return settings.get(section_name, {})\n\ndef get_rcfile_section_value(app_name, section_name, key):\n    \"\"\" Return the value of the rcfile section configuration variable\n    with the given key.\n\n    Parameters\n    ----------\n    section_name: str\n        Name of the section in the rcfiles.\n\n    app_name: str\n        Name of the application to look for its rcfiles.\n\n    key: str\n        Name of the variable to look for.\n\n    Returns\n    -------\n    value: str\n        Value of the variable.\n    \"\"\"\n    try:\n        settings = os.environ['RCFILE_",
        "\n\ndef get_rcfile_section(app_name, section_name=None):\n    \"\"\" Return the section of the app_name rc file.\n\n    Parameters\n    ----------\n    app_name: str\n        Name of the application to look for its rcfiles.\n\n    section_name: str\n        Name of the section in the rcfiles.\n\n    Returns\n    -------\n    cfg: dict\n        The section of the app_name rc file.\n    \"\"\"\n    if section_name is None:\n        section_name = app_name\n\n    rcfile = get_rcfile_path(app_name)\n    if not rcfile:\n        raise KeyError('Application {} not found in rcfile.'.format(app_name))\n\n    return get_rcfile_section_dict(rcfile, section_name)\n\ndef get_rcfile_section_dict(rcfile, section_name):\n    \"\"\" Return the section of the app_name rc file.\n\n    Parameters\n    ----------\n    rcfile: str\n        Path to the rcfile.\n\n    section_name: str\n        Name of the section in the rcfiles.\n\n    Returns\n    -------\n    cfg: dict\n        The section of the app_name rc file.\n    \"\"\"\n    cfg = {}\n\n    for section",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef match_list(lst, pattern):\n    \"\"\"\n    Matches the lst using pattern.\n    If pattern starts with '(' it will be considered a re regular expression,\n    otherwise it will use fnmatch filter.\n\n    :param lst: list of strings\n\n    :param pattern: string\n\n    :return: list of strings\n    Filtered list of strings\n    \"\"\"\n    if is_fnmatch_regex(pattern) and not is_regex(pattern):\n        #use fnmatch\n        log.info('Using fnmatch for {0}'.format(pattern))\n        filst = fnmatch.filter(lst, pattern)\n\n    else:\n        #use re\n        log.info('Using regex match for {0}'.format(pattern))\n        filst = re.findall(pattern, lst)\n\n    if filst:\n        filst.sort()\n\n    return filst\n\ndef is_fnmatch_regex(pattern):\n    \"\"\"\n    Checks if pattern is a fnmatch regex.\n\n    :param pattern: string\n\n    :return: bool\n    \"\"\"\n    return pattern.startswith('(')\n\ndef is_regex(pattern):\n    \"\"\"\n    Checks if pattern is a regex.\n\n    :param pattern: string\n\n    :return: bool\n    \"\"\"\n    return pattern.starts",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n    return result\n\n\ndef get_dict_leaves_recursive(data):\n    \"\"\"\n    Given a nested dictionary, this returns all its leave elements in a list.\n\n    :param adict:\n\n    :return: list\n    \"\"\"\n    result = []\n    if isinstance(data, dict):\n        for item in data.values():\n            result.extend(get_dict_leaves_recursive(item))\n    elif isinstance(data, list):\n        result.extend(data)\n    else:\n        result.append(data)\n\n    return result\n\n\ndef get_dict_leaves_recursive_recursive(data):\n    \"\"\"\n    Given a nested dictionary, this returns all its leave elements in a list.\n\n    :param adict:\n\n    :return: list\n    \"\"\"\n    result = []\n    if isinstance(data, dict):\n        for item in data.values():\n            result.extend(get_dict_leaves_recursive_recursive(item))\n    elif isinstance(data, list):\n        result.extend(data)\n    else:\n        result.append(data)\n\n    return result\n\n\ndef get_dict_leaves_recursive_recursive_recursive(data):\n    \"\"\"\n    Given a nested dictionary, this returns all its leave elements in a",
        " subfolder, it is appended to the list\n\n    :param base_path: str\n\n    :param path_regex: str\n\n    :return list of strings\n    \"\"\"\n    if not path_regex:\n        return []\n\n    if len(path_regex) < 1:\n        return []\n\n    if path_regex[0] == os.sep:\n        path_regex = path_regex[1:]\n\n    rest_files = ''\n    if os.sep in path_regex:\n        #split by os.sep\n        node_names = path_regex.partition(os.sep)\n        first_node = node_names[0]\n        rest_nodes = node_names[2]\n\n        folder_names = filter_list(os.listdir(base_path), first_node)\n\n        for nom in folder_names:\n            new_base = op.join(base_path, nom)\n            if op.isdir(new_base):\n                rest_files = get_possible_paths(new_base, rest_nodes)\n    else:\n        rest_files = filter_list(os.listdir(base_path), path_regex)\n\n    files = []\n    if rest_files:\n        files = [op.join(base_path, f)",
        "\n\ndef create_file(filepath, overwrite=False):\n        \"\"\" Will create filepath file. If filepath already exists and overwrite is False,\n        will append a '+' suffix to filepath until filepath does not exist.\"\"\"\n        if not overwrite:\n            while op.exists(filepath):\n                filepath += '+'\n\n        with open(filepath, 'w') as f:\n            f.write('')\n\n        return filepath\n\ndef create_folder_with_file(dirpath, filepath, overwrite=False):\n        \"\"\" Will create dirpath folder with filepath. If dirpath already exists and overwrite is False,\n        will append a '+' suffix to dirpath until dirpath does not exist.\"\"\"\n        if not overwrite:\n            while op.exists(dirpath):\n                dirpath += '+'\n\n        with open(dirpath, 'w') as f:\n            f.write('')\n\n        return create_file(filepath, overwrite)\n\ndef create_file_with_folder(filepath, dirpath, overwrite=False):\n        \"\"\" Will create dirpath folder with filepath. If dirpath already exists and overwrite is False,\n        will append a '+' suffix to dirpath until dirpath does not exist.\"\"\"\n        if not overwrite:\n            while op.exists(dirpath):\n                dirpath += '+'\n\n        with open(dirpath, 'w') as f:\n            f.write('')\n\n       ",
        "\n\ndef import_pyfile(filepath):\n        \"\"\"\n        Imports a config file from the filepath.\n\n        :param filepath:\n        :return: config object\n        \"\"\"\n        cfg = {}\n\n        with open(filepath, 'r') as f:\n            for line in f:\n                key, value = line.strip().split('=', 1)\n                cfg[key] = value\n\n        return cfg\n\ndef import_data(filepath):\n        \"\"\"\n        Imports data from the filepath.\n\n        :param filepath:\n        :return: data object\n        \"\"\"\n        data = {}\n\n        with open(filepath, 'r') as f:\n            for line in f:\n                key, value = line.strip().split('=', 1)\n                data[key] = value\n\n        return data\n\ndef import_data_from_file(filepath):\n        \"\"\"\n        Imports data from the filepath.\n\n        :param filepath:\n        :return: data object\n        \"\"\"\n        data = {}\n\n        with open(filepath, 'r') as f:\n            for line in f:\n                key, value = line.strip().split('=', 1)\n                data[key] = value\n\n        return data\n\ndef import_data_from_file_with_",
        "\n\ndef filter_list(mylist, pattern):\n        \"\"\"\n        Filter the list by the pattern.\n        \"\"\"\n        return [x for x in mylist if x.lower() in pattern.lower()]\n\ndef filter_dict(mydict, pattern):\n        \"\"\"\n        Filter the dict by the pattern.\n        \"\"\"\n        return {x.lower(): x for x in mydict.values() if x.lower() in pattern.lower()}\n\ndef filter_list_dict(mylist, pattern):\n        \"\"\"\n        Filter the list by the pattern.\n        \"\"\"\n        return {x.lower(): x for x in mylist.values() if x.lower() in pattern.lower()}\n\ndef filter_dict_list(mydict, pattern):\n        \"\"\"\n        Filter the dict by the pattern.\n        \"\"\"\n        return {x.lower(): x for x in mydict.values() if x.lower() in pattern.lower()}\n\ndef filter_list_set(mylist, pattern):\n        \"\"\"\n        Filter the list by the pattern.\n        \"\"\"\n        return {x.lower(): x for x in mylist.values() if x.lower() in pattern.lower()}\n\ndef filter_dict_set(mydict, pattern):\n        \"\"\"\n        Filter the dict by the pattern.\n        \"\"\"",
        "\n\ndef filter_list(list, pattern):\n        \"\"\"\n        Filter the list by the pattern.\n\n        :param list:\n        :param pattern:\n        :return: list\n        \"\"\"\n        filtered = []\n        for item in list:\n                if item.lower() in pattern.lower():\n                        filtered.append(item)\n        return filtered\n\ndef get_node_name(self, node):\n        \"\"\"\n        Return the name of the node.\n\n        :param node:\n        :return: str\n        \"\"\"\n        return node.name\n\ndef get_node_type(self, node):\n        \"\"\"\n        Return the type of the node.\n\n        :param node:\n        :return: str\n        \"\"\"\n        return node.type\n\ndef get_node_value(self, node):\n        \"\"\"\n        Return the value of the node.\n\n        :param node:\n        :return: str\n        \"\"\"\n        return node.value\n\ndef get_node_children(self, node):\n        \"\"\"\n        Return the children of the node.\n\n        :param node:\n        :return: list\n        \"\"\"\n        return node.children\n\ndef get_node_parent(self, node):\n        \"\"\"\n        Return the parent of the node.\n\n        :param",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef check_consistent_length(*iterables):\n    \"\"\"Check consistent length of arrays.\n\n    Checks consistent length, passes through None, and ensures that everything\n    can be indexed by converting sparse matrices to csr and converting\n    non-interable objects to arrays.\n\n    Parameters\n    ----------\n    iterables : lists, dataframes, arrays, sparse matrices\n        List of objects to ensure sliceability.\n    \"\"\"\n    result = []\n    for X in iterables:\n        if sp.issparse(X):\n            result.append(X.tocsr())\n        elif hasattr(X, \"__getitem__\"): or hasattr(X, \"iloc\"):\n            result.append(np.array(X))\n        elif X is None:\n            result.append(X)\n        else:\n            result.append(np.array(X))\n    check_consistent_length(*result)\n    return result\n\ndef check_consistent_length_sparse(*iterables):\n    \"\"\"Check consistent length of sparse matrices.\n\n    Checks consistent length, passes through None, and ensures that everything\n    can be indexed by converting sparse matrices to csr and converting\n    non-interable objects to arrays.\n\n    Parameters\n    ----------\n    iterables : lists, dataframes, arrays, sparse matrices\n        List of objects to ensure sliceability.\n    \"\"\"\n",
        "\n\n\ndef _ensure_sparse_format(array, accept_sparse, dtype=None, order=None, copy=False,\n                          force_all_finite=True):\n    \"\"\"Ensure that the input is a sparse matrix or similar.\n\n    Parameters\n    ----------\n    array : object\n        Input object to check / convert.\n\n    accept_sparse : string, list of string or None (default=None)\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc.  None means that sparse matrix input will raise an error.\n        If the input is sparse but not in the allowed format, it will be\n        converted to the first listed format.\n\n    dtype : string, None (default=None)\n        The dtype of the input.\n\n    order : 'F', 'C' or None (default=None)\n        Whether an array will be forced to be fortran or c-style.\n\n    copy : boolean (default=False)\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n\n    force_all_finite : boolean (default=True)\n        Whether to raise an error on np.inf and np.nan in X.\n\n    Returns\n    -------\n    X_converted : object\n       ",
        "\n\n\ndef check_array(X, accept_sparse=None, dtype=None, order=None, copy=False,\n                force_all_finite=True, ensure_2d=True, allow_nd=False,\n                multi_output=False):\n    \"\"\"Input validation for standard estimators.\n\n    Checks X and y for consistent length, enforces X 2d and y 1d.\n    Standard input checks are only applied to y. For multi-label y,\n    set multi_ouput=True to allow 2d and sparse y.\n\n    Parameters\n    ----------\n    X : nd-array, list or sparse matrix\n        Input data.\n\n    y : nd-array, list or sparse matrix\n        Labels.\n\n    accept_sparse : string, list of string or None (default=None)\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc.  None means that sparse matrix input will raise an error.\n        If the input is sparse but not in the allowed format, it will be\n        converted to the first listed format, it will be converted to\n        the first listed format.\n\n    dtype : string, string or None (default=None)\n        Data type of the input data.\n\n    order : 'F', 'C' or None (",
        "\n\ndef column_vector(y, warn=False):\n    \"\"\" Ravel column or 1d numpy array, else raises an error\n\n    Parameters\n    ----------\n    y : array-like\n\n    Returns\n    -------\n    y : array\n\n    \"\"\"\n    return column_or_1d(y, warn)\n\ndef column_vector_or_1d(y, warn=False):\n    \"\"\" Ravel column or 1d numpy array, else raises an error\n\n    Parameters\n    ----------\n    y : array-like\n\n    Returns\n    -------\n    y : array\n\n    \"\"\"\n    return column_vector(y, warn)\n\ndef column_vector_or_1d_with_index(y, index, warn=False):\n    \"\"\" Ravel column or 1d numpy array, else raises an error\n\n    Parameters\n    ----------\n    y : array-like\n\n    Returns\n    -------\n    y : array\n\n    \"\"\"\n    return column_vector_or_1d(y, warn)\n\ndef column_vector_or_1d_with_index_or_1d(y, index, warn=False):\n    \"\"\" Ravel column or 1d numpy array, else raises an error\n\n    Parameters\n    ----------\n    y : array-like\n\n    Returns\n   ",
        "\n\n\ndef warn_if_not_int(X, estimator='This algorithm'):\n    \"\"\"Warning utility function to check that data type is integer.\n\n    Returns True if a warning was raised (i.e. the input is not integer) and\n    False otherwise, for easier input validation.\n    \"\"\"\n    if not isinstance(estimator, str):\n        estimator = estimator.__class__.__name__\n    if X.dtype.kind != 'i':\n        warnings.warn(\"%s assumes integer values as input, got %s\" % (estimator,\n                                                              X.dtype))\n        return True\n    return False\n\n\ndef warn_if_not_float_or_int(X, estimator='This algorithm'):\n    \"\"\"Warning utility function to check that data type is floating point or integer.\n\n    Returns True if a warning was raised (i.e. the input is not float or\n    integer) and False otherwise, for easier input validation.\n    \"\"\"\n    if not isinstance(estimator, str):\n        estimator = estimator.__class__.__name__\n    if X.dtype.kind != 'f' or X.dtype.kind != 'i':\n        warnings.warn(\"%s assumes floating point or integer values as input, \"\n                      \"got %s\" % (estimator, X.dtype))\n        return True",
        "\n\ndef _asarray(arr, dtype=None, order='K'):\n    \"\"\"Convert an arbitrary array to numpy.ndarray.\n\n    In the case of a memmap array, a copy is automatically made to break the\n    link with the underlying file (whatever the value of the \"copy\" keyword).\n\n    The purpose of this function is mainly to get rid of memmap objects, but\n    it can be used for other purposes. In particular, combining copying and\n    casting can lead to performance improvements in some cases, by avoiding\n    unnecessary copies.\n\n    If not specified, input array order is preserved, in all cases, even when\n    a copy is requested.\n\n    Caveat: this function does not copy during bool to/from 1-byte dtype\n    conversions. This can lead to some surprising results in some rare cases.\n    Example:\n\n        a = numpy.asarray([0, 1, 2], dtype=numpy.int8)\n        b = as_ndarray(a, dtype=bool)  # array([False, True, True], dtype=bool)\n        c = as_ndarray(b, dtype=bool)  # array([0, 1, 2], dtype=bool)\n\n    The usually expected result for the last line would be array([0, 1, 1])\n    because True",
        "\n    else:\n        invwarp_cmd   = invwarp_cmd + ' ' + invwarp_cmd\n        applywarp_cmd = applywarp_cmd + ' ' + applywarp_cmd\n\n    log.debug('Running {}'.format(applywarp_cmd))\n    check_call(applywarp_cmd)\n\n    log.debug('Running {}'.format(invwarp_cmd))\n    check_call(invwarp_cmd)\n\n    log.debug('Running {}'.format(fslsub_cmd))\n    check_call(fslsub_cmd)\n\n    log.debug('Running {}'.format(atlasinfunc_out_filepath))\n    check_call(atlasinfunc_out_filepath)\n\n    log.debug('Running {}'.format(atlasinanat_out_filepath))\n    check_call(atlasinanat_out_filepath)\n\n    log.debug('Running {}'.format(atlasinfunc_out_filepath))\n    check_call(atlasinfunc_out_filepath)\n\n    log.debug('Running {}'.format(atlasinfunc_out_filepath))\n    check_call(atlasinfunc_out_filepath)\n\n    log.debug('Running {}'.format(atlas",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef fwhm2sigma(fwhm):\n    \"\"\"Convert a FWHM value to a sigma value.\n\n    Parameters\n    ----------\n    fwhm: float or numpy.array\n       FWHM value\n\n    Returns\n    -------\n    sigma: float or numpy.array\n       sigma value corresponding to `fwhm` values\n    \"\"\"\n    fwhm = np.asarray(fwhm)\n    return np.sqrt(8 * np.log(2)) * fwhm\n\ndef fwhm2sigma_array(fwhm):\n    \"\"\"Convert a FWHM value to a sigma value array.\n\n    Parameters\n    ----------\n    fwhm: float or numpy.array\n       FWHM value\n\n    Returns\n    -------\n    sigma: numpy.array\n       sigma value corresponding to `fwhm` values\n    \"\"\"\n    fwhm = np.asarray(fwhm)\n    return np.sqrt(8 * np.log(2)) * fwhm\n\ndef sigma2fwhm_array(sigma):\n    \"\"\"Convert a sigma value or values to a FWHM value array.\n\n    Parameters\n    ----------\n    sigma: float or numpy.array\n       sigma value or values\n\n    Returns\n    -------\n    fwhm: numpy",
        "\n\ndef _smooth_image(arr, affine, fwhm, copy=True):\n    \"\"\"Smooth images with a a Gaussian filter.\n\n    Apply a Gaussian filter along the three first dimensions of arr.\n\n    Parameters\n    ----------\n    arr: numpy.ndarray\n        3D or 4D array, with image number as last dimension.\n\n    affine: numpy.ndarray\n        Image affine transformation matrix for image.\n\n    fwhm: scalar, numpy.ndarray\n        Smoothing kernel size, as Full-Width at Half Maximum (FWHM) in millimeters.\n        If a scalar is given, kernel width is identical on all three directions.\n        A numpy.ndarray must have 3 elements, giving the FWHM along each axis.\n\n    copy: bool\n        if True, will make a copy of the input array. Otherwise will directly smooth the input array.\n\n    Returns\n    -------\n    smooth_arr: numpy.ndarray\n    \"\"\"\n\n    if arr.dtype.kind == 'i':\n        if arr.dtype == np.int64:\n            arr = arr.astype(np.float64)\n        else:\n            arr = arr.astype(np.float32)\n    if copy:\n        arr = arr.copy()\n\n    # Zeroe possible NaNs and Inf in the",
        "\n\ndef _smooth_data_array(data, affine, fwhm=None, copy=False):\n    \"\"\"Smooth data using a Gaussian filter.\n\n    Apply a Gaussian filter along the three first dimensions of each image in data.\n    In all cases, non-finite values in input are zeroed.\n\n    Parameters\n    ----------\n    data: numpy.ndarray\n        Input data.\n\n    affine: numpy.ndarray\n        Affine transform.\n\n    fwhm: scalar or numpy.ndarray\n        Smoothing kernel size, as Full-Width at Half Maximum (FWHM) in millimeters.\n        If a scalar is given, kernel width is identical on all three directions.\n        A numpy.ndarray must have 3 elements, giving the FWHM along each axis.\n\n    Returns\n    -------\n    smooth_data: numpy.ndarray\n        Smooth data.\n    \"\"\"\n    if fwhm is None:\n        fwhm = affine.size\n\n    if copy:\n        data = data.copy()\n\n    if isinstance(data, numpy.ndarray):\n        data = data.reshape(data.shape[0], data.shape[1], data.shape[2])\n\n    if isinstance(fwhm, numpy.ndarray):\n        fwhm = fwhm.reshape",
        "\n\ndef _fast_smooth_array(arr):\n    \"\"\"Smooth images by applying a Gaussian filter.\n    Apply a Gaussian filter along the three first dimensions of arr.\n\n    This is copied and slightly modified from nilearn:\n    https://github.com/nilearn/nilearn/blob/master/nilearn/image/image.py\n    Added the **kwargs argument.\n\n    Parameters\n    ==========\n    arr: numpy.ndarray\n        4D array, with image number as last dimension. 3D arrays are also\n        accepted.\n    affine: numpy.ndarray\n        (4, 4) matrix, giving affine transformation for image. (3, 3) matrices\n        are also accepted (only these coefficients are used).\n        If fwhm='fast', the affine is not used and can be None\n    fwhm: scalar, numpy.ndarray, 'fast' or None\n        Smoothing strength, as a full-width at half maximum, in millimeters.\n        If a scalar is given, width is identical on all three directions.\n        A numpy.ndarray must have 3 elements, giving the FWHM along each axis.\n        If fwhm == 'fast', a fast smoothing will be performed with\n        a filter [0.2, 1, 0.2] in each direction and a normalisation\n       ",
        "\n\n\ndef _smooth_array(arr, affine, fwhm=None, ensure_finite=True, copy=True, **kwargs):\n    \"\"\"Smooth an array of values by applying a Gaussian filter.\n    Apply a Gaussian filter along the three first dimensions of arr.\n    In all cases, non-finite values in input image are replaced by zeros.\n\n    This is copied and slightly modified from nilearn:\n    https://github.com/nilearn/nilearn/blob/master/nilearn/image/image.py\n    Added the **kwargs argument.\n\n    Parameters\n    ==========\n    arr: numpy.ndarray\n        Input array to smooth.\n    affine: affine.Affine object\n        Affine transformation to apply to the input array.\n    fwhm: scalar, numpy.ndarray, 'fast' or None\n        Smoothing strength, as a Full-Width at Half Maximum, in millimeters.\n        If a scalar is given, width is identical on all three directions.\n        A numpy.ndarray must have 3 elements, giving the FWHM along each axis.\n        If fwhm == 'fast', a fast smoothing will be performed with\n        a filter [0.2, 1, 0.2] in each direction and a normalisation\n        to preserve the scale.\n        If fwh",
        "\n",
        "\n",
        "\n\ndef mmspace_to_voxspace(img):\n    \"\"\" Return a grid with coordinates in 3D physical space for `img`.\"\"\"\n    shape, affine = img.shape[:3], img.affine\n    coords = np.array(np.meshgrid(*(range(i) for i in shape), indexing='ij'))\n    coords = np.rollaxis(coords, 0, len(shape) + 1)\n    return nib.affines.apply_affine(affine, coords)\n\ndef voxspace_to_mmspace_with_affine(img):\n    \"\"\" Return a grid with coordinates in 3D physical space for `img`.\"\"\"\n    shape, affine = img.shape[:3], img.affine\n    coords = np.array(np.meshgrid(*(range(i) for i in shape), indexing='ij'))\n    coords = np.rollaxis(coords, 0, len(shape) + 1)\n    mm_coords = nib.affines.apply_affine(affine, coords)\n\n    return mm_coords\n\ndef mmspace_to_voxspace_with_affine(img):\n    \"\"\" Return a grid with coordinates in 3D physical space for `img`.\"\"\"\n    shape, affine = img.shape[:3], img.affine\n",
        "\n\ndef get_2D_coordmap(img):\n    '''\n    Gets a 2D CoordinateMap from img.\n\n    Parameters\n    ----------\n    img: nib.Nifti1Image or nipy Image\n\n    Returns\n    -------\n    nipy.core.reference.coordinate_map.CoordinateMap\n    '''\n    if isinstance(img, nib.Nifti1Image):\n        img = nifti2nipy(img)\n\n    if img.ndim == 4:\n        from nipy.core.reference.coordinate_map import drop_io_dim\n        cm = drop_io_dim(img.coordmap, 2)\n    else:\n        cm = img.coordmap\n\n    return cm\n\ndef get_3D_coordmap_from_file(filename):\n    '''\n    Gets a 3D CoordinateMap from a file.\n\n    Parameters\n    ----------\n    filename: str\n\n    Returns\n    -------\n    nipy.core.reference.coordinate_map.CoordinateMap\n    '''\n    with open(filename, 'rb') as f:\n        return get_3D_coordmap(f.read())\n\ndef get_2D_coordmap_from_file(filename):\n    '''\n    Gets a 2D CoordinateMap from a file.\n\n    Parameters",
        "\n\n\ndef get_img_info_from_file(image):\n    \"\"\"Return the header and affine matrix from a Nifti file.\n\n    Parameters\n    ----------\n    image: str\n        The path to a Nifti image.\n\n    Returns\n    -------\n    hdr, aff\n    \"\"\"\n    try:\n        img = check_img(image)\n    except Exception as exc:\n        raise Exception('Error reading file {0}.'.format(repr_imgs(image))) from exc\n    else:\n        return img.get_header(), img.get_affine()\n\n\ndef get_img_info_from_file_path(image):\n    \"\"\"Return the header and affine matrix from a Nifti file.\n\n    Parameters\n    ----------\n    image: str\n        The path to a Nifti image.\n\n    Returns\n    -------\n    hdr, aff\n    \"\"\"\n    try:\n        img = check_img(image)\n    except Exception as exc:\n        raise Exception('Error reading file {0}.'.format(repr_imgs(image))) from exc\n    else:\n        return img.get_header(), img.get_affine()\n\n\ndef get_img_info_from_file_path_with_header(image):\n    \"\"\"Return the header and",
        ".args[0]\n\n\ndef get_img_affine(image, copy=True):\n    \"\"\"Return the affine matrix of the Nifti file.\n    If safe_mode will make a copy of the img before returning the data, so the input image is not modified.\n\n    Parameters\n    ----------\n    image: img-like object or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it, raise TypeError otherwise.\n\n    copy: bool\n    If safe_mode will make a copy of the img before returning the data, so the input image is not modified.\n\n    Returns\n    -------\n    array_like\n    \"\"\"\n    try:\n        img = check_img(image)\n        if copy:\n            return get_affine(img)\n        else:\n            return img.get_affine()\n    except Exception as exc:\n        raise Exception('Error when reading file {0}.'.format(repr_imgs(image))) from exc.args[0]\n\n\ndef get_img_data_as",
        ".args[0]\n\n\ndef load_nipy_img_from_file(nii_file):\n    \"\"\"Read a Nifti file and return as nipy.Image\n\n    Parameters\n    ----------\n    param nii_file: str\n        Nifti file path\n\n    Returns\n    -------\n    nipy.Image\n    \"\"\"\n    # delayed import because could not install nipy on Python 3 on OSX\n    nipy\n\n    if not os.path.exists(nii_file):\n        raise FileNotFound(nii_file)\n\n    try:\n        return nipy.load_image(nii_file)\n    except Exception as exc:\n        raise Exception('Reading file {0}.'.format(repr_imgs(nii_file))) from exc.args[0]\n\n\ndef load_nipy_img_from_file_with_header(nii_file, header):\n    \"\"\"Read a Nifti file and return as nipy.Image\n\n    Parameters\n    ----------\n    param nii_file: str\n        Nifti file path\n    param header: str\n        Header of the image\n\n    Returns\n    -------\n    nipy.Image\n    \"\"\"\n    # delayed import because could not install nipy on Python 3 on OSX\n    nipy",
        ", vol.shape\n\ndef get_img_data(img_file):\n    \"\"\"\n    Loads the image data from a file.\n\n    Parameters\n    ----------\n    img_file: str\n        Path to the image file.\n\n    Returns\n    -------\n    vol: numpy.ndarray\n        The image data.\n\n    \"\"\"\n    try:\n        vol = np.load(img_file)\n    except Exception as exc:\n        raise Exception('Error on reading file {0}.'.format(img_file)) from exc\n\n    return vol\n\ndef repr_imgs(img_file):\n    \"\"\"\n    Represents the image file as a string.\n\n    Parameters\n    ----------\n    img_file: str\n        Path to the image file.\n\n    Returns\n    -------\n    img_file: str\n        Represents the image file as a string.\n\n    \"\"\"\n    return img_file.replace('\\\\', '/')\n\ndef get_img_data_from_file(img_file):\n    \"\"\"\n    Loads the image data from a file.\n\n    Parameters\n    ----------\n    img_file: str\n        Path to the image file.\n\n    Returns\n    -------\n    vol: numpy.ndarray\n        The image data.\n\n    \"\"\"\n    try:",
        "\n\ndef _crop_img_to_slice(image, slices, copy=True):\n    \"\"\"Crops image to a smaller size\n\n    Crop img to size indicated by slices and modify the affine accordingly.\n\n    Parameters\n    ----------\n    image: img-like object or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n        Image to be cropped.\n\n    slices: list of slices\n        Defines the range of the crop.\n        E.g. [slice(20, 200), slice(40, 150), slice(0, 100)]\n        defines a 3D cube\n\n        If slices has less entries than image has dimensions,\n        the slices will be applied to the first len(slices) dimensions.\n\n    copy: boolean\n        Specifies whether cropped data is to be copied or not.\n        Default: True\n\n    Returns\n    -------\n    cropped_img: img-like",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\n\ndef get_h5file_with_name(file_name, mode='r'):\n    \"\"\" Return the h5py.File given its file name.\n\n    Parameters\n    ----------\n    file_name: string\n        HDF5 file name\n\n    mode: string\n        r   Readonly, file must exist\n        r+  Read/write, file must exist\n        w   Create file, truncate if exists\n        w-  Create file, fail if exists\n        a   Read/write if exists, create otherwise (default)\n\n    Returns\n    -------\n    h5file: h5py.File\n    \"\"\"\n    if not op.exists(file_name):\n        raise IOError('Could not find file {}.'.format(file_name))\n\n    try:\n        h5file = h5py.File(file_name, mode=mode)\n    except:\n        raise\n    else:\n        return h5file\n\n\ndef get_h5file_with_name_and_mode(file_name, mode='r'):\n    \"\"\" Return the h5py.File given its file name and mode.\n\n    Parameters\n    ----------\n    file_name: string\n        HDF5 file name\n\n    mode: string\n        r   Readonly, file must exist\n        r+ ",
        "\n\ndef get_datasets(h5file, h5path):\n    \"\"\" Return all datasets contained in h5path group in h5file in an OrderedDict.\n\n    Parameters\n    ----------\n    h5file: h5py.File\n        HDF5 file object\n\n    h5path: str\n        HDF5 group path to read datasets from\n\n    Returns\n    -------\n    datasets: OrderedDict\n        Dict with variables contained in file_path/h5path\n    \"\"\"\n    if isinstance(h5file, str):\n        _h5file = h5py.File(h5file, mode='r')\n    else:\n        _h5file = h5file\n\n    _datasets = _h5file.groups[h5path]\n    datasets  = OrderedDict()\n    try:\n        for ds in _datasets:\n            datasets[ds.name.split('/')[-1]] = ds[:]\n    except:\n        raise RuntimeError('Error reading datasets in {}/{}.'.format(_h5file.filename, h5path))\n    finally:\n        if isinstance(h5file, str):\n            _h5file.close()\n\n    return datasets\n",
        "\n\ndef _hdf5_walk(h5file, node_type=h5py.Dataset):\n    \"\"\"Return a list of all the node names within h5file.\n\n    Parameters\n    ----------\n    h5file: h5py.File\n        HDF5 file object\n\n    node_type: h5py object type\n        HDF5 object type\n\n    Returns\n    -------\n    names: list of str\n        List of names\n    \"\"\"\n    names = []\n    try:\n        h5group = h5file.require_group(h5file.group_path)\n\n        for node in _hdf5_walk(h5group, node_type=node_type):\n            names.append(node.name)\n    except:\n        raise RuntimeError('Error getting node names from {}/{}.'.format(_h5file.filename, h5file.group_path))\n\n    return names\n\ndef _hdf5_get_node_names(h5file, h5path='/', node_type=h5py.Dataset):\n    \"\"\"Return the node of type node_type names within h5path of h5file.\n\n    Parameters\n    ----------\n    h5file: h5py.File\n        HDF5 file object\n\n    h5path: str\n        HDF5 group path",
        "\n\ndef load_mask(image):\n        \"\"\" Load mask image\n\n        Parameters\n        ----------\n        image: str or img-like object.\n            See NeuroImage constructor docstring.\n        \"\"\"\n        if isinstance(image, str):\n            image = Image.open(image)\n        elif isinstance(image, img_like):\n            image = image.convert('RGB')\n        else:\n            raise Exception('Invalid mask image type {}'.format(type(image)))\n\n        return image\n\ndef load_image(image):\n        \"\"\" Load image\n\n        Parameters\n        ----------\n        image: str or img-like object.\n            See NeuroImage constructor docstring.\n        \"\"\"\n        if isinstance(image, str):\n            image = Image.open(image)\n        elif isinstance(image, img_like):\n            image = image.convert('RGB')\n        else:\n            raise Exception('Invalid image type {}'.format(type(image)))\n\n        return image\n\ndef load_image_from_file(image_file):\n        \"\"\" Load image from file\n\n        Parameters\n        ----------\n        image_file: str or img-like object.\n            See NeuroImage constructor docstring.\n        \"\"\"\n        if isinstance(image_file, str):\n            image_file = Image.open(image_file)",
        "\n\n    def load_images(self, images):\n        \"\"\"Load the images, load them into self.items and set the labels.\"\"\"\n        _load_images_and_labels(self, images)\n\n    def load_labels(self, labels):\n        \"\"\"Load the labels, load them into self.items and set the images.\"\"\"\n        _load_images_and_labels(self, labels)\n\n    def set_labels(self, labels):\n        \"\"\"Set the labels, load them into self.items and set the images.\"\"\"\n        _load_images_and_labels(self, labels)\n\n    def set_images(self, images):\n        \"\"\"Set the images, load them into self.items and set the labels.\"\"\"\n        _load_images_and_labels(self, images)\n\n    def set_labels_from_file(self, filename):\n        \"\"\"Set the labels, load them into self.items and set the images.\"\"\"\n        _load_images_and_labels(self, filename)\n\n    def set_images_from_file_list(self, filenames):\n        \"\"\"Set the images, load them into self.items and set the labels.\"\"\"\n        _load_images_and_labels(self, filenames)\n\n    def set_images_from_file_list_and_labels(self",
        ".args[0]\n\n        log.debug('Saving content to file {}.'.format(output_file))\n        try:\n            exporter.save_variables(output_file, content)\n        except Exception as exc:\n            raise Exception('Error saving content to file {}.'.format(output_file)) from exc.args[0]\n\n        log.debug('Saving content to file {}.'.format(output_file))\n        try:\n            exporter.save_variables(output_file, content)\n        except Exception as exc:\n            raise Exception('Error saving content to file {}.'.format(output_file)) from exc.args[0]\n\n        log.debug('Saving content to file {}.'.format(output_file))\n        try:\n            exporter.save_variables(output_file, content)\n        except Exception as exc:\n            raise Exception('Error saving content to file {}.'.format(output_file)) from exc.args[0]\n\n        log.debug('Saving content to file {}.'.format(output_file))\n        try:\n            exporter.save_variables(output_file, content)\n        except Exception as exc:\n            raise Exception('Error saving content to file {}.'.format(output_file)) from exc.args[0]\n\n        log.debug('Saving content to file {}.'.format(output_file",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    cmd_args = ['python', 'test.py']\n    print check_call(cmd_args)\n\nif __name__ == '__main__':\n    main()\n",
        "\n\ndef which(cmd_name):\n    \"\"\"Return the full path to the binary file.\n\n    Parameters\n    ----------\n    cmd_name: str\n        Command name or full path to the binary file.\n\n    Returns\n    -------\n    full_path: str\n        Full path to the binary file.\n    \"\"\"\n    try:\n        return os.path.abspath(os.path.join(os.path.dirname(__file__), cmd_name))\n    except OSError as e:\n        log.exception(\"Error finding command {} with arguments: \"\n                      \"{} \\n With return code: {}\".format(cmd_name, args_strings,\n                                                          e.returncode))\n        raise\n\ndef which_with_args(cmd_name, args_strings):\n    \"\"\"Return the full path to the binary file.\n\n    Parameters\n    ----------\n    cmd_name: str\n        Command name or full path to the binary file.\n\n    args_strings: list of str\n        Argument strings list.\n\n    Returns\n    -------\n    full_path: str\n        Full path to the binary file.\n    \"\"\"\n    try:\n        return os.path.abspath(os.path.join(os.path.dirname(__file__), cmd_name, args_strings))\n    except OSError",
        "\n\ndef condor_submit(cmd):\n    \"\"\"\n    Tries to submit cmd to HTCondor, if it does not succeed, it will\n    be called with subprocess.call.\n\n    Parameters\n    ----------\n    cmd: string\n        Command to be submitted\n\n    Returns\n    -------\n    \"\"\"\n    log.info(cmd)\n    ret = condor_submit_cmd(cmd)\n    if ret != 0:\n        subprocess.call(cmd, shell=shell)\n\ndef condor_submit_cmd(cmd):\n    \"\"\"\n    Tries to submit cmd to HTCondor, if it does not succeed, it will\n    be called with subprocess.call.\n\n    Parameters\n    ----------\n    cmd: string\n        Command to be submitted\n\n    Returns\n    -------\n    \"\"\"\n    log.info(cmd)\n    ret = condor_submit_cmd_with_output(cmd)\n    if ret != 0:\n        subprocess.call(cmd, shell=shell)\n\ndef condor_submit_cmd_with_output(cmd):\n    \"\"\"\n    Tries to submit cmd to HTCondor, if it does not succeed, it will\n    be called with subprocess.call.\n\n    Parameters\n    ----------\n    cmd: string\n        Command to be submitted\n\n    Returns\n    -------",
        "\n\ndef condor_wait(cmd):\n    \"\"\"\n    Waits for cmd to be submitted to HTCondor queue\n\n    Parameters\n    ----------\n    cmd: string\n        Command to be submitted\n\n    Returns\n    -------\n    int\n        returncode value from calling the submission command.\n    \"\"\"\n    is_running = subprocess.call('condor_status', shell=True) == 0\n    if not is_running:\n        raise CalledProcessError('HTCondor is not running.')\n\n    sub_cmd = 'condor_qsub -shell n -b y -r y -N ' \\\n              + cmd.split()[0] + ' -m n'\n\n    log.info('Calling: ' + sub_cmd)\n\n    return subprocess.call(sub_cmd + ' ' + cmd, shell=True)\n\ndef condor_get_status(cmd):\n    \"\"\"\n    Returns status of HTCondor queue\n\n    Parameters\n    ----------\n    cmd: string\n        Command to be submitted\n\n    Returns\n    -------\n    int\n        returncode value from calling the submission command.\n    \"\"\"\n    is_running = subprocess.call('condor_status', shell=True) == 0\n    if not is_running:\n        raise CalledProcessError('HTCondor is not running.')\n\n    sub",
        ".rmtree(dist)\n\ndef build(ctx):\n    \"\"\"Build package artifacts.\n    \"\"\"\n    ctx.run(f'python setup.py build')\n    dist = ROOT.joinpath('dist')\n    print(f'building {dist}')\n    shutil.rmtree(dist)\n    shutil.copytree(ROOT.joinpath('src'), dist)\n    shutil.copytree(ROOT.joinpath('tests'), dist)\n    shutil.copytree(ROOT.joinpath('tests/unit'), dist)\n    shutil.copytree(ROOT.joinpath('tests/unit/tests'), dist)\n    shutil.copytree(ROOT.joinpath('tests/unit/tests/unit'), dist)\n    shutil.copytree(ROOT.joinpath('tests/unit/tests/unit/tests'), dist)\n    shutil.copytree(ROOT.joinpath('tests/unit/tests/unit/tests/unit'), dist)\n    shutil.copytree(ROOT.joinpath('tests/unit/tests/unit/tests/unit/tests'), dist)\n    shutil.copytree(ROOT.joinpath('tests/unit/tests/unit/tests/unit/tests/unit'), dist)\n    shutil.copytree(ROOT.joinpath('tests/unit/tests/unit/tests/unit/tests/unit/tests'),",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\ndef get_abspath(path):\n    \"\"\"Returns absolute path of path\n\n    :param path: path to be absolute\n    :return: absolute path of path\n    \"\"\"\n    return os.path.abspath(path)\n\n\ndef get_file_group_from_serial_num(serial_num):\n    \"\"\"Returns a list of path.py paths\n\n    :param serial_num: serial number\n    :return: list of path.py paths\n    \"\"\"\n    return [f for f in os.listdir(OUTPUT_DICOM_DIR)\n            if f.startswith(str(serial_num))]\n\n\ndef get_file_group_from_serial_num_and_extension(serial_num, extension):\n    \"\"\"Returns a list of path.py paths\n\n    :param serial_num: serial number\n    :param extension: extension to be used\n    :return: list of path.py paths\n    \"\"\"\n    return [f for f in os.listdir(OUTPUT_DICOM_DIR)\n            if f.startswith(str(serial_num)) and f.endswith(extension)]\n\n\ndef get_file_group_from_serial_num_and_extension_and_name(serial_num, extension, name):\n    \"\"\"Returns a list of path",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef is_dicom_file(filename):\n        \"\"\"Returns True if the filename is a dicom file\"\"\"\n        return filename.endswith('.dicom')\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_dcm_writer(store_metadata=True, header_fields=None):\n        \"\"\"\n        Creates a lambda function to write DICOM files.\n        If store_store_metadata is False, will only return the file path.\n        Else if you give header_fields, will return only the set of of\n        header_fields within a DicomFile object or the whole DICOM file if\n        None.\n\n        :return: function\n        This function has only one parameter: file_path\n        \"\"\"\n        if not store_metadata:\n            return lambda fpath: fpath\n\n        if header_fields is None:\n            dicom_header = namedtuple('DicomHeader', header_fields)\n            build_dcm = lambda fpath: dicom_header._make(DicomFile(fpath).get_attributes(header_fields))\n        else:\n            dicom_header = namedtuple('DicomHeader', header_fields)\n            build_dcm = lambda fpath: dicom_header._make(DicomFile(fpath).get_attributes(header_fields))\n\n        return build_dcm\n\ndef get_dcm_reader_writer(store_metadata=True, header_fields=None):\n        \"\"\"\n        Creates a lambda function to read DICOM files.\n        If store_store_metadata is False, will only",
        "\n\ndef read_dcm(dcmf):\n        \"\"\"\n        Read a DICOM file and return a DICOM object\n        \"\"\"\n        try:\n            return DICOM(dcmf)\n        except IOError as ioe:\n            raise IOError('Error reading DICOM file: {}.'.format(dcmf)) from ioe\n\ndef read_dcm_from_file(dcmf):\n        \"\"\"\n        Read a DICOM file and return a DICOM object\n        \"\"\"\n        try:\n            return DICOM(dcmf)\n        except IOError as ioe:\n            raise IOError('Error reading DICOM file: {}.'.format(dcmf)) from ioe\n\ndef read_dcm_from_file_with_header(dcmf, header):\n        \"\"\"\n        Read a DICOM file and return a DICOM object\n        \"\"\"\n        try:\n            return DICOM(dcmf, header)\n        except IOError as ioe:\n            raise IOError('Error reading DICOM file: {}.'.format(dcmf)) from ioe\n\ndef read_dcm_from_file_with_header_and_data(dcmf, header, data):\n        \"\"\"\n        Read a DICOM file and return a DICOM object\n        \"\"\"\n        try:\n            return DICOM(dcmf, header, data)\n        except IOError as ioe:\n            raise IOError('Error reading DICOM file: {}.'.format(dcmf)) from",
        "\n\ndef get_unique_field_values_from_dcm_files(dcm_file_list, field_name):\n    \"\"\"Return a set of unique field values from a list of DICOM files\n\n    Parameters\n    ----------\n    dcm_file_list: iterable of DICOM file paths\n\n    field_name: str\n     Name of the field from where to get each value\n\n    Returns\n    -------\n    Set of field values\n    \"\"\"\n    field_values = set()\n\n    for dcm in dcm_file_list:\n        field_values.add(str(DicomFile(dcm).get_attributes(field_name)))\n\n    return field_values\n\ndef get_unique_field_values_from_dcm_files_with_attributes(dcm_file_list, field_name, attribute_name):\n    \"\"\"Return a set of unique field values from a list of DICOM files\n\n    Parameters\n    ----------\n    dcm_file_list: iterable of DICOM file paths\n\n    field_name: str\n     Name of the field from where to get each value\n\n    attribute_name: str\n     Name of the attribute from where to get each value\n\n    Returns\n    -------\n    Set of field values\n    \"\"\"\n    field_values = set()\n\n    for dcm in dcm_",
        "\n\ndef get_all_files(root_path):\n    \"\"\"\n    Returns a list of all the files within root_path\n\n    Parameters\n    ----------\n    root_path: str\n    Path to the directory to be recursively searched for DICOM files.\n\n    Returns\n    -------\n    files: list\n    List of DICOM absolute file paths\n    \"\"\"\n    files = []\n\n    try:\n        for fpath in os.listdir(root_path):\n            if is_dicom_file(fpath):\n                files.append(fpath)\n    except IOError as ioe:\n        raise IOError('Error reading directory {0}.'.format(fpath)) from ioe\n\n    return files\n\ndef is_dicom_file(fpath):\n    \"\"\"\n    Returns True if the given file is a DICOM file\n\n    Parameters\n    ----------\n    fpath: str\n    Path to the file to be checked\n\n    Returns\n    -------\n    is_dicom_file: bool\n    True if the given file is a DICOM file\n    \"\"\"\n    return fpath.endswith('.dicom')\n",
        "\n\ndef is_dicom_file_with_extension(filepath, extension):\n    \"\"\"\n    Tries to read the file using dicom.read_file,\n    if the file exists and dicom.read_file does not raise\n    and Exception returns True. False otherwise.\n\n    :param filepath: str\n     Path to DICOM file\n\n    :param extension: str\n     Extension of the file\n\n    :return: bool\n    \"\"\"\n    if not os.path.exists(filepath):\n        raise IOError('File {} not found.'.format(filepath))\n\n    filename = os.path.basename(filepath)\n    if filename == 'DICOMDIR':\n        return False\n\n    try:\n        _ = dicom.read_file(filepath)\n    except Exception as exc:\n        log.debug('Checking if {0} was a DICOM, but returned '\n                  'False.'.format(filepath))\n        return False\n\n    return True\n\ndef is_dicom_file_with_extension_and_extension_and_extension_and_extension(filepath, extension, extension_and_extension):\n    \"\"\"\n    Tries to read the file using dicom.read_file,\n    if the file exists and dicom.read_file does not raise\n    and Exception returns True. False otherwise.\n\n    :param filepath",
        "\n\ndef group_dicom_files_by_patient_id(dicom_paths, hdr_field='PatientID'):\n    \"\"\"Group in a dictionary all the DICOM files in dicom_paths\n    separated by the given `hdr_field` tag value.\n\n    Parameters\n    ----------\n    dicom_paths: str\n        Iterable of DICOM file paths.\n\n    hdr_field: str\n        Name of the DICOM tag whose values will be used as key for the group.\n\n    Returns\n    -------\n    dicom_groups: dict of dicom_paths\n    \"\"\"\n    dicom_groups = defaultdict(list)\n    try:\n        for dcm in dicom_paths:\n            hdr = dicom.read_file(dcm)\n            group_key = getattr(hdr, hdr_field)\n            dicom_groups[group_key].append(dcm)\n    except KeyError as ke:\n        raise KeyError('Error reading field {} from file {}.'.format(hdr_field, dcm)) from ke\n\n    return dicom_groups\n\ndef group_dicom_files_by_patient_id_and_type(dicom_paths, hdr_field='PatientID',\n                                          hdr_type='PatientType'):\n    \"\"\"Group in a dictionary all the DICOM files in dicom_paths\n    separated by the given `",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;",
        ")\n\n\ndef apply_mask_to_image(img, mask):\n    \"\"\"Return the image with the given `mask` applied.\"\"\"\n    from .mask import apply_mask_to_image\n\n    vol, _ = apply_mask_to_image(img, mask)\n    return vector_to_volume(vol, read_img(mask).get_data().astype(bool))\n\n\ndef apply_mask_to_volume(vol, mask):\n    \"\"\"Return the image with the given `mask` applied.\"\"\"\n    from .mask import apply_mask_to_volume\n\n    vol, _ = apply_mask_to_volume(vol, mask)\n    return vector_to_image(vol, read_img(mask).get_data().astype(bool))\n\n\ndef apply_mask_to_image_with_mask(img, mask):\n    \"\"\"Return the image with the given `mask` applied.\"\"\"\n    from .mask import apply_mask_to_image_with_mask\n\n    vol, _ = apply_mask_to_image_with_mask(img, mask)\n    return vector_to_image(vol, read_img(mask).get_data().astype(bool))\n\n\ndef apply_mask_to_volume_with_mask(vol, mask):\n   ",
        ".float32\n\n\ndef read_img(img):\n    \"\"\" Read an image from a file.\n\n    Parameters\n    ----------\n    img : str\n        The path to the image file.\n\n    Returns\n    -------\n    img : Image\n        The image.\n    \"\"\"\n    img = Image.open(img)\n    img.thumbnail((256, 256), Image.ANTIALIAS)\n    return img\n\n\ndef write_img(img, path):\n    \"\"\" Write an image to a file.\n\n    Parameters\n    ----------\n    img : Image\n        The image.\n    path : str\n        The path to the file.\n    \"\"\"\n    img.save(path)\n\n\ndef read_img_from_file(path):\n    \"\"\" Read an image from a file.\n\n    Parameters\n    ----------\n    path : str\n        The path to the file.\n\n    Returns\n    -------\n    img : Image\n        The image.\n    \"\"\"\n    img = Image.open(path)\n    img.thumbnail((256, 256), Image.ANTIALIAS)\n    return img\n\n\ndef write_img_to_file(img, path):\n    \"\"\" Write an image to a file.\n\n    Parameters\n    ----------\n    img : Image\n        The image.\n    path : str\n       ",
        "\n\ndef icc_img_to_zscore_with_center(icc, center_image=False):\n    \"\"\" Return a z-scored version of `icc`.\n    This function is based on GIFT `icatb_convertImageToZScores` function.\n    \"\"\"\n    vol = read_img(icc).get_data()\n\n    v2 = vol[vol != 0]\n    if center_image:\n        v2 = detrend(v2, axis=0)\n\n    vstd = np.linalg.norm(v2, ord=2) / np.sqrt(np.prod(v2.shape) - 1)\n\n    eps = np.finfo(vstd.dtype).eps\n    vol /= (eps + vstd)\n\n    return vol\n\ndef icc_img_to_zscore_with_center_and_scale(icc, center_image=False, scale=1.0):\n    \"\"\" Return a z-scored version of `icc`.\n    This function is based on GIFT `icatb_convertImageToZScores` function.\n    \"\"\"\n    vol = read_img(icc).get_data()\n\n    v2 = vol[vol != 0]\n    if center_image:\n        v2 = det",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef write_raw_file(filename, data, shape=None, meta_dict=None):\n    \"\"\" Write the `data` and `meta_dict` in two files with names\n    that use `filename` as a prefix.\n\n    Parameters\n    ----------\n    filename: str\n        Path to the output file.\n        This is going to be used as a preffix.\n        Two files will be created, one with a '.raw' extension\n        and another with '.mhd'. If `filename` has any of these already\n        they will be taken into account to build the filenames.\n\n    data: numpy.ndarray\n        n-dimensional image data array.\n\n    shape: tuple\n        Tuple describing the shape of `data`\n        Default: data.shape\n\n    meta_dict: dict\n        Dictionary with the fields of the metadata .mhd file\n        Default: {}\n\n    Returns\n    -------\n    raw_filename: str\n        Path to the .raw file\n\n    \"\"\"\n    # check its extension\n    ext = get_extension(filename)\n    fname = op.basename(filename)\n    if ext != '.raw' or ext != '.mhd':\n        raise ValueError('`filename` extension {} from {} is not recognised. '\n                         'Expected .raw or .mhd.'.format(ext,",
        "\n\ndef remove_ext(filename):\n    \"\"\"Remove the extension from a filename.\n\n    Parameters\n    ----------\n    filename: str\n        The filename to be removed.\n\n    Returns\n    -------\n    filename: str\n    \"\"\"\n    return filename.replace('.mhd', '')\n\ndef get_extension(filename):\n    \"\"\"Get the extension of a filename.\n\n    Parameters\n    ----------\n    filename: str\n        The filename to be retrieved.\n\n    Returns\n    -------\n    extension: str\n    \"\"\"\n    return op.splitext(filename)[1]\n\ndef write_meta_header(filename, meta_header):\n    \"\"\"Write the meta header to a file.\n\n    Parameters\n    ----------\n    filename: str\n        The filename to be written.\n\n    meta_header: dict\n        The meta header to be written.\n    \"\"\"\n    with open(filename, 'w') as f:\n        f.write(json.dumps(meta_header))\n\ndef _read_meta_header(filename):\n    \"\"\"Read the meta header from a file.\n\n    Parameters\n    ----------\n    filename: str\n        The filename to be read.\n\n    Returns\n    -------\n    meta_header: dict\n    \"\"\"\n    with open(filename, 'r') as f:",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef sav_to_pandas_savwriter(input_file):\n    \"\"\"\n    SPSS .sav files to Pandas DataFrame through savwriter module\n\n    :param input_file: string\n\n    :return:\n    \"\"\"\n    from savWriterWriter import SavWriter\n    lines = []\n    with SavWriter(input_file, returnHeader=True) as writer:\n        header = next(writer)\n        for line in writer:\n            lines.append(line)\n\n    return pd.DataFrame(data=lines, columns=header)\n\ndef sav_to_pandas_savreader_with_header(input_file):\n    \"\"\"\n    SPSS .sav files to Pandas DataFrame through savreader module\n\n    :param input_file: string\n\n    :return:\n    \"\"\"\n    from savReaderWriter import SavReader\n    lines = []\n    with SavReader(input_file, returnHeader=True) as reader:\n        header = next(reader)\n        for line in reader:\n            lines.append(line)\n\n    return pd.DataFrame(data=lines, columns=header)\n\ndef sav_to_pandas_savwriter_with_header(input_file):\n    \"\"\"\n    SPSS .sav files to Pandas DataFrame through savwriter module\n\n",
        "\n\ndef save_varlist_hdf5(filename, varnames, varlist):\n        \"\"\"\n        Valid extensions '.pyshelf', '.mat', '.hdf5' or '.h5'\n\n        @param filename: string\n\n        @param varnames: list of strings\n        Names of the variables\n\n        @param varlist: list of objects\n        The objects to be saved\n        \"\"\"\n        variables = {}\n        for i, vn in enumerate(varnames):\n            variables[vn] = varlist[i]\n\n        ExportData.save_variables(filename, variables)\n\n\ndef save_varlist_h5(filename, varnames, varlist):\n        \"\"\"\n        Valid extensions '.pyshelf', '.mat', '.hdf5' or '.h5'\n\n        @param filename: string\n\n        @param varnames: list of strings\n        Names of the variables\n\n        @param varlist: list of objects\n        The objects to be saved\n        \"\"\"\n        variables = {}\n        for i, vn in enumerate(varnames):\n            variables[vn] = varlist[i]\n\n        ExportData.save_variables(filename, variables)\n\n\ndef save_varlist_hdf5_hdf5(filename, varnames, varlist):\n        \"\"\"\n        Valid extensions '.py",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_img_data(img):\n    \"\"\"Get the data of an image.\n\n    Parameters\n    ----------\n    img: img-like object or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    Returns\n    -------\n    np.ndarray\n        an array of same shape as img_data\n    \"\"\"\n    if isinstance(img, str):\n        img = nibabel.load(img)\n    if isinstance(img, nibabel.Nifti1Image):\n        img = img.copy()\n    return img\n\ndef get_img_data_affine(img):\n    \"\"\"Get the data of an image.\n\n    Parameters\n    ----------\n    img: img-like object or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\ndef large_clusters_mask_with_mask(volume, mask):\n    \"\"\" Return as mask for `volume` that includes only areas where\n    the connected components have a size bigger than `min_cluster_size`\n    in number of voxels.\n\n    Parameters\n    -----------\n    volume: numpy.array\n        3D boolean array.\n\n    mask: numpy.array\n        3D int array with a mask excluding small connected components.\n\n    Returns\n    --------\n    volume: numpy.array\n        3D int array with a mask excluding small connected components.\n    \"\"\"\n    labels, num_labels = scn.label(volume)\n\n    labels_to_keep = set([i for i in range(num_labels)\n                         if np.sum(labels == i) >= min_cluster_size])\n\n    clusters_mask = np.zeros_like(volume, dtype=int)\n    for l in range(num_labels):\n        if l in labels_to_keep:\n            clusters_mask[labels == l] = 1\n\n    return clusters_mask\n\n\ndef large_clusters_mask_with_mask_with_mask(volume, mask, mask_with_mask):\n    \"\"\" Return as mask for `volume` that includes only areas where\n    the connected components have a size bigger",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_unique_nonzeros_with_duplicates(arr):\n    \"\"\" Return a sorted list of the non-zero unique values of arr.\n\n    Parameters\n    ----------\n    arr: numpy.ndarray\n        The data array\n\n    Returns\n    -------\n    list of items of arr.\n    \"\"\"\n    rois = np.unique(arr)\n    rois = rois[np.nonzero(rois)]\n    rois.sort()\n\n    return rois\n\ndef get_unique_nonzeros_with_duplicates_with_duplicates(arr):\n    \"\"\" Return a sorted list of the non-zero unique values of arr.\n\n    Parameters\n    ----------\n    arr: numpy.ndarray\n        The data array\n\n    Returns\n    -------\n    list of items of arr.\n    \"\"\"\n    rois = np.unique(arr)\n    rois = rois[np.nonzero(rois)]\n    rois = rois[np.nonzero(rois)]\n    rois.sort()\n\n    return rois\n\ndef get_unique_nonzeros_with_duplicates_with_duplicates_with_duplicates(arr):\n    \"\"\" Return a sorted list of the non-zero unique values of arr.\n\n    Parameters\n    ----------\n    arr: numpy.ndarray\n        The data array\n\n",
        "\n\ndef get_rois_centers_of_mass_with_mean(vol):\n    \"\"\"Get the center of mass for each ROI in the given volume.\n\n    Parameters\n    ----------\n    vol: numpy ndarray\n        Volume with different values for each ROI.\n\n    Returns\n    -------\n    OrderedDict\n        Each entry in the dict has the ROI value as key and the center_of_mass coordinate as value.\n    \"\"\"\n    from scipy.ndimage.measurements import center_of_mass\n\n    roisvals = np.unique(vol)\n    roisvals = roisvals[roisvals != 0]\n\n    rois_centers = OrderedDict()\n    for r in roisvals:\n        rois_centers[r] = center_of_mass(vol, vol, r, mean=True)\n\n    return rois_centers\n\ndef get_rois_centers_of_mass_with_std(vol):\n    \"\"\"Get the center of mass for each ROI in the given volume.\n\n    Parameters\n    ----------\n    vol: numpy ndarray\n        Volume with different values for each ROI.\n\n    Returns\n    -------\n    OrderedDict\n        Each entry in the dict has the ROI value as key and the center_of_mass coordinate as value.\n    \"\"\"\n    from scipy",
        "\n\ndef _partition_data_mask(datavol, maskvol, zeroe=True):\n    \"\"\" Extracts the values in `datavol` that are in the ROI with value `roivalue` in `roivol`.\n    The ROI can be masked by `maskvol`.\n\n    Parameters\n    ----------\n    datavol: numpy.ndarray\n        4D timeseries volume or a 3D volume to be partitioned\n\n    maskvol: numpy.ndarray\n        3D mask volume\n\n    zeroe: bool\n        If true will remove the null timeseries voxels.  Only applied to timeseries (4D) data.\n\n    Returns\n    -------\n    values: np.array\n        An array of the values in the indicated ROI.\n        A 2D matrix if `datavol` is 4D or a 1D vector if `datavol` is 3D.\n    \"\"\"\n    if maskvol is not None:\n        # get all masked time series within this roi r\n        indices = (maskvol == roivalue) * (maskvol > 0)\n    else:\n        # get all time series within this roi r\n        indices = roivol == roivalue\n\n    if datavol.ndim == 4:\n        ts = datavol[indices, :]\n    else:\n        ts = datavol[indices",
        "\n\ndef get_3D_from_3D(image, vol_idx=0):\n    \"\"\"Pick one 3D volume from a 3D nifti image file\n\n    Parameters\n    ----------\n    image: img-like object or str\n        Volume defining different ROIs.\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    vol_idx: int\n        Index of the 3D volume to be extracted from the 3D volume.\n\n    Returns\n    -------\n    vol, hdr, aff\n        The data array, the image header and the affine transform matrix.\n    \"\"\"\n    img      = check_img(image)\n    hdr, aff = get_img_info(img)\n\n    if len(img.shape) != 3:\n        raise AttributeError('Volume in {} does not have 3 dimensions.'.format(repr_imgs(img)))\n\n    if not 0 <= vol_idx",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef create_dataset(self, ds_name, dtype=np.float32):\n        \"\"\"\n        Creates a Dataset with unknown size.\n        Resize it before using.\n\n        :param ds_name: string\n\n        :param dtype: dtype\n        Datatype of the dataset\n\n        :return: h5py DataSet\n        \"\"\"\n        if ds_name in self._datasets:\n            return self._datasets[ds_name]\n\n        ds = self._group.create_dataset(ds_name, (1, 1), maxshape=None,\n                                        dtype=dtype)\n        self._datasets[ds_name] = ds\n\n        return ds\n\ndef create_dataset_from_file(self, ds_name, filename):\n        \"\"\"\n        Creates a Dataset from a file.\n        Resize it before using.\n\n        :param ds_name: string\n\n        :param filename: string\n        Filename of the dataset\n\n        :return: h5py DataSet\n        \"\"\"\n        if ds_name in self._datasets:\n            return self._datasets[ds_name]\n\n        ds = self._group.create_dataset(ds_name, (1, 1), maxshape=None,\n                                        dtype=np.float32)\n        ds.read_file(filename)\n        self._datasets[",
        "\n\ndef create_dataset_from_file(self, ds_name, file_name, attrs=None, dtype=None):\n        \"\"\"\n        Saves a Numpy array in a dataset in the HDF file, registers it as ds_name\n        and returns the h5py dataset.\n\n        :param ds_name: string\n        Registration name of the dataset to be registered.\n\n        :param file_name: string\n        Name of the file to be saved.\n\n        :param attrs: dict\n        Attributes of the dataset.\n\n        :param dtype: dtype\n        Datatype of the dataset\n\n        :return: h5py dataset\n        \"\"\"\n        if ds_name in self._datasets:\n            ds = self._datasets[ds_name]\n            if ds.dtype != data.dtype:\n                warnings.warn('Dataset and data dtype are different!')\n\n        else:\n            if dtype is None:\n                dtype = data.dtype\n\n            ds = self._group.create_dataset(ds_name, data.shape,\n                                            dtype=dtype)\n\n            if attrs is not None:\n                for key in attrs:\n                    setattr(ds.attrs, key, attrs[key])\n\n            ds.read_direct(open(file_name, 'rb'))\n            self._datasets[ds_name",
        ", dtype=None)\n\ndef load(self, ds_name, data, dtype=None):\n        \"\"\"\n        See create_dataset.\n        \"\"\"\n        return self.create_dataset(ds_name, data, dtype)\n\ndef load_all(self, ds_name, data, dtype=None):\n        \"\"\"\n        See create_dataset.\n        \"\"\"\n        return self.create_dataset(ds_name, data, dtype)\n\ndef load_all_by_name(self, ds_name, data, dtype=None):\n        \"\"\"\n        See create_dataset.\n        \"\"\"\n        return self.create_dataset(ds_name, data, dtype)\n\ndef load_all_by_name_and_dtype(self, ds_name, data, dtype=None):\n        \"\"\"\n        See create_dataset.\n        \"\"\"\n        return self.create_dataset(ds_name, data, dtype)\n\ndef load_all_by_name_and_dtype_and_shape(self, ds_name, data, dtype=None, shape=None):\n        \"\"\"\n        See create_dataset.\n        \"\"\"\n        return self.create_dataset(ds_name, data, dtype, shape)\n\ndef load_all_by_name_and_dtype_and_shape_and_",
        "\n\ndef _fill_missing_values_with_missing_values(df, range_values, fill_value=0, fill_method=None):\n        \"\"\"\n        Will get the names of the index colums of df, obtain their ranges from\n        range_values dict and return a reindexed version of df with the given\n        range values.\n\n        :param df: pandas DataFrame\n\n        :param range_values: dict or array-like\n        Must contain for each index column of df an entry with all the values\n        within the range of the column.\n\n        :param fill_value: scalar or 'nearest', default 0\n        Value to use for missing values. Defaults to 0, but can be any\n        \"compatible\" value, e.g., NaN.\n        The 'nearest' mode will fill the missing value with the nearest value in\n         the column.\n\n        :param fill_method:  {'backfill', 'bfill', 'pad', 'ffill', None}, default None\n        Method to use for filling holes in reindexed DataFrame\n        'pad' / 'ffill': propagate last valid observation forward to next valid\n        'backfill' / 'bfill': use NEXT valid observation to fill gap\n\n        :return: pandas Dataframe and used column ranges\n        reindexed DataFrame and dict with index column ranges\n        \"\"\"\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get(self, key, attrs=None, format=None, **kwargs):\n        \"\"\"\n        Retrieve object from HDFStore\n\n        Parameters\n        ----------\n        key : str\n\n        attrs : dict, default None\n            If None, use the default attributes\n\n        format : 'fixed(f)|table(t)', default is 'fixed'\n            fixed(f) : Fixed format\n                Fast writing/reading. Not-appendable, nor searchable\n\n            table(t) : Table format\n                Write as a PyTables Table structure which may perform worse but allow more flexible operations\n                like searching/selecting subsets of the data\n\n        append : boolean, default False\n            This will force Table format, append the input data to the\n            existing.\n\n        encoding : default None, provide an encoding for strings\n        \"\"\"\n        if not isinstance(key, str):\n            raise TypeError(\"key must be a string\")\n\n        group = self.get_node(key)\n\n        if group is None:\n            raise KeyError(\"Key not found\")\n\n        ds = self._handle.getArray(group, kwargs.get('ds_name', self._array_dsname))\n        if attrs is not None:\n            for key in attrs:\n                setattr(ds.attrs, key, attrs[key])\n\n       ",
        "\n\ndef put_df_as_hdf(self, key, df, range_values, loop_multiindex=False,\n                  unstack=False, fill_value=0, fill_method=None):\n    \"\"\"Returns a PyTables HDF Array from df in the shape given by its index columns range values.\n\n    :param key: string object\n\n    :param df: pandas DataFrame\n\n    :param range_values: dict or array-like\n    Must contain for each index column of df an entry with all the values\n    within the range of the column.\n\n    :param loop_multiindex: bool\n    Will loop through the first index in a multiindex dataframe, extract a\n    dataframe only for one value, complete and fill the missing values and\n    store in the HDF.\n    If this is True, it will not use unstack.\n    This is as fast as unstacking.\n\n    :param unstack: bool\n    Unstack means that this will use the first index name to\n    unfold the DataFrame, and will create a group with as many datasets\n    as valus has this first index.\n    Use this if you think the filled dataframe won't fit in your RAM memory.\n    If set to False, this will transform the dataframe in memory first\n    and only then save it.\n\n    :param fill_value:",
        "\n        self._is_data_smooth = True\n\ndef smooth_fwhm_from_data(self, data):\n        \"\"\" Set a smoothing Gaussian kernel given its FWHM in mm.  \"\"\"\n        if data != self._smooth_fwhm:\n            self._is_data_smooth = False\n            self._smooth_fwhm = data\n        self._is_data_smooth = True\n\ndef smooth_fwhm_from_data_with_noise(self, data, noise):\n        \"\"\" Set a smoothing Gaussian kernel given its FWHM in mm.  \"\"\"\n        if data != self._smooth_fwhm:\n            self._is_data_smooth = False\n            self._smooth_fwhm = data\n        self._is_data_smooth = True\n\ndef smooth_fwhm_from_data_with_noise_with_noise(self, data, noise, noise_with_noise):\n        \"\"\" Set a smoothing Gaussian kernel given its FWHM in mm.  \"\"\"\n        if data != self._smooth_fwhm:\n            self._is_data_smooth = False\n            self._smooth_fwhm = data\n        self._is_data_smooth = True\n\ndef smooth_fwhm_from_data_with_noise_with_noise_with_",
        "\n\ndef apply_mask_to_data(self, mask_img, data):\n        \"\"\"First set_mask and the get_masked_data.\n\n        Parameters\n        ----------\n        mask_img:  nifti-like image, NeuroImage or str\n            3D mask array: True where a voxel should be used\n            Can either be:\n            - a file path to a Nifti image, NeuroImage or str\n            - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n            If niimg is a string, consider it as a path to Nifti image and\n            call nibabel.load on it, if it is an object, check if get_data()\n            and get_affine() methods are present, raise TypeError otherwise\n\n        Returns\n        -------\n        The masked data deepcopied\n        \"\"\"\n        self.set_mask(mask_img)\n        return self.get_data(masked=True, smoothed=True, safe_copy=True, data=data)\n\ndef apply_mask_to_affine(self, mask_img, affine):\n        \"\"\"First set_mask and the get_masked_data.\n\n        Parameters\n        ----------\n        mask_img:  nifti-like image,",
        "\n\ndef load_mask(mask_file, allow_empty=True):\n        \"\"\"Loads a mask from a file.\n\n        Parameters\n        ----------\n        mask_file: str\n            Path to a file with a mask array.\n            If it is a string, consider it as a path to a Nifti image and\n            call nibabel.load on it. If it is an object, check if get_data() and get_affine() methods are present, raise TypeError otherwise.\n\n        Returns\n        -------\n        mask: np.ndarray\n            Mask array.\n        \"\"\"\n        if isinstance(mask_file, str):\n            mask_file = nibabel.load(mask_file)\n        if isinstance(mask_file, nibabel.Nifti1Image):\n            mask = mask_file.get_data()\n        elif isinstance(mask_file, nibabel.Nifti2Image):\n            mask = mask_file.get_data()\n        elif isinstance(mask_file, nibabel.Nifti3Image):\n            mask = mask_file.get_data()\n        elif isinstance(mask_file, nibabel.Nifti4Image):\n            mask = mask_file.get_data()\n        elif isinstance(mask_file, nibabel.Nifti5Image):\n            mask = mask",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef apply_smooth_fwhm(self, smooth_fwhm):\n        \"\"\"Set self._smooth_fwhm and then smooths the data.\n        See boyle.nifti.smooth.smooth_imgs.\n\n        Returns\n        -------\n        the smoothed data deepcopied.\n\n        \"\"\"\n        if smooth_fwhm <= 0:\n            return\n\n        old_smooth_fwhm   = self._smooth_fwhm\n        try:\n            data = self.get_data(smoothed=True, masked=True, safe_copy=True)\n        except ValueError as ve:\n            self._smooth_fwhm = old_smooth_fwhm\n            raise\n        else:\n            self._smooth_fwhm = smooth_fwhm\n            return data\n\ndef apply_smooth_fwhm_to_all(self, smooth_fwhm):\n        \"\"\"Set self._smooth_fwhm and then smooths the data.\n        See boyle.nifti.smooth.smooth_imgs.\n\n        Returns\n        -------\n        the smoothed data deepcopied.\n\n        \"\"\"\n        if smooth_fwhm <= 0:\n            return\n\n        old_smooth_fwhm   = self._smooth_fwhm",
        "\n\ndef get_mask_indices(self):\n        \"\"\"Return a tuple of indices (np.ndarray), tuple of the mask shape.\n\n        Returns\n        -------\n        np.ndarray, tuple of indices (np.ndarray), tuple of the mask shape\n        \"\"\"\n        return self.get_data(smoothed=True, masked=True, safe_copy=False)[self.get_mask_indices()],\\\n               self.get_mask_indices(), self.mask.shape\n\ndef get_mask_shape(self):\n        \"\"\"Return a tuple of indices (np.ndarray), tuple of the mask shape.\n\n        Returns\n        -------\n        np.ndarray, tuple of indices (np.ndarray), tuple of the mask shape\n        \"\"\"\n        return self.get_data(smoothed=True, masked=True, safe_copy=False)[self.get_mask_indices()],\\\n               self.get_mask_indices(), self.mask.shape\n\ndef get_mask_indices_and_shape(self):\n        \"\"\"Return a tuple of indices (np.ndarray), tuple of the mask shape.\n\n        Returns\n        -------\n        np.ndarray, tuple of indices (np.ndarray), tuple of the mask shape\n        \"\"\"\n        return self.get_data(smoothed=True, masked=True, safe_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\ndef get_3D_from_2D(filename, vol_idx=0):\n    \"\"\"Return a 3D volume from a 2D nifti image file\n\n    Parameters\n    ----------\n    filename: str\n        Path to the 2D .mhd file\n\n    vol_idx: int\n        Index of the 3D volume to be extracted from the 2D volume.\n\n    Returns\n    -------\n    vol, hdr\n        The data array and the new 3D image header.\n    \"\"\"\n    def remove_2th_element_from_hdr_string(hdr, fieldname):\n        if fieldname in hdr:\n            hdr[fieldname] = ' '.join(hdr[fieldname].split()[:3])\n\n    vol, hdr = load_raw_data_with_mhd(filename)\n\n    if vol.ndim != 3:\n        raise ValueError('Volume in {} does not have 3 dimensions.'.format(op.join(op.dirname(filename),\n                                                                                   hdr['ElementDataFile'])))\n\n    if not 0 <= vol_idx < vol.shape[2]:\n        raise IndexError('IndexError: 2th dimension in volume {} has {} volumes, not {}.'.format(filename,\n                                                                                                 vol.shape[2], vol_idx))\n\n    new_vol = vol[:, :,",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n    return h5group\n\ndef spatialimg_from_hdfgroup(h5group, h5path):\n    \"\"\"Loads a Nifti1Image from an HDF5 group.\n\n    Parameters\n    ----------\n    h5group: h5py Group\n        Input HDF5 file path\n\n    h5path: str\n        HDF5 group path where the image data will be loaded.\n        Datasets will be created inside the given group path:\n        'data', 'extra', 'affine', the header information will\n        be set as attributes of the 'data' dataset.\n\n    \"\"\"\n    try:\n        h5group['data'] = h5py.File(h5path, 'r')\n\n    except ValueError as ve:\n        raise Exception('Error loading group ' + h5group.name) from ve\n\n    return h5group['data']\n\ndef spatialimg_from_hdffile(h5file, h5path):\n    \"\"\"Loads a Nifti1Image from an HDF5 file.\n\n    Parameters\n    ----------\n    h5file: h5py File\n        Input HDF5 file path\n\n    h5path: str\n        HDF5 group path where the image data will be loaded.\n        Datasets will be created inside the given group path:\n        'data', 'extra",
        "\n\n    return file_path\n\ndef spatialimg_to_hdfgroup(h5img, spatial_img):\n    \"\"\"Saves a Nifti1Image into an HDF5 group.\n\n    Parameters\n    ----------\n    h5img: h5py.Group\n        HDF5 group to save the image data\n\n    spatial_img: nibabel SpatialImage\n        Image to be saved\n\n    \"\"\"\n    h5img.create_dataset('data', spatial_img.data,\n                        attributes=['data', 'extra', 'affine'])\n    h5img.create_dataset('extra', spatial_img.extra,\n                        attributes=['extra'])\n    h5img.create_dataset('affine', spatial_img.affine,\n                        attributes=['affine'])\n\ndef spatialimg_from_hdfpath(file_path, h5path=None, append=True):\n    \"\"\"Loads a Nifti1Image from an HDF5 file.\n\n    Parameters\n    ----------\n    file_path: string\n        Input HDF5 file path\n\n    h5path: string\n        HDF5 group path where the image data will be saved.\n        Datasets will be created inside the given group path:\n        'data', 'extra', 'affine', the header information will\n        be set as attributes of the '",
        "\n\ndef get_nifti1hdr_from_hdf5(hdf5file):\n    \"\"\"Transforms an HDF5 file to a dict.\n    Converts unicode string keys into standard strings\n    and each value into a numpy array.\n\n    Parameters\n    ----------\n    hdf5file: HDF5 file\n\n    Returns\n    --------\n    dict\n    \"\"\"\n    hdr = nib.Nifti1Header()\n    for k in list(hdf5file.keys()):\n        hdr[str(k)] = np.array(hdf5file[k])\n\n    return hdr\n\ndef get_nifti1hdr_from_hdf5_file(hdf5file):\n    \"\"\"Transforms an HDF5 file to a dict.\n    Converts unicode string keys into standard strings\n    and each value into a numpy array.\n\n    Parameters\n    ----------\n    hdf5file: HDF5 file\n\n    Returns\n    --------\n    dict\n    \"\"\"\n    hdr = nib.Nifti1Header()\n    for k in list(hdf5file.keys()):\n        hdr[str(k)] = np.array(hdf5file[k])\n\n    return hdr\n\ndef get_nifti1hdr_from_hdf5_file_with_header(hdf5file, hdr):\n    \"\"\"Transforms an HDF5 file to",
        "\n\ndef hdfgroup_to_nifti1image(h5group):\n    \"\"\"Returns in a list all images found under h5group.\n\n    Parameters\n    ----------\n    h5group: h5py.Group\n        HDF group\n\n    Returns\n    -------\n    list of nifti1Image\n    \"\"\"\n    child_nodes = []\n    def append_parent_if_dataset(name, obj):\n        if isinstance(obj, h5py.Dataset):\n            if name.split('/')[-1] == 'data':\n                child_nodes.append(obj.parent)\n\n    vols = []\n    h5group.visititems(append_parent_if_dataset)\n    for c in child_nodes:\n        vols.append(hdfgroup_to_nifti1image(c))\n\n    return vols\n\ndef hdfgroup_to_nifti1image_from_hdf(h5group):\n    \"\"\"Returns in a list all images found under h5group.\n\n    Parameters\n    ----------\n    h5group: h5py.Group\n        HDF group\n\n    Returns\n    -------\n    list of nifti1Image\n    \"\"\"\n    child_nodes = []\n    def append_parent_if_dataset(name, obj):\n        if",
        "\n\n    return\n\n\ndef insert_volumes_in_two_datasets(file_path, h5path, file_list, newshape=None,\n                                 concat_axis=0, dtype=None, append=True):\n    \"\"\"Inserts all given nifti files from file_list into two datasets in fname.\n    This will not check if the dimensionality of all files match.\n\n    Parameters\n    ----------\n    file_path: string\n        HDF5 file path\n\n    h5path: string\n\n    file_list: list of strings\n\n    newshape: tuple or lambda function\n        If None, it will not reshape the images.\n        If a lambda function, this lambda will receive only the shape array.\n        e.g., newshape = lambda x: (np.prod(x[0:3]), x[3])\n        If a tuple, it will try to reshape all the images with the same shape.\n        It must work for all the images in file_list.\n\n    concat_axis: int\n        Axis of concatenation after reshaping\n\n    dtype: data type\n    Dataset data type\n    If not set, will use the type of the first file.\n\n    append: bool\n\n    Raises\n    ------\n    ValueError if concat_axis is bigger than data dimensionality.\n\n    Note\n    ----",
        "\n\n\ndef combinations(iterable, n):\n    \"\"\"\n    Generate all combinations of the elements of iterable and its subsets.\n\n    Parameters\n    ----------\n    iterable: list, set or dict or any iterable object\n    n: int\n\n    Returns\n    -------\n    A generator of all possible combinations of the iterable.\n\n    Example:\n    -------\n    >>> for i in treefall([1, 2, 3, 4, 5]): print(i)\n    >>> (1, 2, 3)\n    >>> (1, 2)\n    >>> (1, 3)\n    >>> (2, 3)\n    >>> (1,)\n    >>> (2,)\n    >>> (3,)\n    >>> ()\n    \"\"\"\n    if n == 0:\n        return iterable\n    if n == 1:\n        yield iterable\n        return\n    if n == 2:\n        yield iterable[0]\n        yield iterable[1]\n        return\n    if n == 3:\n        yield iterable[0]\n        yield iterable[1]\n        yield iterable[2]\n        return\n    if n == 4:\n        yield iterable[0]\n        yield iterable[1]\n        yield iterable[2]\n        yield iterable[3]\n        return\n    if n == 5:\n        yield iterable[0]\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;",
        ")\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef execute_reliabledictionary_with_custom_headers(client, application_name, service_name, input_file, custom_headers):\n    \"\"\"Execute create, update, delete operations on existing reliable dictionaries.\n\n    carry out create, update and delete operations on existing reliable dictionaries for given application and service.\n\n    :param application_name: Name of the application.\n    :type application_name: str\n    :param service_name: Name of the service.\n    :type service_name: str\n    :param input_file: input file with list of json to provide the operation information for reliable dictionaries.\n    :type input_file: str\n    :param custom_headers: custom headers to be added to the request.\n    :type custom_headers: dict\n    :param output_file: input file with list of json to provide the operation information for reliable dictionaries.\n    :type output_file: str\n    \"\"\"\n\n    cluster = Cluster.from_sfclient(client)\n    service = cluster.get_application(application_name).get_service(service_name)\n\n    # call get service with headers and params\n    with open(input_file) as json_file:\n        json_data = json.load(json_file)\n        service.execute(json_data, custom_headers)\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "_token\n\n\ndef set_aad_metadata(authority_uri, cluster_id, client_id):\n    \"\"\"Set AAD metadata\"\"\"\n    from azure.servicefabric.service_fabric_client_ap_is import (\n        ServiceFabricClientAPIs\n    )\n    from azure.servicefabric.service_fabric_client_ap_is import (\n        ServiceFabricClientAPIs\n    )\n    from azure.servicefabric.service_fabric_client_ap_is import (\n        ServiceFabricClientAPIs\n    )\n    from azure.servicefabric.service_fabric_client_ap_is import (\n        ServiceFabricClientAPIs\n    )\n    from azure.servicefabric.service_fabric_client_ap_is import (\n        ServiceFabricClientAPIs\n    )\n    from azure.servicefabric.service_fabric_client_ap_is import (\n        ServiceFabricClientAPIs\n    )\n    from azure.servicefabric.service_fabric_client_ap_is import (\n        ServiceFabricClientAPIs\n    )\n    from azure.servicefabric.service_fabric_client_ap_is import (\n        ServiceFabricClientAPIs\n    )\n    from azure.servicefabric.service_fabric_client_ap_is import (\n        ServiceFabricClientAPI",
        "\n    return wb\n\n\ndef _openpyxl_write_xl(xl_path: str, wb: Workbook) -> None:\n    \"\"\" Use openpyxl to write an Excel file. \"\"\"\n    try:\n        wb.save(filename=xl_path)\n    except:\n        raise\n\n\ndef _openpyxl_write_workbook(wb: Workbook, xl_path: str) -> None:\n    \"\"\" Use openpyxl to write an Excel file. \"\"\"\n    try:\n        wb.save(filename=xl_path)\n    except:\n        raise\n\n\ndef _openpyxl_write_workbook_to_file(wb: Workbook, xl_path: str) -> None:\n    \"\"\" Use openpyxl to write an Excel file. \"\"\"\n    try:\n        wb.save(filename=xl_path)\n    except:\n        raise\n\n\ndef _openpyxl_write_workbook_to_file_with_header(wb: Workbook, xl_path: str, header: str) -> None:\n    \"\"\" Use openpyxl to write an Excel file. \"\"\"\n    try:\n        wb.save(filename=xl_path, header=header)\n    except:\n        raise\n\n\ndef _openpyxl_write_workbook_to_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ", choice)\n\n\ndef _check_xl_path(xl_path: str):\n    \"\"\" Check if the Excel file is valid.\n\n    :param xl_path: The path to the Excel file.\n    :type xl_path: str\n    :return: The path to the Excel file, or None if it is invalid.\n    :rtype: tuple\n    \"\"\"\n    try:\n        xl_path = os.path.abspath(xl_path)\n    except OSError:\n        return None, None\n\n    if not os.path.isfile(xl_path):\n        return None, None\n\n    return xl_path, XL_READERS[XL_READER_DEFAULT]\n\n\nXL_READERS = {\n    XL_READER_DEFAULT: ExcelReader,\n    XL_READER_XLS: ExcelReader,\n    XL_READER_XLSX: ExcelReader,\n    XL_READER_XLSX_WITH_HEADER: ExcelReader,\n    XL_READER_XLSX_WITH_FOOTER: ExcelReader,\n    XL_READER_XLSX_WITH_HEADER_FOOTER: ExcelReader,\n    XL_READER_XLSX_WITH_FOOTER_WITH_HEADER",
        "\n\n\ndef get_sheet_names(xl_path: str) -> List:\n    \"\"\"Return a list with the names of the sheets in\n    the Excel file in `xl_path`.\n    \"\"\"\n    wb = read_xl(xl_path)\n\n    if hasattr(wb, 'sheetnames'):\n        return wb.sheetnames\n    else:\n        return wb.sheet_names()\n\n\ndef get_sheet_names_by_name(xl_path: str) -> List:\n    \"\"\"Return a list with the names of the sheets in\n    the Excel file in `xl_path`.\n    \"\"\"\n    wb = read_xl(xl_path)\n\n    if hasattr(wb, 'sheetnames'):\n        return wb.sheetnames\n    else:\n        return wb.sheet_names_by_name()\n\n\ndef get_sheet_names_by_name_and_index(xl_path: str, sheet_name: str, sheet_index: int) -> List:\n    \"\"\"Return a list with the names of the sheets in\n    the Excel file in `xl_path`.\n    \"\"\"\n    wb = read_xl(xl_path)\n\n    if hasattr(wb, 'sheetnames'):\n        return wb.sheetnames\n    else:\n        return wb.sheet_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;",
        "\n\ndef _check_cols(df, cols):\n    \"\"\" Check that the `cols` column of `df` is a list of strings.\"\"\"\n    if not isinstance(cols, list):\n        raise ValueError('cols must be a list of strings')\n\n    for col in cols:\n        if not isinstance(df[col], str):\n            raise ValueError('cols must be a list of strings')\n\ndef _check_columns(df, cols):\n    \"\"\" Check that the `cols` column of `df` is a list of strings.\"\"\"\n    if not isinstance(cols, list):\n        raise ValueError('cols must be a list of strings')\n\n    for col in cols:\n        if not isinstance(df[col], str):\n            raise ValueError('cols must be a list of strings')\n\ndef _check_columns_names(df, cols):\n    \"\"\" Check that the `cols` column of `df` is a list of strings.\"\"\"\n    if not isinstance(cols, list):\n        raise ValueError('cols must be a list of strings')\n\n    for col in cols:\n        if not isinstance(df[col], str):\n            raise ValueError('cols must be a list of strings')\n\ndef _check_columns_names_and_types(df, cols):\n    \"\"\" Check that the `cols` column of `df` is",
        "\n\ndef _check_cols(df, cols):\n    \"\"\" Check that the columns in `df` are in `cols`.\"\"\"\n    if not all(col in df for col in cols):\n        raise ValueError(\"Column names must be in `cols`\")\n\n\ndef _check_values(df, values):\n    \"\"\" Check that the values in `df` are in `values`.\"\"\"\n    if not all(val in df for val in values):\n        raise ValueError(\"Values must be in `values`\")\n\n\ndef _check_columns(df, cols):\n    \"\"\" Check that the columns in `df` are in `cols`.\"\"\"\n    if not all(col in df for col in cols):\n        raise ValueError(\"Column names must be in `cols`\")\n\n\ndef _check_index(df, index):\n    \"\"\" Check that the index in `df` is in `index`.\"\"\"\n    if not all(index in df for index in index):\n        raise ValueError(\"Index names must be in `index`\")\n\n\ndef _check_columns_and_values(df, cols, values):\n    \"\"\" Check that the columns in `df` and `values` are in `cols` and `values`.\"\"\"\n    _check_columns(df, cols)\n    _check_values(df, values)\n\n\n",
        ",\n\n    # If the values are not duplicated, return the values\n    if not values.duplicated():\n        return values\n\n    # If the values are duplicated, return the values\n    if values.duplicated() == values:\n        return values\n\n    # If the values are not duplicated, return the values\n    if values.duplicated() != values:\n        return values\n\n    # If the values are duplicated, return the values\n    if values.duplicated() == values.duplicated():\n        return values\n\n    # If the values are not duplicated, return the values\n    if values.duplicated() != values.duplicated():\n        return values\n\n    # If the values are duplicated, return the values\n    if values.duplicated() == values.duplicated():\n        return values\n\n    # If the values are duplicated, return the values\n    if values.duplicated() != values.duplicated():\n        return values\n\n    # If the values are duplicated, return the values\n    if values.duplicated() == values.duplicated():\n        return values\n\n    # If the values are duplicated, return the values\n    if values.duplicated() != values.duplicated():\n        return values\n\n    # If the values are duplicated, return the values\n    if values.duplicated() == values.duplicated():",
        "\n\ndef _to_datetime(data):\n    \"\"\" Convert to datetime all values in `data`.\n\n    Parameters\n    ----------\n    data: dict[str]->object\n\n    Returns\n    -------\n    datetime_data: dict[str]->datetime\n    \"\"\"\n    sdata = data.copy()\n    for k, v in data.items():\n        if isinstance(v, datetime):\n            sdata[k] = timestamp_to_date_str(v)\n\n        elif not isinstance(v, (string_types, float, int)):\n            sdata[k] = datetime.strptime(str(v), '%Y-%m-%dT%H:%M:%S')\n\n    return sdata\n\n\ndef timestamp_to_date_str(timestamp):\n    \"\"\" Convert to string all values in `timestamp`.\n\n    Parameters\n    ----------\n    timestamp: datetime\n\n    Returns\n    -------\n    string_data: dict[str]->str\n    \"\"\"\n    sdata = timestamp.copy()\n    for k, v in timestamp.items():\n        if isinstance(v, datetime):\n            sdata[k] = timestamp_to_date_str(v)\n\n        elif not isinstance(v, (string_types, float, int)):\n            sdata[k] = str(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef search_unique(table, sample, unique_fields=None):\n    \"\"\"Search in `table` an item with the value of the `unique_fields` in the `sample` sample.\n    Check if the the obtained result is unique. If nothing is found will return an empty list,\n    if there is more than one item found, will raise an IndexError.\n\n    Parameters\n    ----------\n    table: tinydb.table\n\n    sample: dict\n        Sample data\n\n    unique_fields: list of str\n        Name of fields (keys) from `data` which are going to be used to build\n        a sample to look for exactly the same values in `data`.\n        If None, will use every key in `data`.\n\n    Returns\n    -------\n    eid: int\n        Id of the object found with same `unique_fields`.\n        None if none found.\n\n    Raises\n    ------\n    MoreThanOneItemError\n        If more than one example is found.\n    \"\"\"\n    if unique_fields is None:\n        unique_fields = [key for key in sample.keys()]\n    if len(unique_fields) > 1:\n        raise IndexError(\"More than one unique field found\")\n    if unique_fields[0] not in table.columns:\n        raise IndexError(\"Unique field not found\")\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef search_by_name(self, table_name, name):\n        \"\"\"Return the element in `table_name` with name `name`.\n        If None is found will raise a KeyError exception.\n\n        Parameters\n        ----------\n        table_name: str\n            The name of the table to look in.\n\n        name: str\n            The name of the element to look for.\n\n        Returns\n        -------\n        elem: tinydb.database.Element\n\n        Raises\n        ------\n        KeyError\n            If the element with name `name` is not found.\n        \"\"\"\n        elem = self.table(table_name).get(name=name)\n        if elem is None:\n            raise KeyError('Could not find {} with name {}.'.format(table_name, name))\n\n        return elem\n\ndef search_by_type(self, table_name, type):\n        \"\"\"Return the element in `table_name` with type `type`.\n        If None is found will raise a KeyError exception.\n\n        Parameters\n        ----------\n        table_name: str\n            The name of the table to look in.\n\n        type: str\n            The type of the element to look for.\n\n        Returns\n        -------\n        elem: tinydb.database.Element\n\n        Raises\n        ------\n        KeyError\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef find_unique(self, table_name, sample, unique_fields=None):\n        \"\"\"Return an item with the value of `unique_fields`\n        from `data` is unique in the table with `table_name`.\n        False if no sample is found or more than one is found.\n\n        See function `find_unique` for more details.\n\n        Parameters\n        ----------\n        table_name: str\n\n        sample: dict\n            Sample data for query\n\n        unique_fields: str or list of str\n\n        Returns\n        -------\n        eid: str\n        \"\"\"\n        try:\n            eid = find_unique(self.table(table_name),\n                              sample=sample,\n                              unique_fields=unique_fields)\n        except:\n            return False\n        else:\n            return eid is not None\n\ndef find_unique_by_id(self, table_name, sample, unique_fields=None):\n        \"\"\"Return an item with the value of `unique_fields`\n        from `data` is unique in the table with `table_name`.\n        False if no sample is found or more than one is found.\n\n        See function `find_unique` for more details.\n\n        Parameters\n        ----------\n        table_name: str\n\n        sample: dict\n            Sample",
        "\n\ndef find_unique(self, table_name, data, unique_fields=None):\n        \"\"\"Find the unique matching element with a given set of fields.\n\n        Parameters\n        ----------\n        table_name: str\n\n        fields: dict or function[dict -> None]\n            new data/values to insert into the unique element\n            or a method that will update the elements.\n\n        data: dict\n            Sample data for query\n\n        unique_fields: list of str\n\n        Raises\n        ------\n        IndexError:\n            If the element is not found for update\n        \"\"\"\n        eid = self.table(table_name).find_unique(data, unique_fields)\n        if eid is None:\n            raise IndexError('Could not find {} with {}'.format(table_name, data))\n        return eid\n\ndef _to_string(fields):\n    \"\"\"Convert a dict to a string.\n\n    Parameters\n    ----------\n    fields: dict\n        A dict or function[dict -> None]\n        A dict or function[dict -> None]\n        A dict or function[dict -> None]\n        A dict or function[dict -> None]\n        A dict or function[dict -> None]\n        A dict or function[dict -> None]\n        A dict or function[dict -> None]\n        A dict or",
        "\n\ndef search_sample(table, sample):\n        \"\"\"Return a list of items that match the `sample` field values in table `table`.\n        Check function search_sample for more details.\n        \"\"\"\n        return list(search_sample(table=table,\n                                 sample=sample))\n\n\ndef search_sample(table, sample):\n        \"\"\"Return a list of items that match the `sample` field values in table `table`.\n        Check function search_sample for more details.\n        \"\"\"\n        return list(search_sample(table=table,\n                                 sample=sample))\n\n\ndef search_sample_by_id(table, sample):\n        \"\"\"Return a list of items that match the `sample` field values in table `table`.\n        Check function search_sample for more details.\n        \"\"\"\n        return list(search_sample_by_id(table=table,\n                                      sample=sample))\n\n\ndef search_sample_by_id(table, sample):\n        \"\"\"Return a list of items that match the `sample` field values in table `table`.\n        Check function search_sample for more details.\n        \"\"\"\n        return list(search_sample_by_id(table=table,\n                                      sample=sample))\n\n\ndef search_sample_by_name(table, sample):\n       ",
        "\n\ndef is_img_array(obj):\n    \"\"\" Check for get_data and get_affine method in an object\n\n    Parameters\n    ----------\n    obj: any object\n        Tested object\n\n    Returns\n    -------\n    is_img_array: boolean\n        True if get_data and get_affine methods are present and callable,\n        False otherwise.\n    \"\"\"\n    try:\n        get_data   = getattr(obj, 'get_data')\n        get_affine = getattr(obj, 'get_affine')\n\n        return isinstance(get_data,   collections.Callable) and \\\n               isinstance(get_affine, collections.Callable)\n    except AttributeError:\n        return False\n\ndef is_img_array_array(obj):\n    \"\"\" Check for get_data and get_affine method in an object\n\n    Parameters\n    ----------\n    obj: any object\n        Tested object\n\n    Returns\n    -------\n    is_img_array_array: boolean\n        True if get_data and get_affine methods are present and callable,\n        False otherwise.\n    \"\"\"\n    try:\n        get_data   = getattr(obj, 'get_data')\n        get_affine = getattr(obj, 'get_affine')\n\n        return isinstance(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\ndef get_shape_from_file(filename):\n    \"\"\"Return the shape of img.\n\n    Paramerers\n    -----------\n    filename:\n\n    Returns\n    -------\n    shape: tuple\n    \"\"\"\n    with open(filename, 'rb') as f:\n        return get_shape(f)\n\ndef get_shape_from_image(img):\n    \"\"\"Return the shape of img.\n\n    Paramerers\n    -----------\n    img:\n\n    Returns\n    -------\n    shape: tuple\n    \"\"\"\n    return get_shape(img)\n\ndef get_shape_from_image_array(img_array):\n    \"\"\"Return the shape of img.\n\n    Paramerers\n    -----------\n    img_array:\n\n    Returns\n    -------\n    shape: tuple\n    \"\"\"\n    return get_shape(img_array)\n\ndef get_shape_from_image_array_with_shape(img_array, shape):\n    \"\"\"Return the shape of img.\n\n    Paramerers\n    -----------\n    img_array:\n    shape: tuple\n\n    Returns\n    -------\n    shape: tuple\n    \"\"\"\n    return get_shape(img_array, shape)\n\ndef get_shape_from_image_array_with_shape_from",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        " ValueError('Affine matrix of one_img and another_img are not close.')\n\n\ndef have_same_affine_3d(one_img, another_img, only_check_3d=False):\n    \"\"\"Return True if the affine matrix of one_img is close to the affine matrix of another_img.\n    False otherwise.\n\n    Parameters\n    ----------\n    one_img: nibabel.Nifti1Image\n\n    another_img: nibabel.Nifti1Image\n\n    only_check_3d: bool\n        If True will extract only the 3D part of the affine matrices when they have more dimensions.\n\n    Returns\n    -------\n    bool\n\n    Raises\n    ------\n    ValueError\n\n    \"\"\"\n    img1 = check_img(one_img)\n    img2 = check_img(another_img)\n    ndim1 = len(img1.shape)\n    ndim2 = len(img2.shape)\n\n    if ndim1 < 3:\n        raise ValueError('Image {} has only {} dimensions, at least 3 dimensions is expected.'.format(repr_imgs(img1), ndim1))\n\n    if ndim2 < 3:\n        raise ValueError('Image {} has only {} dimensions, at least 3 dimensions is expected.'.format(repr_imgs(",
        "\n\ndef get_shape(imgs):\n    \"\"\"Get shape of img or imgs\"\"\"\n    if isinstance(imgs, string_types):\n        return imgs\n\n    if isinstance(imgs, collections.Iterable):\n        return '[{}]'.format(', '.join(get_shape(img) for img in imgs))\n\n    return repr(imgs.shape)\n\ndef get_affine(imgs):\n    \"\"\"Get affine of img or imgs\"\"\"\n    if isinstance(imgs, string_types):\n        return imgs\n\n    if isinstance(imgs, collections.Iterable):\n        return '[{}]'.format(', '.join(get_affine(img) for img in imgs))\n\n    return repr(imgs.affine)\n\ndef get_shape_from_affine(affine):\n    \"\"\"Get shape of img or imgs\"\"\"\n    if isinstance(affine, string_types):\n        return affine\n\n    if isinstance(affine, collections.Iterable):\n        return '[{}]'.format(', '.join(get_shape_from_affine(affine) for affine in affine))\n\n    return repr(affine.shape)\n\ndef get_affine_from_shape(shape):\n    \"\"\"Get affine of img or imgs\"\"\"\n    if isinstance(shape, string_",
        "\n\ndef have_same_shape_with_dtype(array1, array2, dtype, nd_to_check=None):\n    \"\"\"\n    Returns true if array1 and array2 have the same shapes, false\n    otherwise.\n\n    Parameters\n    ----------\n    array1: numpy.ndarray\n\n    array2: numpy.ndarray\n\n    dtype: numpy.dtype\n        The dtype of the arrays to check.\n\n    nd_to_check: int\n        Number of the dimensions to check, i.e., if == 3 then will check only the 3 first numbers of array.shape.\n    Returns\n    -------\n    bool\n    \"\"\"\n    shape1 = array1.shape\n    shape2 = array2.shape\n    if nd_to_check is not None:\n        if len(shape1) < nd_to_check:\n            msg = 'Number of dimensions to check {} is out of bounds for the shape of the first image: \\n{}\\n.'.format(shape1, dtype)\n            raise ValueError(msg)\n        elif len(shape2) < nd_to_check:\n            msg = 'Number of dimensions to check {} is out of bounds for the shape of the second image: \\n{}\\n.'.format(shape2, dtype)\n            raise ValueError(msg)\n\n        shape1 = shape1",
        "\n\ndef filter_list(ls, filt):\n    \"\"\"Filter a list of strings based on a regex.\n\n    @param ls: list of strings\n    @param filt: function\n    @return: list of strings\n    \"\"\"\n    return [l for l in ls if filt(l)]\n\ndef match_regex(regex, wd=os.curdir):\n    \"\"\"Create a list of regex matches that result from the match_regex\n    of all file names within wd.\n    The list of files will have wd as path prefix.\n\n    @param regex: string\n    @param wd: string\n    working directory\n    @return: list of strings\n    \"\"\"\n    ls = os.listdir(wd)\n\n    filt = re.compile(regex).match\n    return filter_list(ls, filt)\n\ndef match_regex_all(regex, wd=os.curdir):\n    \"\"\"Create a list of regex matches that result from the match_regex\n    of all file names within wd.\n    The list of files will have wd as path prefix.\n\n    @param regex: string\n    @param wd: string\n    working directory\n    @return: list of strings\n    \"\"\"\n    ls = os.listdir(wd)\n\n    filt = re.compile(regex).match\n    return filter_list",
        "\n\ndef recursive_file_match(folder_path, regex=''):\n    \"\"\"\n    Returns absolute paths of files that match the regex within folder_path and\n    all its children files.\n\n    Note: The regex matching is done using the match function\n    of the re module.\n\n    Parameters\n    ----------\n    folder_path: string\n\n    regex: string\n\n    Returns\n    -------\n    A list of strings.\n    \"\"\"\n    outlist = []\n    for root, dirs, files in os.walk(folder_path):\n        outlist.extend([op.join(root, f) for f in files\n                        if re.match(regex, f)])\n\n    return outlist\n\ndef recursive_dir_list(folder_path, regex=''):\n    \"\"\"\n    Returns absolute paths of folders that match the regex within folder_path and\n    all its children folders.\n\n    Note: The regex matching is done using the match function\n    of the re module.\n\n    Parameters\n    ----------\n    folder_path: string\n\n    regex: string\n\n    Returns\n    -------\n    A list of strings.\n    \"\"\"\n    outlist = []\n    for root, dirs, files in os.walk(folder_path):\n        outlist.extend([op.join(root, f",
        "\n\ndef search_list(file_list, regex):\n    \"\"\"\n    Searches for files that match the regex within file_list.\n    The list of files will have file_dir as path prefix.\n\n    Parameters\n    ----------\n    @param file_list:\n\n    @param regex:\n\n    Returns:\n    --------\n    List of paths to files that match the regex\n    \"\"\"\n    file_list = [op.join(file_dir, fname) for fname in file_list]\n    file_list = [fname for fname in file_list if fname.endswith(regex)]\n    return file_list\n\ndef get_file_list_by_extension(file_dir, extension):\n    \"\"\"\n    Creates a list of files that match the search_regex within file_dir.\n    The list of files will have file_dir as path prefix.\n\n    Parameters\n    ----------\n    @param file_dir:\n\n    @param extension:\n\n    Returns:\n    --------\n    List of paths to files that match the search_regex\n    \"\"\"\n    file_list = os.listdir(file_dir)\n    file_list.sort()\n\n    if extension:\n        file_list = search_list(file_list, extension)\n\n    file_list = [op.join",
        "\n\ndef recursive_find_search_recursive(folder_path, regex=''):\n    \"\"\"\n    Returns absolute paths of files that match the regex within file_dir and\n    all its children folders.\n\n    Note: The regex matching is done using the search function\n    of the re module.\n\n    Parameters\n    ----------\n    folder_path: string\n\n    regex: string\n\n    Returns\n    -------\n    A list of strings.\n\n    \"\"\"\n    outlist = []\n    for root, dirs, files in os.walk(folder_path):\n        outlist.extend([op.join(root, f) for f in files\n                        if re.search(regex, f)])\n\n    return outlist\n\ndef recursive_find_search_recursive_recursive(folder_path, regex=''):\n    \"\"\"\n    Returns absolute paths of files that match the regex within file_dir and\n    all its children folders.\n\n    Note: The regex matching is done using the search function\n    of the re module.\n\n    Parameters\n    ----------\n    folder_path: string\n\n    regex: string\n\n    Returns\n    -------\n    A list of strings.\n\n    \"\"\"\n    outlist = []\n    for root, dirs, files in os.walk(folder_path):\n        outlist.extend",
        "\n                outlist = []\n        else:\n            yield root\n\n\ndef iter_recursive_find_all(folder_path, *regex):\n    \"\"\"\n    Returns absolute paths of files that match the regexs within folder_path and\n    all its children folders.\n\n    This is an iterator function that will use yield to return each set of\n    file_paths in one iteration.\n\n    Will only return value if all the strings in regex match a file name.\n\n    Note: The regex matching is done using the search function\n    of the re module.\n\n    Parameters\n    ----------\n    folder_path: string\n\n    regex: strings\n\n    Returns\n    -------\n    A list of strings.\n    \"\"\"\n    for root, dirs, files in os.walk(folder_path):\n        if len(files) > 0:\n            outlist = []\n            for f in files:\n                for reg in regex:\n                    if re.search(reg, f):\n                        outlist.append(op.join(root, f))\n            if len(outlist) == len(regex):\n                yield outlist\n\n\ndef iter_recursive_find_all_recursive(folder_path, *regex):\n    \"\"\"\n    Returns absolute paths of files that match the regexs within folder_path and\n    all its children",
        "\n\n\ndef get_all_files_in_folder(folder):\n    \"\"\"\n    Generator that loops through all absolute paths of the files within folder\n\n    Parameters\n    ----------\n    folder: str\n    Root folder start point for recursive search.\n\n    Yields\n    ------\n    fpath: str\n    Absolute path of one file in the folders\n    \"\"\"\n    for path, dirlist, filelist in os.walk(folder):\n        for fn in filelist:\n            yield op.join(path, fn)\n\n\ndef get_all_files_in_folder_with_extension(folder, extension):\n    \"\"\"\n    Generator that loops through all absolute paths of the files within folder\n\n    Parameters\n    ----------\n    folder: str\n    Root folder start point for recursive search.\n\n    Yields\n    ------\n    fpath: str\n    Absolute path of one file in the folders\n    \"\"\"\n    for path, dirlist, filelist in os.walk(folder):\n        for fn in filelist:\n            if fn.endswith(extension):\n                yield op.join(path, fn)\n\n\ndef get_all_files_in_folder_with_extension_and_name(folder, extension, name):\n    \"\"\"\n    Generator that loops through all absolute paths of the files within folder\n\n    Parameters\n    ----------\n",
        "\n\ndef recursive_glob_recursive(base_directory, regex=''):\n    \"\"\"\n    Uses recursive_glob to find all files or folders that match the regex\n    starting from the base_directory.\n\n    Parameters\n    ----------\n    base_directory: str\n\n    regex: str\n\n    Returns\n    -------\n    files: list\n\n    \"\"\"\n    files = recursive_glob(base_directory, regex)\n    for path, dirlist, filelist in os.walk(base_directory):\n        for dir_name in dirlist:\n            files.extend(recursive_glob_recursive(path, regex))\n\n    return files\n\ndef recursive_glob_recursive_recursive(base_directory, regex=''):\n    \"\"\"\n    Uses recursive_glob_recursive to find all files or folders that match the regex\n    starting from the base_directory.\n\n    Parameters\n    ----------\n    base_directory: str\n\n    regex: str\n\n    Returns\n    -------\n    files: list\n\n    \"\"\"\n    files = recursive_glob_recursive(base_directory, regex)\n    for path, dirlist, filelist in os.walk(base_directory):\n        for dir_name in dirlist:\n            files.extend(recursive_glob_recursive_recursive(path, regex))\n\n    return files\n\ndef",
        "\n\n\ndef compose_msg(msg, **kwargs):\n    \"\"\"Append key-value pairs to msg, for display.\n\n    Parameters\n    ----------\n    msg: string\n        arbitrary message\n    kwargs: dict\n        arbitrary dictionary\n\n    Returns\n    -------\n    updated_msg: string\n        msg, with \"key: value\" appended. Only string values are appended.\n\n    Example\n    -------\n    >>> compose_msg('Error message with arguments...', arg_num=123, \\\n        arg_str='filename.nii', arg_bool=True)\n    'Error message with arguments...\\\\narg_str: filename.nii'\n    >>>\n    \"\"\"\n    updated_msg = msg\n    for k, v in sorted(kwargs.items()):\n        if isinstance(v, _basestring):  # print only str-like arguments\n            updated_msg += \"\\n\" + k + \": \" + v\n\n    return updated_msg\n\n\ndef compose_msg_with_kwargs(msg, **kwargs):\n    \"\"\"Append key-value pairs to msg, for display.\n\n    Parameters\n    ----------\n    msg: string\n        arbitrary message\n    kwargs: dict\n        arbitrary dictionary\n\n    Returns\n    -------\n    updated_msg: string\n        msg, with \"key: value\" appended. Only",
        "\n\ndef get_dicom_file_paths(dicom_file_paths):\n    \"\"\"\n    Gets a list of DICOM file absolute paths and returns a list of lists of\n    DICOM file paths. Each group contains a set of DICOM files that have\n    exactly the same headers.\n\n    Parameters\n    ----------\n    dicom_file_paths: list of str\n        List or set of DICOM file paths\n\n    Returns\n    -------\n    list of str\n        The key is one filepath representing the group (the first found).\n    \"\"\"\n    path_list = dicom_file_paths.copy()\n\n    path_groups = DefaultOrderedDict(DicomFileSet)\n\n    while len(path_list) > 0:\n        file_path1 = path_list.pop()\n        file_subgroup = [file_path1]\n\n        dist = SimpleDicomFileDistance(field_weights=header_fields)\n\n        dist.set_dicom_file1(file_path1)\n        j = len(path_list)-1\n        while j >= 0:\n            file_path2 = path_list[j]\n            dist.set_dicom_file2(file_path2)\n\n            if dist.transform():\n                file_subgroup.append(file_path2)\n               ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef calculate_file_distances_from_files(dicom_files, field_weights=None,\n                                       dist_method_cls=None, **kwargs):\n    \"\"\"\n    Calculates the DicomFileDistance between all files in dicom_files, using an\n    weighted Levenshtein measure between all field names in field_weights and\n    their corresponding weights.\n\n    Parameters\n    ----------\n    dicom_files: iterable of str\n        Dicom file paths\n\n    field_weights: dict of str to float\n        A dict with header field names to float scalar values, that\n        indicate a distance measure ratio for the levenshtein distance\n        averaging of all the header field names in it. e.g., {'PatientID': 1}\n\n    dist_method_cls: DicomFileDistance class\n        Distance method object to compare the files.\n        If None, the default DicomFileDistance method using Levenshtein\n        distance between the field_wieghts will be used.\n\n    kwargs: DicomFileDistance instantiation named arguments\n        Apart from the field_weitghts argument.\n\n    Returns\n    -------\n    file_dists: np.ndarray or scipy.sparse.lil_matrix of shape NxN\n        Levenshtein distances between each of the N items in dicom_files",
        "\n\ndef transform_to_dcmf(self):\n        \"\"\"Transform the field values in self.dcmf1 and self.dcmf2 to\n        the DCMF format.\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        if self.dcmf1 is None or self.dcmf2 is None:\n            return np.inf\n\n        for field_name in self.field_weights:\n            if (str(getattr(self.dcmf1, field_name, ''))\n                    != str(getattr(self.dcmf2, field_name, ''))):\n                return False\n\n        return True\n\ndef transform_to_dcmf_with_weights(self):\n        \"\"\"Transform the field values in self.dcmf1 and self.dcmf2 to\n        the DCMF format with the given field weights.\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        if self.dcmf1 is None or self.dcmf2 is None:\n            return np.inf\n\n        for field_name in self.field_weights:\n            if (str(getattr(self.dcmf1, field_name, ''))\n                    != str(getattr(self.dcmf2, field_name, ''))):\n                return False\n\n        return True\n\ndef transform_to",
        "\n\ndef calculate_file_distances(key_dicoms, field_weights, dist_method_cls):\n    \"\"\"\n    Calculates the file distances between the key files using the\n    levenshtein weighted measure using either the header_fields or self.header_fields.\n\n    Parameters\n    ----------\n    key_dicoms: list of strings\n        A list of key files to be compared.\n    field_weights: dict of strings with floats\n        A dict with header field names to float scalar values, that indicate a distance measure\n        ratio for the levenshtein distance averaging of all the header field names in it.\n        e.g., {'PatientID': 1}\n    dist_method_cls: class\n        A class that implements the distance method used to calculate the file\n        distances.\n    \"\"\"\n    if field_weights is None:\n        if not isinstance(field_weights, dict):\n            raise ValueError('Expected a dict for `field_weights` parameter, '\n                                 'got {}'.format(type(field_weights)))\n\n    key_dicoms = list(key_dicoms)\n    file_dists = {}\n    for key_dicom in key_dicoms:\n        file_dists[key_dicom] = {}\n        for field_name in field_weights:\n            file_dists[key_dicom][",
        "\n\ndef dist_percentile_threshold_with_k(dist_matrix, perc_thr=0.05, k=1):\n        \"\"\"Thresholds a distance matrix and returns the result.\n\n        Parameters\n        ----------\n\n        dist_matrix: array_like\n        Input array or object that can be converted to an array.\n\n        perc_thr: float in range of [0,100]\n        Percentile to compute which must be between 0 and 100 inclusive.\n\n        k: int, optional\n        Diagonal above which to zero elements.\n        k = 0 (the default) is the main diagonal,\n        k < 0 is below it and k > 0 is above.\n\n        Returns\n        -------\n        array_like\n\n        \"\"\"\n        triu_idx = np.triu_indices(dist_matrix.shape[0], k=k)\n        upper = np.zeros_like(dist_matrix)\n        upper[triu_idx] = dist_matrix[triu_idx] < np.percentile(dist_matrix[triu_idx], perc_thr)\n        return upper\n\ndef dist_percentile_threshold_with_k_with_k(dist_matrix, perc_thr=0.05, k=1, k_thr=0.5):\n        \"\"\"Thresholds",
        "\n\ndef get_folder_subpath(group, folder_depth=3):\n        \"\"\"\n        Returns a string with the path of the group that is in the same\n        folder within given depth.\n\n        Parameters\n        ----------\n        folder_depth: int\n        Path depth to check for folder equality.\n\n        Returns\n        -------\n        str\n        \"\"\"\n        return group + '/' + str(folder_depth)\n\ndef get_folder_name(group):\n        \"\"\"\n        Returns a string with the name of the group that is in the same\n        folder within given depth.\n\n        Parameters\n        ----------\n        folder_depth: int\n        Path depth to check for folder equality.\n\n        Returns\n        -------\n        str\n        \"\"\"\n        return group + '/'\n\ndef get_folder_name_with_extension(group):\n        \"\"\"\n        Returns a string with the name of the group that is in the same\n        folder within given depth.\n\n        Parameters\n        ----------\n        folder_depth: int\n        Path depth to check for folder equality.\n\n        Returns\n        -------\n        str\n        \"\"\"\n        return group + '/' + group[:-1] + '.' + group[-1]\n\ndef get_folder_name_with_extension_and_folder_depth(group):\n        \"\"\"\n        Returns a",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef copy_groups_to_folder(self, groups, folder_path, groupby_field_name=None):\n        \"\"\"Copy the file groups to folder_path. Each group will be copied into\n        a subfolder with named given by groupby_field.\n\n        Parameters\n        ----------\n        groups: list\n         List of DICOM groups.\n\n        folder_path: str\n         Path to where copy the DICOM files.\n\n        groupby_field_name: str\n         DICOM field name. Will get the value of this field to name the group\n         folder. If empty or None will use the basename of the group key file.\n        \"\"\"\n        for group in groups:\n                if groupby_field_name is None:\n                        groupby_field_name = group.group_key\n                if groupby_field_name is None:\n                        groupby_field_name = group.group_key.split('.')[-1]\n                if groupby_field_name in folder_path:\n                        continue\n                folder_path = folder_path + '/' + groupby_field_name\n                copy_group_to_folder(group, folder_path)\n\ndef copy_group_to_folder(self, group, folder_path):\n        \"\"\"Copy the group to folder_path.\n\n        Parameters\n        ----------\n        group: DICOM group\n        ",
        "\n\ndef get_unique_field_values_per_group_and_file(self, field_name,\n                                              field_to_use_as_key=None):\n        \"\"\"Return a dictionary where the key is the group key file path and\n        the values are sets of unique values of the field name of all DICOM\n        files in the group.\n\n        Parameters\n        ----------\n        field_name: str\n         Name of the field to read from all files\n\n        field_to_use_as_key: str\n         Name of the field to get the value and use as key.\n         If None, will use the same key as the dicom_groups.\n\n        Returns\n        -------\n        Dict of sets\n        \"\"\"\n        unique_vals = get_unique_field_values_per_group(field_name,\n                                              field_to_use_as_key)\n        return unique_vals\n\ndef get_unique_field_values_per_group_and_file_and_file(self, field_name,\n                                                     field_to_use_as_key=None):\n        \"\"\"Return a dictionary where the key is the group key file path and\n        the values are sets of unique values of the field name of all DICOM\n        files in the group.\n\n        Parameters\n        ----------\n        field_",
        "\n\ndef get_config_value_from_env(name, fallback=None):\n    \"\"\"Gets a config by name.\n\n    In the case where the config name is not found, will use fallback value.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n\n    return cli_config.get('servicefabric', name, fallback)\n\ndef get_config_value_from_file(name, fallback=None):\n    \"\"\"Gets a config by name.\n\n    In the case where the config name is not found, will use fallback value.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n\n    return cli_config.get('servicefabric', name, fallback)\n\ndef get_config_value_from_file_with_fallback(name, fallback=None):\n    \"\"\"Gets a config by name.\n\n    In the case where the config name is not found, will use fallback value.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n\n    return cli_config.get('servicefabric', name, fallback)\n\ndef get_config_value_from_file_with_fallback_and_",
        "\n\ndef get_config_int(name):\n    \"\"\"Checks if a config value is set to a valid int value.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n    return cli_config.getint('sf', name, 0)\n\ndef get_config_float(name):\n    \"\"\"Checks if a config value is set to a valid float value.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n    return cli_config.getfloat('sf', name, 0.0)\n\ndef get_config_string(name):\n    \"\"\"Checks if a config value is set to a valid string value.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n    return cli_config.getstring('sf', name, '')\n\ndef get_config_list(name):\n    \"\"\"Checks if a config value is set to a valid list value.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n    return cli_config.getlist('sf', name, [])\n\ndef get_config_dict(name):\n    \"\"\"",
        "\n\ndef get_config_value(name):\n    \"\"\"Get a config by name.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n    return cli_config.get_value('fabric', name)\n\ndef get_config_value_list(name):\n    \"\"\"Get a config by name.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n    return cli_config.get_value_list('fabric', name)\n\ndef get_config_value_dict(name):\n    \"\"\"Get a config by name.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n    return cli_config.get_value_dict('fabric', name)\n\ndef get_config_value_list_dict(name):\n    \"\"\"Get a config by name.\"\"\"\n\n    cli_config = CLIConfig(SF_CLI_CONFIG_DIR, SF_CLI_ENV_VAR_PREFIX)\n    return cli_config.get_value_list_dict('fabric', name)\n\ndef get_config_value_dict_list(name):\n    \"\"\"Get a config by name.\"\"\"\n\n    cli_config =",
        "\n\ndef key_info():\n    \"\"\"Path to key related files, either a single file path or a tuple. In the\n    case of no security, returns None.\"\"\"\n\n    sec_type = security_type()\n    if sec_type == 'pem':\n        return get_config_value('pem_path', fallback=None)\n    if sec_type == 'key':\n        key_path = get_config_value('key_path', fallback=None)\n        return key_path\n\n    return None\n\ndef security_type():\n    \"\"\"Returns the security type of the current environment.\"\"\"\n\n    return get_config_value('security_type', fallback='cert')\n\ndef get_config_value(key, fallback=None):\n    \"\"\"Returns the value of the given config key, or fallback if it doesn't exist.\"\"\"\n\n    try:\n        return get_config_value(key, fallback)\n    except KeyError:\n        return fallback\n\ndef get_config_value_list(key, fallback=None):\n    \"\"\"Returns the value of the given config key, or fallback if it doesn't exist.\"\"\"\n\n    try:\n        return get_config_value_list(key, fallback)\n    except KeyError:\n        return fallback\n\ndef get_config_value_dict(key, fallback=None):\n",
        "\n\ndef get_aad_cache(token):\n    \"\"\"Get AAD token cache.\"\"\"\n    return jsonpickle.decode(get_config_value('aad_cache'))\n\ndef set_aad_token(token):\n    \"\"\"Set AAD token.\"\"\"\n    set_aad_cache(token, get_aad_cache(token))\n\ndef get_aad_token():\n    \"\"\"Get AAD token.\"\"\"\n    return get_config_value('aad_token')\n\ndef set_aad_token_cache(token, cache):\n    \"\"\"Set AAD token cache.\"\"\"\n    set_aad_cache(token, cache)\n\ndef get_aad_token_cache(token):\n    \"\"\"Get AAD token cache.\"\"\"\n    return jsonpickle.decode(get_config_value('aad_token_cache'))\n\ndef set_aad_token_cache(token, cache):\n    \"\"\"Set AAD token cache.\"\"\"\n    set_aad_cache(token, cache)\n\ndef set_aad_token_cache_for_user(user, cache):\n    \"\"\"Set AAD token cache for user.\"\"\"\n    set_aad_cache(get_aad_token_for_user(user), cache)\n\ndef get_aad_token_for_",
        "\n\ndef set_aad_client(uri, resource, client):\n    \"\"\"Set AAD client.\"\"\"\n    set_config_value('authority_uri', uri)\n    set_config_value('aad_resource', resource)\n    set_config_value('aad_client', client)\n\ndef set_aad_resource(uri, resource):\n    \"\"\"Set AAD resource.\"\"\"\n    set_config_value('authority_uri', uri)\n    set_config_value('aad_resource', resource)\n\ndef set_aad_client(uri, client):\n    \"\"\"Set AAD client.\"\"\"\n    set_config_value('authority_uri', uri)\n    set_config_value('aad_client', client)\n\ndef set_aad_client_id(uri, client):\n    \"\"\"Set AAD client id.\"\"\"\n    set_config_value('authority_uri', uri)\n    set_config_value('aad_client', client)\n\ndef set_aad_client_secret(uri, client):\n    \"\"\"Set AAD client secret.\"\"\"\n    set_config_value('authority_uri', uri)\n    set_config_value('aad_client', client)\n\ndef set_aad_client_secret_id(uri, client):\n    \"\"\"",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef is_valid_email(string):\n    \"\"\"\n    Checks whether the email module can compile the given email address.\n\n    Parameters\n    ----------\n    string: str\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    try:\n        email.parse(string)\n        is_valid = True\n    except email.error:\n        is_valid = False\n    return is_valid\n\ndef is_valid_url(string):\n    \"\"\"\n    Checks whether the url module can compile the given URL.\n\n    Parameters\n    ----------\n    string: str\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    try:\n        urlparse.urlparse(string)\n        is_valid = True\n    except urlparse.error:\n        is_valid = False\n    return is_valid\n\ndef is_valid_ip(string):\n    \"\"\"\n    Checks whether the ip module can compile the given IP address.\n\n    Parameters\n    ----------\n    string: str\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    try:\n        ipaddr.ip_address(string)\n        is_valid = True\n    except ipaddr.error:\n        is_valid = False\n    return is_valid\n\ndef is_valid_ip_address(string):\n    \"\"\"\n",
        "\n\ndef is_fnmatch_regex_with_regex(string):\n    \"\"\"\n    Returns True if the given string is considered a fnmatch\n    regular expression, False otherwise.\n    It will look for\n\n    :param string: str\n\n    \"\"\"\n    is_regex = False\n    regex_chars = ['!', '*', '$']\n    for c in regex_chars:\n        if string.find(c) > -1:\n            return True\n    return is_regex\n\ndef is_fnmatch_regex_with_regex_with_regex(string):\n    \"\"\"\n    Returns True if the given string is considered a fnmatch\n    regular expression, False otherwise.\n    It will look for\n\n    :param string: str\n\n    \"\"\"\n    is_regex = False\n    regex_chars = ['!', '*', '$']\n    for c in regex_chars:\n        if string.find(c) > -1:\n            return True\n    return is_regex\n\ndef is_fnmatch_regex_with_regex_with_regex(string):\n    \"\"\"\n    Returns True if the given string is considered a fnmatch\n    regular expression, False otherwise.\n    It will look for\n\n    :param string: str\n\n    \"\"\"\n    is_regex = False\n    regex_chars = ['!',",
        "\n",
        "\n\ndef main():\n    \"\"\" Main function.\n    \"\"\"\n    output_directory = op.join(op.dirname(__file__), \"..\", \"..\", \"..\", \"..\", \"..\")\n    config_file = generate_config(output_directory)\n    print(\"Config file: %s\" % config_file)\n\n    # Read the DICOM2NII configuration file\n    config = dcm2nii.read_config(config_file)\n\n    # Set the DICOM2NII configuration file to be interactive\n    config.set_interactive(False)\n\n    # Write the DICOM2NII configuration file\n    dcm2nii.write_config(config_file, config)\n\n    # Write the DICOM2NII configuration file to a file\n    with open(config_file, \"w\") as config_file:\n        config.write(config_file)\n\n    # Write the DICOM2NII configuration file to a file\n    with open(config_file, \"a\") as config_file:\n        config.write_to_file(config_file)\n\n    # Write the DICOM2NII configuration file to a file\n    with open(config_file, \"a\") as config_file:\n        config.write_to_file(config_file, \"dcm2nii",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef remove_dcm2nii_underprocessed(filenames):\n    \"\"\" Remove the files that dcm2nii produced by dcm2nii that are not a NifTI file, e.g., *.bvals, *.bvecs, etc.\n\n    Parameters\n    ----------\n    filenames: list of str\n        List of file paths to remove\n\n    Returns\n    -------\n    filenames: list of str\n        List of file paths that dcm2nii produced by dcm2nii that are not a NifTI file\n    \"\"\"\n    # get the filenames of the files that dcm2nii produced\n    filenames  = glob(op.join(tmpdir.name, '*.nii*'))\n\n    # cleanup `filenames`, using only the post-processed (reoriented, cropped, etc.) images by dcm2nii\n    cleaned_filenames = []\n    for srcpath in filenames:\n        basename = op.basename(remove_ext(srcpath))\n        aux_files = set(glob(op.join(tmpdir.name, '{}.*'     .format(basename)))) - \\\n                        set(glob(op.join(tmpdir.name, '{}.nii*'.format(basename))))\n        for aux_file in aux_files:\n            aux_dstpath = copy_w_ext(aux_file",
        "\n\ndef remove_dcm2nii_unprocessed(filepaths):\n    \"\"\" Return a subset of `filepaths`. Keep only the files that have a basename longer than the\n    others with same suffix.\n    This works based on that dcm2nii appends a preffix character for each processing\n    step it does automatically in the DICOM to NifTI conversion.\n\n    Parameters\n    ----------\n    filepaths: iterable of str\n\n    Returns\n    -------\n    cleaned_paths: iterable of str\n    \"\"\"\n    cln_flist = []\n\n    # sort them by size\n    len_sorted = sorted(filepaths, key=len)\n\n    for idx, fpath in enumerate(len_sorted):\n        remove = False\n\n        # get the basename and the rest of the files\n        fname = op.basename(fpath)\n        rest  = len_sorted[idx+1:]\n\n        # check if the basename is in the basename of the rest of the files\n        for rest_fpath in rest:\n            rest_file = op.basename(rest_fpath)\n            if rest_file.endswith(fname):\n                remove = True\n                break\n\n        if not remove:\n            cln_flist.append(fpath)\n\n    return cln_flist\n\ndef remove_dcm2n",
        ")\n\ndef get_named_tuple(a_named_tuple):\n    \"\"\"Transform a named tuple into a tuple\"\"\"\n    return tuple(dictify(s) for s in a_named_tuple._fields)\n\ndef get_named_tuple_by_name(a_named_tuple, a_name):\n    \"\"\"Transform a named tuple into a tuple\"\"\"\n    return dictify(s) for s in a_named_tuple._fields if s.name == a_name\n\ndef get_named_tuple_by_name_and_value(a_named_tuple, a_name, a_value):\n    \"\"\"Transform a named tuple into a tuple\"\"\"\n    return dictify(s) for s in a_named_tuple._fields if s.name == a_name and s.value == a_value\n\ndef get_named_tuple_by_name_and_value_and_type(a_named_tuple, a_name, a_value, a_type):\n    \"\"\"Transform a named tuple into a tuple\"\"\"\n    return dictify(s) for s in a_named_tuple._fields if s.name == a_name and s.value == a_value and s.type == a_type\n\ndef get_named_tuple_by_name_and_value_and_type_and_",
        "\n\ndef merge_dict_of_lists_with_indices(adict, indices, pop_later=True, copy=True):\n    \"\"\"Extend the within a dict of lists. The indices will indicate which\n    list have to be extended by which other list.\n\n    Parameters\n    ----------\n    adict: OrderedDict\n        An ordered dictionary of lists\n\n    indices: list or tuple of 2 iterables of int, bot having the same length\n        The indices of the lists that have to be merged, both iterables items\n         will be read pair by pair, the first is the index to the list that\n         will be extended with the list of the second index.\n         The indices can be constructed with Numpy e.g.,\n         indices = np.where(square_matrix)\n\n    pop_later: bool\n        If True will oop out the lists that are indicated in the second\n         list of indices\n\n    copy: bool\n        If True will perform a deep copy of the input adict before\n         modifying it, hence not changing the original input\n\n    Returns\n    -------\n    Dictionary of lists\n\n    Raises\n    ------\n    IndexError\n        If the indices are out of range\n    \"\"\"\n    check_indices(indices, len(adict))\n\n    rdict = adict.copy() if copy else adict\n\n    dict_",
        "\n\n\ndef append_dict_values_with_keys(list_of_dicts, keys=None):\n    \"\"\"\n    Return a dict of lists from a list of dicts with the same keys.\n    For each dict in list_of_dicts with look for the values of the\n    given keys and append it to the output dict.\n\n    Parameters\n    ----------\n    list_of_dicts: list of dicts\n\n    keys: list of str\n        List of keys to create in the output dict\n        If None will use all keys in the first element of list_of_dicts\n    Returns\n    -------\n    DefaultOrderedDict of lists\n    \"\"\"\n    if keys is None:\n        keys = list(list_of_dicts[0].keys())\n\n    dict_of_lists = DefaultOrderedDict(list)\n    for d in list_of_dicts:\n        for k in keys:\n            dict_of_lists[k].append(d[k])\n    return dict_of_lists\n\n\ndef append_dict_values_with_keys_and_values(list_of_dicts, keys=None, values=None):\n    \"\"\"\n    Return a dict of lists from a list of dicts with the same keys.\n    For each dict in list_of_dicts with look for the values of the\n    given keys",
        "\n\ndef import_module(mod_name, filepath=None):\n    \"\"\"\n    Imports the contents of filepath as a Python module.\n\n    :param filepath: string\n\n    :param mod_name: string\n    Name of the module when imported\n\n    :return: module\n    Imported module\n    \"\"\"\n    import sys\n    if sys.version_info.major == 3:\n        import importlib.machinery\n        loader = importlib.machinery.SourceFileLoader('', filepath)\n        mod = loader.load_module(mod_name)\n    else:\n        import imp\n        mod = imp.load_source(mod_name, filepath)\n\n    return mod\n\ndef import_module_from_path(mod_name, filepath):\n    \"\"\"\n    Imports the contents of filepath as a Python module.\n\n    :param filepath: string\n\n    :param mod_name: string\n    Name of the module when imported\n\n    :return: module\n    Imported module\n    \"\"\"\n    import sys\n    if sys.version_info.major == 3:\n        import importlib.machinery\n        loader = importlib.machinery.SourceFileLoader('', filepath)\n        mod = loader.load_module(mod_name)\n    else:\n        import imp\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef load_mask_from_file(image, allow_empty=True):\n    \"\"\"Load a Nifti mask volume from a file.\n\n    Parameters\n    ----------\n    image: img-like object or boyle.nifti.NeuroImage or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it, raise TypeError otherwise.\n\n    allow_empty: boolean, optional\n        Allow loading an empty mask (full of 0 values)\n\n    Returns\n    -------\n    nibabel.Nifti1Image with boolean data.\n    \"\"\"\n    img    = check_img(image, make_it_3d=True)\n    values = np.unique(img.get_data())\n\n    if len(values) == 1:\n        # We accept a single value if it is not 0 (full true mask).\n        if values[0] == 0 and not allow_empty:\n            raise ValueError('Given mask is invalid because it masks all data')\n\n    elif len(values) == 2:\n        # If",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef load_mask_data(mask):\n    \"\"\"Read a mask Nifti file and return the mask data.\n    Returns the mask indices and the mask shape.\n\n    Parameters\n    ----------\n    mask: img-like object or boyle.nifti.NeuroImage or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    Returns\n    -------\n    mask_indices, mask_shape\n    \"\"\"\n    mask_indices = np.zeros(mask.shape)\n    mask_shape   = np.zeros(mask.shape)\n\n    vol = mask.get_data()\n    for i in range(mask.shape[0]):\n        mask_indices[i] = vol[i]\n        mask_shape[i] = mask.shape[i]\n\n    return mask_indices, mask_shape\n\ndef check_img_compatibility(img, mask):\n",
        "\n    Returns\n    -------\n    session_series, mask_data\n\n    Note\n    ----\n    nii_file and mask_file must have the same shape\n\n    Raises\n    ------\n    FileNotFound, NiftiFilesNotCompatible\n    \"\"\"\n    img  = check_img(image)\n    mask = check_img(mask_img)\n    check_img_compatibility(img, mask, only_check_3d=True)\n\n    vol = get_data(img)\n    series, mask_data = _apply_mask_to_4d_data(vol, mask)\n    return series, mask_data\n\n\ndef _apply_mask_to_4d_data(vol, mask):\n    \"\"\"Extract the signals in nii_file that are within the mask, the mask indices\n    and the mask shape.\n\n    Parameters\n    ----------\n    vol: vol-like object or boyle.nifti.NeuroImage or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it.",
        "\n\ndef volume_to_vector(volume, order='C'):\n    \"\"\"Transform a given volume to a vector. This is a reshape function for\n    3D flattened and maybe masked vectors.\n\n    Parameters\n    ----------\n    volume: np.ndarray\n        1-Dimensional array\n\n    Returns\n    -------\n    np.array\n    \"\"\"\n    if volume.dtype != np.bool:\n        raise ValueError(\"volume must be a boolean array\")\n\n    if volume.ndim != 3:\n        raise ValueError(\"volume must be a 3-dimensional array\")\n\n    if volume.ndim == 2 and any(v == 1 for v in volume.shape):\n        log.debug('Got an array of shape {}, flattening for my purposes.'.format(volume.shape))\n        volume = volume.flatten()\n\n    return volume\n\ndef volume_to_vector_mask(volume, order='C'):\n    \"\"\"Transform a given volume to a vector. This is a reshape function for\n    3D flattened and maybe masked vectors.\n\n    Parameters\n    ----------\n    volume: np.ndarray\n        1-Dimensional array\n\n    Returns\n    -------\n    np.ndarray\n    \"\"\"\n    if volume.dtype != np.bool:\n        raise ValueError(\"volume must be a boolean array\")\n\n    if volume.n",
        "\n\ndef matrix_to_3dvolume(arr, mask, order='C'):\n    \"\"\"Transform a given vector to a volume. This is a reshape function for\n    3D flattened masked matrices where the second dimension of the matrix\n    corresponds to the original 4th dimension.\n\n    Parameters\n    ----------\n    arr: numpy.array\n        2D numpy.array\n\n    mask: numpy.ndarray\n        Mask image. Must have 3 dimensions, bool dtype.\n\n    dtype: return type\n        If None, will get the type from vector\n\n    Returns\n    -------\n    data: numpy.ndarray\n        Unmasked data.\n        Shape: (mask.shape[0], mask.shape[1], mask.shape[2], X.shape[1])\n    \"\"\"\n    if mask.dtype != np.bool:\n        raise ValueError(\"mask must be a boolean array\")\n\n    if arr.ndim != 2:\n        raise ValueError(\"X must be a 2-dimensional array\")\n\n    if mask.sum() != arr.shape[0]:\n        # raise an error if the shape of arr is not what expected\n        raise ValueError('Expected arr of shape ({}, samples). Got {}.'.format(mask.sum(), arr.shape))\n\n    data = np.zeros(mask.shape + (arr.shape[1],), dtype",
        ", indices\n\ndef load_mask_data(mask_file):\n    \"\"\"Load a Nifti mask file.\n\n    Parameters\n    ----------\n    mask_file: str\n        Path to a Nifti mask file.\n\n    Returns\n    -------\n    mask_data: ndarray\n        Numpy array with shape N x prod(vol.shape) containing the N files as flat vectors.\n\n    \"\"\"\n    img = check_img(mask_file)\n    return img.data, img.shape\n\ndef get_img_data(img):\n    \"\"\"Get the data of an image.\n\n    Parameters\n    ----------\n    img: ndarray\n        Numpy array with shape N x prod(vol.shape) containing the N files as flat vectors.\n\n    Returns\n    -------\n    vol: ndarray\n        Numpy array with shape N x prod(vol.shape) containing the N files as flat vectors.\n\n    \"\"\"\n    return img.data, img.shape\n\ndef are_compatible_imgs(img1, img2):\n    \"\"\"Check if the two images are compatible.\n\n    Parameters\n    ----------\n    img1: ndarray\n        Numpy array with shape N x prod(vol.shape) containing the N files as flat vectors.\n\n    img2: ndarray\n        Numpy array with shape N x prod",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "(c)\n\ndef _ord(c):\n    \"\"\"Return the ord of a character\"\"\"\n    return ord(c)\n\ndef _escape_string(s, escape_char=ESCAPE_CHAR):\n    \"\"\"Escape a string\"\"\"\n    buf = []\n    for c in s.encode('utf8'):\n        buf.append(_escape_char(c, escape_char))\n    return ''.join(buf)\n\ndef _escape_list(l, escape_char=ESCAPE_CHAR):\n    \"\"\"Escape a list\"\"\"\n    buf = []\n    for c in l:\n        buf.append(_escape_char(c, escape_char))\n    return ''.join(buf)\n\ndef _escape_dict(d, escape_char=ESCAPE_CHAR):\n    \"\"\"Escape a dictionary\"\"\"\n    buf = []\n    for k, v in d.items():\n        buf.append(_escape_char(k, escape_char))\n        buf.append(_escape_char(v, escape_char))\n    return ''.join(buf)\n\ndef _escape_tuple(t, escape_char=ESCAPE_CHAR):\n    \"\"\"Escape a tuple\"\"\"\n    buf = []\n    for i, v in enumerate(t):\n        buf.append(_escape_char(v, escape_char))\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".can_send(user, notice_type)\n\ndef send_notification(self, user, notice_type, message):\n        \"\"\"\n        Sends a notification to the given user and notice_type.\n        \"\"\"\n        from notification.models import NoticeSetting\n        return NoticeSetting.for_user(user, notice_type, self.medium_id).send(message)\n\ndef send_notification_to_all(self, user, notice_type, message):\n        \"\"\"\n        Sends a notification to all users and notice_types.\n        \"\"\"\n        from notification.models import NoticeSetting\n        return NoticeSetting.for_user(user, notice_type, self.medium_id).send_all(message)\n\ndef send_notification_to_user(self, user, notice_type, message):\n        \"\"\"\n        Sends a notification to the given user and notice_type.\n        \"\"\"\n        from notification.models import NoticeSetting\n        return NoticeSetting.for_user(user, notice_type, self.medium_id).send_user(message)\n\ndef send_notification_to_all_users(self, user, notice_type, message):\n        \"\"\"\n        Sends a notification to all users and notice_types.\n        \"\"\"\n        from notification.models import NoticeSetting\n        return NoticeSetting.",
        "\n\ndef get_formatted_message(self, message, label, context):\n        \"\"\"\n        Returns a dictionary with the message identifier as the key. The values are\n        are fully rendered templates with the given context.\n        \"\"\"\n        return get_formatted_messages(self.FORMATS, label, context)\n\ndef get_formatted_message_no_args(self, message, label, context):\n        \"\"\"\n        Returns a dictionary with the message identifier as the key. The values are\n        are fully rendered templates with the given context.\n        \"\"\"\n        return get_formatted_messages(self.FORMATS, label, context)\n\ndef get_formatted_message_no_args_no_context(self, message, label, context):\n        \"\"\"\n        Returns a dictionary with the message identifier as the key. The values are\n        are fully rendered templates with the given context.\n        \"\"\"\n        return get_formatted_messages(self.FORMATS, label, context)\n\ndef get_formatted_message_no_args_no_context_no_args(self, message, label, context):\n        \"\"\"\n        Returns a dictionary with the message identifier as the key. The values are\n        are fully rendered templates with the given context.\n        \"\"\"\n        return get_formatted_messages(self.FORMATS, label, context)\n\ndef",
        ", None)\n\ndef _wildcard_filter(source, *ignore_patterns):\n    \"\"\"\n    Filter the list of attributes from a source object.\n    \"\"\"\n    return [attr for attr in dir(source) if attr not in ignore_patterns]\n",
        "\n\ndef column(self, idx):\n        \"\"\"\n        Returns DataFrameColumn of the DataFrame given its index.\n\n        :param idx: the index of the column in the DataFrame.\n        :return: returns a DataFrameColumn\n        \"\"\"\n        return DataFrameColumn(idx, [x[idx] for x in self], self.colnames)\n\ndef column_names(self):\n        \"\"\"\n        Returns a list of column names of the DataFrame.\n\n        :return: returns a list of column names\n        \"\"\"\n        return self.colnames\n\ndef column_names_as_list(self):\n        \"\"\"\n        Returns a list of column names of the DataFrame.\n\n        :return: returns a list of column names\n        \"\"\"\n        return [x[0] for x in self]\n\ndef column_names_as_dict(self):\n        \"\"\"\n        Returns a dict of column names of the DataFrame.\n\n        :return: returns a dict of column names\n        \"\"\"\n        return {x[0]: x[1] for x in self}\n\ndef column_names_as_dict_as_list(self):\n        \"\"\"\n        Returns a dict of column names of the DataFrame.\n\n        :return: returns a dict of column names\n        \"\"\"\n        return {x[0]: x[1] for x in",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef find_all(self, *args):\n        \"\"\"\n        Find all nodes in the tree.\n\n        :param args: a tuple\n        :return: returns a list of nodes\n        \"\"\"\n        curr_node = self.__root\n        return self.__traverse(curr_node, 0,  *args)\n\ndef find_all_sorted(self, *args):\n        \"\"\"\n        Find all nodes in the tree.\n\n        :param args: a tuple\n        :return: returns a list of nodes\n        \"\"\"\n        curr_node = self.__root\n        return self.__traverse(curr_node, 0,  sorted(*args))\n\ndef find_all_sorted_sorted(self, *args):\n        \"\"\"\n        Find all nodes in the tree.\n\n        :param args: a tuple\n        :return: returns a list of nodes\n        \"\"\"\n        curr_node = self.__root\n        return self.__traverse(curr_node, 0,  sorted(*args), sorted(*args))\n\ndef find_all_sorted_sorted_sorted(self, *args):\n        \"\"\"\n        Find all nodes in the tree.\n\n        :param args: a tuple\n        :return: returns a list of nodes\n        \"\"\"\n        curr_node = self.__root\n        return self.__traverse",
        "\n\n\ndef get_notification_type(user):\n    \"\"\"\n    Returns site-specific notification type for this user. Raises\n    LanguageStoreNotAvailable if this site does not use translated\n    notifications.\n    \"\"\"\n    if getattr(settings, \"NOTIFICATION_TYPE_MODULE\", False):\n        try:\n            app_label, model_name = settings.NOTIFICATION_TYPE_MODULE.split(\".\")\n            model = models.get_model(app_label, model_name)\n            # pylint: disable-msg=W0212\n            language_model = model._default_manager.get(user__id__exact=user.id)\n            if hasattr(language_model, \"type\"):\n                return language_model.type\n        except (ImportError, ImproperlyConfigured, model.DoesNotExist):\n            raise LanguageStoreNotAvailable\n    raise LanguageStoreNotAvailable\n\n\ndef get_notification_message(user):\n    \"\"\"\n    Returns site-specific notification message for this user. Raises\n    LanguageStoreNotAvailable if this site does not use translated\n    notifications.\n    \"\"\"\n    if getattr(settings, \"NOTIFICATION_MESSAGE_MODULE\", False):\n        try:\n            app_label, model_name = settings.NOTIFICATION_MESSAGE_MODULE.split(\".\")\n            model = models.get_model(app",
        "\n\n\ndef send_now_with_context(users, label, extra_context=None, sender=None):\n    \"\"\"\n    Creates a new notice.\n\n    This is intended to be how other apps create new notices.\n\n    notification.send(user, \"friends_invite_sent\", {\n        \"spam\": \"eggs\",\n        \"foo\": \"bar\",\n    )\n    \"\"\"\n    sent = False\n    if extra_context is None:\n        extra_context = {}\n\n    notice_type = NoticeType.objects.get(label=label)\n\n    current_language = get_language()\n\n    for user in users:\n        # get user language for user from language store defined in\n        # NOTIFICATION_LANGUAGE_MODULE setting\n        try:\n            language = get_notification_language(user)\n        except LanguageStoreNotAvailable:\n            language = None\n\n        if language is not None:\n            # activate the user's language\n            activate(language)\n\n        for backend in NOTIFICATION_BACKENDS.values():\n            if backend.can_send(user, notice_type):\n                backend.deliver(user, sender, notice_type, extra_context)\n                sent = True\n\n    # reset environment to original language\n    activate(current_language)\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef is_disjoint_set(set1, set2, warn):\n    \"\"\"\n    Checks if elements of set2 are in set1.\n\n    :param set1: a set of values\n    :param set2: a set of values\n    :param warn: the error message that should be thrown\n     when the sets are NOT disjoint\n    :return: returns true no elements of set2 are in set1\n    \"\"\"\n    for elem in set2:\n        if elem not in set1:\n            raise ValueError(warn)\n    return True\n\ndef is_disjoint_set_of_sets(set1, set2, warn):\n    \"\"\"\n    Checks if elements of set2 are in set1.\n\n    :param set1: a set of values\n    :param set2: a set of values\n    :param warn: the error message that should be thrown\n     when the sets are NOT disjoint\n    :return: returns true no elements of set2 are in set1\n    \"\"\"\n    for elem in set2:\n        if elem not in set1:\n            raise ValueError(warn)\n    return True\n\ndef is_disjoint_set_of_sets_of_sets(set1, set2, warn):\n    \"\"\"\n    Checks if elements of set2 are in set1.\n",
        "\n\ndef contains_any(set1, set2, warn):\n    \"\"\"\n    Checks if any element from set2 is in set1.\n\n    :param set1:  a set of values\n    :param set2:  a set of values\n    :param warn: the error message that should be thrown \n     when the sets are not containd\n    :return: returns true if any element from set2 is in set1\n    \"\"\"\n    for elem in set2:\n        if elem not in set1:\n            raise ValueError(warn)\n    return True\n\ndef contains_none(set1, set2, warn):\n    \"\"\"\n    Checks if none element from set2 is in set1.\n\n    :param set1:  a set of values\n    :param set2:  a set of values\n    :param warn: the error message that should be thrown \n     when the sets are not containd\n    :return: returns true if none element from set2 is in set1\n    \"\"\"\n    for elem in set2:\n        if elem in set1:\n            raise ValueError(warn)\n    return True\n\ndef contains_all_or_none(set1, set2, warn):\n    \"\"\"\n    Checks if all elements from set2 are in set1 or none.\n\n    :param set1:",
        "\n\ndef from_XML(xml_input):\n        \"\"\"\n        Deserialize object from XML string.\n\n        Returns:\n            object: Object which should be same as original input, if everything\\\n                 works as expected.\n        \"\"\"\n\n        marcxml_template = \"\"\"<record xmlns=\"http://www.loc.gov/MARC21/slim/\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://www.loc.gov/MARC21/slim\nhttp://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd\">\n$LEADER\n$CONTROL_FIELDS\n$DATA_FIELDS\n</record>\n\"\"\"\n\n        oai_template = \"\"\"<record>\n<metadata>\n<oai_marc>\n$LEADER$CONTROL_FIELDS\n$DATA_FIELDS\n</oai_marc>\n</metadata>\n</record>\n\"\"\"\n\n        # deserialize leader, if it is present and record is marc xml\n        leader = Template(marcxml_template).substitute(\n            LEADER=xml_input.strip(),\n            CONTROL_FIELDS=xml_input.strip(),\n            DATA_FIELDS=xml_input.strip()\n        )\n",
        "\n\n        # for backward compatibility of MARC XML with OAI\n        if self.oai_marc and \"LDR\" in self.datafields:\n            self.leader = self.datafields[\"LDR\"]\n\n        # for backward compatibility of MARC XML with OAI\n        if self.oai_marc and \"LDR\" in self.controlfields:\n            self.leader = self.controlfields[\"LDR\"]\n\n        # for backward compatibility of MARC XML with OAI\n        if self.oai_marc and \"LDR\" in self.datafields:\n            self.leader = self.datafields[\"LDR\"]\n\n        # for backward compatibility of MARC XML with OAI\n        if self.oai_marc and \"LDR\" in self.controlfields:\n            self.leader = self.controlfields[\"LDR\"]\n\n        # for backward compatibility of MARC XML with OAI\n        if self.oai_marc and \"LDR\" in self.datafields:\n            self.leader = self.datafields[\"LDR\"]\n\n        # for backward compatibility of MARC XML with OAI\n        if self.oai_marc and \"LDR\" in self.controlfields:\n            self.leader = self.controlfields[\"LDR\"]\n\n        # for",
        "\n\ndef _parse_control_fields_from_xml(self, xml):\n        \"\"\"\n        Parse control fields from XML.\n\n        Args:\n            xml (str): XML string\n        \"\"\"\n        fields = xml.xpath(\"//controlfields\")\n        _parse_control_fields(self, fields)\n\ndef _parse_control_fields_from_file(self, file_name):\n        \"\"\"\n        Parse control fields from file.\n\n        Args:\n            file_name (str): file name\n        \"\"\"\n        with open(file_name, \"r\") as f:\n            _parse_control_fields_from_xml(self, f.read())\n\ndef _parse_control_fields_from_string(self, string):\n        \"\"\"\n        Parse control fields from string.\n\n        Args:\n            string (str): string\n        \"\"\"\n        fields = string.split(\"\\n\")\n        _parse_control_fields(self, fields)\n\ndef _parse_control_fields_from_file_with_header(self, file_name, header):\n        \"\"\"\n        Parse control fields from file with header.\n\n        Args:\n            file_name (str): file name\n            header (str): header string\n        \"\"\"\n        with open(file_name, \"r\") as f",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_datafields(self, datafield, exception=False):\n        \"\"\"\n        Return content of given `datafield`.\n\n        Args:\n            datafield (str): Section name (for example \"001\", \"100\", \"700\").\n            exception (bool): If ``True``, :exc:`~exceptions.KeyError` is\n                      raised when method couldn't found given `datafield` /\n                      `subfield`. If ``False``, blank array ``[]`` is returned.\n\n        Returns:\n            list: of :class:`.MARCDatafield`.\n\n        Raises:\n            KeyError: If the datafield couldn't be found.\n\n        Note:\n            MARCDatafield is practically same thing as string, but has defined\n            :meth:`.MARCDatafield.i1` and :attr:`.MARCDatafield.i2` methods.\n\n            You may need to be able to get this, because MARC XML depends on\n            i/ind parameters from time to time (names of authors for example).\n\n        \"\"\"\n        if len(datafield) != 3:\n            raise ValueError(\n                \"`datafield` parameter have to be exactly 3 chars long!\"\n            )\n        if datafield not in self.datafields:\n            if exception:\n                raise KeyError(datafield + \" is",
        "\n            if s in ['', '2', '3']]\n\ndef _get_joint_params(target, param, dof):\n    '''Get the given joint param from each of the DOFs for a joint.'''\n    return [target.getJointParam(getattr(ode, 'JointParam{}{}'.format(param, s)))\n            for s in ['', '2', '3']]\n\ndef _get_joint_params_from_joint(target, joint, dof):\n    '''Get the given joint param from each of the DOFs for a joint.'''\n    return [target.getJointParam(getattr(ode, 'JointParam{}{}'.format(joint, s)))\n            for s in ['', '2', '3']]\n\ndef _get_joint_params_from_joint_joint(target, joint, dof):\n    '''Get the given joint param from each of the DOFs for a joint.'''\n    return [target.getJointParam(getattr(ode, 'JointParam{}{}'.format(joint, s)))\n            for s in ['', '2', '3']]\n\ndef _get_joint_params_from_joint_joint_joint(target, joint, dof):\n    '''Get the given joint param from each of the DOFs for",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef make_quaternion_from_axis(theta, *axis):\n    '''Given an angle and an axis, create a quaternion.'''\n    return make_quaternion(theta, *axis)\n\ndef make_quaternion_from_axis_and_angle(theta, *axis, angle):\n    '''Given an angle and an axis and an angle, create a quaternion.'''\n    return make_quaternion(theta, *axis, angle)\n\ndef make_quaternion_from_axis_and_angle_and_axis(theta, *axis, angle, *axis2):\n    '''Given an angle and an axis and an angle and an axis, create a quaternion.'''\n    return make_quaternion(theta, *axis, angle, *axis2)\n\ndef make_quaternion_from_axis_and_angle_and_axis2(theta, *axis, angle, *axis2):\n    '''Given an angle and an axis and an angle and an axis2, create a quaternion.'''\n    return make_quaternion(theta, *axis, angle, *axis2)\n\ndef make_quaternion_from_axis_and_angle_and_axis2_and_angle(theta, *axis, angle, *axis2, angle2):\n    '''Given an angle and an axis and an angle and an axis",
        "\n\ndef mass_of_mass(bodies):\n    '''Given a set of bodies, compute their mass in world coordinates.\n    '''\n    x = np.zeros(3.)\n    t = 0.\n    for b in bodies:\n        m = b.mass\n        x += b.body_to_world(m.c) * m.mass\n        t += m.mass\n    return x / t\n\ndef mass_of_mass_in_world(bodies):\n    '''Given a set of bodies, compute their mass in world coordinates.\n    '''\n    x = np.zeros(3.)\n    t = 0.\n    for b in bodies:\n        m = b.mass\n        x += b.body_to_world(m.c) * m.mass\n        t += m.mass\n    return x / t\n\ndef mass_of_mass_in_world_in_meters(bodies):\n    '''Given a set of bodies, compute their mass in world coordinates.\n    '''\n    x = np.zeros(3.)\n    t = 0.\n    for b in bodies:\n        m = b.mass\n        x += b.body_to_world(m.c) * m.mass\n        t += m.mass\n    return x / t\n\ndef mass",
        "\n        self.angular_velocity_max = state.angular_velocity_max\n        self.angular_velocity_min = state.angular_velocity_min\n        self.angular_velocity_step = state.angular_velocity_step\n        self.angular_velocity_max_step = state.angular_velocity_max_step\n        self.angular_velocity_min_step = state.angular_velocity_min_step\n        self.angular_velocity_step_max = state.angular_velocity_step_max\n        self.angular_velocity_step_min = state.angular_velocity_step_min\n        self.angular_velocity_step_max_step = state.angular_velocity_step_max_step\n        self.angular_velocity_step_min_step = state.angular_velocity_step_min_step\n        self.angular_velocity_step_max_step = state.angular_velocity_step_max_step\n        self.angular_velocity_step_max_step_max = state.angular_velocity_step_max_step_max\n        self.angular_velocity_step_max_step_min = state.angular_velocity_step_max_step_min\n        self.angular_veloc",
        "\n\ndef position(self, position):\n        '''Set the position of this body using a position vector.\n\n        Parameters\n        ----------\n        position : sequence of 3 floats\n            The desired position vector for this body.\n        '''\n        self.ode_body.setPosition(tuple(position))\n\ndef velocity(self, velocity):\n        '''Set the velocity of this body using a velocity vector.\n\n        Parameters\n        ----------\n        velocity : sequence of 3 floats\n            The desired velocity vector for this body.\n        '''\n        self.ode_body.setVelocity(tuple(velocity))\n\ndef angular_velocity(self, angular_velocity):\n        '''Set the angular velocity of this body using a angular velocity vector.\n\n        Parameters\n        ----------\n        angular_velocity : sequence of 3 floats\n            The desired angular velocity vector for this body.\n        '''\n        self.ode_body.setAngularVelocity(tuple(angular_velocity))\n\ndef angular_velocity_at_position(self, angular_velocity, position):\n        '''Set the angular velocity of this body using a angular velocity vector.\n\n        Parameters\n        ----------\n        angular_velocity : sequence of 3 floats\n            The desired angular velocity vector for this body.\n        position : sequence of 3 floats\n            The desired position vector for this body",
        "\n\ndef world_to_body(self, world):\n        '''Convert a world-relative offset to body coordinates.\n\n        Parameters\n        ----------\n        world : 3-tuple of float\n            A tuple giving world-relative offsets.\n\n        Returns\n        -------\n        position : 3-tuple of float\n            A tuple giving the body coordinates of the given offset.\n        '''\n        return tuple(self.ode_body.getRelPointPos(world))\n\ndef get_body_position(self, position):\n        '''Convert a world-relative offset to body coordinates.\n\n        Parameters\n        ----------\n        position : 3-tuple of float\n            A tuple giving world-relative offsets.\n\n        Returns\n        -------\n        position : 3-tuple of float\n            A tuple giving the body coordinates of the given offset.\n        '''\n        return tuple(self.ode_body.getRelPointPos(world))\n\ndef get_body_position_from_world(self, world):\n        '''Convert a world-relative offset to body coordinates.\n\n        Parameters\n        ----------\n        world : 3-tuple of float\n            A tuple giving world-relative offsets.\n\n        Returns\n        -------\n        position : 3-tuple of float\n            A tuple giving the body coordinates of the given offset.\n        '''\n        return tuple(self.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef add_force_at_rel_pos(self, force, relative=False, position=None, relative_position=None):\n        '''Add a force to this body.\n\n        Parameters\n        ----------\n        force : 3-tuple of float\n            A vector giving the forces along each world or body coordinate axis.\n        relative : bool, optional\n            If False, the force values are assumed to be given in the world\n            coordinate frame. If True, they are assumed to be given in the\n            body-relative coordinate frame. Defaults to False.\n        position : 3-tuple of float, optional\n            If given, apply the force at this location in world coordinates.\n            Defaults to the current position of the body. If\n            given, this method ignores the ``position`` parameter.\n        '''\n        b = self.ode_body\n        if relative_position is not None:\n            op = b.addRelForceAtRelPos if relative else b.addForceAtRelPos\n            op(force, relative_position)\n        elif position is not None:\n            op = b.addRelForceAtPos if relative else b.addForceAtPos\n            op(force, position)\n        else:\n            op = b.addRelForce if relative else b.addForce\n            op(force)\n\ndef add_force_at_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "]\n\ndef angles_in_rad(self):\n        '''List of angles for rotational degrees of freedom.'''\n        return [self.ode_obj.getAngle(i) for i in range(self.ADOF)]\n\ndef angles_in_deg(self):\n        '''List of angles for rotational degrees of freedom.'''\n        return [self.ode_obj.getAngle(i) for i in range(self.ADOF)]\n\ndef angles_in_deg_in_rad(self):\n        '''List of angles for rotational degrees of freedom.'''\n        return [self.ode_obj.getAngle(i) for i in range(self.ADOF)]\n\ndef angles_in_rad_in_deg(self):\n        '''List of angles for rotational degrees of freedom.'''\n        return [self.ode_obj.getAngle(i) for i in range(self.ADOF)]\n\ndef angles_in_deg_in_rad_in_deg(self):\n        '''List of angles for rotational degrees of freedom.'''\n        return [self.ode_obj.getAngle(i) for i in range(self.ADOF)]\n\ndef angles_in_rad_in_deg_in_rad(self):\n        '''List of angles for rotation",
        "]\n\ndef angle_rates_for_rotational_degrees_of_freedom(self, degrees_of_freedom):\n        '''List of angle rates for rotational degrees of freedom.'''\n        return [self.ode_obj.getAngleRate(i) for i in range(degrees_of_freedom)]\n\ndef angle_rates_for_rotational_degrees_of_freedom_with_angle_rate(self, angle_rate):\n        '''List of angle rates for rotational degrees of freedom with angle rate.'''\n        return [self.ode_obj.getAngleRate(i) for i in range(self.ADOF, angle_rate)]\n\ndef angle_rates_for_rotational_degrees_of_freedom_with_angle_rate_and_angle_rate_and_angle_rate(self, angle_rate, angle_rate_and_angle_rate):\n        '''List of angle rates for rotational degrees of freedom with angle rate and angle rate and angle rate.'''\n        return [self.ode_obj.getAngleRate(i) for i in range(self.ADOF, angle_rate, angle_rate_and_angle_rate)]\n\ndef angle_rates_for_rotational_degrees_of_freedom_with_angle",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "\n\ndef joint_names(self):\n        '''A list of joint names for this joint.'''\n        return [self.ode_obj.getJointName()]\n\ndef joint_names_list(self):\n        '''A list of joint names for this joint.'''\n        return [self.ode_obj.getJointName()]\n\ndef joint_names_list_with_names(self):\n        '''A list of joint names for this joint.'''\n        return [self.ode_obj.getJointName() + ' ' + self.ode_obj.getJointName()]\n\ndef joint_names_list_with_names_and_names(self):\n        '''A list of joint names for this joint.'''\n        return [self.ode_obj.getJointName() + ' ' + self.ode_obj.getJointName() + ' ' + self.ode_obj.getJointName()]\n\ndef joint_names_list_with_names_and_names_and_names(self):\n        '''A list of joint names for this joint.'''\n        return [self.ode_obj.getJointName() + ' ' + self.ode_obj.getJointName() + ' ' + self.ode_obj.getJointName() + ' ' + self.ode_obj.getJointName",
        "\n\ndef create_body_from_shape(self, shape, name=None, **kwargs):\n        '''Create a new body.\n\n        Parameters\n        ----------\n        shape : str\n            The \"shape\" of the body to be created. This should name a type of\n            body object, e.g., \"box\" or \"cap\".\n        name : str, optional\n            The name to use for this body. If not given, a default name will be\n            constructed of the form \"{shape}{# of objects in the world}\".\n\n        Returns\n        -------\n        body : :class:`Body`\n            The created body object.\n        '''\n        shape = shape.lower()\n        if name is None:\n            for i in range(1 + len(self._bodies)):\n                name = '{}{}'.format(shape, i)\n                if name not in self._bodies:\n                    break\n        self._bodies[name] = Body.build(shape, name, self, **kwargs)\n        return self._bodies[name]\n\ndef create_body_from_shape_and_name(self, shape, name=None, **kwargs):\n        '''Create a new body.\n\n        Parameters\n        ----------\n        shape : str\n            The \"shape\" of the body to be created. This",
        "\n\ndef build(shape, name, world, body_a=None, body_b=None, **kwargs):\n    '''Create a new joint that connects two bodies together.\n\n    Parameters\n    ----------\n    shape : str\n        The \"shape\" of the joint to use for joining together two bodies.\n        This should name a type of joint, such as \"ball\" or \"piston\".\n    body_a : str or :class:`Body`\n        The first body to join together with this joint. If a string is\n        given, it will be used as the name of a body to look up in the\n        world.\n    body_b : str or :class:`Body`, optional\n        If given, identifies the second body to join together with\n        ``body_a``. If not given, ``body_a`` is joined to the world.\n    name : str, optional\n        If given, use this name for the created joint. If not given, a name\n        will be constructed of the form\n        \"{body_a.name}^{shape}^{body_b.name}\".\n\n    Returns\n    -------\n    joint : :class:`Joint`\n        The joint object that was created.\n    '''\n    if shape == 'ball':\n        return BallJoint(name, world, body_a, body",
        "\n\ndef move_next_to_body(self, body_a, body_b, offset_a, offset_b):\n        '''Move one body to be near another one.\n\n        After moving, the location described by ``offset_a`` on ``body_a`` will\n        be coincident with the location described by ``offset_b`` on ``body_b``.\n\n        Parameters\n        ----------\n        body_a : str or :class:`Body`\n            The body to use as a reference for moving the other body. If this is\n            a string, it is treated as the name of a body to look up in the\n            world.\n        body_b : str or :class:`Body`\n            The body to move next to ``body_a``. If this is a string, it is\n            treated as the name of a body to look up in the world.\n        offset_a : 3-tuple of float\n            The offset of the anchor point, given as a relative fraction of the\n            size of ``body_a``. See :func:`Body.relative_offset_to_world`.\n        offset_b : 3-tuple of float\n            The offset of the anchor point, given as a relative fraction of the\n            size of ``body_b``. See :func:`Body.relative_offset_to_world",
        "\n\ndef get_body_states(self):\n        '''Get the states of some bodies in the world.\n\n        Returns\n        -------\n        states : sequence of states\n            A complete state tuple for one or more bodies in the world. See\n            :func:`get_body_states`.\n        '''\n        return [self.get_body(b.name).state for b in self.get_bodies()]\n\ndef get_body_names(self):\n        '''Get the names of all bodies in the world.\n\n        Returns\n        -------\n        names : sequence of str\n            A complete list of names for all bodies in the world. See\n            :func:`get_body_names`.\n        '''\n        return [b.name for b in self.get_bodies()]\n\ndef get_body_position(self, name):\n        '''Get the position of a body in the world.\n\n        Parameters\n        ----------\n        name : str\n            The name of the body to get the position of.\n\n        Returns\n        -------\n        position : tuple\n            A tuple of the position of the body in the world.\n        '''\n        return self.get_body(name).position\n\ndef get_body_velocity(self, name):\n        '''Get the velocity of a body in the world.\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef create_bones(self, translate=(0, 1, 0), size=0.1):\n        '''Traverse the bone hierarchy and create physics bones.'''\n        stack = [('root', 0, self.root['position'] + translate)]\n        while stack:\n            name, depth, end = stack.pop()\n\n            for child in self.hierarchy.get(name, ()):\n                stack.append((child, depth + 1, end + self.bones[child].end))\n\n            if name not in self.bones:\n                continue\n\n            bone = self.bones[name]\n            body = self.world.create_body(\n                'box', name=bone.name, density=self.density,\n                lengths=(size, size, bone.length))\n            body.color = self.color\n\n            self.bones[name] = bone\n\ndef create_bones_from_file(self, filename):\n        '''Traverse the bone hierarchy and create physics bones from a file.'''\n        with open(filename, 'r') as f:\n            for line in f:\n                name, depth, end = line.split()\n                stack = [('root', 0, self.root['position'] + translate)]\n                while stack:\n                    name, depth,",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\",
        "\n\n\nclass Corporation(object):\n    \"\"\"\n    Represents a corporation in MARC.\n\n    Attributes:\n        name (str): name of the corporation\n        place (str): place of the corporation\n        date (str): date of the corporation\n    \"\"\"\n\n    def __init__(self, name, place, date):\n        self.name = name\n        self.place = place\n        self.date = date\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return \"<Corporation: {}>\".format(self.name)\n\n    def __eq__(self, other):\n        return self.name == other.name\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.name)\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return \"<Corporation: {}>\".format(self.name)\n\n    def __eq__(self, other):\n        return self.name == other.name\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(",
        "\n\n\nclass Person(object):\n    \"\"\"\n    Person object.\n\n    Attributes:\n        name (str): name of person.\n        second_name (str): second name of person.\n        surname (str): surname of person.\n        title (str): title of person.\n    \"\"\"\n\n    def __init__(self, name, second_name, surname, title):\n        self.name = name\n        self.second_name = second_name\n        self.surname = surname\n        self.title = title\n\n    def __str__(self):\n        return self.name + \" \" + self.second_name + \" \" + self.surname + \" \" + self.title\n\n\nclass Persons(object):\n    \"\"\"\n    Persons object.\n\n    Attributes:\n        persons (list of Person): list of persons.\n    \"\"\"\n\n    def __init__(self, persons):\n        self.persons = persons\n\n    def __str__(self):\n        return \"\\n\".join(\n            [\n                person.name + \" \" + person.second_name + \" \" + person.surname + \" \" + person.title\n                for person in self.persons\n            ]\n        )\n\n\nclass MARCData(object):\n   ",
        "\n\ndef get_invalid_ISBNs(self):\n        \"\"\"\n        Get list of invalid ISBN.\n\n        Returns:\n            list: List with *invalid* ISBN strings.\n        \"\"\"\n        return [\n            self._clean_isbn(isbn)\n            for isbn in self[\"901i\"]\n            if isbn not in self.get_valid_ISBNs()\n        ]\n\ndef get_valid_ISBNs(self):\n        \"\"\"\n        Get list of valid ISBN.\n\n        Returns:\n            list: List with *valid* ISBN strings.\n        \"\"\"\n        return [\n            self._clean_isbn(isbn)\n            for isbn in self[\"020a\"]\n            if self._clean_isbn(isbn) not in self.get_invalid_ISBNs()\n        ]\n\ndef _clean_isbn(self, isbn):\n        \"\"\"\n        Clean ISBN.\n\n        Args:\n            isbn (str): ISBN string.\n\n        Returns:\n            str: Cleaned ISBN string.\n        \"\"\"\n        return isbn.replace(\" \", \"\")\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_joint_index(self, name):\n        '''Get the index of a specific joint.\n\n        Parameters\n        ----------\n        name : str\n            The name of the joint to look up.\n\n        Returns\n        -------\n        int :\n            The index of the joint.\n        '''\n        for joint in self.joints:\n            if joint.name == name:\n                return joint.index\n        return -1\n\ndef get_joint_index_by_name(self, name):\n        '''Get the index of a specific joint.\n\n        Parameters\n        ----------\n        name : str\n            The name of the joint to look up.\n\n        Returns\n        -------\n        int :\n            The index of the joint.\n        '''\n        for joint in self.joints:\n            if joint.name == name:\n                return joint.index\n        return -1\n\ndef get_joint_index_by_name_and_index(self, name, index):\n        '''Get the index of a specific joint.\n\n        Parameters\n        ----------\n        name : str\n            The name of the joint to look up.\n        index : int\n            The index of the joint.\n\n        Returns\n        -------\n        int :\n            The index of the joint.\n        '''\n        for joint in",
        "\n\ndef indices_for_quaternion(self, q, step=3):\n        '''Get a list of the indices for a specific quaternion.\n\n        Parameters\n        ----------\n        q : Quaternion\n            The quaternion to look up.\n        step : int, optional\n            The number of numbers for each quaternion. Defaults to 3, should be set\n            to 4 for body rotation (since quaternions have 4 values).\n\n        Returns\n        -------\n        list of int :\n            A list of the index values for quantities related to the named quaternion.\n        '''\n        for j, quaternion in enumerate(self.quaternions):\n            if quaternion.name == q.name:\n                return list(range(j * step, (j + 1) * step))\n        return []\n\ndef indices_for_quaternion_rotation(self, q, step=3):\n        '''Get a list of the indices for a specific quaternion rotation.\n\n        Parameters\n        ----------\n        q : Quaternion\n            The quaternion to look up.\n        step : int, optional\n            The number of numbers for each quaternion. Defaults to 3, should be set\n            to 4 for body rotation (since quaternions have 4 values).\n\n        Returns\n        -------\n        list of int :\n            A list of the index values for quantities related to the named",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef disable_motors(self):\n        '''Disable the joint motors in this skeleton.\n\n        This method disables all joint motors.\n        '''\n        for joint in self.joints:\n            amotor = getattr(joint, 'amotor', joint)\n            amotor.disable_feedback()\n\ndef set_joint_position(self, joint, position):\n        '''Set the joint position in this skeleton.\n\n        This method sets the joint position in this skeleton to the given position.\n\n        Parameters\n        ----------\n        joint : str\n            The name of the joint to set the position of.\n        position : float\n            The position of the joint in the skeleton.\n        '''\n        for joint in self.joints:\n            amotor = getattr(joint, 'amotor', joint)\n            amotor.set_position(position)\n\ndef set_joint_velocity(self, joint, velocity):\n        '''Set the joint velocity in this skeleton.\n\n        This method sets the joint velocity in this skeleton to the given velocity.\n\n        Parameters\n        ----------\n        joint : str\n            The name of the joint to set the velocity of.\n        velocity : float\n            The velocity of the joint in the skeleton.\n        '''\n        for joint in self.joints:\n           ",
        "\n\ndef set_pid_params(self, pid_params):\n        '''Set PID parameters.\n\n        Parameters\n        ----------\n        pid_params : list of float\n            A list of the PID parameters for every joint in the skeleton.\n        '''\n        for joint in self.joints:\n            joint.set_pid_params(pid_params)\n\ndef set_joint_angles(self, angles):\n        '''Move each joint toward a target angle.\n\n        This method uses a PID controller to set a target angular velocity for\n        each degree of freedom in the skeleton, based on the difference between\n        the current and the target angle for the respective DOF.\n\n        PID parameters are by default set to achieve a tiny bit less than\n        complete convergence in one time step, using only the P term (i.e., the\n        P coefficient is set to 1 - \\delta, while I and D coefficients are set\n        to 0). PID parameters can be updated by calling the `set_pid_params`\n        method.\n\n        Parameters\n        ----------\n        angles : list of float\n            A list of the target angles for every joint in the skeleton.\n        '''\n        j = 0\n        for joint in self.joints:\n            velocities = [\n                ctrl(tgt - cur, self.world.dt)",
        "\n\ndef add_joints(self, joints):\n        '''Add joints for each degree of freedom in the skeleton.\n\n        Parameters\n        ----------\n        joints : list of float\n            A list of the joints to add to each degree of freedom in the\n            skeleton.\n        '''\n        j = 0\n        for joint in self.joints:\n            joint.add_joints(joints[j:j+joint.ADOF])\n            j += joint.ADOF\n\ndef add_joint_angles(self, joints):\n        '''Add joint angles for each degree of freedom in the skeleton.\n\n        Parameters\n        ----------\n        joints : list of float\n            A list of the joint angles to add to each degree of freedom in the\n            skeleton.\n        '''\n        j = 0\n        for joint in self.joints:\n            joint.add_joint_angles(joints[j:j+joint.ADOF])\n            j += joint.ADOF\n\ndef add_joint_angles_to_joints(self, joints):\n        '''Add joint angles to joints for each degree of freedom in the skeleton.\n\n        Parameters\n        ----------\n        joints : list of float\n            A list of the joint angles to add to each degree of freedom in the",
        ".keys())\n\ndef labels_names(self):\n        '''Return the names of our marker labels in canonical order.'''\n        return sorted(self.channels, key=lambda c: self.channels[c])\n\ndef labels_names_by_name(self):\n        '''Return the names of our marker labels in canonical order.'''\n        return sorted(self.channels, key=lambda c: self.channels[c])\n\ndef labels_names_by_name_by_name(self):\n        '''Return the names of our marker labels in canonical order.'''\n        return sorted(self.channels, key=lambda c: self.channels[c])\n\ndef labels_names_by_name_by_name_by_name(self):\n        '''Return the names of our marker labels in canonical order.'''\n        return sorted(self.channels, key=lambda c: self.channels[c])\n\ndef labels_names_by_name_by_name_by_name(self):\n        '''Return the names of our marker labels in canonical order.'''\n        return sorted(self.channels, key=lambda c: self.channels[c])\n\ndef labels_names_by_name_by_name_by_name(self):\n        '''Return the names of our marker labels in canonical order.'''\n        return sorted",
        "\n        self.create_world()\n        self.create_markers()\n        self.create_markers_and_bodies()\n        self.create_markers_and_bodies_and_markers()\n        self.create_markers_and_bodies_and_markers_and_bodies()\n        self.create_markers_and_bodies_and_markers_and_bodies_and_markers()\n        self.create_markers_and_bodies_and_markers_and_bodies_and_markers()\n        self.create_markers_and_bodies_and_markers_and_bodies_and_markers()\n        self.create_markers_and_bodies_and_markers_and_bodies_and_markers()\n        self.create_markers_and_bodies_and_markers_and_bodies_and_markers()\n        self.create_markers_and_bodies_and_markers_and_bodies_and_markers()\n        self.create_markers_and_bodies_and_markers_and_bodies_and_markers()\n        self.create_markers_and_bodies_and_markers_and_bodies_and_markers()\n        self.create_markers_and_bodies_and_markers_and_bodies_and",
        "\n\ndef load_c3d_from_file(self, filename, start_frame=0, max_frames=int(1e300)):\n        '''Load marker data from a C3D file.\n\n        The file will be imported using the c3d module, which must be installed\n        to use this method. (``pip install c3d``)\n\n        Parameters\n        ----------\n        filename : str\n            Name of the C3D file to load.\n        start_frame : int, optional\n            Discard the first N frames. Defaults to 0.\n        max_frames : int, optional\n            Maximum number of frames to load. Defaults to loading all frames.\n        '''\n        import c3d\n\n        with open(filename, 'rb') as handle:\n            reader = c3d.Reader(handle)\n\n        logging.info('world frame rate %s, marker frame rate %s',\n                         1 / self.world.dt, reader.point_rate)\n\n        # set up a map from marker label to index in the data stream.\n        self.channels = self._map_labels_to_channels([\n            s.strip() for s in reader.point_labels])\n\n        # read the actual c3d data into a numpy array.\n        data = []\n        for i, (_,",
        "_SIZE\n        self.cfms[0, 0] = 0\n        self.cfms[0, 1] = 0\n        self.cfms[0, 2] = 0\n        self.cfms[0, 3] = 0\n        self.cfms[0, 4] = 0\n        self.cfms[0, 5] = 0\n        self.cfms[0, 6] = 0\n        self.cfms[0, 7] = 0\n        self.cfms[0, 8] = 0\n        self.cfms[0, 9] = 0\n        self.cfms[0, 10] = 0\n        self.cfms[0, 11] = 0\n        self.cfms[0, 12] = 0\n        self.cfms[0, 13] = 0\n        self.cfms[0, 14] = 0\n        self.cfms[0, 15] = 0\n        self.cfms[0, 16] = 0\n        self.cfms[0, 17] = 0\n        self.cfms[0, 18] = 0\n        self.cfms[0, 19] = 0\n        self.cfms[0, 20] = 0\n        self.cfms[0, 21] = 0\n        self.cfms[0, 22]",
        "\n\ndef create_meshes(self):\n        '''Create meshes for each marker in our data.'''\n        for label in self.channels:\n            mesh = self.world.create_mesh(\n                'sphere', name='marker:{}'.format(label), radius=0.02)\n            mesh.is_kinematic = True\n            mesh.color = 0.9, 0.1, 0.1, 0.5\n            self.meshes[label] = mesh\n\ndef create_mesh_objects(self):\n        '''Create mesh objects for each marker in our data.'''\n        for label in self.channels:\n            mesh = self.meshes[label]\n            mesh.create_mesh_object(\n                'sphere', name='marker:{}'.format(label), radius=0.02)\n            mesh.create_mesh_object(\n                'sphere', name='marker:{}'.format(label), radius=0.02)\n            mesh.create_mesh_object(\n                'sphere', name='marker:{}'.format(label), radius=0.02)\n            mesh.create_mesh_object(\n                'sphere', name='marker:{}'.format(label), radius=0.02)\n            mesh.create_mesh_object(\n                'sphere',",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef detach(self, frame_no):\n        '''Detach marker bodies from the corresponding skeleton bodies.\n\n        Detachments are only made for markers that are not in a dropout state in\n        the given frame.\n\n        Parameters\n        ----------\n        frame_no : int\n            The frame of data we will use for detaching marker bodies.\n        '''\n        assert not self.joints\n        for label, j in self.channels.items():\n            target = self.targets.get(label)\n            if target is None:\n                continue\n            if self.visibility[frame_no, j] < 0:\n                continue\n            joint = self.joints[label]\n            joint.detach()\n            joint.name = None\n            self.joints[label] = None\n        self._frame_no = frame_no\n\ndef update(self, frame_no):\n        '''Update the marker bodies in the corresponding skeleton bodies.\n\n        Updates are only made for markers that are not in a dropout state in\n        the given frame.\n\n        Parameters\n        ----------\n        frame_no : int\n            The frame of data we will use for updating marker bodies.\n        '''\n        assert not self.joints\n        for label, j in self.channels.items():\n            target = self.targets.get(label)",
        "\n\ndef update(self, frame_no):\n        '''Update the markers in a specific frame of data.\n\n        Parameters\n        ----------\n        frame_no : int\n            The frame of data where we should update markers.\n        '''\n        for label, j in self.channels.items():\n            body = self.bodies[label]\n            body.position = self.positions[frame_no, j]\n            body.linear_velocity = self.velocities[frame_no, j]\n\ndef update_all(self, frame_no):\n        '''Update all markers in a specific frame of data.\n\n        Parameters\n        ----------\n        frame_no : int\n            The frame of data where we should update markers.\n        '''\n        for label, j in self.channels.items():\n            body = self.bodies[label]\n            body.position = self.positions[frame_no, j]\n            body.linear_velocity = self.velocities[frame_no, j]\n\ndef update_all_with_dropouts(self, frame_no):\n        '''Update all markers in a specific frame of data with dropouts.\n\n        Parameters\n        ----------\n        frame_no : int\n            The frame of data where we should update markers.\n        '''\n        for label, j in self",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef distances(self):\n        '''Return an array of the distances exerted by marker springs.\n\n        Notes\n        -----\n\n        The distances exerted by the marker springs can be approximated by::\n\n          D = kp * dx\n\n        where ``dx`` is the current array of marker distances. An even more\n        accurate value is computed by approximating the velocity of the spring\n        displacement::\n\n          D = kp * dx + kd * (dx - dx_tm1) / dt\n\n        where ``dx_tm1`` is an array of distances from the previous time step.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        D : ndarray\n            An array of distances that the markers are exerting on the skeleton.\n        '''\n        cfm = self.cfms[self._frame_no][:, None]\n        kp = self.erp / (cfm * self.world.dt)\n        kd = (1 - self.erp) / cfm\n        dx = self.distances()\n        return D + kp * dx\n\ndef distance_to_target(self, dx_tm1=None):\n        '''Return an array of the distances exerted by marker springs.\n\n        Notes\n        -----\n\n       ",
        ".1\n        self.skeleton.joint_names = ['joint_1', 'joint_2', 'joint_3']\n        self.skeleton.joint_names_names = ['joint_1_name', 'joint_2_name', 'joint_3_name']\n        self.skeleton.joint_names_names_names = ['joint_1_name', 'joint_2_name', 'joint_3_name_name']\n        self.skeleton.joint_names_names_names = ['joint_1_name', 'joint_2_name', 'joint_3_name_name']\n        self.skeleton.joint_names_names_names = ['joint_1_name', 'joint_2_name', 'joint_3_name_name']\n        self.skeleton.joint_names_names_names = ['joint_1_name', 'joint_2_name', 'joint_3_name_name']\n        self.skeleton.joint_names_names_names = ['joint_1_name', 'joint_2_name', 'joint_3_name_name']\n        self.skeleton.joint_names_names_names = ['joint_1_name', 'joint_2_name', 'joint_3_name_name']\n        self.skeleton.joint_",
        "\n        return self.markers\n\ndef load_markers_from_file(self, filename, attachments, max_frames=1e100):\n        '''Load marker data and attachment preferences into the model.\n\n        Parameters\n        ----------\n        filename : str\n            The name of a file containing marker data. This currently needs to\n            be either a .C3D or a .CSV file. CSV files must adhere to a fairly\n            strict column naming convention; see :func:`Markers.load_csv` for\n            more information.\n        attachments : str\n            The name of a text file specifying how markers are attached to\n            skeleton bodies.\n        max_frames : number, optional\n            Only read in this many frames of marker data. By default, the entire\n            data file is read into memory.\n\n        Returns\n        -------\n        markers : :class:`Markers`\n            Returns a markers object containing loaded marker data as well as\n            skeleton attachment configuration.\n        '''\n        self.markers = Markers(self)\n        fn = filename.lower()\n        if fn.endswith('.c3d'):\n            self.markers.load_c3d(filename, max_frames=max_frames)\n        elif fn.endswith('.csv') or fn.endswith('.csv.gz'):\n            self.markers",
        "\n            raise err\n        self.frame_no += substeps\n\ndef reset(self):\n        '''Reset the physics world.\n\n        This is called when the viewer is reset, but it can be called manually.\n        '''\n        self.frame_no = 0\n        self.follower = None\n        self.follower_count = 0\n        self.follower_last = None\n        self.follower_next = None\n        self.follower_prev = None\n        self.follower_prev_next = None\n        self.follower_prev_prev = None\n        self.follower_prev_prev_next = None\n        self.follower_prev_prev_prev = None\n        self.follower_prev_prev_prev_next = None\n        self.follower_prev_prev_prev_prev = None\n        self.follower_prev_prev_prev_prev_next = None\n        self.follower_prev_prev_prev_prev_next = None\n        self.follower_prev_prev_prev_prev_next = None\n        self.follower_prev_prev_prev_prev_next = None\n        self.follower_prev_prev_prev_prev_next = None\n        self.follower_prev_prev_prev_prev_next",
        "\n\ndef settle_to_markers_at_frame(self, frame_no, max_distance=0.05, max_iters=300,\n                              states=None):\n    '''Settle the skeleton to our marker data at a specific frame.\n\n    Parameters\n    ----------\n    frame_no : int, optional\n        Settle the skeleton to marker data at this frame. Defaults to 0.\n    max_distance : float, optional\n        The settling process will stop when the mean marker distance falls\n        below this threshold. Defaults to 0.1m (10cm). Setting this too\n        small prevents the settling process from finishing (it will loop\n        indefinitely), and setting it too large prevents the skeleton from\n        settling to a stable state near the markers.\n    max_iters : int, optional\n        Attempt to settle markers for at most this many iterations. Defaults\n        to 1000.\n    states : list of body states, optional\n        If given, set the bodies in our skeleton to these kinematic states\n        before starting the settling process.\n    '''\n    return self.settle_to_markers(frame_no, max_distance, max_iters, states)\n\ndef settle_to_markers_at_frame_with_states(self, frame_no, max_distance=0.",
        "\n        end : int, optional\n            Stop following marker data after this frame. Defaults to 1e100.\n        states : list of body states, optional\n            If given, set the states of the skeleton bodies to these values\n            before starting to follow the marker data.\n        '''\n        if states is not None:\n            self.skeleton.set_body_states(states)\n        for frame_no, frame in enumerate(self.markers):\n            if frame_no < start:\n                continue\n            if frame_no >= end:\n                break\n            for states in self._step_to_marker_frame(frame_no):\n                yield states\n\ndef _step_to_marker_frame(self, frame_no):\n        '''Iterate over a set of marker data, dragging its skeleton along.\n\n        Parameters\n        ----------\n        frame_no : int, optional\n            Frame number to step to. Defaults to 0.\n        '''\n        if frame_no < 0:\n            frame_no = 0\n        if frame_no >= self.markers.shape[0]:\n            frame_no = self.markers.shape[0] - 1\n        return [self.markers[frame_no]]\n",
        "\n\n        # update the marker positions and velocities.\n        self.markers.reposition(frame_no)\n        self.markers.attach(frame_no)\n\n        # update the ode space.\n        self.ode_space.step(dt or self.dt)\n\n        # update the contact joints.\n        self.ode_contactgroup.step(dt or self.dt)\n\n        # update the skeleton.\n        self.skeleton.step(dt or self.dt)\n\n        # update the ode world.\n        self.ode_world.step(dt or self.dt)\n\n        # clear out contact joints to prepare for the next frame.\n        self.ode_contactgroup.empty()\n\n        # update the marker positions and velocities.\n        self.markers.reposition(frame_no)\n        self.markers.attach(frame_no)\n\n        # update the ode space.\n        self.ode_space.step(dt or self.dt)\n\n        # update the contact joints.\n        self.ode_contactgroup.step(dt or self.dt)\n\n        # update the skeleton.\n        self.skeleton.step(dt or self.dt)\n\n        # update the ode world.\n        self.ode_world.",
        ".T\n\n        '''\n        if states is None:\n            states = self.skeleton.get_body_states()\n        for _ in self.follow_markers(start, end, states):\n            yield self.skeleton.joint_angles.T\n\n        '''\n        if max_force > 0:\n            self.skeleton.enable_motors(max_force)\n            zeros = np.zeros(self.skeleton.num_dofs)\n            for _ in self.follow_markers(start, end, states):\n                self.skeleton.set_target_angles(zeros)\n        '''\n",
        "\n            self.ode_space.collide(None, self.on_collision)\n\n            states = self.skeleton.get_body_states()\n            self.skeleton.set_body_states(states)\n\n            # joseph's stability fix: step to compute torques, then reset the\n            # skeleton to the start of the step, and then step using computed\n            # torques. thus any numerical errors between the body states after\n            # stepping using angle constraints will be removed, because we\n            # will be stepping the model using the computed torques.\n\n            self.skeleton.enable_motors(max_force)\n            self.skeleton.set_target_angles(angles[frame_no])\n            self.ode_world.step(self.dt)\n            torques = self.skeleton.joint_torques\n            self.skeleton.disable_motors()\n\n            self.skeleton.set_body_states(states)\n            self.skeleton.add_torques(torques)\n            yield torques\n            self.ode_world.step(self.dt)\n\n            self.ode_contactgroup.empty()\n            self.ode_space.collide(None, self.on_collision)\n\n            states = self.skeleton",
        "\n\ndef backward_dynamics(self, torques, start=0, states=None):\n        '''Move the body according to a set of torque data.'''\n        if states is not None:\n            self.skeleton.set_body_states(states)\n        for frame_no, torque in enumerate(torques):\n            if frame_no < start:\n                continue\n            if frame_no >= end:\n                break\n            self.ode_space.collide(None, self.on_collision)\n            self.skeleton.add_torques(torque)\n            self.ode_world.step(self.dt)\n            yield\n            self.ode_contactgroup.empty()\n\ndef forward_dynamics_with_states(self, torques, start=0, states=None):\n        '''Move the body according to a set of torque data.'''\n        if states is not None:\n            self.skeleton.set_body_states(states)\n        for frame_no, torque in enumerate(torques):\n            if frame_no < start:\n                continue\n            if frame_no >= end:\n                break\n            self.ode_space.collide(None, self.on_collision)\n            self.skeleton.add_torques(torque",
        "\n",
        "\n\n        if hasattr(self.world, 'markers'):\n            # draw line between anchor1 and anchor2 for marker joints.\n            window.glColor4f(0.9, 0.1, 0.1, 0.9)\n            window.glLineWidth(3)\n            for j in self.world.markers.joints.values():\n                window.glBegin(window.GL_LINES)\n                window.glVertex3f(*j.getAnchor())\n                window.glVertex3f(*j.getAnchor2())\n                window.glEnd()\n\n        if hasattr(self.world, 'markers'):\n            # draw line between anchor1 and anchor2 for marker joints.\n            window.glColor4f(0.9, 0.1, 0.1, 0.9)\n            window.glLineWidth(3)\n            for j in self.world.markers.joints.values():\n                window.glBegin(window.GL_LINES)\n                window.glVertex3f(*j.getAnchor())\n                window.glVertex3f(*j.getAnchor2())\n                window.glEnd()\n\n        if hasattr(self.world, 'markers'):\n            # draw line between anchor1 and anchor2 for marker joints.\n            window.glColor4",
        "\n\nclass Stream(object):\n    \"\"\" Stream class.\n\n    This class is used to listen for messages.\n    \"\"\"\n\n    def __init__(self, room, error_callback=None, live=True):\n        \"\"\" Initialize the stream.\n\n        Kwargs:\n            error_callback (func): Callback to call when an error occurred (parameters: exception)\n            live (bool): If True, issue a live stream, otherwise an offline stream\n        \"\"\"\n        self.room = room\n        self.error_callback = error_callback\n        self.live = live\n        self.stream = None\n        self.stream_id = None\n        self.stream_name = None\n        self.stream_type = None\n        self.stream_id_str = None\n        self.stream_name_str = None\n        self.stream_type_str = None\n        self.stream_id_list = []\n        self.stream_name_list = []\n        self.stream_type_list = []\n        self.stream_id_list_str = []\n        self.stream_name_list_str = []\n        self.stream_type_list_str = []\n        self.stream_id_list_list = []\n        self.stream_name_list_list = []\n        self.stream",
        "\n\ndef get_rooms(self):\n        \"\"\" Get list of rooms in the room.\n\n        Returns:\n            array. List of rooms\n        \"\"\"\n        self._load()\n        return self.rooms\n\ndef get_room(self, name):\n        \"\"\" Get room by name.\n\n        Kwargs:\n            name (str): Name of room\n\n        Returns:\n            Room object.\n        \"\"\"\n        self._load()\n        return self.rooms[name]\n\ndef get_room_by_name(self, name):\n        \"\"\" Get room by name.\n\n        Kwargs:\n            name (str): Name of room\n\n        Returns:\n            Room object.\n        \"\"\"\n        self._load()\n        return self.rooms[name]\n\ndef get_room_by_id(self, id):\n        \"\"\" Get room by id.\n\n        Kwargs:\n            id (int): Room id\n\n        Returns:\n            Room object.\n        \"\"\"\n        self._load()\n        return self.rooms[id]\n\ndef get_room_by_id_and_name(self, id, name):\n        \"\"\" Get room by id and name.\n\n        Kwargs:\n            id (int): Room id\n            name (str): Name of room",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _get_config_filename(self):\n        # type: () -> str\n        \"\"\"\n        Returns the filename which is effectively used by the application. If\n        overridden by an environment variable, it will return that filename.\n        \"\"\"\n        # same logic for the configuration filename. First, check if we were\n        # initialized with a filename...\n        config_filename = ''\n        if self.filename:\n            config_filename = self.filename\n\n        # ... next, take the value from the environment\n        env_filename = getenv(self.env_filename_name)\n        if env_filename:\n            self._log.info('Configuration filename was overridden with %r '\n                           'by the environment variable %s.',\n                           env_filename,\n                           self.env_filename_name)\n            config_filename = env_filename\n\n        return config_filename\n\ndef _get_config_filename_from_env(self):\n        # type: () -> str\n        \"\"\"\n        Returns the filename which is effectively used by the application. If\n        overridden by an environment variable, it will return that filename.\n        \"\"\"\n        # same logic for the configuration filename. First, check if we were\n        # initialized with a filename...\n        config_filename = ''\n        if self.filename:\n            config_filename = self",
        "\n\n\ndef exists(filename):\n        # type: (str) -> bool\n        \"\"\"\n        Check if ``filename`` exists. Will return boolean which is True if the file\n        exists, False otherwise.\n        \"\"\"\n        return os.path.exists(filename)\n\n\ndef read_file(filename):\n        # type: (str) -> str\n        \"\"\"\n        Read ``filename`` into ``self.config`` instance. Will return string which is\n        the contents of the file, or None if the file could not be read.\n        \"\"\"\n        return open(filename).read()\n\n\ndef write_file(filename, content):\n        # type: (str, str) -> None\n        \"\"\"\n        Write ``content`` to ``filename`` in ``self.config`` instance. Will return\n        nothing.\n        \"\"\"\n        open(filename, 'w').write(content)\n\n\ndef write_file_to_file(filename, content):\n        # type: (str, str) -> None\n        \"\"\"\n        Write ``content`` to ``filename`` in ``self.config`` instance. Will return\n        nothing.\n        \"\"\"\n        open(filename, 'w').write(content)\n\n\ndef write_file_to_file_with_version(filename, content, version):\n        # type: (str",
        "\n\n        self._loaded_files = []\n        self.config = self._load_config(config_filename)\n\n        if reload:  # pragma: no cover\n            self._log.debug('Returning cached config instance. Use '\n                            '``reload=True`` to avoid caching!')\n            return\n\n        self._log.debug('Loading config from %s', config_filename)\n        self.config = self._load_config(config_filename)\n\n        if reload:  # pragma: no cover\n            self._log.debug('Returning cached config instance. Use '\n                            '``reload=True`` to avoid caching!')\n            return\n\n        self._log.debug('Loading config from %s', config_filename)\n        self.config = self._load_config(config_filename)\n\n        if reload:  # pragma: no cover\n            self._log.debug('Returning cached config instance. Use '\n                            '``reload=True`` to avoid caching!')\n            return\n\n        self._log.debug('Loading config from %s', config_filename)\n        self.config = self._load_config(config_filename)\n\n        if reload:  # pragma: no cover\n            self._log.debug('Returning cached config instance. Use '\n                            '``reload=True`` to avoid caching!'",
        "\ndef post(self, q=None, page=None):\n        \"\"\"Post styles.\"\"\"\n        # Check cache to exit early if needed\n        etag = generate_etag(current_ext.content_version.encode('utf8'))\n        self.check_etag(etag, weak=True)\n\n        # Build response\n        res = jsonify(current_ext.styles)\n        res.set_etag(etag)\n\n        return res\n\ndef put(self, q=None, page=None):\n        \"\"\"Put styles.\"\"\"\n        # Check cache to exit early if needed\n        etag = generate_etag(current_ext.content_version.encode('utf8'))\n        self.check_etag(etag, weak=True)\n\n        # Build response\n        res = jsonify(current_ext.styles)\n        res.set_etag(etag)\n\n        return res\n\ndef delete(self, q=None, page=None):\n        \"\"\"Delete styles.\"\"\"\n        # Check cache to exit early if needed\n        etag = generate_etag(current_ext.content_version.encode('utf8'))\n        self.check_etag(etag, weak=True)\n\n        # Build response\n        res = jsonify(current_ext.styles)\n        res.set_etag(etag)\n\n        return res\n\ndef",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.",
        "\n\ndef get_body(self):\n        \"\"\" Get body.\n\n        Returns:\n            tuple: Body\n        \"\"\"\n        body = \"\"\n        for key, value in self._settings.items():\n            if isinstance(value, str):\n                body += key + \": \" + value + \"\\n\"\n            elif isinstance(value, list):\n                for item in value:\n                    body += key + \": \" + item + \"\\n\"\n            else:\n                body += key + \": \" + str(value) + \"\\n\"\n\n        return body\n\ndef get_url(self, path):\n        \"\"\" Get url.\n\n        Args:\n            path: Path\n\n        Returns:\n            tuple: Url\n        \"\"\"\n        return self._settings[\"base_url\"] + path\n\ndef get_password_url(self):\n        \"\"\" Get password url.\n\n        Returns:\n            tuple: Url\n        \"\"\"\n        return self._settings[\"password_url\"]\n\ndef get_auth_url(self):\n        \"\"\" Get auth url.\n\n        Returns:\n            tuple: Url\n        \"\"\"\n        return self._settings[\"auth_url\"]\n\ndef get_auth_token(self):\n        \"\"\" Get auth token.\n\n        Returns:\n            tuple: Token\n        \"\"\"\n        return self._settings",
        "\n\ndef _get_user_id(self):\n        \"\"\" Get user ID\n\n        Returns:\n            string: User ID\n        \"\"\"\n        if self._settings[\"user\"]:\n            return self._settings[\"user\"]\n        else:\n            return self._settings[\"authorization\"]\n\ndef _get_user_name(self):\n        \"\"\" Get user name\n\n        Returns:\n            string: User name\n        \"\"\"\n        if self._settings[\"user\"]:\n            return self._settings[\"user\"]\n        else:\n            return self._settings[\"authorization\"]\n\ndef _get_user_email(self):\n        \"\"\" Get user email\n\n        Returns:\n            string: User email\n        \"\"\"\n        if self._settings[\"user\"]:\n            return self._settings[\"user\"]\n        else:\n            return self._settings[\"authorization\"]\n\ndef _get_user_password(self):\n        \"\"\" Get user password\n\n        Returns:\n            string: User password\n        \"\"\"\n        if self._settings[\"user\"]:\n            return self._settings[\"user\"]\n        else:\n            return self._settings[\"authorization\"]\n\ndef _get_user_password_confirmation(self):\n        \"\"\" Get user password confirmation\n\n        Returns:\n            string: User password confirmation\n        \"\"\"\n        if self._settings[\"",
        "\n\n    def get(self, url, key=None):\n        \"\"\" Returns a response.\n\n        Args:\n            url (str): URL to fetch\n\n        Kwargs:\n            key (str): Key to look for, if any\n\n        Returns:\n            Parsed value\n\n        Raises:\n            ValueError\n        \"\"\"\n        return self.parse(self.get_request(url, key=key))\n\n    def post(self, url, data, key=None):\n        \"\"\" Returns a response.\n\n        Args:\n            url (str): URL to fetch\n\n            data (dict): Data to send\n\n            key (str): Key to look for, if any\n\n        Returns:\n            Parsed value\n\n        Raises:\n            ValueError\n        \"\"\"\n        return self.parse(self.post_request(url, data=data, key=key))\n\n    def put(self, url, data, key=None):\n        \"\"\" Returns a response.\n\n        Args:\n            url (str): URL to fetch\n\n            data (dict): Data to send\n\n            key (str): Key to look for, if any\n\n        Returns:\n            Parsed value\n\n        Raises:\n            ValueError\n        \"\"\"\n        return self.parse(self.put_request(url, data=data, key=",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\nclass AuthenticationError(Exception):\n    \"\"\" Raised when the user is not authorized to access the resource.\n\n    Args:\n        user (str): The user name\n        password (str): The password\n    \"\"\"\n\n    def __init__(self, user, password):\n        self.user = user\n        self.password = password\n\nclass ConnectionError(Exception):\n    \"\"\" Raised when the resource cannot be accessed.\n\n    Args:\n        resource (str): The resource name\n    \"\"\"\n\n    def __init__(self, resource):\n        self.resource = resource\n\nclass RESTRequest(object):\n    \"\"\" A REST request.\n\n    Args:\n        url (str): The URL to request\n        method (str): The HTTP method to use\n        headers (dict): The HTTP headers to use\n        data (str): The data to send\n        parameters (dict): The GET parameters to append to the URL\n        listener (func): The callback to call when uploading a file\n        full_return (bool): If set to True, get a full response (with success, data, info, body)\n    \"\"\"\n\n    def __init__(self, url, method, headers=None, data=None, parameters=None, listener=None, full_return=False):\n        self.url = url\n        self.",
        "\n\ndef _get_json(self, url, parameters=None):\n        \"\"\" Get JSON from a URL.\n\n        Kwargs:\n            url (str): URL\n            parameters (dict): Additional GET parameters to append to the URL\n\n        Returns:\n            dict. JSON\n        \"\"\"\n\n        return self._get(url, parameters=parameters)\n\ndef _get(self, url, parameters=None):\n        \"\"\" Get JSON from a URL.\n\n        Kwargs:\n            url (str): URL\n            parameters (dict): Additional GET parameters to append to the URL\n\n        Returns:\n            dict. JSON\n        \"\"\"\n\n        if not url:\n            raise ValueError(\"URL must be specified\")\n\n        if not parameters:\n            parameters = {}\n\n        url = _url(url, parameters)\n\n        try:\n            response = requests.get(url, params=parameters)\n        except requests.exceptions.RequestException as e:\n            raise ValueError(\"Error getting JSON from %s: %s\" % (url, e))\n\n        return response.json()\n\ndef _post(self, url, data, parameters=None):\n        \"\"\" Post JSON to a URL.\n\n        Kwargs:\n            url (str): URL\n            data (dict): JSON data\n            parameters (dict): Additional GET parameters to append",
        "\n\ndef is_image(self):\n        \"\"\" Tells if this message is an image message.\n\n        Returns:\n            bool. Success\n        \"\"\"\n        return self.type in [\n            self._TYPE_PASTE,\n            self._TYPE_IMAGE,\n            self._TYPE_TWEET\n        ]\n\ndef is_video(self):\n        \"\"\" Tells if this message is a video message.\n\n        Returns:\n            bool. Success\n        \"\"\"\n        return self.type in [\n            self._TYPE_PASTE,\n            self._TYPE_VIDEO,\n            self._TYPE_TWEET\n        ]\n\ndef is_audio(self):\n        \"\"\" Tells if this message is an audio message.\n\n        Returns:\n            bool. Success\n        \"\"\"\n        return self.type in [\n            self._TYPE_PASTE,\n            self._TYPE_AUDIO,\n            self._TYPE_TWEET\n        ]\n\ndef is_voice(self):\n        \"\"\" Tells if this message is a voice message.\n\n        Returns:\n            bool. Success\n        \"\"\"\n        return self.type in [\n            self._TYPE_PASTE,\n            self._TYPE_VOICE,\n            self._TYPE_TWEET\n        ]\n\ndef",
        "\n\ndef get_room(self, name):\n        \"\"\" Get room by name.\n\n        Kwargs:\n            name (str): Name of room\n\n        Returns:\n            dict. Room dict\n        \"\"\"\n        return self._connection.get(\"rooms\", name)\n\ndef get_room_by_id(self, id):\n        \"\"\" Get room by id.\n\n        Kwargs:\n            id (int): Room id\n\n        Returns:\n            dict. Room dict\n        \"\"\"\n        return self._connection.get(\"rooms\", id)\n\ndef get_room_by_name(self, name):\n        \"\"\" Get room by name.\n\n        Kwargs:\n            name (str): Name of room\n\n        Returns:\n            dict. Room dict\n        \"\"\"\n        return self._connection.get(\"rooms\", name)\n\ndef get_room_by_id_and_name(self, id, name):\n        \"\"\" Get room by id and name.\n\n        Kwargs:\n            id (int): Room id\n            name (str): Name of room\n\n        Returns:\n            dict. Room dict\n        \"\"\"\n        return self._connection.get(\"rooms\", id, name)\n\ndef get_room_by_name_and_id(self, name, id):\n",
        "\n\ndef get_room_by_id(self, id):\n        \"\"\" Get a room by id.\n\n        Returns:\n            :class:`Room`. Room\n\n        Raises:\n            RoomNotFoundException\n        \"\"\"\n        rooms = self.get_rooms()\n        for room in rooms or []:\n            if room[\"id\"] == id:\n                return self.get_room(room[\"id\"])\n        raise RoomNotFoundException(\"Room %s not found\" % id)\n\ndef get_rooms(self):\n        \"\"\" Get all rooms.\n\n        Returns:\n            :class:`list`. List of :class:`Room`.\n        \"\"\"\n        return self.get_rooms_json()\n\ndef get_rooms_json(self):\n        \"\"\" Get all rooms.\n\n        Returns:\n            :class:`dict`. Dictionary of :class:`Room`.\n        \"\"\"\n        return self.get_rooms_json_response()\n\ndef get_rooms_json_response(self):\n        \"\"\" Get all rooms.\n\n        Returns:\n            :class:`dict`. Dictionary of :class:`Room`.\n        \"\"\"\n        return self.get_rooms_json_response_response()\n\ndef get_rooms_json_response_response(self):\n        \"\"\" Get all rooms.\n\n       ",
        "\n\nclass Room(object):\n    \"\"\" Room.\n\n    Attributes:\n        id (str): Room ID.\n        name (str): Room name.\n        description (str): Room description.\n        members (list[str]): Room members.\n        members_count (int): Room members count.\n        members_count_all (int): Room members count all.\n        members_count_all_all (int): Room members count all all.\n        members_count_all_all_all (int): Room members count all all all all all.\n        members_count_all_all_all (int): Room members count all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all all",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\n\nclass Message(object):\n    \"\"\" Message class.\n\n    Args:\n        self (object): Message object\n        message (str): Message text\n    \"\"\"\n    def __init__(self, self, message):\n        self._message = message\n        self._message_id = message.get(\"message_id\")\n        self._message_type = message.get(\"message_type\")\n        self._message_text = message.get(\"message_text\")\n        self._message_timestamp = message.get(\"message_timestamp\")\n        self._message_user = message.get(\"message_user\")\n        self._message_user_id = message.get(\"message_user_id\")\n        self._message_user_name = message.get(\"message_user_name\")\n        self._message_user_avatar = message.get(\"message_user_avatar\")\n        self._message_user_avatar_url = message.get(\"message_user_avatar_url\")\n        self._message_user_avatar_large = message.get(\"message_user_avatar_large\")\n        self._message_user_avatar_medium = message.get(\"message_user_avatar_medium\")\n        self._message_user_avatar_small = message.get(\"message_user_avatar_small\")\n        self._message_",
        "\n        self._observers.append(observer)\n        return self\n\ndef detach(self, observer):\n        \"\"\" Detach an observer.\n\n        Args:\n            observer (func): A function to be called when new messages arrive\n\n        Returns:\n            :class:`Stream`. Current instance to allow chaining\n        \"\"\"\n        if observer in self._observers:\n            self._observers.remove(observer)\n        return self\n\ndef subscribe(self, observer):\n        \"\"\" Subscribe to a new observer.\n\n        Args:\n            observer (func): A function to be called when new messages arrive\n\n        Returns:\n            :class:`Stream`. Current instance to allow chaining\n        \"\"\"\n        if observer not in self._observers:\n            self._observers.append(observer)\n        return self\n\ndef unsubscribe(self, observer):\n        \"\"\" Unsubscribe from a new observer.\n\n        Args:\n            observer (func): A function to be called when new messages arrive\n\n        Returns:\n            :class:`Stream`. Current instance to allow chaining\n        \"\"\"\n        if observer in self._observers:\n            self._observers.remove(observer)\n        return self\n\ndef publish(self, message):\n        \"\"\" Publish a message.\n\n        Args:\n            message (str): A message to be published\n",
        "\n        if self._observers:\n            campfire = self._room.get_campfire()\n            for message in messages:\n                for observer in self._observers:\n                    observer(Message(campfire, message))\n\n        self._room.incoming(messages)\n\n    def outgoing(self, messages):\n        \"\"\" Called when outgoing messages arrive.\n\n        Args:\n            messages (tuple): Messages (each message is a dict)\n        \"\"\"\n        if self._observers:\n            campfire = self._room.get_campfire()\n            for message in messages:\n                for observer in self._observers:\n                    observer(Message(campfire, message))\n\n        self._room.outgoing(messages)\n\n    def update(self, messages):\n        \"\"\" Called when messages arrive.\n\n        Args:\n            messages (tuple): Messages (each message is a dict)\n        \"\"\"\n        if self._observers:\n            campfire = self._room.get_campfire()\n            for message in messages:\n                for observer in self._observers:\n                    observer(Message(campfire, message))\n\n        self._room.update(messages)\n\n    def update_room(self, room):\n        \"\"\" Called when room changes.\n\n        Args:\n           ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        else:\n            if self._queue:\n                self._queue.put_nowait(None)\n\n            if self._callback:\n                self._callback(None)\n\n\nclass Message(object):\n    \"\"\" A message is a tuple of data and a timestamp.\n\n    Args:\n        data (tuple): Data\n        timestamp (int): Timestamp\n    \"\"\"\n\n    def __init__(self, data, timestamp):\n        \"\"\" Initialize a new message.\n\n        Args:\n            data (tuple): Data\n            timestamp (int): Timestamp\n        \"\"\"\n        self._data = data\n        self._timestamp = timestamp\n\n    def __str__(self):\n        \"\"\" Return a string representation of the message.\n\n        Returns:\n            str: String representation of the message\n        \"\"\"\n        return \"Message(data=%s, timestamp=%s)\" % (self._data, self._timestamp)\n\n    def __repr__(self):\n        \"\"\" Return a string representation of the message.\n\n        Returns:\n            str: String representation of the message\n        \"\"\"\n        return \"Message(data=%s, timestamp=%s)\" % (self._data, self._timestamp)\n\n    def __eq__(self, other):\n        \"\"\" Return true if the two messages are equal.\n\n        Args:\n            other (",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "\n\ndef connectionMade(self):\n        \"\"\" Callback issued by twisted when connection is made.\n\n        Args:\n            self (twisted.internet.Connection): Connection to which the connection\n                is made\n        \"\"\"\n        self.factory.get_stream().connected()\n\ndef connectionLost(self, reason):\n        \"\"\" Callback issued by twisted when connection is lost.\n\n        Args:\n            reason (str): Reason for connection lost\n        \"\"\"\n        self.factory.get_stream().disconnected(reason)\n\ndef connectionLostByPeer(self, reason):\n        \"\"\" Callback issued by twisted when connection is lost by peer.\n\n        Args:\n            reason (str): Reason for connection lost by peer\n        \"\"\"\n        self.factory.get_stream().disconnected(reason)\n\ndef connectionLostByServer(self, reason):\n        \"\"\" Callback issued by twisted when connection is lost by server.\n\n        Args:\n            reason (str): Reason for connection lost by server\n        \"\"\"\n        self.factory.get_stream().disconnected(reason)\n\ndef connectionLostByClient(self, reason):\n        \"\"\" Callback issued by twisted when connection is lost by client.\n\n        Args:\n            reason (str): Reason for connection lost by client\n        \"\"\"\n        self.factory.get_stream",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        return styles\n\ndef get_all_styles():\n        \"\"\"Get a dictionary of CSL styles.\"\"\"\n        styles = {}\n        for style in self.app.config.get('CSL_STYLES', []):\n            styles[style] = self.app.config.get(style)\n        return styles\n\ndef get_style(self, style):\n        \"\"\"Get a CSL style.\"\"\"\n        return self.app.config.get(style)\n\ndef get_style_name(self, style):\n        \"\"\"Get a CSL style name.\"\"\"\n        return self.app.config.get(style, '')\n\ndef get_style_value(self, style):\n        \"\"\"Get a CSL style value.\"\"\"\n        return self.app.config.get(style, '')\n\ndef get_style_value_list(self, style):\n        \"\"\"Get a CSL style value list.\"\"\"\n        return self.app.config.get(style, [])\n\ndef get_style_value_dict(self, style):\n        \"\"\"Get a CSL style value dict.\"\"\"\n        return self.app.config.get(style, {})\n\ndef get_style_value_list_dict(self, style):\n        \"\"\"Get a CSL style value list dict.\"\"\"\n        return self.app.config.",
        "\n\ndef stopProducing(self, consumer):\n        \"\"\" Stop producing.\n\n        Args:\n            consumer: Consumer\n        \"\"\"\n        self._consumer = consumer\n        self._current_deferred = defer.Deferred()\n        self._sent = 0\n        self._paused = True\n\n        if self._files:\n            self._files_iterator = self._files.iterkeys()\n            self._files_sent = 0\n            self._files_length = len(self._files)\n            self._current_file_path = None\n            self._current_file_handle = None\n            self._current_file_length = None\n            self._current_file_sent = 0\n\n            result = self._produce()\n            if result:\n                return result\n        else:\n            return defer.succeed(None)\n\n        return self._current_deferred\n\ndef _build_chunk_headers(self):\n        \"\"\" Build chunk headers.\n\n        Returns:\n            dict: Chunk headers\n        \"\"\"\n        headers = {}\n        for field in self._data:\n            headers[field] = self._chunk_headers[field]\n\n        return headers\n\ndef _send_to_consumer(self, block):\n        \"\"\" Send block to consumer.\n\n        Args:\n            block: Block to send",
        "\n        self._deferred = None\n        self._sent = None\n        self._current_file_handle = None\n        self._current_deferred = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n        self._current_file_handle = None\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _build_chunk_headers(self):\n        \"\"\" Builds the chunk headers for this request.\n\n        Returns:\n            dict. Chunk headers\n        \"\"\"\n        self._chunk_headers = {}\n\n        for field in self._data:\n            self._chunk_headers[field] = self._chunk_headers.get(field, 0) + 2\n\n        for field in self._files:\n            self._chunk_headers[field] = self._chunk_headers.get(field, 0) + 2\n\n        return self._chunk_headers\n\ndef _file_size(self, field):\n        \"\"\" Returns the size of the file for this request.\n\n        Args:\n            field (str): The field name\n\n        Returns:\n            int. Size of the file\n        \"\"\"\n        return self._data[field] + self._files[field]\n\ndef _parse_headers(self, headers):\n        \"\"\" Parses the headers from the request.\n\n        Args:\n            headers (dict): The headers\n\n        Returns:\n            dict. The parsed headers\n        \"\"\"\n        parsed_headers = {}\n\n        for header in headers:\n            if header.startswith('Content-Length:'):\n                parsed_headers[header[6:]] = header[7:]\n\n        return parsed_headers",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n    return s\n\n\ndef _path_to_str(path, result_type):\n    \"\"\"Given a path, returns an ASCII str.\"\"\"\n\n    assert isinstance(path, str)\n    if isinstance(path, bytes) and result_type is text_type:\n        return path.decode('ascii')\n    elif isinstance(path, text_type) and result_type is bytes:\n        return path.encode('ascii')\n    return path\n\n\ndef _path_to_str_with_encoding(path, result_type, encoding):\n    \"\"\"Given a path, returns an ASCII str with the given encoding.\"\"\"\n\n    assert isinstance(path, str)\n    if isinstance(path, bytes) and result_type is text_type:\n        return path.decode('ascii', encoding)\n    elif isinstance(path, text_type) and result_type is bytes:\n        return path.encode('ascii', encoding)\n    return path\n\n\ndef _path_to_str_with_encoding_and_encoding(path, result_type, encoding, encoding):\n    \"\"\"Given a path, returns an ASCII str with the given encoding and encoding.\"\"\"\n\n    assert isinstance(path, str)\n    if isinstance(path, bytes) and result_type is text_type:\n        return path.decode('ascii', encoding)\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef _PathLike(path):\n    \"\"\"A strategy which generates pathlike objects.\n\n    :param path:\n        The path to be generated.\n\n    :type path: :class:`python:str`\n\n    .. versionadded:: 3.15\n\n    \"\"\"\n    if path is None:\n        raise InvalidArgument('path is None')\n    if not isinstance(path, str):\n        raise InvalidArgument('path must be a string')\n    if not path.startswith('/'):\n        raise InvalidArgument('path must start with /')\n    if not path.endswith('/'):\n        raise InvalidArgument('path must end with /')\n    if not path.endswith('\\\\'):\n        raise InvalidArgument('path must end with \\\\')\n    if not path.endswith('\\\\'):\n        raise InvalidArgument('path must end with \\\\')\n    if not path.endswith('\\\\'):\n        raise InvalidArgument('path must end with \\\\')\n    if not path.endswith('\\\\'):\n        raise InvalidArgument('path must end with \\\\')\n    if not path.endswith('\\\\'):\n        raise InvalidArgument('path must end with \\\\')\n    if not path.endswith('\\\\'):\n        raise InvalidArgument('path must end with \\\\')\n    if not path.endswith('\\\\'):\n        raise InvalidArgument('path must end with \\\\')\n   ",
        "\n\ndef _compile(self, code, globals_dict=None):\n        \"\"\"compile compiled code\"\"\"\n        globals_dict = globals_dict or {}\n        globals_dict.setdefault('__builtins__', {})\n        exec(code, globals_dict)\n        return globals_dict\n\ndef _compile_file(self, filename, globals_dict=None):\n        \"\"\"compile compiled code\"\"\"\n        globals_dict = globals_dict or {}\n        globals_dict.setdefault('__builtins__', {})\n        exec(filename, globals_dict)\n        return globals_dict\n\ndef _compile_string(self, code, globals_dict=None):\n        \"\"\"compile compiled code\"\"\"\n        globals_dict = globals_dict or {}\n        globals_dict.setdefault('__builtins__', {})\n        exec(code, globals_dict)\n        return globals_dict\n\ndef _compile_file_string(self, filename, code, globals_dict=None):\n        \"\"\"compile compiled code\"\"\"\n        globals_dict = globals_dict or {}\n        globals_dict.setdefault('__builtins__', {})\n        exec(filename, globals_dict)\n        return globals_dict\n\ndef _compile_string_file(self, filename, code, globals_dict=None):\n        \"\"\"",
        "\n\ndef handle_include(self, text):\n        \"\"\"replace all blocks in includes with current blocks\"\"\"\n        match = self.re_include.match(text)\n        if match:\n            extra_text = self.re_include.sub('', text, count=1)\n            blocks = self.get_blocks(extra_text)\n            path = os.path.join(self.base_dir, match.group('path'))\n            with open(path, encoding='utf-8') as fp:\n                return self.replace_blocks_in_includes(fp.read(), blocks)\n        else:\n            return None\n\ndef handle_include_block(self, text):\n        \"\"\"replace all blocks in includes with current blocks\"\"\"\n        match = self.re_include_block.match(text)\n        if match:\n            extra_text = self.re_include_block.sub('', text, count=1)\n            blocks = self.get_blocks(extra_text)\n            path = os.path.join(self.base_dir, match.group('path'))\n            with open(path, encoding='utf-8') as fp:\n                return self.replace_blocks_in_includes(fp.read(), blocks)\n        else:\n            return None\n\ndef handle_include_block_",
        "(self.buffered) = []\n\ndef get_code(self):\n        \"\"\"return the generated code\"\"\"\n        return self.code_builder.get_code()\n\ndef get_result_var(self):\n        \"\"\"return the result variable\"\"\"\n        return self.result_var\n\ndef get_code_builder(self):\n        \"\"\"return the generated code builder\"\"\"\n        return self.code_builder\n\ndef get_result_var(self):\n        \"\"\"return the result variable\"\"\"\n        return self.result_var\n\ndef get_code_builder(self):\n        \"\"\"return the generated code builder\"\"\"\n        return self.code_builder\n\ndef get_code_builder(self):\n        \"\"\"return the generated code builder\"\"\"\n        return self.code_builder\n\ndef get_code_builder(self):\n        \"\"\"return the generated code builder\"\"\"\n        return self.code_builder\n\ndef get_code_builder(self):\n        \"\"\"return the generated code builder\"\"\"\n        return self.code_builder\n\ndef get_code_builder(self):\n        \"\"\"return the generated code builder\"\"\"\n        return self.code_builder\n\ndef get_code_builder(self):\n        \"\"\"return the generated code builder\"\"\"\n        return self.code_builder\n\ndef get_code_builder(self):\n",
        "\n\nclass Base(object):\n    \"\"\" Base class for all API classes.\n\n    This class is used to define the API methods.\n    \"\"\"\n\n    def __init__(self, api_key, api_secret):\n        \"\"\" Initialize the API.\n\n        Args:\n            api_key (str): API key\n            api_secret (str): API secret\n        \"\"\"\n        self._api_key = api_key\n        self._api_secret = api_secret\n        self._data = {}\n\n    def get_data(self):\n        \"\"\" Get POST data.\n\n        Returns:\n            dict: key => value dictionary\n        \"\"\"\n        return self._data\n\n    def add_data(self, data):\n        \"\"\" Add POST data.\n\n        Args:\n            data (dict): key => value dictionary\n        \"\"\"\n        self._data.update(data)\n\n    def get_api_key(self):\n        \"\"\" Get API key.\n\n        Returns:\n            str: API key\n        \"\"\"\n        return self._api_key\n\n    def get_api_secret(self):\n        \"\"\" Get API secret.\n\n        Returns:\n            str: API secret\n        \"\"\"\n        return self._api_secret\n\n    def get_api_url(self):\n        \"\"\" Get",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ":\n            raise RuntimeError('invalid XML character: ' + repr(c) + ' at offset ' + str(offset))\n\ndef validate_xml_comment(text):\n    \"\"\"validates XML comment\"\"\"\n    bad_chars = __INVALID_XML_COMMENT_CHARS & set(text)\n    if bad_chars:\n        for offset,c in enumerate(text):\n            if c in bad_chars:\n                raise RuntimeError('invalid XML character: ' + repr(c) + ' at offset ' + str(offset))\n\ndef validate_xml_element(text):\n    \"\"\"validates XML element\"\"\"\n    bad_chars = __INVALID_XML_ELEMENT_CHARS & set(text)\n    if bad_chars:\n        for offset,c in enumerate(text):\n            if c in bad_chars:\n                raise RuntimeError('invalid XML character: ' + repr(c) + ' at offset ' + str(offset))\n\ndef validate_xml_text_node(text):\n    \"\"\"validates XML text node\"\"\"\n    bad_chars = __INVALID_XML_TEXT_NODE_CHARS & set(text)\n    if bad_chars:\n        for offset,c in enumerate(text):\n            if c in bad_chars:\n                raise RuntimeError('invalid XML character: ' + repr(c) + ' at offset ' + str(",
        "\n    if name[0] in __INVALID_NAME_END_CHARS:\n        raise RuntimeError('XML name ends with invalid character')\n\n    if name[0] in __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS:\n        raise RuntimeError('XML name starts with invalid character and ends with invalid character')\n\n    if name[0] in __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS + __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS:\n        raise RuntimeError('XML name starts with invalid character and ends with invalid character and starts with invalid character')\n\n    if name[0] in __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS + __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS + __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS + __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS + __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS + __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS + __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS + __INVALID_NAME_START_CHARS + __INVALID_NAME_END_CHARS + __INVALID_NAME_START",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support",
        "\n\ndef on_exit_stage(self):\n        \"\"\"\n        Exit the stage.\n        \"\"\"\n        self.world.on_exit_game()\n\ndef on_exit_game(self):\n        \"\"\"\n        Exit the game.\n        \"\"\"\n        self.world.on_exit_game()\n\ndef on_update_game(self, dt):\n        \"\"\"\n        Update the game.\n        \"\"\"\n        self.world.on_update_game(dt)\n\ndef on_update_game_stage(self, dt):\n        \"\"\"\n        Update the game stage.\n        \"\"\"\n        self.world.on_update_game_stage(dt)\n\ndef on_update_game_stage_end(self, dt):\n        \"\"\"\n        Update the game stage end.\n        \"\"\"\n        self.world.on_update_game_stage_end(dt)\n\ndef on_update_game_stage_end_end(self, dt):\n        \"\"\"\n        Update the game stage end end.\n        \"\"\"\n        self.world.on_update_game_stage_end_end(dt)\n\ndef on_update_game_stage_end_end_end(self, dt):\n        \"\"\"\n        Update the game stage end end end end.\n        \"\"\"\n        self.world",
        "\n\n        # 4. Let the messaging system react to the end of the game.\n\n        self.messaging.on_finish_game()\n\n        # 5. Let the game system react to the end of the game.\n\n        self.game.on_finish_game()\n\n        # 6. Let the game system react to the end of the game.\n\n        self.game.on_finish_game()\n\n        # 7. Let the game system react to the end of the game.\n\n        self.game.on_finish_game()\n\n        # 8. Let the game system react to the end of the game.\n\n        self.game.on_finish_game()\n\n        # 9. Let the game system react to the end of the game.\n\n        self.game.on_finish_game()\n\n        # 10. Let the game system react to the end of the game.\n\n        self.game.on_finish_game()\n\n        # 11. Let the game system react to the end of the game.\n\n        self.game.on_finish_game()\n\n        # 12. Let the game system react to the end of the game.\n\n        self.game.on_finish_game()\n\n        # 13. Let the game system react to the end of the game.\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n            self._state.init()\n\n        self._state.init_async()\n\n        self._state.init_db()\n\n        self._state.init_db_async()\n\n        self._state.init_db_async_lock()\n\n        self._state.init_db_async_lock_async()\n\n        self._state.init_db_async_lock_async_lock()\n\n        self._state.init_db_async_lock_async_lock()\n\n        self._state.init_db_async_lock_async_lock_async()\n\n        self._state.init_db_async_lock_async_lock_async()\n\n        self._state.init_db_async_lock_async_lock_async()\n\n        self._state.init_db_async_lock_async_lock_async()\n\n        self._state.init_db_async_lock_async_lock_async()\n\n        self._state.init_db_async_lock_async_lock_async()\n\n        self._state.init_db_async_lock_async_lock_async()\n\n        self._state.init_db_async_lock_async_lock_async()\n\n        self._state.init_db_async_lock_async_lock",
        ".async_connect()\n\n    async def async_disconnect(self):\n        \"\"\"Catch a connection asyncrounosly.\"\"\"\n        if self._async_lock is None:\n            raise Exception('Error, database not properly initialized before async connection')\n\n        async with self._async_lock:\n            self.disconnect(True)\n\n        return self.conn.async_disconnect()\n\n    async def async_close(self):\n        \"\"\"Catch a connection asyncrounosly.\"\"\"\n        if self._async_lock is None:\n            raise Exception('Error, database not properly initialized before async connection')\n\n        async with self._async_lock:\n            self.close()\n\n        return self.conn.async_close()\n\n    async def async_execute(self, query, params=None):\n        \"\"\"Catch a connection asyncrounosly.\"\"\"\n        if self._async_lock is None:\n            raise Exception('Error, database not properly initialized before async connection')\n\n        async with self._async_lock:\n            return await self.conn.async_execute(query, params)\n\n    async def async_execute_async(self, query, params=None):\n        \"\"\"Catch a connection asyncrounosly.\"\"\"\n        if self._async_lock is None:\n            raise Exception('Error, database not properly initialized before",
        "\n\n    def _get_async(self):\n        \"\"\"Get self.\"\"\"\n        return self._async_result(self._get_result())\n\n    def _get_result(self):\n        \"\"\"Get self.\"\"\"\n        return self._async_result(self._get_result())\n\n    def _get_result(self):\n        \"\"\"Get self.\"\"\"\n        return self._async_result(self._get_result())\n\n    def _get_result(self):\n        \"\"\"Get self.\"\"\"\n        return self._async_result(self._get_result())\n\n    def _get_result(self):\n        \"\"\"Get self.\"\"\"\n        return self._async_result(self._get_result())\n\n    def _get_result(self):\n        \"\"\"Get self.\"\"\"\n        return self._async_result(self._get_result())\n\n    def _get_result(self):\n        \"\"\"Get self.\"\"\"\n        return self._async_result(self._get_result())\n\n    def _get_result(self):\n        \"\"\"Get self.\"\"\"\n        return self._async_result(self._get_result())\n\n    def _get_result(self):\n        \"\"\"Get self.\"\"\"\n        return self._async_result(self._get_result())\n\n    def _get_result(self):",
        "\n\n    async def connect(self):\n        \"\"\"Connect to the database.\"\"\"\n        if self._state.conn:\n            return\n\n        self._state.conn = await self._loop.run_in_executor(None, self._connect)\n\n    async def disconnect(self):\n        \"\"\"Disconnect from the database.\"\"\"\n        if not self._state.conn:\n            return\n\n        await self._loop.run_in_executor(None, self._disconnect)\n\n    async def _connect(self):\n        \"\"\"Connect to the database.\"\"\"\n        if self._state.conn:\n            return\n\n        self._state.conn = await self._loop.run_in_executor(None, self._connect)\n\n    async def _disconnect(self):\n        \"\"\"Disconnect from the database.\"\"\"\n        if not self._state.conn:\n            return\n\n        await self._loop.run_in_executor(None, self._disconnect)\n\n    async def _in_use(self):\n        \"\"\"Return the number of connections in the pool.\"\"\"\n        return len(self._in_use)\n\n    async def _in_use_count(self):\n        \"\"\"Return the number of connections in the pool.\"\"\"\n        return len(self._in_use)\n\n    async def _in_use_size(self):\n",
        "\n\nclass PooledAIODatabase(AIODatabase):\n    \"\"\"A database that uses a pool of connections.\"\"\"\n\n    def __init__(self, pool_size=None, pool_timeout=None, pool_timeout_multiplier=1,\n                 pool_timeout_multiplier_factor=1, pool_max_size=None,\n                 pool_max_size_multiplier=1, pool_max_size_multiplier_factor=1,\n                 pool_max_idle=None, pool_max_idle_multiplier=1,\n                 pool_max_idle_multiplier_factor=1, pool_max_waiters=None,\n                 pool_max_waiters_multiplier=1, pool_max_waiters_multiplier_factor=1,\n                 pool_min_size=None, pool_min_size_multiplier=1,\n                 pool_min_size_multiplier_factor=1, pool_min_size_multiplier_factor=1,\n                 pool_min_waiters=None, pool_min_waiters_multiplier=1,\n                 pool_min_waiters_multiplier_factor=1, pool_min_waiters_multiplier_factor=1,\n                 pool_min_waiters_multiplier_factor=1, pool_min_waiters_multiplier_factor=1,\n                 pool_min_wait",
        " false\n\ndef receive_id_from_client(self):\n        \"\"\"\n        Listen for an id from the client.\n\n        At the beginning of a game, each client receives an IdFactory from the \n        client.  This factory are used to give id numbers that are guaranteed \n        to be unique to tokens that created locally.  This method checks to see if such \n        a factory has been received.  If it hasn't, this method does not block \n        and immediately returns False.  If it has, this method returns True \n        after saving the factory internally.  At this point it is safe to enter \n        the GameStage.\n        \"\"\"\n        for message in self.pipe.receive():\n            if isinstance(message, IdFactory):\n                self.actor_id_factory = message\n                return True\n        return False\n\ndef receive_id_from_client_with_token(self, token):\n        \"\"\"\n        Listen for an id from the client with a token.\n\n        At the beginning of a game, each client receives an IdFactory from the \n        client.  This factory are used to give id numbers that are guaranteed \n        to be unique to tokens that created locally.  This method checks to see if such \n        a factory has been received.  If it hasn't, this method does not block \n        and immediately returns False.  If it has",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\n\ndef _relay_message_to_client(self, message):\n        \"\"\"\n        Relay messages from the forum on the server to the client represented by this actor.\n        \"\"\"\n        info(\"relaying message: {message}\".format(message=message))\n\n        if not message.was_sent_by(self._id_factory):\n            self.pipe.send(message)\n            self.pipe.deliver()\n\ndef _relay_message_to_server(self, message):\n        \"\"\"\n        Relay messages from the forum on the server to the client represented by this actor.\n        \"\"\"\n        info(\"relaying message: {message}\".format(message=message))\n\n        if message.was_sent_by(self._id_factory):\n            self.pipe.send(message)\n            self.pipe.deliver()\n\ndef _relay_message_to_all(self, message):\n        \"\"\"\n        Relay messages from the forum on the server to the client represented by this actor.\n        \"\"\"\n        info(\"relaying message: {message}\".format(message=message))\n\n        if message.was_sent_by(self._id_factory):\n            self.pipe.send(message)\n            self.pipe.deliver()\n\ndef _relay_",
        ".HTTPFound('/')\n\ndef index(request):\n    \"\"\" Return a list of all DataItems. \"\"\"\n    return models.DataItem.all()\n\ndef show(request, id):\n    \"\"\" Return a single DataItem. \"\"\"\n    return models.DataItem.get(id)\n\ndef update(request, id):\n    \"\"\" Update a DataItem. \"\"\"\n    return models.DataItem.update(id, content=''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(20)))\n\ndef delete(request, id):\n    \"\"\" Delete a DataItem. \"\"\"\n    models.DataItem.delete(id)\n    return muffin.HTTPFound('/')\n",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.internal.nio.Connection;\nimport com.hazelcast.internal.nio.ConnectionState;\nimport com.hazelcast.internal.protocol.ClientMessage;\nimport com.hazelcast.internal.protocol.codec.MapRemove",
        "\n\ndef _remove_from_world_with_extensions(self, extensions):\n        \"\"\"\n        Remove all the internal data the token needed while it was part of the world.\n\n        Note that this method doesn't actually remove the token from the \n        world.  That's what World._remove_token() does.  This method is just \n        responsible for setting the internal state of the token being removed.\n        \"\"\"\n        self.on_remove_from_world()\n        self._extensions = {}\n        self._disable_forum_observation()\n        self._world = None\n        self._id = None\n        for extension in extensions:\n            self._extensions[extension] = None\n\ndef _remove_from_world_with_id(self, id):\n        \"\"\"\n        Remove all the internal data the token needed while it was part of the world.\n\n        Note that this method doesn't actually remove the token from the \n        world.  That's what World._remove_token() does.  This method is just \n        responsible for setting the internal state of the token being removed.\n        \"\"\"\n        self.on_remove_from_world()\n        self._world = None\n        self._id = id\n\ndef _remove_from_world_with_world(self, world):\n        \"\"\"\n        Remove all the internal data the",
        "\n\ndef _lock_temporarily(self):\n        \"\"\"\n        Allow tokens to modify the world for the duration of a with-block.\n\n        It's important that tokens only modify the world at appropriate times, \n        otherwise the changes they make may not be communicated across the\n        network to other clients.  To help catch and prevent these kinds of\n        errors, the game engine keeps the world locked most of the time and\n        only briefly unlocks it (using this method) when tokens are allowed to\n        make changes.  When the world is locked, any token method can be called.\n        These checks can be disabled by running python with optimization enabled.\n        \"\"\"\n        if not self._is_locked:\n            yield\n        else:\n            try:\n                self._is_locked = True\n                yield\n            finally:\n                self._is_locked = False\n\ndef _lock_temporarily_with_block(self):\n        \"\"\"\n        Allow tokens to modify the world for the duration of a with-block.\n\n        It's important that tokens only modify the world at appropriate times, \n        otherwise the changes they make may not be communicated across the\n        network to other clients.  To help catch and prevent these kinds of\n        errors, the game engine keeps the world locked most of the time and\n        only briefly",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _obj2elt(obj, nsmap=None):\n    \"\"\"Converts lXML object to lXML tree\"\"\"\n\n    if obj.get('type') == ENTER:\n        return et.Enter(obj['text'], nsmap=nsmap)\n    elif obj.get('type') == PI:\n        return et.PI(obj['target'], nsmap=nsmap)\n    elif obj.get('type') == TEXT:\n        return et.Text(obj['text'], nsmap=nsmap)\n    elif obj.get('type') == COMMENT:\n        return et.Comment(obj['text'], nsmap=nsmap)\n    else:\n        assert False, obj\n\ndef _elt2obj(elt, nsmap=None):\n    \"\"\"Converts lXML tree to lXML object\"\"\"\n\n    if elt.get('type') == ENTER:\n        return obj2enter(elt)\n    elif elt.get('type') == PI:\n        return obj2pi(elt)\n    elif elt.get('type') == TEXT:\n        return obj2text(elt)\n    elif elt.get('type') == COMMENT:\n        return obj2comment(elt)\n    else:\n        assert False, elt\n\ndef obj2enter(elt):\n    \"\"\"Converts lXML tree to lXML object\"\"\"\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n    yield obj\n\ndef select(events):\n    \"\"\"selects sub-tree events\"\"\"\n    for obj in events:\n        if obj['type'] == ENTER:\n            yield obj\n        elif obj['type'] == EXIT:\n            yield obj\n\ndef select_all(events):\n    \"\"\"selects all sub-tree events\"\"\"\n    for obj in events:\n        if obj['type'] == ENTER:\n            yield obj\n        elif obj['type'] == EXIT:\n            yield obj\n\ndef select_all_with_children(events):\n    \"\"\"selects all sub-tree events with children\"\"\"\n    for obj in events:\n        if obj['type'] == ENTER:\n            for child in obj['children']:\n                yield select_all_with_children(child)\n        elif obj['type'] == EXIT:\n            for child in obj['children']:\n                yield select_all_with_children(child)\n\ndef select_all_with_children_and_children(events):\n    \"\"\"selects all sub-tree events with children and children\"\"\"\n    for obj in events:\n        if obj['type'] == ENTER:\n            for child in obj['children']:\n                yield select_all_with_children(child)\n                yield select_all_with_children(child)\n        elif obj",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef with_peer_with_text(events):\n    \"\"\"locates ENTER peer for each EXIT object. Convenient when selectively\n    filtering out XML markup\"\"\"\n\n    stack = []\n    for obj in events:\n        if obj['type'] == ENTER:\n            stack.append(obj)\n            yield obj, None\n        elif obj['type'] == EXIT:\n            yield obj, stack.pop()\n        else:\n            yield obj, obj['text']\n\ndef with_peer_with_text_and_text(events):\n    \"\"\"locates ENTER peer for each EXIT object. Convenient when selectively\n    filtering out XML markup\"\"\"\n\n    stack = []\n    for obj in events:\n        if obj['type'] == ENTER:\n            stack.append(obj)\n            yield obj, None\n        elif obj['type'] == EXIT:\n            yield obj, stack.pop()\n        else:\n            yield obj, obj['text'] + obj['text']\n\ndef with_peer_with_text_and_text_and_text(events):\n    \"\"\"locates ENTER peer for each EXIT object. Convenient when selectively\n    filtering out XML markup\"\"\"\n\n    stack = []\n    for obj in events:\n        if obj['type'] == ENTER:\n            stack.append(obj)\n           ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "\ndef to_ymd(self):\n        \"\"\"\n        construct datetime.date instance represented calendar date of BusinessDate instance\n\n        :return datetime.date:\n        \"\"\"\n        y, m, d = self.to_ymd_with_tz()\n        return date(y, m, d)\n\ndef to_ymd_with_tz(self):\n        \"\"\"\n        construct datetime.date instance represented calendar date of BusinessDate instance\n\n        :return datetime.date:\n        \"\"\"\n        y, m, d = self.to_ymd_with_tz_with_tz()\n        return date(y, m, d)\n\ndef to_ymd_with_tz_with_tz(self):\n        \"\"\"\n        construct datetime.date instance represented calendar date of BusinessDate instance\n\n        :return datetime.date:\n        \"\"\"\n        y, m, d = self.to_ymd_with_tz_with_tz_with_tz()\n        return date(y, m, d)\n\ndef to_ymd_with_tz_with_tz(self):\n        \"\"\"\n        construct datetime.date instance represented calendar date of BusinessDate instance\n\n        :return datetime.date:\n        \"\"\"\n        y, m, d = self.to_ymd_with_tz_with_tz",
        "\n\ndef add_business_days(self, d, businessdays, holiday_obj=None):\n        \"\"\"\n        addition of a businessdays object\n\n        :param BusinessDate d:\n        :param businessdays:\n        :type businessdays: BusinessPeriod or list\n        :param holiday_obj:\n        :return bankdate:\n        \"\"\"\n\n        if isinstance(businessdays, (list, tuple)):\n            return [BusinessDate.add_business_days(d, pd) for pd in businessdays]\n        elif isinstance(businessdays, str):\n            period = BusinessPeriod(businessdays)\n        else:\n            period = businessdays\n\n        res = self\n        res = BusinessDate.add_months(res, period.months)\n        res = BusinessDate.add_years(res, period.years)\n        res = BusinessDate.add_days(res, period.days)\n\n        if period.businessdays:\n            if holiday_obj:\n                res = BusinessDate.add_business_days(res, period.businessdays, holiday_obj)\n            else:\n                res = BusinessDate.add_business_days(res, period.businessdays, period.holiday)\n\n        return res\n\ndef add_business_days_to_date(self, d, businessdays, holiday_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef add_business_days_to_date(self, days_int, holiday_obj=None):\n        \"\"\"\n        private method for the addition of business days, used in the addition of a BusinessPeriod only\n\n        :param BusinessDate d:\n        :param int days_int:\n        :param list holiday_obj:\n        :return: BusinessDate\n        \"\"\"\n\n        res = self\n        if days_int >= 0:\n            count = 0\n            while count < days_int:\n                res = BusinessDate.add_days(res, 1)\n                if BusinessDate.is_business_day(res, holiday_obj):\n                    count += 1\n        else:\n            count = 0\n            while count > days_int:\n                res = BusinessDate.add_days(res, -1)\n                if BusinessDate.is_business_day(res, holiday_obj):\n                    count -= 1\n\n        return res\n\ndef add_business_days_to_date_with_holiday(self, days_int, holiday_obj=None):\n        \"\"\"\n        private method for the addition of business days, used in the addition of a BusinessPeriod only\n\n        :param BusinessDate d:\n        :param int days_int:\n        :param list holiday_obj:\n        :return:",
        ", quote_char\n\ndef quote(parser=any_token):\n    \"\"\"Parses as much as possible until it encounters a matching closing quote.\n    \n    By default matches any_token, but can be provided with a more specific parser if required.\n    Returns a string\n    \"\"\"\n    quote_char = quote()\n    value, _ = many_until(parser, partial(one_of, quote_char))\n    return build_string(value)\n\ndef build_string(value):\n    \"\"\"Builds a string from a value.\n    \n    By default matches any_token, but can be provided with a more specific parser if required.\n    Returns a string\n    \"\"\"\n    return value\n\ndef one_of(char):\n    \"\"\"Parses as much as possible until it encounters a matching one of the characters.\n    \n    By default matches any_token, but can be provided with a more specific parser if required.\n    Returns a string\n    \"\"\"\n    return char\n\ndef one_of_quote(char):\n    \"\"\"Parses as much as possible until it encounters a matching one of the characters.\n    \n    By default matches any_token, but can be provided with a more specific parser if required.\n    Returns a string\n    \"\"\"\n    return quote(char)\n\ndef one_of_quote_char(char):\n   ",
        "\n\ndef is_leap_year(year):\n    \"\"\"\n    returns True if the given year is a leap year\n\n    :param int year: calendar year\n    :return bool:\n    \"\"\"\n\n    return year % 4 == 0\n\ndef _days_per_month:\n    \"\"\"\n    returns the number of days per month\n\n    :return int:\n    \"\"\"\n\n    return _days_per_month[1]\n\ndef _days_per_year:\n    \"\"\"\n    returns the number of days per year\n\n    :return int:\n    \"\"\"\n\n    return _days_per_year[1]\n\ndef _days_per_week:\n    \"\"\"\n    returns the number of days per week\n\n    :return int:\n    \"\"\"\n\n    return _days_per_week[1]\n\ndef _days_per_month_week:\n    \"\"\"\n    returns the number of days per month week\n\n    :return int:\n    \"\"\"\n\n    return _days_per_month_week[1]\n\ndef _days_per_year_week:\n    \"\"\"\n    returns the number of days per year week\n\n    :return int:\n    \"\"\"\n\n    return _days_per_year_week[1]\n\ndef _days_per_month",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        self.cfg.connection_manual = True\n        self.cfg.connection_manual_callback = self.database.manual_callback\n        self.cfg.connection_manual_callback(self.database)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self.cfg)\n        self.cfg.connection_manual_callback(self",
        "\n        self.database.close()\n        self.database.delete()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self.database.delete_all()\n        self",
        "\ndef get(self, table_name):\n        \"\"\"Return a model from self.\"\"\"\n        return self.models[table_name]\n\ndef get_all(self):\n        \"\"\"Return all models in self.\"\"\"\n        return self.models.values()\n\ndef get_all_by_table_name(self, table_name):\n        \"\"\"Return all models in self by table_name.\"\"\"\n        return self.models.values().filter(table_name=table_name)\n\ndef get_all_by_table_name_and_model(self, table_name, model):\n        \"\"\"Return all models in self by table_name and model.\"\"\"\n        return self.models.values().filter(table_name=table_name, model=model)\n\ndef get_all_by_table_name_and_model_and_database(self, table_name, model, database):\n        \"\"\"Return all models in self by table_name and model and database.\"\"\"\n        return self.models.values().filter(table_name=table_name, model=model, database=database)\n\ndef get_all_by_table_name_and_model_and_database_and_model(self, table_name, model, database, model):\n        \"\"\"Return all models in self by table_name and model and database",
        "\n\n    async def close(self):\n        \"\"\"Close the database connection.\"\"\"\n        await self.database.async_close()\n\n    async def _context_manager(self, database):\n        \"\"\"Context manager for a database connection.\"\"\"\n        return _ContextManager(database)\n\n    def __init__(self, database):\n        \"\"\"Initialize a database connection.\"\"\"\n        self.database = database\n        self.connection = None\n\n    def connect(self):\n        \"\"\"Connect to the database.\"\"\"\n        self.connection = await self.database.async_connect()\n\n    def disconnect(self):\n        \"\"\"Disconnect from the database.\"\"\"\n        await self.database.async_disconnect()\n\n    async def execute(self, sql, *args, **kwargs):\n        \"\"\"Execute a SQL statement.\"\"\"\n        return await self.connection.execute(sql, *args, **kwargs)\n\n    async def execute_batch(self, sql, *args, **kwargs):\n        \"\"\"Execute a SQL statement with batch.\"\"\"\n        return await self.connection.execute_batch(sql, *args, **kwargs)\n\n    async def execute_scalar(self, sql, *args, **kwargs):\n        \"\"\"Execute a SQL statement with scalar.\"\"\"\n        return await self.connection.execute_scalar(sql, *args, **kwargs)\n\n    async def",
        "\n        title = pw.CharField()\n        image = pw.CharField()\n        rating = pw.IntegerField()\n        rating_count = pw.IntegerField()\n        rating_average = pw.FloatField()\n        rating_max = pw.FloatField()\n        rating_min = pw.FloatField()\n        rating_sum = pw.FloatField()\n        rating_avg = pw.FloatField()\n        rating_max_count = pw.IntegerField()\n        rating_min_count = pw.IntegerField()\n        rating_sum_count = pw.IntegerField()\n        rating_avg_count = pw.IntegerField()\n        rating_max_average = pw.FloatField()\n        rating_min_average = pw.FloatField()\n        rating_sum_average = pw.FloatField()\n        rating_max_count_average = pw.IntegerField()\n        rating_min_count_average = pw.IntegerField()\n        rating_sum_count_average = pw.IntegerField()\n        rating_avg_count_average = pw.FloatField()\n        rating_max_average_count = pw.IntegerField()\n        rating_min_average_count = pw.IntegerField()\n        rating_sum_average_count = pw.IntegerField()\n        rating_avg_count_average =",
        "\n\ndef parse(parser):\n    \"\"\"Parses a string and returns a parser object.\n    \"\"\"\n    def parse_block(*args, **kwargs):\n        return parser(*args, **kwargs)\n    return parse_block\n\ndef parse_list(parser):\n    \"\"\"Parses a string and returns a parser object.\n    \"\"\"\n    def parse_list_block(*args, **kwargs):\n        return parser(*args, **kwargs)\n    return parse_list_block\n\ndef parse_dict(parser):\n    \"\"\"Parses a string and returns a parser object.\n    \"\"\"\n    def parse_dict_block(*args, **kwargs):\n        return parser(*args, **kwargs)\n    return parse_dict_block\n\ndef parse_string(parser):\n    \"\"\"Parses a string and returns a parser object.\n    \"\"\"\n    def parse_string_block(*args, **kwargs):\n        return parser(*args, **kwargs)\n    return parse_string_block\n\ndef parse_number(parser):\n    \"\"\"Parses a string and returns a parser object.\n    \"\"\"\n    def parse_number_block(*args, **kwargs):\n        return parser(*args, **kwargs)\n    return parse_number_block\n\ndef parse_boolean(parser):\n    \"\"\"Parses a string and returns a parser object.\n    \"\"\"\n",
        "\n\ndef fail(these):\n    \"\"\"Returns the current token if is not found in the collection provided.\n    \n    Fails otherwise.\n    \"\"\"\n    ch = peek()\n    try:\n        if (ch is EndOfFile) or (ch not in these):\n            fail(list(these))\n    except TypeError:\n        if ch != these:\n            fail([these])\n    next()\n    return ch\n\ndef eof():\n    \"\"\"Returns the current token if it is found in the collection provided.\n    \n    Fails otherwise.\n    \"\"\"\n    ch = peek()\n    try:\n        if (ch is EndOfFile) or (ch in EndOfFile):\n            fail(list(EndOfFile))\n    except TypeError:\n        if ch != EndOfFile:\n            fail([EndOfFile])\n    next()\n    return ch\n\ndef eof_or_eof():\n    \"\"\"Returns the current token if it is found in the collection provided.\n    \n    Fails otherwise.\n    \"\"\"\n    ch = peek()\n    try:\n        if (ch is EndOfFile) or (ch in EndOfFile):\n            fail(list(EndOfFile))\n    except TypeError:\n        if ch != EndOfFile:\n            fail([EndOfFile])\n    next()\n    return ch\n",
        "\n\ndef one_of(these):\n    \"\"\"Returns the current token if it is found in the collection provided.\n    \n    The positive of one_of. \n    \"\"\"\n    ch = peek()\n    desc = \"one_of\" + repr(these)\n    try:\n        if (ch is EndOfFile) or (ch not in these):\n            fail([desc])\n    except TypeError:\n        if ch != these:\n            fail([desc])\n    next()\n    return ch\n\ndef not_one_of_all(these):\n    \"\"\"Returns the current token if it is not found in the collection provided.\n    \n    The negative of one_of_all. \n    \"\"\"\n    ch = peek()\n    desc = \"not_one_of_all\" + repr(these)\n    try:\n        if (ch is EndOfFile) or (ch not in these):\n            fail([desc])\n    except TypeError:\n        if ch != these:\n            fail([desc])\n    next()\n    return ch\n\ndef one_of_all(these):\n    \"\"\"Returns the current token if it is found in the collection provided.\n    \n    The positive of one_of_all. \n    \"\"\"\n    ch = peek()\n    desc = \"one_of_all",
        "\n\ndef one_of(guard):\n    \"\"\"Returns the current token if it satisfies the guard function provided.\n    \n    Fails otherwise.\n    This is the a generalisation of one_of.\n    \"\"\"\n    i = peek()\n    if (i is EndOfFile) or (not guard(i)):\n        fail([\"<one_of predicate \" + _fun_to_str(guard) + \">\"])\n    next()\n    return i\n\ndef _fun_to_str(fun):\n    \"\"\"Converts a function to a string representation of the function.\n    \n    This is the a generalisation of one_of.\n    \"\"\"\n    return fun.__name__\n\ndef _fun_to_int(fun):\n    \"\"\"Converts a function to an integer representation of the function.\n    \n    This is the a generalisation of one_of.\n    \"\"\"\n    return int(fun.__name__)\n\ndef _fun_to_float(fun):\n    \"\"\"Converts a function to a float representation of the function.\n    \n    This is the a generalisation of one_of.\n    \"\"\"\n    return float(fun.__name__)\n\ndef _fun_to_bool(fun):\n    \"\"\"Converts a function to a boolean representation of the function.\n    \n    This is the a generalisation",
        "\n\ndef not_followed_by_with_error(parser):\n    \"\"\"Succeeds if the given parser cannot consume input\"\"\"\n    @tri\n    def not_followed_by_with_error_block():\n        failed = object()\n        result = optional(tri(parser), failed)\n        if result != failed:\n            fail([\"not \" + _fun_to_str(parser)])\n    choice(not_followed_by_with_error_block)\n\ndef not_followed_by_with_error_with_error(parser):\n    \"\"\"Succeeds if the given parser cannot consume input\"\"\"\n    @tri\n    def not_followed_by_with_error_with_error_block():\n        failed = object()\n        result = optional(tri(parser), failed, error=object())\n        if result != failed:\n            fail([\"not \" + _fun_to_str(parser)])\n    choice(not_followed_by_with_error_with_error_block)\n\ndef not_followed_by_with_error_with_error_with_error(parser):\n    \"\"\"Succeeds if the given parser cannot consume input\"\"\"\n    @tri\n    def not_followed_by_with_error_with_error_",
        "\ndef optional(parser, terminate):\n    \"\"\"Applies the parser to input one or more times.\n    \n    Returns a parser result.\n    \"\"\"\n    result = parser.parse()\n    if result == terminate:\n        return terminate\n    return result\n\ndef parse(parser):\n    \"\"\"Parses a string.\n    \n    Returns a parser result.\n    \"\"\"\n    result = parser.parse()\n    return result\n\ndef local_ps():\n    \"\"\"Returns a local parser state.\n    \n    Returns a parser state.\n    \"\"\"\n    return parser.local_ps()\n\ndef local_ps_value():\n    \"\"\"Returns a local parser state.\n    \n    Returns a parser state.\n    \"\"\"\n    return parser.local_ps_value()\n\ndef local_ps_value_value():\n    \"\"\"Returns a local parser state.\n    \n    Returns a parser state.\n    \"\"\"\n    return parser.local_ps_value_value()\n\ndef local_ps_value_value_value():\n    \"\"\"Returns a local parser state.\n    \n    Returns a parser state.\n    \"\"\"\n    return parser.local_ps_value_value_value()\n\ndef local_ps_value_value_value_value():\n    \"\"\"Returns a local parser state.\n    \n    Returns a parser state.",
        ", result\n    return results, None\n\ndef choice(these, term):\n    \"\"\"Returns a tuple of the list of these results and the term result \n    \"\"\"\n    results = []\n    while True:\n        stop, result = choice(_tag(True, term),\n                              _tag(False, these))\n        if stop:\n            return results, result\n        else:\n            results.append(result)\n    return results, None\n\ndef _tag(tag, these):\n    \"\"\"Returns a tuple of the tag value and the list of these results\n    \"\"\"\n    return tag, these\n\ndef _tag_and_term(tag, these):\n    \"\"\"Returns a tuple of the tag value and the list of these results\n    \"\"\"\n    return tag, these, term\n\ndef _tag_and_term_and_these(tag, these, term):\n    \"\"\"Returns a tuple of the tag value and the list of these results\n    \"\"\"\n    return tag, these, term, these\n\ndef _tag_and_term_and_these_and_term(tag, these, term, these):\n    \"\"\"Returns a tuple of the tag value and the list of these results\n    \"\"\"\n    return tag, these, term, these, term\n\ndef _tag_and_term_and_these_and",
        ")\n\ndef many_until2(these, term):\n    \"\"\"Like many_until but must consume at least one of these.\n    \"\"\"\n    first = [these()]\n    these_results, term_result = many_until(these, term)\n    return (first + these_results, term_result)\n\ndef many_until3(these, term):\n    \"\"\"Like many_until but must consume at least one of these.\n    \"\"\"\n    first = [these()]\n    these_results, term_result = many_until(these, term)\n    return (first + these_results, term_result)\n\ndef many_until4(these, term):\n    \"\"\"Like many_until but must consume at least one of these.\n    \"\"\"\n    first = [these()]\n    these_results, term_result = many_until(these, term)\n    return (first + these_results, term_result)\n\ndef many_until5(these, term):\n    \"\"\"Like many_until but must consume at least one of these.\n    \"\"\"\n    first = [these()]\n    these_results, term_result = many_until(these, term)\n    return (first + these_results, term_result)\n\n",
        "(inner))\n\ndef sep2(parser, separator):\n    \"\"\"Like sep but must consume at least one of parser.\n    \"\"\"\n    first = [parser()]\n    def inner():\n        separator()\n        return parser()\n    return first + many(tri(inner))\n\ndef sep3(parser, separator):\n    \"\"\"Like sep but must consume at least one of parser.\n    \"\"\"\n    first = [parser()]\n    def inner():\n        separator()\n        return parser()\n    return first + many(tri(inner))\n\ndef sep4(parser, separator):\n    \"\"\"Like sep but must consume at least one of parser.\n    \"\"\"\n    first = [parser()]\n    def inner():\n        separator()\n        return parser()\n    return first + many(tri(inner))\n\ndef sep5(parser, separator):\n    \"\"\"Like sep but must consume at least one of parser.\n    \"\"\"\n    first = [parser()]\n    def inner():\n        separator()\n        return parser()\n    return first + many(tri(inner))\n\ndef sep6(parser, separator):\n    \"\"\"Like sep but must consume at least one of parser.\n    \"\"\"\n    first = [parser()]\n    def inner():\n        separator()\n        return parser()\n    return first + many(",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        return t\n\ndef peek(self):\n        \"\"\"Returns the next token or returns EndOfFile\"\"\"\n        if self.index >= len(self.tokens):\n                return EndOfFile\n        return self.tokens[self.index]\n\ndef _cut(self):\n        \"\"\"Removes the last token from the stack\"\"\"\n        self.index -= 1\n        self.tokens.pop()\n\ndef _print(self, s):\n        \"\"\"Prints the given string to the console\"\"\"\n        print s\n\ndef _print_list(self, s):\n        \"\"\"Prints the given string to the console\"\"\"\n        print s\n\ndef _print_dict(self, s):\n        \"\"\"Prints the given string to the console\"\"\"\n        print s\n\ndef _print_string(self, s):\n        \"\"\"Prints the given string to the console\"\"\"\n        print s\n\ndef _print_integer(self, s):\n        \"\"\"Prints the given string to the console\"\"\"\n        print s\n\ndef _print_float(self, s):\n        \"\"\"Prints the given string to the console\"\"\"\n        print s\n\ndef _print_boolean(self, s):\n        \"\"\"Prints the given string to the console\"\"\"\n        print s\n\ndef _print_null(self):\n        \"\"\"Prints the given string to the console\"\"\"\n        print",
        "\n\nif __name__ == '__main__':\n    main()\n",
        "\n\ndef _run_worker(self):\n        \"\"\"\n        Poll the queues that the worker can use to communicate with the supervisor, \n        until all the workers are done and all the queues are empty.  Handle messages \n        as they appear.\n        \"\"\"\n        import time\n\n        still_supervising = lambda: (\n                multiprocessing.active_children()\n                or not self.log_queue.empty()\n                or not self.exception_queue.empty())\n\n        try:\n            while still_supervising():\n                # When a log message is received, make a logger with the same \n                # name in this process and use it to re-log the message.  It \n                # will get handled in this process.\n\n                try:\n                    record = self.log_queue.get_nowait()\n                    logger = logging.getLogger(record.name)\n                    logger.handle(record)\n                except queue.Empty:\n                    pass\n                else:\n                    raise exception\n\n                # When an exception is received, immediately re-raise it.\n\n                try:\n                    exception = self.exception_queue.get_nowait()\n                except queue.Empty:\n                    pass\n                else:\n                    raise exception\n\n                # Sleep for a little bit, and make sure that the workers haven't \n                # outl",
        "\n\ndef field_type_choices():\n        \"\"\"Return database field type choices.\"\"\"\n        return [\n            ('JSON', 'JSON'),\n            ('TEXT', 'TEXT'),\n        ]\n\ndef field_type_choices_for_field(self, field):\n        \"\"\"Return database field type choices for field.\"\"\"\n        if not self.model:\n            return []\n        database = self.model._meta.database\n        if isinstance(database, Proxy):\n            database = database.obj\n        if Json and isinstance(database, PostgresqlDatabase):\n            return [\n                ('JSON', 'JSON'),\n                ('TEXT', 'TEXT'),\n            ]\n        return [\n            ('JSON', 'JSON'),\n            ('TEXT', 'TEXT'),\n        ]\n\ndef field_type_choices_for_field_choices(self, field, choices):\n        \"\"\"Return database field type choices for field choices.\"\"\"\n        if not self.model:\n            return []\n        database = self.model._meta.database\n        if isinstance(database, Proxy):\n            database = database.obj\n        if Json and isinstance(database, PostgresqlDatabase):\n            return [\n                ('JSON', 'JSON'),\n                ('TEXT', 'TEXT'),\n            ]\n        return [\n            ('JSON', 'JSON'),\n            ('TEXT', 'TEXT'),\n        ]\n",
        "\n        return value\n\ndef python_value_list(self, value):\n        \"\"\"Parse value from database.\"\"\"\n        if self.field_type == 'TEXT' and isinstance(value, str):\n            return self.loads(value)\n        return value\n\ndef python_value_dict(self, value):\n        \"\"\"Parse value from database.\"\"\"\n        if self.field_type == 'TEXT' and isinstance(value, str):\n            return self.loads(value)\n        return value\n\ndef python_value_datetime(self, value):\n        \"\"\"Parse value from database.\"\"\"\n        if self.field_type == 'DATE' and isinstance(value, str):\n            return self.loads(value)\n        return value\n\ndef python_value_datetime_list(self, value):\n        \"\"\"Parse value from database.\"\"\"\n        if self.field_type == 'DATE' and isinstance(value, str):\n            return self.loads(value)\n        return value\n\ndef python_value_datetime_dict(self, value):\n        \"\"\"Parse value from database.\"\"\"\n        if self.field_type == 'DATE' and isinstance(value, str):\n            return self.loads(value)\n        return value\n\ndef python_value_datetime_datetime(self, value):\n        \"\"\"Parse value from database.\"\"\"\n        if",
        ".text\n\ndef get_fsapi_device_url(self):\n        \"\"\"Parse the fsapi device url from the device url.\"\"\"\n        endpoint = yield from self.__session.get(self.fsapi_device_url, timeout = self.timeout)\n        text = yield from endpoint.text(encoding='utf-8')\n        doc = objectify.fromstring(text)\n        return doc.webfsapi.text\n\ndef get_fsapi_device_id(self):\n        \"\"\"Parse the fsapi device id from the device url.\"\"\"\n        endpoint = yield from self.__session.get(self.fsapi_device_url, timeout = self.timeout)\n        text = yield from endpoint.text(encoding='utf-8')\n        doc = objectify.fromstring(text)\n        return doc.webfsapi.id\n\ndef get_fsapi_device_name(self):\n        \"\"\"Parse the fsapi device name from the device url.\"\"\"\n        endpoint = yield from self.__session.get(self.fsapi_device_url, timeout = self.timeout)\n        text = yield from endpoint.text(encoding='utf-8')\n        doc = objectify.fromstring(text)\n        return doc.webfsapi.name\n\ndef get_fsapi_device_type(self):\n        \"\"\"Parse",
        "\n\ndef get_session(self):\n        \"\"\"Get a session from the frontier silicon device.\"\"\"\n        req_url = '%s/%s' % (self.__webfsapi, 'GET_SESSION')\n        sid = yield from self.__session.get(req_url, params=dict(pin=self.pin),\n                                            timeout = self.timeout)\n        text = yield from sid.text(encoding='utf-8')\n        doc = objectify.fromstring(text)\n        return doc.sessionId.text\n\ndef get_session_by_id(self, sid):\n        \"\"\"Get a session by its ID.\"\"\"\n        req_url = '%s/%s' % (self.__webfsapi, 'GET_SESSION_BY_ID')\n        sid = yield from self.__session.get(req_url, params=dict(pin=self.pin, sid=sid),\n                                            timeout = self.timeout)\n        text = yield from sid.text(encoding='utf-8')\n        doc = objectify.fromstring(text)\n        return doc.sessionId.text\n\ndef get_session_by_name(self, name):\n        \"\"\"Get a session by its name.\"\"\"\n        req_url = '%s/%s' % (self.__webfsapi, 'GET_SESSION_BY_",
        "\n\ndef get_fsapi_endpoint():\n    \"\"\"Get the webfsapi endpoint.\"\"\"\n    return 'https://api.webfs.com/v1'\n\ndef create_session():\n    \"\"\"Create a new session.\"\"\"\n    return objectify.Session(self.pin, self.sid)\n",
        "\n\ndef handle_get(self, item):\n        \"\"\"Helper method for getting a value by using the fsapi API.\"\"\"\n        doc = yield from self.call('GET/{}'.format(item), dict())\n        if doc is None:\n            return None\n\n        return doc.status == 'FS_OK'\n\ndef handle_list(self, item):\n        \"\"\"Helper method for listing values by using the fsapi API.\"\"\"\n        doc = yield from self.call('LIST/{}'.format(item), dict())\n        if doc is None:\n            return None\n\n        return doc.status == 'FS_OK'\n\ndef handle_delete(self, item):\n        \"\"\"Helper method for deleting a value by using the fsapi API.\"\"\"\n        doc = yield from self.call('DELETE/{}'.format(item), dict())\n        if doc is None:\n            return None\n\n        return doc.status == 'FS_OK'\n\ndef handle_exists(self, item):\n        \"\"\"Helper method for checking if a value exists by using the fsapi API.\"\"\"\n        doc = yield from self.call('EXISTS/{}'.format(item), dict())\n        if doc is None:\n            return None\n\n        return doc.status == 'FS_OK'\n\ndef handle_exists_recursive(self, item):\n        \"\"\"Helper method",
        "\n\ndef handle_date(self, item):\n        \"\"\"Helper method for fetching a date value.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return doc.value.c8_array.date\n\ndef handle_datetime(self, item):\n        \"\"\"Helper method for fetching a datetime value.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return doc.value.c8_array.datetime\n\ndef handle_datetime_utc(self, item):\n        \"\"\"Helper method for fetching a datetime value.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return doc.value.c8_array.datetime_utc\n\ndef handle_datetime_local(self, item):\n        \"\"\"Helper method for fetching a datetime value.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return doc.value.c8_array.datetime_local\n\ndef handle_datetime_utc_local(self, item):\n        \"\"\"Helper method for fetching a datetime value.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:",
        "\n\ndef handle_float(self, item):\n        \"\"\"Helper method for fetching a float value.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return float(doc.value.u8.text)\n\ndef handle_string(self, item):\n        \"\"\"Helper method for fetching a string value.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return str(doc.value.u8.text)\n\ndef handle_date(self, item):\n        \"\"\"Helper method for fetching a date value.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return datetime.datetime.strptime(doc.value.u8.text, '%Y-%m-%d')\n\ndef handle_datetime(self, item):\n        \"\"\"Helper method for fetching a datetime value.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return datetime.datetime.strptime(doc.value.u8.text, '%Y-%m-%d %H:%M:%S')\n\ndef handle_boolean(self, item):\n        \"\"\"Helper method for fetching a boolean value",
        "\n\ndef handle_float(self, item):\n        \"\"\"Helper method for fetching a float value. Result is float.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return float(doc.value.u32.text)\n\ndef handle_date(self, item):\n        \"\"\"Helper method for fetching a date value. Result is datetime.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return datetime.datetime.strptime(doc.value.u32.text, \"%Y-%m-%d\").date()\n\ndef handle_datetime(self, item):\n        \"\"\"Helper method for fetching a datetime value. Result is datetime.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return datetime.datetime.strptime(doc.value.u32.text, \"%Y-%m-%d %H:%M:%S\").date()\n\ndef handle_datetime_utc(self, item):\n        \"\"\"Helper method for fetching a datetime value. Result is datetime.\"\"\"\n        doc = yield from self.handle_get(item)\n        if doc is None:\n            return None\n\n        return datetime.datetime.strptime(doc.value",
        "(power)\n\ndef set_power(self, power):\n        \"\"\"Set the power of the device.\"\"\"\n        self.API.set('power', power)\n\ndef get_temperature(self):\n        \"\"\"Get the current temperature.\"\"\"\n        return self.handle_float(self.API.get('temperature'))\n\ndef set_temperature(self, temperature):\n        \"\"\"Set the current temperature.\"\"\"\n        self.API.set('temperature', temperature)\n\ndef get_humidity(self):\n        \"\"\"Get the current humidity.\"\"\"\n        return self.handle_float(self.API.get('humidity'))\n\ndef set_humidity(self, humidity):\n        \"\"\"Set the current humidity.\"\"\"\n        self.API.set('humidity', humidity)\n\ndef get_battery(self):\n        \"\"\"Get the current battery level.\"\"\"\n        return self.handle_float(self.API.get('battery'))\n\ndef set_battery(self, battery):\n        \"\"\"Set the current battery level.\"\"\"\n        self.API.set('battery', battery)\n\ndef get_water_level(self):\n        \"\"\"Get the current water level.\"\"\"\n        return self.handle_float(self.API.get('water_level'))\n\ndef set_",
        ")\n\ndef get_power(self):\n        \"\"\"Return the current power level of the device.\"\"\"\n        return int(yield from self.handle_get(\n            self.API.get('power')))\n\ndef set_temperature(self, value=None):\n        \"\"\"Set the temperature of the device.\"\"\"\n        if value is None:\n            value = self.API.get('temperature')\n        return (yield from self.handle_set(\n            self.API.get('temperature'), int(value)))\n\ndef get_temperature(self):\n        \"\"\"Return the current temperature of the device.\"\"\"\n        return int(yield from self.handle_get(\n            self.API.get('temperature')))\n\ndef set_humidity(self, value=None):\n        \"\"\"Set the humidity of the device.\"\"\"\n        if value is None:\n            value = self.API.get('humidity')\n        return (yield from self.handle_set(\n            self.API.get('humidity'), int(value)))\n\ndef get_humidity(self):\n        \"\"\"Return the current humidity of the device.\"\"\"\n        return int(yield from self.handle_get(\n            self.API.get('humidity')))\n\ndef set_battery(self, value=None):\n        \"\"\"",
        "\n\n    @property\n    def supported_features(self):\n        \"\"\"Flag supported features.\"\"\"\n        return self.API.get('supported_features')\n\n    @property\n    def supported_modes(self):\n        \"\"\"Flag supported modes.\"\"\"\n        return self.API.get('supported_modes')\n\n    @property\n    def supported_devices(self):\n        \"\"\"Flag supported devices.\"\"\"\n        return self.API.get('supported_devices')\n\n    @property\n    def device_state_attributes(self):\n        \"\"\"Return the state attributes.\"\"\"\n        return self.API.get('device_state_attributes')\n\n    @property\n    def device_info(self):\n        \"\"\"Return the device info.\"\"\"\n        return {\n            'identifiers': {(DOMAIN, self.API.get('id'))},\n            'name': self.API.get('name'),\n            'manufacturer': self.API.get('manufacturer'),\n            'model': self.API.get('model'),\n            'sw_version': self.API.get('sw_version'),\n        }\n\n    @property\n    def device_class(self):\n        \"\"\"Return the device class.\"\"\"\n        return self.API.get('device_class')\n\n    @property\n    def device_state_attributes_full(self):",
        "\n\n    @property\n    def volume_level(self):\n        \"\"\"Return the volume level of the device.\"\"\"\n        return self.__volume_level\n\n    @volume_level.setter\n    def volume_level(self, volume):\n        \"\"\"Set the volume level, range 0..1.\"\"\"\n        if volume < 0:\n            volume = 0\n        if volume > 1:\n            volume = 1\n        self.__volume_level = volume\n\n    @property\n    def supported_features(self):\n        \"\"\"Flag supported features.\"\"\"\n        return SUPPORT_VOLUME_STEP\n\n    @property\n    def supported_features_list(self):\n        \"\"\"Flag supported features.\"\"\"\n        return SUPPORT_VOLUME_STEP\n\n    @property\n    def device_state_attributes(self):\n        \"\"\"Return the state attributes.\"\"\"\n        return {\n            ATTR_VOLUME_STEP: self.volume_level,\n        }\n\n    @property\n    def device_state_attributes_max(self):\n        \"\"\"Return the max state attributes.\"\"\"\n        return {\n            ATTR_VOLUME_STEP: self.volume_level,\n        }\n\n    @property\n    def device_state_attributes_min(self):\n        \"\"\"Return the min state attributes.\"\"\"\n        return {\n            ATTR_VOLUME_STEP: self",
        "\n\ndef set_mute(self, mute):\n        \"\"\"Set the device's muted state.\"\"\"\n        self.API.set('mute', mute)\n\ndef get_volume_level(self):\n        \"\"\"Get the volume level of the media player (0..1).\"\"\"\n        return self.API.get('volume')\n\ndef set_volume_level(self, volume):\n        \"\"\"Set the volume level, range 0..1.\"\"\"\n        self.API.set('volume', volume)\n\ndef get_volume_max(self):\n        \"\"\"Get the maximum volume of the media player (0..1).\"\"\"\n        return self.API.get('maxVolume')\n\ndef set_volume_max(self, volume):\n        \"\"\"Set the maximum volume of the media player (0..1).\"\"\"\n        self.API.set('maxVolume', volume)\n\ndef get_volume_min(self):\n        \"\"\"Get the minimum volume of the media player (0..1).\"\"\"\n        return self.API.get('minVolume')\n\ndef set_volume_min(self, volume):\n        \"\"\"Set the minimum volume of the media player (0..1).\"\"\"\n        self.API.set('minVolume', volume)\n\ndef get_current_volume(self):\n        \"\"\"Get the current volume",
        ")\n\ndef set_volume_level(self, value):\n        \"\"\"Set volume level, range 0..1.\"\"\"\n        volume = (yield from self.handle_set(self.API.get('volume'), int(value)))\n        return int(volume)\n\ndef set_volume_mute(self, value):\n        \"\"\"Mute or unmute the device.\"\"\"\n        volume = (yield from self.handle_set(self.API.get('volume_mute'), int(value)))\n        return int(volume)\n\ndef set_volume_level(self, value):\n        \"\"\"Set volume level, range 0..1.\"\"\"\n        volume = (yield from self.handle_set(self.API.get('volume_level'), int(value)))\n        return int(volume)\n\ndef set_volume_mute(self, value):\n        \"\"\"Mute or unmute the device.\"\"\"\n        volume = (yield from self.handle_set(self.API.get('volume_mute'), int(value)))\n        return int(volume)\n\ndef set_volume_level(self, value):\n        \"\"\"Set volume level, range 0..1.\"\"\"\n        volume = (yield from self.handle_set(self.API.get('volume_level'), int(value)))\n        return int(volume)\n\ndef",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\n    @property\n    def name(self):\n        \"\"\"Return the name of the equaliser.\"\"\"\n        return self.API.get('name')\n\n    @property\n    def is_on(self):\n        \"\"\"Return true if the equaliser is on.\"\"\"\n        return self.API.get('is_on')\n\n    @property\n    def is_off(self):\n        \"\"\"Return true if the equaliser is off.\"\"\"\n        return self.API.get('is_off')\n\n    @property\n    def is_on_off(self):\n        \"\"\"Return true if the equaliser is on or off.\"\"\"\n        return self.API.get('is_on_off')\n\n    @property\n    def is_on_on(self):\n        \"\"\"Return true if the equaliser is on or on.\"\"\"\n        return self.API.get('is_on_on')\n\n    @property\n    def is_on_off_on(self):\n        \"\"\"Return true if the equaliser is on or on or on.\"\"\"\n        return self.API.get('is_on_off_on')\n\n    @property\n    def is_on_off_off(self):\n        \"\"\"Return true if the equaliser is on or on or off.\"\"\"\n        return self.API.get('is_on",
        "))\n\ndef set_sleep_interval(self, value=0):\n        \"\"\"Set device sleep timer interval.\"\"\"\n        return (yield from self.handle_set(self.API.get('sleep_interval'), int(value)))\n\ndef set_sleep_mode(self, value=False):\n        \"\"\"Set device sleep timer mode.\"\"\"\n        return (yield from self.handle_set(self.API.get('sleep_mode'), int(value)))\n\ndef set_sleep_mode_interval(self, value=0):\n        \"\"\"Set device sleep timer mode interval.\"\"\"\n        return (yield from self.handle_set(self.API.get('sleep_mode_interval'), int(value)))\n\ndef set_sleep_mode_mode(self, value=False):\n        \"\"\"Set device sleep timer mode mode.\"\"\"\n        return (yield from self.handle_set(self.API.get('sleep_mode_mode'), int(value)))\n\ndef set_sleep_mode_mode_interval(self, value=0):\n        \"\"\"Set device sleep timer mode mode interval.\"\"\"\n        return (yield from self.handle_set(self.API.get('sleep_mode_mode_interval'), int(value)))\n\ndef set_sleep_mode_mode_interval_mode(self, value=0):\n        \"\"\"Set device sleep timer",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _parse_variant(self, vcf_fields):\n        \"\"\"Parse variant from VCF line data\"\"\"\n        return vcf_fields[0]\n\ndef _parse_variant_id(self, vcf_fields):\n        \"\"\"Parse variant id from VCF line data\"\"\"\n        return vcf_fields[1]\n\ndef _parse_variant_name(self, vcf_fields):\n        \"\"\"Parse variant name from VCF line data\"\"\"\n        return vcf_fields[2]\n\ndef _parse_variant_type(self, vcf_fields):\n        \"\"\"Parse variant type from VCF line data\"\"\"\n        return vcf_fields[3]\n\ndef _parse_variant_quality(self, vcf_fields):\n        \"\"\"Parse variant quality from VCF line data\"\"\"\n        return vcf_fields[4]\n\ndef _parse_variant_alt(self, vcf_fields):\n        \"\"\"Parse variant alt from VCF line data\"\"\"\n        return vcf_fields[5]\n\ndef _parse_variant_alt_id(self, vcf_fields):\n        \"\"\"Parse variant alt id from VCF line data\"\"\"\n        return vcf_fields[6]\n\ndef _parse_variant_alt_name(self, vcf_fields):\n        \"\"\"Parse variant alt name from VCF line data\"\"\"\n        return vcf_fields[7]\n\ndef _parse_variant_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef objHasUnsavedChanges(self, cascadeObjects=True):\n\t\t'''\n\t\t\tobjHasUnsavedChanges - Check if any object has unsaved changes, cascading.\n\t\t'''\n\t\tif not self.obj:\n\t\t\treturn False\n\n\t\treturn self.obj.hasUnsavedChanges(cascadeObjects=cascadeObjects)\n\ndef objHasUnsavedChanges(self, cascadeObjects=False):\n\t\t'''\n\t\t\tobjHasUnsavedChanges - Check if any object has unsaved changes, cascading.\n\t\t'''\n\t\tif not self.obj:\n\t\t\treturn False\n\n\t\treturn self.obj.hasUnsavedChanges(cascadeObjects=cascadeObjects)\n\ndef objHasUnsavedChanges(self, cascadeObjects=False, cascade=False):\n\t\t'''\n\t\t\tobjHasUnsavedChanges - Check if any object has unsaved changes, cascading.\n\t\t'''\n\t\tif not self.obj:\n\t\t\treturn False\n\n\t\treturn self.obj.hasUnsavedChanges(cascadeObjects=cascade, cascade=cascade)\n\ndef objHasUnsavedChanges(self, cascade=False):\n\t\t'''\n\t\t\tobjHasUnsavedChanges - Check if any object has unsaved changes, cascading.\n\t\t'''\n\t\tif not self.obj:\n\t\t",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef save(cls, fh, data):\n        \"\"\"\n        Save json or yaml data to file handle.\n\n        Args:\n            fh (file): File handle to save to.\n            data (object): Data to save.\n\n        Examlple:\n            >>> with open('data.json', 'w') as json:\n            >>>    jsdata = composite.save(json, jsdata)\n            >>>\n            >>> with open('data.yml', 'w') as yml:\n            >>>    ymldata = composite.save(yml, ymldata)\n        \"\"\"\n        fh.write(data.to_json())\n\ndef from_json(data):\n        \"\"\"\n        Load json data from string.\n\n        Args:\n            data (string): Data to load.\n\n        Examlple:\n            >>> with open('data.json', 'r') as json:\n            >>>    jsdata = composite.from_json(json)\n        \"\"\"\n        return cls(data)\n\ndef from_yaml(data):\n        \"\"\"\n        Load yaml data from string.\n\n        Args:\n            data (string): Data to load.\n\n        Examlple:\n            >>> with open('data.yml', 'r') as yml:\n            >>>    ymldata = composite.from_yaml(yml)\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        " None\n\ndef union(self, other, recursive=True):\n        \"\"\"\n        Recursively compute union of data. For dictionaries, items\n        for specific keys will be reduced to unique items. For lists, items\n        will be reduced to unique items. This method is meant to be analogous\n        to set.union for composite objects.\n\n        Args:\n            other (composite): Other composite object to union with.\n            recursive (bool): Whether or not to perform the operation recursively,\n                for all nested composite objects.\n        \"\"\"\n        if not isinstance(other, composite):\n            raise AssertionError('Cannot union composite and {} types'.format(type(other)))\n        \n        if self.meta_type != other.meta_type:\n            return composite({})\n\n        if self.meta_type == 'list':\n            keep = []\n            for item in self._list:\n                if item in other._list:\n                    if recursive and isinstance(item, composite):\n                        keep.extend(item.union(other.index(item), recursive=True))\n                    else:\n                        keep.append(item)\n            return composite(keep)\n        elif self.meta_type == 'dict':\n            keep = {}\n            for key in self._dict:\n                item = self._dict[key]\n                if key in other._dict:\n",
        " None\n\ndef intersection(self, other, recursive=True, overwrite=False):\n        \"\"\"\n        Recursively compute intersection of data. For dictionaries, items\n        for specific keys will be combined into a list, depending on the\n        status of the overwrite= parameter. For lists, items will be appended\n        and reduced to unique items. This method is meant to be analogous\n        to set.intersection for composite objects.\n\n        Args:\n            other (composite): Other composite object to intersection with.\n            recursive (bool): Whether or not to perform the operation recursively,\n                for all nested composite objects.\n            overwrite (bool): Whether or not to overwrite entries with the same\n                key in a nested dictionary. \n        \"\"\"\n        if not isinstance(other, composite):\n            raise AssertionError('Cannot intersection composite and {} types'.format(type(other)))\n        \n        if self.meta_type != other.meta_type:\n            return composite([self, other])\n\n        if self.meta_type == 'list':\n            keep = []\n            for item in self._list:\n                keep.append(item)\n            for item in other._list:\n                if item not in self._list:\n                    keep.append(item)\n            return composite(keep)\n        elif self.meta_type == 'dict':\n            keep = {}\n           ",
        "\n        self._list.append(item)\n        return\n\ndef prepend(self, item):\n        \"\"\"\n        Prepend to object, if object is list.\n        \"\"\"\n        if self.meta_type == 'dict':\n            raise AssertionError('Cannot prepend to object of `dict` base type!')\n        if self.meta_type == 'list':\n            self._list.prepend(item)\n        return\n\ndef remove(self, item):\n        \"\"\"\n        Remove item from object, if object is list.\n        \"\"\"\n        if self.meta_type == 'dict':\n            raise AssertionError('Cannot remove from object of `dict` base type!')\n        if self.meta_type == 'list':\n            self._list.remove(item)\n        return\n\ndef remove_item(self, item):\n        \"\"\"\n        Remove item from object, if object is list.\n        \"\"\"\n        if self.meta_type == 'dict':\n            raise AssertionError('Cannot remove from object of `dict` base type!')\n        if self.meta_type == 'list':\n            self._list.remove_item(item)\n        return\n\ndef remove_last(self):\n        \"\"\"\n        Remove last item from object, if object is list.\n        \"\"\"\n        if self.meta_type == 'dict':",
        "\n        self._list.extend([item])\n        return\n\ndef extend_list(self, item):\n        \"\"\"\n        Extend list from object, if object is list.\n        \"\"\"\n        if self.meta_type == 'dict':\n            raise AssertionError('Cannot extend to object of `dict` base type!')\n        if self.meta_type == 'list':\n            self._list.extend([item])\n        return\n\ndef extend_dict(self, item):\n        \"\"\"\n        Extend dict from object, if object is dict.\n        \"\"\"\n        if self.meta_type == 'dict':\n            raise AssertionError('Cannot extend to object of `dict` base type!')\n        if self.meta_type == 'list':\n            self._dict.extend([item])\n        return\n\ndef extend_dict_list(self, item):\n        \"\"\"\n        Extend dict from object, if object is dict.\n        \"\"\"\n        if self.meta_type == 'dict':\n            raise AssertionError('Cannot extend to object of `dict` base type!')\n        if self.meta_type == 'list':\n            self._dict_list.extend([item])\n        return\n\ndef extend_dict_dict(self, item):\n        \"\"\"\n        Extend dict from object, if object is dict.\n        \"\"\"\n       ",
        "\n\ndef read_json(fh):\n        \"\"\"\n        Read composite object from file handle in JSON format.\n\n        Args:\n            fh (file): File handle to read from.\n        \"\"\"\n        sjson = json.JSONDecoder().decode(fh.read())\n        return self.json(sjson)\n\ndef write_csv(self, fh, pretty=True):\n        \"\"\"\n        Write composite object to file handle in CSV format.\n\n        Args:\n            fh (file): File handle to write to.\n            pretty (bool): Sort keys and indent in output.\n        \"\"\"\n        scsv = csv.writer(fh, delimiter=',', quotechar='\"')\n        scsv.writerow(self.json())\n        return\n\ndef read_csv(fh):\n        \"\"\"\n        Read composite object from file handle in CSV format.\n\n        Args:\n            fh (file): File handle to read from.\n        \"\"\"\n        scsv = csv.reader(fh, delimiter=',', quotechar='\"')\n        return self.json(scsv.read())\n\ndef write_csv_to_file(self, fh, pretty=True):\n        \"\"\"\n        Write composite object to file handle in CSV format.\n\n        Args:\n            fh (file): File handle to write to.\n            pretty (",
        "\n\ndef get_filelist(self):\n        \"\"\"\n        Return list of files in filetree.\n        \"\"\"\n        return self._filelist\n\ndef get_filelist_by_name(self, name):\n        \"\"\"\n        Return list of files in filetree.\n        \"\"\"\n        for item in self._data:\n            if item.name == name:\n                return self._data[item].filelist()\n        return []\n\ndef get_filelist_by_path(self, path):\n        \"\"\"\n        Return list of files in filetree.\n        \"\"\"\n        for item in self._data:\n            if item.path == path:\n                return self._data[item].filelist()\n        return []\n\ndef get_filelist_by_path_and_name(self, path, name):\n        \"\"\"\n        Return list of files in filetree.\n        \"\"\"\n        for item in self._data:\n            if item.path == path and item.name == name:\n                return self._data[item].filelist()\n        return []\n\ndef get_filelist_by_path_and_name_and_type(self, path, name, type):\n        \"\"\"\n        Return list of files in filetree.\n        \"\"\"\n        for item in self._data:\n            if",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "(self)\n\ndef save(self):\n\t\t'''\n\t\t\tsave - Save all objects in this list.\n\n\t\t\t@return <int> - Number of objects saved\n\t\t'''\n\t\tif len(self) == 0:\n\t\t\treturn 0\n\t\tmdl = self.getModel()\n\t\treturn mdl.saveMultiple(self)\n\ndef save_all(self):\n\t\t'''\n\t\t\tsave_all - Save all objects in this list.\n\n\t\t\t@return <int> - Number of objects saved\n\t\t'''\n\t\tif len(self) == 0:\n\t\t\treturn 0\n\t\tmdl = self.getModel()\n\t\treturn mdl.saveAll(self)\n\ndef save_one(self):\n\t\t'''\n\t\t\tsave_one - Save one object in this list.\n\n\t\t\t@return <int> - Number of objects saved\n\t\t'''\n\t\tif len(self) == 0:\n\t\t\treturn 0\n\t\tmdl = self.getModel()\n\t\treturn mdl.saveOne(self)\n\ndef save_many(self):\n\t\t'''\n\t\t\tsave_many - Save many objects in this list.\n\n\t\t\t@return <int> - Number of objects saved\n\t\t'''\n\t\t",
        "\n\ndef load(self, *args, **kwargs):\n\t\t'''\n\t\t\tload - Load all objects in this list\n\t\t'''\n\t\tif len(self) == 0:\n\t\t\treturn []\n\t\tmdl = self.getModel()\n\t\treturn mdl.saver.load(*args, **kwargs)\n\ndef delete(self, *args, **kwargs):\n\t\t'''\n\t\t\tdelete - Delete all objects in this list\n\t\t'''\n\t\tif len(self) == 0:\n\t\t\treturn []\n\t\tmdl = self.getModel()\n\t\treturn mdl.saver.delete(*args, **kwargs)\n\ndef delete_all(self):\n\t\t'''\n\t\t\tdelete_all - Delete all objects in this list\n\t\t'''\n\t\tif len(self) == 0:\n\t\t\treturn []\n\t\tmdl = self.getModel()\n\t\treturn mdl.saver.delete_all()\n\ndef delete_one(self, *args, **kwargs):\n\t\t'''\n\t\t\tdelete_one - Delete one object in this list\n\t\t'''\n\t\tif len(self) == 0:\n\t\t\treturn []\n\t\tmdl = self.getModel()\n\t\treturn mdl.saver.delete_one",
        "\n\ndef fetch(self, *args, **kwargs):\n\t\t'''\n\t\t\tfetch - Fetch all objects in this list. \n\t\t\t\tUpdates in-place. To just fetch all these objects again, use \"reload\"\n\n\t\t\t@return - List (same order as current objects) of either exception (KeyError) if operation failed,\n\t\t\t  or a dict of fields changed -> (old, new)\n\t\t'''\n\t\tif len(self) == 0:\n\t\t\treturn []\n\n\t\tret = []\n\t\tfor obj in self:\n\t\t\tres = None\n\t\t\ttry:\n\t\t\t\tres = obj.fetch(*args, **kwargs)\n\t\t\texcept Exception as e:\n\t\t\t\tres = e\n\n\t\t\tret.append(res)\n\n\t\treturn ret\n\ndef fetch_all(self, *args, **kwargs):\n\t\t'''\n\t\t\tfetch_all - Fetch all objects in this list. \n\t\t\t\tUpdates in-place. To just fetch all these objects again, use \"reload\"\n\n\t\t\t@return - List (same order as current objects) of either exception (KeyError) if operation failed,\n\t\t\t  or a dict of fields changed -> (old, new)\n\t\t'''\n\t\tif len(self) == 0:\n\t\t\treturn []\n\n\t\tret",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef output(self, output, *args, **kwargs):\n        '''Renders as a string'''\n        output.write(self.render_template(*args, **kwargs))\n\ndef render_template(self, *args, **kwargs):\n        '''Renders a template'''\n        template = self.template_path % args\n        return render_to_string(template, *args, **kwargs)\n\ndef render_to_string(self, template, *args, **kwargs):\n        '''Renders a string'''\n        return render_to_file(template, *args, **kwargs)\n\ndef render_to_file(self, template, *args, **kwargs):\n        '''Renders a file'''\n        with open(template, 'w') as f:\n                f.write(self.render_template(*args, **kwargs))\n\ndef render_to_file_with_context(self, template, *args, **kwargs):\n        '''Renders a file with context'''\n        with open(template, 'w') as f:\n                f.write(self.render_template(*args, **kwargs))\n                f.write('\\n')\n                f.write(self.render_context(*args, **kwargs))\n\ndef render_context(self, *args, **kwargs):\n        '''Renders a context'''",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef safe_repr_with_id(obj):\n    \"\"\"Returns a repr of an object and falls back to a minimal representation of type and ID if the call to repr raised an error.\n\n    :param obj: object to safe repr\n    :returns: repr string or '(type<id> repr error)' string\n    :rtype: str\n    \"\"\"\n    try:\n        obj_repr = repr(obj)\n    except:\n        obj_repr = \"({0}<{1}> repr error)\".format(type(obj), id(obj))\n    return obj_repr\n\ndef safe_repr_with_type(obj):\n    \"\"\"Returns a repr of an object and falls back to a minimal representation of type and ID if the call to repr raised an error.\n\n    :param obj: object to safe repr\n    :returns: repr string or '(type<id> repr error)' string\n    :rtype: str\n    \"\"\"\n    try:\n        obj_repr = repr(obj)\n    except:\n        obj_repr = \"({0}<{1}> repr error)\".format(type(obj), id(obj))\n    return obj_repr\n\ndef safe_repr_with_type_and_id(obj):\n    \"\"\"Returns a repr of an object and falls back to a minimal representation",
        "\n\n    # If we get here, we didn't find any matches.\n    raise StopIteration\n\n\ndef _next_line(file):\n    \"\"\"\n    Return the next line from a file.\n\n    This is a helper function that returns the next line from a file.\n    \"\"\"\n    while True:\n        try:\n            return file.readline()\n        except StopIteration:\n            break\n\n\ndef _get_chrom(line):\n    \"\"\"\n    Return the chrom of the line.\n\n    This is a helper function that returns the chrom of the line.\n    \"\"\"\n    return line.split()[0]\n\n\ndef _get_pos(line):\n    \"\"\"\n    Return the position of the line.\n\n    This is a helper function that returns the position of the line.\n    \"\"\"\n    return line.split()[1]\n",
        "\n\ndef as_csv(self):\n        \"\"\"Return Allele data as csv object.\"\"\"\n        self_as_csv = csv.DictWriter(sys.stdout, delimiter='\\t')\n        self_as_csv.writerow(self.as_dict())\n        return sys.stdout\n\ndef as_csv_with_header(self):\n        \"\"\"Return Allele data as csv object with header.\"\"\"\n        self_as_csv = csv.DictWriter(sys.stdout, delimiter='\\t', header=True)\n        self_as_csv.writerow(self.as_dict())\n        return sys.stdout\n\ndef as_csv_with_header_and_footer(self):\n        \"\"\"Return Allele data as csv object with header and footer.\"\"\"\n        self_as_csv = csv.DictWriter(sys.stdout, delimiter='\\t', header=True, footer=True)\n        self_as_csv.writerow(self.as_dict())\n        return sys.stdout\n\ndef as_csv_with_header_and_footer_with_header(self):\n        \"\"\"Return Allele data as csv object with header and footer with header.\"\"\"\n        self_as_csv = csv.DictWriter(sys.stdout, delimiter='\\t', header=True, footer=True, header=True)\n       ",
        "]\n\ndef _parse_variant_data(self):\n        \"\"\"Create list of Variant from VCF line data\"\"\"\n        return [Variant(sequence=x) for x in\n                [self.ref_variant, self.alt_variant] + self.alt_variants]\n\ndef _parse_variant_info(self):\n        \"\"\"Create list of VariantInfo from VCF line data\"\"\"\n        return [VariantInfo(variant=x) for x in\n                [self.ref_variant_info, self.alt_variant_info] + self.alt_variant_infos]\n\ndef _parse_variant_info_list(self):\n        \"\"\"Create list of VariantInfo from VCF line data\"\"\"\n        return [VariantInfo(variant=x) for x in\n                [self.ref_variant_info_list, self.alt_variant_info_list] + self.alt_variant_infos_list]\n\ndef _parse_variant_info_list_by_variant(self):\n        \"\"\"Create list of VariantInfo from VCF line data\"\"\"\n        return [VariantInfo(variant=x) for x in\n                [self.ref_variant_info_list, self.alt_variant_info_list,\n                 self.ref_variant_info_list_by_variant] + self.alt_variant_infos_list_by_",
        "\n\ndef _parse_variant_id(self, variant_id_field):\n        \"\"\"Parse the VCF variant ID field\"\"\"\n        variant_id = dict()\n        for item in variant_id_field.split(';'):\n            # Variant IDs may be \"foo=bar\" or just \"foo\".\n            # For the first case, store key \"foo\" with value \"bar\"\n            variant_id_item_data = item.split('=')\n            if len(variant_id_item_data) == 1:\n                variant_id[variant_id_item_data[0]] = True\n            elif len(variant_id_item_data) == 2:\n                variant_id[variant_id_item_data[0]] = variant_id_item_data[1]\n        return variant_id\n\ndef _parse_variant_name(self, variant_name_field):\n        \"\"\"Parse the VCF variant name field\"\"\"\n        variant_name = dict()\n        for item in variant_name_field.split(';'):\n            # Variant names may be \"foo=bar\" or just \"foo\".\n            # For the first case, store key \"foo\" with value \"bar\"\n            variant_name_item_data = item.split('=')\n            if len(variant_name_item_data",
        "\n\ndef parse_vcf(vcf_file):\n        \"\"\"Parse a VCF file and return a parsed VCF object\"\"\"\n        with open(vcf_file, 'r') as f:\n            vcf = Vcf(f.read())\n        return vcf\n\ndef parse_vcf_with_info(vcf_file, info_file):\n        \"\"\"Parse a VCF file and return a parsed VCF object\"\"\"\n        with open(vcf_file, 'r') as f:\n            vcf = Vcf(f.read())\n        with open(info_file, 'r') as f:\n            info = VcfInfo(f.read())\n        return vcf, info\n\ndef parse_vcf_with_info_and_alleles(vcf_file, info_file, alleles):\n        \"\"\"Parse a VCF file and return a parsed VCF object\"\"\"\n        with open(vcf_file, 'r') as f:\n            vcf = Vcf(f.read())\n        with open(info_file, 'r') as f:\n            info = VcfInfo(f.read())\n        with open(alleles, 'r') as f:\n            alleles = [Vcf(x.as_dict()) for x in f]\n        return vcf, info, alleles\n\ndef parse_vcf_with_info_and_alleles_and_",
        "\n\ndef get_chrom(vcf_line):\n        \"\"\"\n        Very lightweight parsing of a vcf line to get chromosome.\n\n        Returns a dict containing:\n        'chrom': index of chromosome (int), indicates sort order\n        'pos': position on chromosome (int)\n        \"\"\"\n        if not vcf_line:\n            return None\n        vcf_data = vcf_line.strip().split('\\t')\n        return_data = dict()\n        return_data['chrom'] = CHROM_INDEX[vcf_data[0]]\n        return_data['pos'] = int(vcf_data[1])\n        return return_data\n\ndef get_pos_and_chrom(vcf_line):\n        \"\"\"\n        Very lightweight parsing of a vcf line to get position and chromosome.\n\n        Returns a dict containing:\n        'chrom': index of chromosome (int), indicates sort order\n        'pos': position on chromosome (int)\n        'pos_and_chrom': position and chromosome (int)\n        \"\"\"\n        if not vcf_line:\n            return None\n        vcf_data = vcf_line.strip().split('\\t')\n        return_data = dict()\n        return_data['chrom'] = CHROM_INDEX[vcf_data[0]]\n        return_data['pos'] = int(",
        "\ndef _fromStorage(self, value):\n\t\t'''\n\t\t\t_fromStorage - Convert the string representation of a value to an item.\n\n\t\t\t@param value - The string representation of the item to convert\n\t\t\t@return An item object\n\t\t'''\n\n\t\tfor chainedField in self.chainedFields:\n\t\t\tvalue = chainedField.fromStorage(value)\n\n\t\treturn value\n\nclass _ChainedField(object):\n\t'''\n\t\t_ChainedField - A chained field.\n\n\t\t@param name - The name of the field.\n\t\t@param type - The type of the field.\n\t\t@param chainedFields - The chained fields.\n\t'''\n\n\tdef __init__(self, name, type, chainedFields):\n\t\t'''\n\t\t\t_ChainedField - Constructor.\n\n\t\t\t@param name - The name of the field.\n\t\t\t@param type - The type of the field.\n\t\t\t@param chainedFields - The chained fields.\n\t\t'''\n\n\t\tself.name = name\n\t\tself.type = type\n\t\tself.chainedFields = chainedFields\n\n\tdef toStorage(self, value):\n\t\t'''\n\t\t\ttoStorage - Convert the value to a string representation for storage.\n\n\t\t\t@param",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef from_dict(self, d):\n        \"\"\"Return ClinVarAllele data from dict object.\"\"\"\n        return ClinVarAllele(**d)\n\nclass ClinVarAllele(object):\n    \"\"\"ClinVarAllele class.\"\"\"\n    def __init__(self, hgvs=None, clnalleleid=None, clnsig=None, clndn=None, clndisdb=None, clnvi=None):\n        \"\"\"Initialize ClinVarAllele object.\"\"\"\n        self.hgvs = hgvs\n        self.clnalleleid = clnalleleid\n        self.clnsig = clnsig\n        self.clndn = clndn\n        self.clndisdb = clndisdb\n        self.clnvi = clnvi\n",
        "\n\ndef _parse_alleles(self):\n        \"\"\"Parse allele data in ClinVar VCF\"\"\"\n        alleles = OrderedDict([\n            ('A', 'Unknown'),\n            ('C', 'Unknown'),\n            ('G', 'Unknown'),\n            ('T', 'Unknown'),\n            ('N', 'Unknown'),\n            ('O', 'Unknown'),\n            ('P', 'Unknown'),\n            ('Q', 'Unknown'),\n            ('R', 'Unknown'),\n            ('S', 'Unknown'),\n            ('T', 'Unknown'),\n            ('U', 'Unknown'),\n            ('V', 'Unknown'),\n            ('W', 'Unknown'),\n            ('X', 'Unknown'),\n            ('Y', 'Unknown'),\n            ('Z', 'Unknown')])\n        pref_alleles = 'Unknown'\n        for source in alleles.keys():\n            allele_key = 'AF_' + source\n            if allele_key in self.info:\n                alleles[source] = self.info[allele_key]\n                if pref_alleles == 'Unknown':\n                    pref_alleles = alleles[source]\n        return pref_alleles, alleles\n\ndef _parse_alleles_and_counts(self):\n        \"\"\"Parse allele data in ClinVar VCF\"\"\"\n        alleles_and_counts = OrderedDict([\n            ('A', 'Unknown'),\n",
        "\n\nclass ClinVarAllele(VCFAllele):\n    \"\"\"Represents a single ClinVar allele in a VCF.\"\"\"\n\n    def __init__(self, frequency, sequence, **cln_data):\n        \"\"\"Initialize a ClinVar allele.\"\"\"\n        super(ClinVarAllele, self).__init__(\n            frequency=frequency, sequence=sequence, **cln_data)\n\n    def __str__(self):\n        \"\"\"Return a string representation of the allele.\"\"\"\n        return 'ClinVarAllele(frequency=%s, sequence=%s, **%s)' % (\n            self.frequency, self.sequence, self.info)\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the allele.\"\"\"\n        return '<ClinVarAllele(frequency=%s, sequence=%s, **%s)>' % (\n            self.frequency, self.sequence, self.info)\n\n    def __eq__(self, other):\n        \"\"\"Return true if the allele is equal to another.\"\"\"\n        return self.frequency == other.frequency and self.sequence == other.sequence\n\n    def __ne__(self, other):\n        \"\"\"Return true if the allele is not equal to another.\"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self",
        "\n        return decorator\n\ndef register(name, *names):\n        '''Registers a Blox to this factory'''\n        self[name] = name\n\ndef register_all(name, *names):\n        '''Registers all Blox to this factory'''\n        for name in names:\n                self[name] = name\n\ndef register_all_names(name, *names):\n        '''Registers all Blox to this factory'''\n        for name in names:\n                self[name] = name\n\ndef register_all_names_and_defaults(name, *names):\n        '''Registers all Blox to this factory'''\n        for name in names:\n                self[name] = name\n                self[name] = name\n\ndef register_all_names_and_defaults_and_defaults(name, *names):\n        '''Registers all Blox to this factory'''\n        for name in names:\n                self[name] = name\n                self[name] = name\n                self[name] = name\n\ndef register_all_names_and_defaults_and_defaults(name, *names):\n        '''Registers all Blox to this factory'''\n        for name in names:\n                self[name] = name\n                self[name] = name\n                self[name] = name\n\n",
        "\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef clearRedisPools():\n\t'''\n\t\tclearRedisPools - Clears all Redis connections and connections pools.\n\t'''\n\tglobal RedisPools\n\tglobal _defaultRedisConnectionParams\n\tglobal _redisManagedConnectionParams\n\n\tfor key in _redisManagedConnectionParams.keys():\n\t\t_redisManagedConnectionParams[key] = []\n\n\tfor key in RedisPools.keys():\n\t\tRedisPools[key] = None\n\n\t_defaultRedisConnectionParams = {}\n\t_redisManagedConnectionParams = {}\n\n\ndef hashDictOneLevel(params):\n\t'''\n\t\thashDictOneLevel - Hashes a dict of REDIS_CONNECTION_PARAMS to a hash value.\n\n\t\t\t@param params <dict> - REDIS_CONNECTION_PARAMS - kwargs to redis.Redis\n\n\t\t\t@return hash value of the dict\n\t'''\n\thashValue = 0\n\tfor key in params.keys():\n\t\thashValue = hashValue * 31 + key\n\treturn hashValue\n\n\ndef hashDict(params):\n\t'''\n\t\thashDict - Hashes a dict of REDIS_CONNECTION_PARAMS to a hash value.\n\n\t\t\t@param params <dict> - REDIS_CONNECTION_PARAMS - kwargs to redis.Redis\n\n\t\t\t@return hash value of the dict\n\t'''\n\thashValue",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef objHasUnsavedChanges(self):\n\t\t'''\n\t\t\tobjHasUnsavedChanges - Check if any unsaved changes are present in this model, or if it has never been saved.\n\n\t\t\t@return <bool> - True if any fields have changed since last fetch, or if never saved, False\n\t\t'''\n\t\tif not self._id or not self._origData:\n\t\t\treturn True\n\n\t\tfor thisField in self.FIELDS:\n\t\t\tthisVal = object.__getattribute__(self, thisField)\n\t\t\tif self._origData.get(thisField, '') != thisVal:\n\t\t\t\treturn True\n\n\t\treturn False\n\ndef objHasUnsavedChangesRecursive(self, cascadeObjects=False):\n\t\t'''\n\t\t\tobjHasUnsavedChangesRecursive - Check if any unsaved changes are present in this model, or if it has never been saved.\n\n\t\t\t@param cascadeObjects <bool> default False, if True will check if any foreign linked objects themselves have unsaved changes (recursively).\n\t\t\t\tOtherwise, will just check if the pk has changed.\n\n\t\t\t@return <bool> - True if any fields have changed since last fetch, or if never saved, False\n\t\t'''\n\t\tif not self._id or not self._origData:\n\t\t\t",
        "\n\ndef isIndexedRedisModel(obj):\n\t\t'''\n\t\t\tisIndexedRedisModel - Check if the given object is an IndexedRedisModel.\n\n\t\t\t@param obj <IndexedRedisModel instance> - Object to check.\n\n\t\t\t@return <bool> - True if the object is an IndexedRedisModel, False otherwise.\n\t\t'''\n\n\t\treturn isinstance(obj, IndexedRedisModel)\n\ndef isIndexedRedisModelInstance(obj):\n\t\t'''\n\t\t\tisIndexedRedisModelInstance - Check if the given object is an IndexedRedisModelInstance.\n\n\t\t\t@param obj <IndexedRedisModelInstance instance> - Object to check.\n\n\t\t\t@return <bool> - True if the object is an IndexedRedisModelInstance, False otherwise.\n\t\t'''\n\n\t\treturn isinstance(obj, IndexedRedisModelInstance)\n\ndef isIndexedRedisModelInstanceOrSelf(obj):\n\t\t'''\n\t\t\tisIndexedRedisModelInstanceOrSelf - Check if the given object is an IndexedRedisModelInstanceOrSelf.\n\n\t\t\t@param obj <IndexedRedisModelInstanceOrSelf instance> - Object to check.\n\n\t\t\t@return <bool> - True if the object is an IndexedRedisModelInstanceOrSelf, False otherwise.\n\t\t'''\n\n\t\treturn isinstance(obj, IndexedRedisModelInstanceOrSelf)\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "\n\ndef asDict(self, copyPrimaryKey=False, forStorage=False):\n\t\t'''\n                    asDict - Returns a dictionary representation of this object.\n\n                    @param copyPrimaryKey <bool> default False - If True, any changes to the copy will save over-top the existing entry in Redis.\n                        If False, only the data is copied, and nothing is saved.\n\n\t\t    @param forStorage <bool> default False - If True, the object will be saved in Redis for storage. If False, the object will be saved in Redis for\n\t\t      storage.\n\n\t\t@return <dict> - A dictionary representation of this object, per above\n\n\t\t@see IndexedRedisModel.asDict\n\t\t'''\n\t\treturn self.__class__.asDict(**self.asDict(copyPrimaryKey, forStorage=forStorage))\n\ndef asDictWithPrimaryKey(self, copyPrimaryKey=False, forStorage=False):\n\t\t'''\n                    asDictWithPrimaryKey - Returns a dictionary representation of this object.\n\n                    @param copyPrimaryKey <bool> default False - If True, any changes to the copy will save over-top the existing entry in Redis.\n                        If False, only the data is copied, and nothing is saved.\n\n\t\t    @param forStorage <bool> default False - If True, the object will be saved in Redis for",
        "\n\ndef saveToExternalWithPipeline(self, redisCon):\n\t\t'''\n\t\t\tsaveToExternalWithPipeline - Saves this object to a different Redis than that specified by REDIS_CONNECTION_PARAMS on this model.\n\n\t\t\t@param redisCon <dict/redis.Redis> - Either a dict of connection params, a la REDIS_CONNECTION_PARAMS, or an existing Redis connection.\n\t\t\t\tIf you are doing a lot of bulk copies, it is recommended that you create a Redis connection and pass it in rather than establish a new\n\t\t\t\tconnection with each call.\n\n\t\t\t@note - You will generate a new primary key relative to the external Redis environment. If you need to reference a \"shared\" primary key, it is better\n\t\t\t\t\tto use an indexed field than the internal pk.\n\n\t\t'''\n\t\tif type(redisCon) == dict:\n\t\t\tconn = redis.Redis(**redisCon)\n\t\telif hasattr(conn, '__class__') and issubclass(conn.__class__, redis.Redis):\n\t\t\tconn = redisCon\n\t\telse:\n\t\t\traise ValueError('saveToExternalWithPipeline \"redisCon\" param must either be a dictionary of connection parameters, or redis.Redis, or extension thereof')\n\n\t\tsaver = self.saver\n\n\t\t# Fetch next PK from external\n",
        "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "\n\ndef _modelCopyMap:\n\t\t'''\n\t\t\t_modelCopyMap - A map of model classes to their unique names.\n\t\t'''\n\t\tif _modelCopyMap is None:\n\t\t\t_modelCopyMap = {}\n\t\treturn _modelCopyMap\n\nclass IndexedRedisModel(object):\n\t'''\n\t\tIndexedRedisModel - A model class that can be used to store and retrieve data from Redis.\n\t'''\n\tdef __init__(self, name, fields, indexed_fields, **kwargs):\n\t\t'''\n\t\t\tIndexedRedisModel - Constructor.\n\n\t\t\t@param name - The name of the model.\n\t\t\t@param fields - The fields of the model.\n\t\t\t@param indexed_fields - The fields of the model.\n\t\t'''\n\t\tself.name = name\n\t\tself.fields = fields\n\t\tself.indexed_fields = indexed_fields\n\t\tself.validateModel()\n\n\tdef validateModel(self):\n\t\t'''\n\t\t\tvalidateModel - Validate the model.\n\t\t'''\n\t\tfor field in self.fields:\n\t\t\tfield.validateModel()\n\n\tdef __str__(self):\n\t\t'''\n\t\t\t__str__ - Return a string representation of the model.\n\t\t'''\n\t\treturn self.name",
        "\n\ndef hashDictOneLevel(redisConnectionParams):\n\t\t'''\n\t\t\thashDictOneLevel - Create a hash value for the REDIS_CONNECTION_PARAMS dictionary.\n\n\t\t\t@param redisConnectionParams <dict> - Dictionary of arguments to redis.Redis, same as REDIS_CONNECTION_PARAMS.\n\n\t\t\t@return - A hash value for the REDIS_CONNECTION_PARAMS dictionary.\n\t\t'''\n\t\thashVal = 0\n\t\tfor key in redisConnectionParams:\n\t\t\thashVal += key\n\t\treturn hashVal\n\nclass IndexedRedisModel(object):\n\t'''\n\t\tIndexedRedisModel - Create a class of this model which will use an alternate connection than the one specified by REDIS_CONNECTION_PARAMS on this model.\n\n\t\t@param redisConnectionParams <dict> - Dictionary of arguments to redis.Redis, same as REDIS_CONNECTION_PARAMS.\n\n\t\t@return - A class that can be used in all the same ways as the existing IndexedRedisModel, but that connects to a different instance.\n\t'''\n\tdef __init__(self, redisConnectionParams):\n\t\t'''\n\t\t\t__init__ - Create a class of this model which will use an alternate connection than the one specified by REDIS_CONNECTION_PARAMS on this model.\n\n\t\t\t@param redisConnectionParams <dict> - Dictionary",
        "(connection_pool=pool)\n\ndef _get_new_connection_with_timeout(self, timeout):\n\t\t'''\n\t\t\t_get_new_connection_with_timeout - Get a new connection\n\t\t\tinternal\n\t\t'''\n\t\tpool = getRedisPool(self.mdl.REDIS_CONNECTION_PARAMS)\n\t\treturn redis.Redis(connection_pool=pool, timeout=timeout)\n\ndef _get_new_connection_with_timeout_and_pool(self, timeout, pool):\n\t\t'''\n\t\t\t_get_new_connection_with_timeout_and_pool - Get a new connection\n\t\t\tinternal\n\t\t'''\n\t\tpool = getRedisPool(self.mdl.REDIS_CONNECTION_PARAMS)\n\t\treturn redis.Redis(connection_pool=pool, timeout=timeout)\n\ndef _get_new_connection_with_pool(self, pool):\n\t\t'''\n\t\t\t_get_new_connection_with_pool - Get a new connection\n\t\t\tinternal\n\t\t'''\n\t\tpool = getRedisPool(self.mdl.REDIS_CONNECTION_PARAMS)\n\t\treturn redis.Redis(connection_pool=pool)\n\ndef _get_new_connection_with_pool_and_timeout(self, pool, timeout):\n",
        "\n\ndef _get_new_connection(self):\n\t\t'''\n\t\t\t_get_new_connection - Create a new connection, or reuse if passed in.\n\t\t\t\tWill share a connection with a model\n\t\t'''\n\t\treturn Connection()\n\nclass Connection(object):\n\t'''\n\t\tConnection - A connection to a model\n\t'''\n\tdef __init__(self):\n\t\t'''\n\t\t\tConnection - Create a connection to a model\n\t\t'''\n\t\tself._connection = None\n\n\tdef _get_new_connection(self):\n\t\t'''\n\t\t\t_get_new_connection - Create a new connection, or reuse if passed in.\n\t\t\t\tWill share a connection with a model\n\t\t'''\n\t\treturn Connection()\n\nclass Model(object):\n\t'''\n\t\tModel - A model to be used by the database\n\t'''\n\tdef __init__(self, name, **kwargs):\n\t\t'''\n\t\t\tModel - Create a model\n\t\t'''\n\t\tself._name = name\n\t\tself._connection = _get_connection()\n\t\tself._connection.add_model(self)\n\t\tself._connection.save()\n\n\tdef _get_new_connection(self):\n\t\t'''\n\t\t\t_get_new_connection -",
        "\ndef _remove_id_from_keys(self, pk, conn=None):\n\t\t'''\n\t\t\t_remove_id_from_keys - Removes primary key from table\n\t\t\tinternal\n\t\t'''\n\t\tif conn is None:\n\t\t\tconn = self._get_connection()\n\t\tconn.srem(self._get_ids_key(), pk)\n\ndef _get_ids_key(self):\n\t\t'''\n\t\t\t_get_ids_key - Returns primary key for table\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_connection().smembers(self._get_table_name())\n\ndef _get_table_name(self):\n\t\t'''\n\t\t\t_get_table_name - Returns table name for table\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_connection().smembers(self._get_table_name())\n\ndef _get_connection(self):\n\t\t'''\n\t\t\t_get_connection - Returns connection for table\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_connection_name()\n\ndef _get_connection_name(self):\n\t\t'''\n\t\t\t_get_connection_name - Returns connection name for table\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_connection",
        "\ndef _get_ids_key(self):\n\t\t'''\n\t\t\t_get_ids_key - Get primary key from table\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_connection().srem(self._get_ids_key(), self._get_primary_key())\n\ndef _get_primary_key(self):\n\t\t'''\n\t\t\t_get_primary_key - Get primary key from table\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_connection().srem(self._get_primary_key(), self._get_ids_key())\n\ndef _get_connection(self):\n\t\t'''\n\t\t\t_get_connection - Get connection from table\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_table().connection\n\ndef _get_table(self):\n\t\t'''\n\t\t\t_get_table - Get table from table\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_connection().table(self._get_table_name())\n\ndef _get_table_name(self):\n\t\t'''\n\t\t\t_get_table_name - Get table name from table\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_connection().table(self._get_table_name())\n\ndef _get_",
        "\ndef _get_key_for_index(self, indexedField, val):\n\t\t'''\n\t\t\t_get_key_for_index - Returns the key for an index\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_key_for_field(indexedField, val)\n\ndef _get_key_for_field(self, indexedField, val):\n\t\t'''\n\t\t\t_get_key_for_field - Returns the key for an index\n\t\t\tinternal\n\t\t'''\n\t\treturn indexedField + ':' + str(val)\n\ndef _get_connection(self):\n\t\t'''\n\t\t\t_get_connection - Returns the connection to the database\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_db().cursor()\n\ndef _get_db(self):\n\t\t'''\n\t\t\t_get_db - Returns the database to the database\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_connection().db\n\ndef _get_key_for_field(self, indexedField, val):\n\t\t'''\n\t\t\t_get_key_for_field - Returns the key for an index\n\t\t\tinternal\n\t\t'''\n\t\treturn indexedField + ':' + str(val)\n\ndef _get_key_for_field_value",
        ", val)\n\ndef _get_key_for_index(self, indexedField, val):\n\t\t'''\n\t\t\t_get_key_for_index - Returns a key for an index\n\t\t\tinternal\n\t\t'''\n\t\treturn self._get_key_for_field(indexedField, val)\n\ndef _get_key_for_field(self, indexedField, val):\n\t\t'''\n\t\t\t_get_key_for_field - Returns a key for an index\n\t\t\tinternal\n\t\t'''\n\t\treturn indexedField + ':' + str(val)\n\ndef _get_key_for_index_value(self, indexedField, val):\n\t\t'''\n\t\t\t_get_key_for_index_value - Returns a key for an index\n\t\t\tinternal\n\t\t'''\n\t\treturn indexedField + ':' + str(val)\n\ndef _get_key_for_field_value(self, indexedField, val):\n\t\t'''\n\t\t\t_get_key_for_field_value - Returns a key for an index\n\t\t\tinternal\n\t\t'''\n\t\treturn indexedField + ':' + str(val)\n\ndef _get_key_for_field_value_with_prefix(self, indexedField, val, prefix):\n\t\t'''\n\t\t\t",
        "\n\n\nclass IndexedRedis(object):\n\t'''\n\t\tA redis-based index.\n\t'''\n\tdef __init__(self, redis_connection, key_name, indexed_fields, indexed_values):\n\t\tself.redis_connection = redis_connection\n\t\tself.key_name = key_name\n\t\tself.indexed_fields = indexed_fields\n\t\tself.indexed_values = indexed_values\n\n\tdef get_key_for_index(self, indexedField, val):\n\t\treturn _get_key_for_index(self.indexed_fields, val)\n\n\tdef get_key_for_value(self, val):\n\t\treturn _get_key_for_index(self.indexed_fields, val)\n\n\tdef get_key_for_value_with_index(self, val, indexedField, val):\n\t\treturn _get_key_for_index(indexedField, val)\n\n\tdef get_key_for_value_with_index_with_prefix(self, val, indexedField, val):\n\t\treturn _get_key_for_index(indexedField, val)\n\n\tdef get_key_for_value_with_index_with_prefix_with_prefix(self, val, indexedField, val):\n",
        ", conn=None):\n\t\t'''\n\t\t\t_compat_rem_str_id_from_index - Used in compat_convertHashedIndexes to remove the old string repr of a field,\n\t\t\t\tin order to later add the hashed value,\n\t\t'''\n\t\tif conn is None:\n\t\t\tconn = self._get_connection()\n\t\tconn.srem(self._compat_get_str_key_for_index(indexedField, val), pk)\n\ndef _compat_rem_str_id_from_index_with_hash(self, indexedField, pk, val, conn=None):\n\t\t'''\n\t\t\t_compat_rem_str_id_from_index_with_hash - Used in compat_convertHashedIndexes to remove the old string repr of a field,\n\t\t\t\tin order to later add the hashed value,\n\t\t'''\n\t\tif conn is None:\n\t\t\tconn = self._get_connection()\n\t\tconn.srem(self._compat_get_str_key_for_index(indexedField, val), pk)\n\ndef _compat_rem_str_id_from_index_with_hash_with_hash(self, indexedField, pk, val, hash, conn=None):\n\t\t'''\n\t\t\t_compat_rem_str_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _filterInline(filterObj, **kwargs):\n\t\t'''\n\t\t\tInternal for handling filters; the guts of .filter and .filterInline\n\t\t'''\n\t\tfor key, value in kwargs.items():\n\t\t\tif key.endswith('__ne'):\n\t\t\t\tnotFilter = True\n\t\t\t\tkey = key[:-4]\n\t\t\telse:\n\t\t\t\tnotFilter = False\n\t\t\tif key not in filterObj.indexedFields:\n\t\t\t\traise ValueError('Field \"' + key + '\" is not in INDEXED_FIELDS array. Filtering is only supported on indexed fields.')\n\n\t\t\tif notFilter is False:\n\t\t\t\tfilterObj.filters.append( (key, value) )\n\t\t\telse:\n\t\t\t\tfilterObj.notFilters.append( (key, value) )\n\n\t\treturn filterObj\n\ndef _filterAll(filterObj, **kwargs):\n\t\t'''\n\t\t\tInternal for handling filters; the guts of .filter and .filterAll\n\t\t'''\n\t\tfor key, value in kwargs.items():\n\t\t\tif key.endswith('__ne'):\n\t\t\t\tnotFilter = True\n\t\t\t\tkey = key[:-4]\n\t\t\telse:\n\t\t\t\tnotFilter = False\n\t\t\tif key not in filterObj.indexedFields:\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_primary_key(self, primary_key):\n\t\t'''\n\t\t\tget_primary_key - Returns the primary key associated with the given primary key.\n\n\t\t\t@param primary_key <str> - The primary key to get.\n\n\t\t\t@return <int> - The primary key associated with the given primary key.\n\t\t'''\n\t\tconn = self._get_connection()\n\t\tprimary_key = int(primary_key)\n\t\treturn conn.get(self._get_ids_key(), primary_key)\n\ndef get_primary_key_for_index(self, index_name, index_value):\n\t\t'''\n\t\t\tget_primary_key_for_index - Returns the primary key associated with the given index name and value.\n\n\t\t\t@param index_name <str> - The name of the index to get.\n\t\t\t@param index_value <str> - The value of the index to get.\n\n\t\t\t@return <int> - The primary key associated with the given index name and value.\n\t\t'''\n\t\tconn = self._get_connection()\n\t\tprimary_key = conn.get(self._get_ids_key(), index_name, index_value)\n\t\treturn primary_key\n\ndef get_primary_key",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\n\tdef random_many(self, cascadeFetch=False):\n\t\t'''\n\t\t\tRandom - Returns a random record in current filterset.\n\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access\n\n\t\t\t@return - Instance of Model object, or None if no items math current filters\n\t\t'''\n\t\tmatchedKeys = list(self.getPrimaryKeys())\n\t\tobj = None\n\t\t# Loop so we don't return None when there are items, if item is deleted between getting key and getting obj\n\t\twhile matchedKeys and not obj:\n\t\t\tkey = matchedKeys.pop(random.randint(0, len(matchedKeys)-1))\n\t\t\tobj = self.get(key, cascadeFetch=cascadeFetch)\n\n\t\treturn obj\n\n\n\tdef random_many_many(self, cascadeFetch=False):\n\t\t'''\n\t\t\tRandom - Returns a random record in current filterset.\n\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access\n\n\t\t\t@return - Instance of Model object, or None",
        "\n\ndef update(self):\n\t\t'''\n\t\t\tupdate - Updates all entries matching the filter criteria\n\n\t\t'''\n\t\tif self.filters or self.notFilters:\n\t\t\treturn self.mdl.updater.updateMultiple(self.allOnlyIndexedFields())\n\t\treturn self.mdl.updater.updateModel()\n\ndef allOnlyIndexedFields(self):\n\t\t'''\n\t\t\tallOnlyIndexedFields - Returns all entries matching the filter criteria\n\n\t\t'''\n\t\treturn self.mdl.allOnlyIndexedFields()\n\ndef allOnlyIndexedFields_(self):\n\t\t'''\n\t\t\tallOnlyIndexedFields_ - Returns all entries matching the filter criteria\n\n\t\t'''\n\t\treturn self.mdl.allOnlyIndexedFields_()\n\ndef allOnlyIndexedFields_(self):\n\t\t'''\n\t\t\tallOnlyIndexedFields_ - Returns all entries matching the filter criteria\n\n\t\t'''\n\t\treturn self.mdl.allOnlyIndexedFields_()\n\ndef allOnlyIndexedFields_(self):\n\t\t'''\n\t\t\tallOnlyIndexedFields_ - Returns all entries matching the filter criteria\n\n\t\t'''\n\t\treturn self.mdl.allOnlyIndexedFields_()\n\ndef allOnlyIndexedFields_(self):\n\t\t'''\n\t\t\tallOnlyIndexedFields",
        "\n\n\tdef set(self, obj, pk, cascadeFetch=False):\n\t\t'''\n\t\t\tset - Set a single value with the internal primary key.\n\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\t\t\t@param obj - object to set\n\t\t\t@param pk - internal primary key (can be found via .getPk() on an item)\n\t\t'''\n\t\tconn = self._get_connection()\n\t\tkey = self._get_key_for_id(pk)\n\t\tconn.hset(key, obj)\n\t\tif cascadeFetch is True:\n\t\t\tself._doCascadeFetch(obj)\n\t\treturn obj\n\n\tdef delete(self, pk, cascadeFetch=False):\n\t\t'''\n\t\t\tdelete - Delete a single value with the internal primary key.\n\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\t\t\t@param pk - internal primary key (can be found via .getPk() on an item)\n\t\t'''\n\t\tconn = self._",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get(self, pk, cascadeFetch=False):\n\t\t'''\n\t\t\tget - Gets an object with a single atomic operation\n\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\t\t\t@param pk - internal key\n\t\t'''\n\n\t\tif type(pk) == set:\n\t\t\tpks = list(pk)\n\n\t\tif len(pks) == 1:\n\t\t\t# Optimization to not pipeline on 1 id\n\t\t\treturn IRQueryable(self.get(pks[0], cascadeFetch=cascadeFetch), mdl=self.mdl)\n\n\t\tconn = self._get_connection()\n\t\tpipeline = conn.pipeline()\n\t\tfor pk in pks:\n\t\t\tkey = self._get_key_for_id(pk)\n\t\t\tpipeline.hgetall(key)\n\n\t\tres = pipeline.execute()\n\n\t\tobj = self._redisResultToObj(res)\n\t\tret = IRQueryable(obj, mdl=self.mdl)\n\t\ti = 0\n\t\tpksLen = len(pks)\n\t\twhile i < pksLen:\n\t\t\t",
        "\n\ndef allOnlyFields(self, pk, fields, cascadeFetch=False):\n\t\t'''\n\t\t\tallOnlyFields - Gets all fields from a paticular primary key. For working on entire filter set, see getOnlyFields\n\n\t\t\t@param pk <int> - Primary Key\n\n\t\t\t@param fields list<str> - List of fields\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\n\t\t\treturn - Partial objects with all fields applied\n\t\t'''\n\t\tconn = self._get_connection()\n\t\tkey = self._get_key_for_id(pk)\n\n\t\tres = conn.hmget(key, fields)\n\t\tif type(res) != list or not len(res):\n\t\t\treturn None\n\n\t\tobjDict = {}\n\t\tnumFields = len(fields)\n\t\ti = 0\n\t\tanyNotNone = False\n\t\twhile i < numFields:\n\t\t\tobjDict[fields[i]] = res[i]\n\t\t\tif res[i] != None:\n\t\t\t\tanyNotNone = True\n\t\t\ti += 1\n\n\t\tif anyNotNone is False:\n\t\t",
        "\n\ndef getAllOnlyFields(self, pks, fields, cascadeFetch=False):\n\t\t'''\n\t\t\tgetAllOnlyFields - Gets all fields from a list of  primary keys. For working on entire filter set, see allOnlyFields\n\n\t\t\t@param pks list<str> - Primary Keys\n\n\t\t\t@param fields list<str> - List of fields\n\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\t\t\treturn - List of partial objects with only fields applied\n\t\t'''\n\t\tif type(pks) == set:\n\t\t\tpks = list(pks)\n\n\t\tif len(pks) == 1:\n\t\t\treturn IRQueryableList([self.getOnlyFields(pks[0], fields, cascadeFetch=cascadeFetch)], mdl=self.mdl)\n\n\t\tconn = self._get_connection()\n\t\tpipeline = conn.pipeline()\n\n\t\tfor pk in pks:\n\t\t\tkey = self._get_key_for_id(pk)\n\t\t\tpipeline.hmget(key, fields)\n\n\t\tres = pipeline.execute()\n\t\tret = IRQueryableList(mdl",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\t\tself._add_id_to_keys(obj._id, pipeline)\n\n\t\tfor indexedField in self.indexedFields:\n\t\t\tself._add_id_to_index(indexedField, obj._id, obj._origData[indexedField], pipeline)\n\n\tdef _doLoad(self, obj, isInsert, conn, pipeline=None):\n\t\t'''\n\t\t\t_doLoad - Internal function to load a single object. Don't call this directly. \n\t\t\t            Use \"load\" instead.\n\n\t\t\t  If a pipeline is provided, the operations (setting values, updating indexes, etc)\n\t\t\t    will be queued into that pipeline.\n\t\t\t  Otherwise, everything will be executed right away.\n\n\t\t\t  @param obj - Object to load\n\t\t\t  @param isInsert - Bool, if insert or update. Either way, obj._id is expected to be set.\n\t\t\t  @param conn - Redis connection\n\t\t\t  @param pipeline - Optional pipeline, if present the items will be queued onto it. Otherwise, go directly to conn.\n\t\t'''\n\n\t\tif pipeline is None:\n\t\t\tpipeline = conn\n\n\t\tnewDict = obj.asDict(forStorage=True)\n\t\tkey = self._get_key_for_id(obj._id)\n\n\t\tif isInsert is True",
        "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "\n\ndef deleteMany(self, objs, conn=None):\n\t\t'''\n\t\t\tdeleteMany - Delete many objects\n\n\t\t\t@param objs - list of objects to delete\n\t\t\t@param conn - Connection to reuse, or None\n\n\t\t\t@return - number of items deleted (0 or 1)\n\t\t'''\n\t\tif not isinstance(objs, list):\n\t\t\tobjs = [objs]\n\n\t\tif conn is None:\n\t\t\tconn = self._get_connection()\n\t\t\tpipeline = conn.pipeline()\n\t\t\texecuteAfter = True\n\t\telse:\n\t\t\tpipeline = conn # In this case, we are inheriting a pipeline\n\t\t\texecuteAfter = False\n\n\t\tfor obj in objs:\n\t\t\tself.deleteOne(obj, conn)\n\n\t\treturn len(objs)\n\ndef updateOne(self, obj, conn=None):\n\t\t'''\n\t\t\tupdateOne - Update one object\n\n\t\t\t@param obj - object to update\n\t\t\t@param conn - Connection to reuse, or None\n\n\t\t\t@return - number of items updated (0 or 1)\n\t\t'''\n\t\tif not getattr(obj, '_id', None):\n\t\t\treturn 0\n\n\t\tif conn is None:\n\t\t\tconn = self._get_connection()\n\t\t",
        "\n\ndef deleteByPks(self, pks):\n\t\t'''\n\t\t\tdeleteByPks - Delete objects associated with given primary keys\n\t\t'''\n\t\tfor pk in pks:\n\t\t\tself.deleteByPk(pk)\n\ndef deleteByPksAndIds(self, pks, ids):\n\t\t'''\n\t\t\tdeleteByPksAndIds - Delete objects associated with given primary keys and ids\n\t\t'''\n\t\tfor pk in pks:\n\t\t\tself.deleteByPk(pk)\n\t\tfor id in ids:\n\t\t\tself.deleteByPk(id)\n\ndef deleteByPksAndIdsAndIds(self, pks, ids, ids2):\n\t\t'''\n\t\t\tdeleteByPksAndIdsAndIds - Delete objects associated with given primary keys and ids and ids2\n\t\t'''\n\t\tfor pk in pks:\n\t\t\tself.deleteByPk(pk)\n\t\tfor id in ids:\n\t\t\tself.deleteByPk(id)\n\t\tfor id2 in ids2:\n\t\t\tself.deleteByPk(id2)\n\ndef deleteByPksAndIdsAndIdsAndIds(self, pks, ids, ids2, ids3):\n\t\t'''\n\t\t\tdeleteByPksAndIdsAndIdsAndIds - Delete objects associated with given primary keys",
        "\n\ndef deleteOne(self, obj, pipeline):\n\t\t'''\n\t\t\tdeleteOne - Delete one object\n\n\t\t\t@param obj - Object to delete\n\n\t\t\t@param pipeline - Pipeline to execute\n\t\t'''\n\t\tconn = self._get_connection()\n\t\tpipeline.execute(self.deleteOne, obj, pipeline)\n\n\t\tpipeline.execute()\n\n\t\treturn 1\n\ndef deleteOne(self, obj, pipeline):\n\t\t'''\n\t\t\tdeleteOne - Delete one object\n\n\t\t\t@param obj - Object to delete\n\n\t\t\t@param pipeline - Pipeline to execute\n\t\t'''\n\t\tconn = self._get_connection()\n\t\tpipeline.execute(self.deleteOne, obj, pipeline)\n\n\t\tpipeline.execute()\n\n\t\treturn 1\n\ndef deleteOneBatch(self, objs, pipeline):\n\t\t'''\n\t\t\tdeleteOneBatch - Delete multiple objects\n\n\t\t\t@param objs - List of objects\n\n\t\t\t@param pipeline - Pipeline to execute\n\t\t'''\n\t\tconn = self._get_connection()\n\t\tpipeline.execute(self.deleteOneBatch, objs, pipeline)\n\n\t\tpipeline.execute()\n\n\t\treturn 1\n\ndef deleteOneBatch(self, objs, pipeline):\n\t\t'''\n\t\t\t",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ")\n\ndef fromstring(html):\n    '''Returns a blox template from a string'''\n    return _to_template(fromstring(html), start_on=None,\n                        ignore=(), **queries)\n\ndef grow_short(html):\n    '''Returns a blox template from a string with a short html string'''\n    return _to_template(fromstring(html), start_on=None,\n                        ignore=(), use_short=True, **queries)\n\ndef _to_template(html, start_on=None, ignore=(), use_short=True, **queries):\n    '''Returns a blox template from a string'''\n    if start_on is None:\n        start_on = _get_start_on(html)\n    if ignore is None:\n        ignore = _get_ignore(html)\n    if use_short:\n        html = grow_short(html)\n    return Template(html, start_on=start_on, ignore=ignore, **queries)\n\ndef _get_start_on(html):\n    '''Returns a start_on attribute from a string'''\n    start_on = None\n    if html.startswith('<'):\n        start_on = html.split('<')[0]\n    return start_on\n\ndef _",
        ")\n\ndef string(template, start_on=None, ignore=(), use_short=True, **queries):\n    '''Returns a blox template from a string'''\n    return Template(template, start_on=start_on, ignore=ignore, use_short=use_short, **queries)\n\ndef template(template, **queries):\n    '''Returns a blox template from a template'''\n    return Template(template, **queries)\n\ndef template_from_file(file_object, **queries):\n    '''Returns a blox template from a file stream object'''\n    return Template(file_object.read(), **queries)\n\ndef template_from_string(template, **queries):\n    '''Returns a blox template from a string'''\n    return Template(template, **queries)\n\ndef template_from_template(template, **queries):\n    '''Returns a blox template from a template'''\n    return Template(template, **queries)\n\ndef template_from_template_from_file(template, file_object, **queries):\n    '''Returns a blox template from a template from a file stream object'''\n    return Template(template.read(), file_object.read(), **queries)\n\ndef template_from_template_from_string(template, **queries):\n   ",
        ")\n\ndef file(template_file, start_on=None, ignore=(), use_short=True, **queries):\n    '''Returns a blox template from a valid file'''\n    template = Template(template_file)\n    template.start_on = start_on\n    template.ignore = ignore\n    template.use_short = use_short\n    return template\n\ndef template(template_file, **queries):\n    '''Returns a blox template from a valid file'''\n    template = Template(template_file)\n    return template\n\ndef template_from_file(template_file, **queries):\n    '''Returns a blox template from a valid file'''\n    template = Template(template_file)\n    return template\n\ndef template_from_string(template_string, **queries):\n    '''Returns a blox template from a valid string'''\n    template = Template(template_string)\n    return template\n\ndef template_from_string_with_start_on(template_string, start_on=None, **queries):\n    '''Returns a blox template from a valid string'''\n    template = Template(template_string)\n    template.start_on = start_on\n    return template\n\ndef template_from_string_with_ignore(template_string, ignore=",
        "\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\ndef fromBytes(self, value):\n\t\t'''\n\t\t\tfromBytes - Convert a value from bytes using the encoding specified on this field\n\n\t\t\t@param value <bytes> - The object to convert from bytes\n\n\t\t\t@return <str> - The object decoded using the codec specified on this field\n\n\t\t\tNOTE: This method may go away.\n\t\t'''\n\t\tif type(value) == str:\n\t\t\treturn value\n\t\treturn value.decode(self.getEncoding())\n\ndef toDecimal(self, value):\n\t\t'''\n\t\t\ttoDecimal - Convert a value to a decimal using the encoding specified on this field\n\n\t\t\t@param value <float> - The field to convert to a decimal\n\n\t\t\t@return <float> - The object converted to a decimal using the codec specified on this field\n\n\t\t\tNOTE: This method may go away.\n\t\t'''\n\t\tif type(value) == float:\n\t\t\treturn value\n\t\treturn float(value)\n\ndef fromDecimal(self, value):\n\t\t'''\n\t\t\tfromDecimal - Convert a value from a decimal using the encoding specified on this field\n\n\t\t\t@param value <float> - The object to convert from a decimal\n\n\t\t\t@return <float> - The object converted to a decimal using the codec specified on",
        "\n",
        "\n\ndef remote_jupyter_proxy_port(port):\n    \"\"\"\n    Callable to configure Bokeh's show method when a proxy must be\n    configured.\n\n    If port is None we're asking about the URL\n    for the origin header.\n    \"\"\"\n    base_url = os.environ['EXTERNAL_URL']\n    host = urllib.parse.urlparse(base_url).netloc\n\n    # If port is None we're asking for the URL origin\n    # so return the public hostname.\n    if port is None:\n        return host\n\n    service_url_path = os.environ['JUPYTERHUB_SERVICE_PREFIX']\n    proxy_url_path = 'proxy/%d' % port\n\n    user_url = urllib.parse.urljoin(base_url, service_url_path)\n    full_url = urllib.parse.urljoin(user_url, proxy_url_path)\n    return int(full_url.split('/')[-1])\n\ndef remote_jupyter_proxy_host(port):\n    \"\"\"\n    Callable to configure Bokeh's show method when a proxy must be\n    configured.\n\n    If port is None we're asking about the URL\n    for the origin header.\n    \"\"\"\n    base_url = os.environ['EXTERNAL",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef create_hierarchy_from_dict(hierarchy, level):\n    \"\"\"Create an OrderedDict\n\n    :param hierarchy: a dictionary\n    :param level: single key\n    :return: deeper dictionary\n    \"\"\"\n    if level not in hierarchy:\n        hierarchy[level] = OrderedDict()\n    return hierarchy[level]\n\n\ndef create_hierarchy_from_list(hierarchy, level):\n    \"\"\"Create an OrderedDict\n\n    :param hierarchy: a dictionary\n    :param level: single key\n    :return: deeper dictionary\n    \"\"\"\n    if level not in hierarchy:\n        hierarchy[level] = OrderedDict()\n    return hierarchy[level]\n\n\ndef create_hierarchy_from_list_of_dicts(hierarchy, level):\n    \"\"\"Create an OrderedDict\n\n    :param hierarchy: a dictionary\n    :param level: single key\n    :return: deeper dictionary\n    \"\"\"\n    if level not in hierarchy:\n        hierarchy[level] = OrderedDict()\n    return hierarchy[level]\n\n\ndef create_hierarchy_from_list_of_dicts_with_level(hierarchy, level):\n    \"\"\"Create an OrderedDict\n\n    :param hierarchy: a dictionary\n    :param level: single key\n    :return: deeper dictionary\n    \"\"\"\n    if level not in hierarchy:\n        hierarchy[level] = OrderedDict()\n    return",
        "\n\ndef line_chunker_with_citation(text, getreffs, citation=None, lines=30):\n    \"\"\" Groups line reference together\n\n    :param text: Text object\n    :type text: MyCapytains.resources.text.api\n    :param getreffs: Callback function to retrieve text\n    :type getreffs: function(level)\n    :param citation: Citation to use for group\n    :type citation: str\n    :param lines: Number of lines to use by group\n    :type lines: int\n    :return: List of grouped urn references with their human readable version\n    :rtype: [(str, str)]\n    \"\"\"\n    level = len(text.citation)\n    source_reffs = [reff.split(\":\")[-1] for reff in getreffs(level=level)]\n    reffs = []\n    i = 0\n    while i + lines - 1 < len(source_reffs):\n        reffs.append(tuple([source_reffs[i]+\"-\"+source_reffs[i+lines-1], source_reffs[i]]))\n        i += lines\n    if i < len(source_reffs):\n        reffs.append(tuple([source_reff",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef round_arr_teff_luminosity(arr):\n    \"\"\"\n    Round the array to the nearest integer.\n    \"\"\"\n    arr = np.array(arr, dtype='int')\n    arr = arr.round(2)\n    return arr\n\ndef teff(cluster):\n    \"\"\"\n    Compute the teff values for each field.\n    \"\"\"\n    return cluster.to_array()['temp']\n\ndef luminosity(cluster):\n    \"\"\"\n    Compute the luminosity values for each field.\n    \"\"\"\n    return cluster.to_array()['lum']\n\ndef cluster_to_array(cluster):\n    \"\"\"\n    Convert a cluster to a numpy.ndarray.\n    \"\"\"\n    arr = cluster.to_array()\n    arr = arr.reshape(arr.shape[0], arr.shape[1])\n    return arr\n\ndef cluster_to_table(cluster):\n    \"\"\"\n    Convert a cluster to a numpy.ndarray.\n    \"\"\"\n    arr = table(cluster)\n    return arr\n\ndef cluster_to_csv(cluster):\n    \"\"\"\n    Convert a cluster to a csv file.\n    \"\"\"\n    arr = cluster_to_array(cluster)\n    return arr.to_csv()\n\ndef cluster_to_csv_header(",
        "\n\ndef round_arr_temperature(arr):\n    \"\"\"\n    Return the numpy array with rounded temperature columns.\n    \"\"\"\n    arr['temp'] = np.around(arr['temp'], -1)\n    return arr\n\ndef round_arr_luminosity(arr):\n    \"\"\"\n    Return the numpy array with rounded luminosity columns.\n    \"\"\"\n    arr['lum'] = np.around(arr['lum'], 3)\n    return arr\n\ndef round_arr_luminosity_temperature(arr):\n    \"\"\"\n    Return the numpy array with rounded luminosity temperature columns.\n    \"\"\"\n    arr['lum_temp'] = np.around(arr['lum_temp'], -1)\n    return arr\n\ndef round_arr_luminosity_temperature_luminosity(arr):\n    \"\"\"\n    Return the numpy array with rounded luminosity temperature luminosity columns.\n    \"\"\"\n    arr['lum_lum_temp'] = np.around(arr['lum_lum_temp'], 3)\n    return arr\n\ndef round_arr_luminosity_temperature_luminosity_temperature(arr):\n    \"\"\"\n    Return the numpy array with rounded luminosity temperature luminosity temperature columns.\n    \"\"\"\n    arr['lum_lum_l",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        ".canvas\n\ndef skyimage_figure_with_labels(cluster):\n    \"\"\"\n    Given a cluster create a Bokeh plot figure using the\n    cluster's image.\n    \"\"\"\n    pf_image = figure(x_range=(0, 1), y_range=(0, 1),\n                      title='Image of {0}'.format(cluster.name),\n                      x_range=(0, 1), y_range=(0, 1),\n                      title_text='Label of {0}'.format(cluster.name))\n    pf_image.image_url(url=[cluster.image_path],\n                       x=0, y=0, w=1, h=1, anchor='bottom_left')\n    pf_image.toolbar_location = None\n    pf_image.axis.visible = False\n    return pf_image.canvas\n\ndef skyimage_figure_with_labels_with_labels(cluster):\n    \"\"\"\n    Given a cluster create a Bokeh plot figure using the\n    cluster's image.\n    \"\"\"\n    pf_image = figure(x_range=(0, 1), y_range=(0, 1),\n                      title='Image of {0}'.format(cluster.name),\n                      x_range=(0, 1), y_range=(0, 1),\n                      title_text='Label of {",
        "\n\ndef teff(cluster):\n    \"\"\"\n    Returns teff list.\n    \"\"\"\n    return [round(t, -1) for t in cluster.teff]\n\ndef luminosity(cluster):\n    \"\"\"\n    Returns luminosity list.\n    \"\"\"\n    return [round(l, 3) for l in cluster.luminosity]\n\ndef cluster_to_cluster(cluster):\n    \"\"\"\n    Returns cluster list.\n    \"\"\"\n    return [cluster.name for cluster in cluster]\n\ndef cluster_to_cluster_list(cluster):\n    \"\"\"\n    Returns cluster list.\n    \"\"\"\n    return [cluster.name for cluster in cluster]\n\ndef cluster_to_cluster_list_with_teff(cluster):\n    \"\"\"\n    Returns cluster list.\n    \"\"\"\n    return [cluster.name for cluster in cluster]\n\ndef cluster_to_cluster_list_with_luminosity(cluster):\n    \"\"\"\n    Returns cluster list.\n    \"\"\"\n    return [cluster.name for cluster in cluster]\n\ndef cluster_to_cluster_list_with_teff_luminosity(cluster):\n    \"\"\"\n    Returns cluster list.\n    \"\"\"\n    return [cluster.name for cluster in cluster]\n\ndef cluster_to_cluster_list_with_te",
        "\n\ndef hr_diagram_color_helper(temps):\n    \"\"\"\n    Given a list of temps create a list of colors and a function\n    that maps the temps to the colors.\n    \"\"\"\n    colors = [\n        'red', 'green', 'blue', 'yellow', 'magenta', 'cyan', 'white',\n        'black', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray',\n        'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray',\n        'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray',\n        'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray',\n        'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray',\n        'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray',\n        'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray',\n        'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray', 'gray',\n        'gray', 'gray', 'gray', 'gray',",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ".utime(self.extended_path, *args, **kwargs)\n\ndef utimensat(self, *args, **kwargs):\n        \"\"\" Set the access and modified times of the file specified by path. \"\"\"\n        os.utimensat(self.extended_path, *args, **kwargs)\n\ndef utimes(self, *args, **kwargs):\n        \"\"\" Set the access and modified times of the file specified by path. \"\"\"\n        os.utimes(self.extended_path, *args, **kwargs)\n\ndef utimensat2(self, *args, **kwargs):\n        \"\"\" Set the access and modified times of the file specified by path. \"\"\"\n        os.utimensat2(self.extended_path, *args, **kwargs)\n\ndef utimesat3(self, *args, **kwargs):\n        \"\"\" Set the access and modified times of the file specified by path. \"\"\"\n        os.utimensat3(self.extended_path, *args, **kwargs)\n\ndef utimesat4(self, *args, **kwargs):\n        \"\"\" Set the access and modified times of the file specified by path. \"\"\"\n        os.utimensat4(self.extended_path, *args, **kwargs)\n\ndef utimesat5(self, *args, **kwargs):\n        \"\"\"",
        ", init)\n\nclass WindowsPath2(Path2):\n    \"\"\"\n    A Windows path\n    \"\"\"\n    def __init__(self, path):\n        self.path = path\n\n    def __str__(self):\n        return self.path\n\n    def __repr__(self):\n        return \"<WindowsPath2 %r>\" % self.path\n\n    def __eq__(self, other):\n        return isinstance(other, WindowsPath2) and self.path == other.path\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.path)\n\n    def __str__(self):\n        return self.path\n\n    def __repr__(self):\n        return \"<WindowsPath2 %r>\" % self.path\n\n    def __eq__(self, other):\n        return isinstance(other, WindowsPath2) and self.path == other.path\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.path)\n\n    def __str__(self):\n        return self.path\n\n    def __repr__(self):\n        return \"<Windows",
        "\n        return path\n\nclass WindowsPath2(WindowsPath):\n    \"\"\"\n    A WindowsPath that uses the Windows path separator.\n    \"\"\"\n    def __init__(self, path=None):\n        super(WindowsPath2, self).__init__(path)\n        self.separator = \"\\\\\"\n\nclass UnixPath2(UnixPath):\n    \"\"\"\n    A UnixPath that uses the Unix path separator.\n    \"\"\"\n    def __init__(self, path=None):\n        super(UnixPath2, self).__init__(path)\n        self.separator = \"/\"\n\nclass WindowsPath3(WindowsPath):\n    \"\"\"\n    A WindowsPath that uses the Windows path separator.\n    \"\"\"\n    def __init__(self, path=None):\n        super(WindowsPath3, self).__init__(path)\n        self.separator = \"\\\\\"\n\nclass UnixPath3(UnixPath):\n    \"\"\"\n    A UnixPath that uses the Unix path separator.\n    \"\"\"\n    def __init__(self, path=None):\n        super(UnixPath3, self).__init__(path)\n        self.separator = \"/\"\n\nclass WindowsPath4(WindowsPath):\n    \"\"\"\n    A WindowsPath that uses the Windows path separator.\n    \"\"\"\n    def __init__(self, path=",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_ip_address():\n    \"\"\"\n        Gets the IP address from the inet interfaces.\n    \"\"\"\n    own_ip = get_own_ip()\n    if own_ip:\n        return str(ipaddress.ip_address(own_ip))\n    else:\n        return None\n\ndef get_ip_address_by_name(name):\n    \"\"\"\n        Gets the IP address by name.\n    \"\"\"\n    own_ip = get_own_ip()\n    if own_ip:\n        return str(ipaddress.ip_address(own_ip, name))\n    else:\n        return None\n\ndef get_ip_address_by_ip_address(ip_address):\n    \"\"\"\n        Gets the IP address by ip_address.\n    \"\"\"\n    own_ip = get_own_ip()\n    if own_ip:\n        return str(ipaddress.ip_address(own_ip, ip_address))\n    else:\n        return None\n\ndef get_ip_address_by_ip_address_and_name(ip_address, name):\n    \"\"\"\n        Gets the IP address by ip_address and name.\n    \"\"\"\n    own_ip = get_own_ip()\n    if own_ip:\n        return str(ipaddress.ip",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".write(l)\n            labels.append(l)\n    return labels\n\ndef get_labels(filename):\n    \"\"\"Gets labels.\"\"\"\n    labels = []\n    with open(filename) as f, open('processed_labels.txt', 'r') as f1:\n        for l in f1:\n            if l.startswith('#'):\n                continue\n            l = l.replace(\" .\", '')\n            l = l.replace(\">\\tskos:prefLabel\\t\", ' ')\n            l = l.replace(\"<\", '')\n            l = l.replace(\">\\trdfs:label\\t\", ' ')\n            labels.append(l)\n    return labels\n\ndef get_labels_from_file(filename):\n    \"\"\"Gets labels from file.\"\"\"\n    labels = []\n    with open(filename) as f, open('processed_labels.txt', 'r') as f1:\n        for l in f1:\n            if l.startswith('#'):\n                continue\n            l = l.replace(\" .\", '')\n            l = l.replace(\">\\tskos:prefLabel\\t\", ' ')\n            l = l.replace(\"<\", '')\n            l = l.replace(\">\\trdfs:label\\t\", ' ')\n            labels.append(l)\n    return labels",
        "\n      break\n  return doc\n\ndef remove_namespace_from_xml(doc, namespace):\n  '''Remove namespace from the passed document in place.'''\n  ns = u'{%s}' % namespace\n  nsl = len(ns)\n  for elem in doc.getiterator():\n    if elem.tag.startswith(ns):\n      elem.tag = elem.tag[nsl:]\n      elem.attrib['oxmlns'] = None\n      break\n  return doc\n\ndef remove_namespace_from_xml_with_prefix(doc, prefix, namespace):\n  '''Remove namespace from the passed document in place.'''\n  ns = u'{%s}' % namespace\n  nsl = len(ns)\n  for elem in doc.getiterator():\n    if elem.tag.startswith(ns):\n      elem.tag = elem.tag[nsl:]\n      elem.attrib['oxmlns'] = prefix\n      break\n  return doc\n\ndef remove_namespace_from_xml_with_prefix_and_namespace(doc, prefix, namespace):\n  '''Remove namespace from the passed document in place.'''\n  ns = u'{%s}' % namespace\n  nsl = len(ns)\n  for elem in doc.getiterator():\n    if elem.tag.startswith(ns):\n     ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n",
        "\n\ndef removeHook(self, name):\n    '''\n    Removes `callable` from listening to events of `name` type.\n    '''\n    if name not in self._hooks:\n      return\n    del self._hooks[name]\n\ndef trigger(self, name, *args, **kwargs):\n    '''\n    Triggers `callable` with the parameters passed to `callable` as\n    arguments.\n    '''\n    for hook in self._hooks[name]:\n      hook(*args, **kwargs)\n\ndef triggerAll(self, name, *args, **kwargs):\n    '''\n    Triggers all `callable`s with the parameters passed to `callable` as\n    arguments.\n    '''\n    for hook in self._hooks[name]:\n      hook(*args, **kwargs)\n\ndef triggerAll(self, name, *args, **kwargs):\n    '''\n    Triggers all `callable`s with the parameters passed to `callable` as\n    arguments.\n    '''\n    for hook in self._hooks[name]:\n      hook(*args, **kwargs)\n\ndef triggerAll(self, name, *args, **kwargs):\n    '''\n    Triggers all `callable`s with the parameters passed to `callable` as\n    arguments.\n    '''\n    for hook in self._hooks[name]:\n",
        "\n\ndef main(argv=None):\n    '''\n    Main function for the engine.\n    '''\n    engine = configure(argv)\n    engine.run()\n\nif __name__ == '__main__':\n    main()\n",
        ", columns, *args, **kwargs)\n\ndef _assemble_with_columns(self, sql_str, columns, *args, **kwargs):\n        \"\"\" Alias for _assemble_select\n        \"\"\"\n        warnings.warn(\"_assemble_with_columns has been depreciated for _assemble_select. It will be removed in a future version.\", DeprecationWarning)\n        return self._assemble_select(sql_str, columns, *args, **kwargs)\n\ndef _assemble_select_with_columns(self, sql_str, columns, *args, **kwargs):\n        \"\"\" Alias for _assemble_select\n        \"\"\"\n        warnings.warn(\"_assemble_select_with_columns has been depreciated for _assemble_select. It will be removed in a future version.\", DeprecationWarning)\n        return self._assemble_select(sql_str, columns, *args, **kwargs)\n\ndef _assemble_select_with_columns_with_default(self, sql_str, columns, *args, **kwargs):\n        \"\"\" Alias for _assemble_select\n        \"\"\"\n        warnings.warn(\"_assemble_select_with_columns_with_default has been depreciated for _assemble_select. It will be removed in a future version.\", DeprecationWarning)\n        return self._assemble_select(sql_str, columns, *args, **",
        "\n\nclass RawlResult(object):\n    \"\"\"\n    A class that holds a list of rows and a dict of column names and values\n    \"\"\"\n\n    def __init__(self, columns, row_dict):\n        self.columns = columns\n        self.row_dict = row_dict\n\n    def __repr__(self):\n        return \"<RawlResult %s>\" % self.columns\n\n    def __str__(self):\n        return \"<RawlResult %s>\" % self.columns\n\n    def __eq__(self, other):\n        return self.columns == other.columns and self.row_dict == other.row_dict\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        return self.columns < other.columns\n\n    def __le__(self, other):\n        return not self.__lt__(other)\n\n    def __gt__(self, other):\n        return self.columns > other.columns\n\n    def __ge__(self, other):\n        return not self.__gt__(other)\n\n    def __eq__(self, other):\n        return self.columns == other.columns and self.row_dict == other.row_dict\n\n   ",
        "\n\ndef process_rows(self, rows):\n        \"\"\" \n        Handle provided rows and if necessary, convert rows to a list for internal \n        strage.\n\n        :rows: A sequence of rows for the table. Can be list, comma-delimited string, or IntEnum.\n        \"\"\"\n        if type(rows) == list:\n            self.rows = rows\n        elif type(rows) == str:\n            self.rows = [r.strip() for r in rows.split()]\n        elif type(rows) == IntEnum:\n            self.rows = [str(c) for c in rows]\n        else:\n            raise RawlException(\"Unknown format for rows\")\n\ndef process_columns_and_rows(self, columns, rows):\n        \"\"\" \n        Handle provided columns and rows and if necessary, convert columns and rows to a list for \n        internal strage.\n\n        :columns: A sequence of columns for the table. Can be list, comma-delimited string, or IntEnum.\n        :rows: A sequence of rows for the table. Can be list, comma-delimited string, or IntEnum.\n        \"\"\"\n        if type(columns) == list:\n            self.columns = columns\n        elif type(columns) == str:\n            self.columns = [c.strip()",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        return f3\n\ndef main():\n        \"\"\"\n            Main function.\n        \"\"\"\n        # Create the directory if it doesn't exist\n        if not os.path.exists(self.datadir):\n            os.makedirs(self.datadir)\n\n        # Create the files\n        f1 = os.path.join(self.datadir, 'f1.txt')\n        f2 = os.path.join(self.datadir, 'f2.txt')\n        f3 = os.path.join(self.datadir, 'f3.txt')\n\n        # Create the files\n        combine_files(f1, f2, f3)\n\n        # Run the program\n        print('Running the program...')\n        os.system('python ./main.py')\n\nif __name__ == '__main__':\n        main()\n",
        "\n\ndef detect_os_version(self, ip):\n        \"\"\"\n            Runs the checker.py scripts to detect the os version.\n        \"\"\"\n        process = subprocess.run(['python2', os.path.join(self.datadir, 'MS17-010', 'checker.py'), str(ip)], stdout=subprocess.PIPE)\n        out = process.stdout.decode('utf-8').split('\\n')\n        system_os = ''\n        for line in out:\n            if line.startswith('Target OS:'):\n                system_os = line.replace('Target OS: ', '')\n                break\n        return system_os\n\ndef detect_os_arch(self, ip):\n        \"\"\"\n            Runs the checker.py scripts to detect the os arch.\n        \"\"\"\n        process = subprocess.run(['python2', os.path.join(self.datadir, 'MS17-010', 'checker.py'), str(ip)], stdout=subprocess.PIPE)\n        out = process.stdout.decode('utf-8').split('\\n')\n        system_os = ''\n        for line in out:\n            if line.startswith('Target OS:'):\n                system_os = line.replace('Target OS: ', '')\n                break\n        return system_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef make_websocket_server(host, port, app=None,\n                           server_class=AsyncWsgiServer,\n                           handler_class=AsyncWsgiHandler,\n                           ws_handler_class=None,\n                           ws_path='/ws'):\n    \"\"\"Create server instance with an optional WebSocket handler\n\n    For pure WebSocket server ``app`` may be ``None`` but an attempt to access\n    any path other than ``ws_path`` will cause server error.\n    \n    :param host: hostname or IP\n    :type host: str\n    :param port: server port\n    :type port: int\n    :param app: WSGI application\n    :param server_class: WSGI server class, defaults to AsyncWsgiServer\n    :param handler_class: WSGI handler class, defaults to AsyncWsgiHandler\n    :param ws_handler_class: WebSocket hanlder class, defaults to ``None``\n    :param ws_path: WebSocket path on the server, defaults to '/ws'\n    :type ws_path: str, optional\n    :return: initialized server instance\n    \"\"\"\n    handler_class.ws_handler_class = ws_handler_class\n    handler_class.ws_path = ws_path\n    httpd = server_class((host, port), RequestHandlerClass=handler_class)",
        "\n        self._poll_func(timeout, self._map)\n\n    def _poll_func(self, timeout, map):\n        \"\"\"\n        Poll active sockets once\n\n        :param timeout: polling timeout\n        :param map: map to poll\n        \"\"\"\n        if self._map:\n            self._map.poll_once(timeout)\n\n    def _poll_once_with_timeout(self, timeout, map):\n        \"\"\"\n        Poll active sockets once with timeout\n\n        :param timeout: polling timeout\n        :param map: map to poll\n        \"\"\"\n        if self._map:\n            self._map.poll_once_with_timeout(timeout)\n\n    def _poll_once_with_timeout_and_map(self, timeout, map):\n        \"\"\"\n        Poll active sockets once with timeout and map\n\n        :param timeout: polling timeout\n        :param map: map to poll\n        \"\"\"\n        if self._map:\n            self._map.poll_once_with_timeout_and_map(timeout)\n\n    def _poll_once_with_timeout_and_map_with_timeout(self, timeout, map):\n        \"\"\"\n        Poll active sockets once with timeout and map with timeout\n\n        :param timeout: polling timeout\n        :param map: map to poll\n        :",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ".encode(delimiter, triple_order)\n\ndef read_triples(filename, delimiter=DEFAULT_DELIMITER, triple_order=\"hrt\"):\n    \"\"\"read triples from file.\"\"\"\n    with open(filename, 'r') as f:\n        for line in f:\n            t = Triple.deserialize(line.decode(delimiter, triple_order))\n            yield t\n\ndef read_triples_from_file(filename, delimiter=DEFAULT_DELIMITER, triple_order=\"hrt\"):\n    \"\"\"read triples from file.\"\"\"\n    with open(filename, 'r') as f:\n        for line in f:\n            t = Triple.deserialize(line.decode(delimiter, triple_order))\n            yield t\n\ndef read_triples_from_file_with_order(filename, delimiter=DEFAULT_DELIMITER, triple_order=\"hrt\"):\n    \"\"\"read triples from file.\"\"\"\n    with open(filename, 'r') as f:\n        for line in f:\n            t = Triple.deserialize(line.decode(delimiter, triple_order))\n            yield t\n\ndef read_triples_from_file_with_order_and_order(filename, delimiter=DEFAULT_DELIMITER, triple_order=\"hrt\"):\n    \"\"\"read triples from file.\"\"\"\n    with open(filename, 'r') as f",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef read_openke_translation_from_file(filename, delimiter='\\t', entity_first=True):\n    \"\"\"Returns map with entity or relations from plain text.\"\"\"\n    result = {}\n    with open(filename, \"r\") as f:\n        _ = next(f) # pass the total entry number\n        for line in f:\n            line_slice = line.rstrip().split(delimiter)\n            if not entity_first:\n                line_slice = list(reversed(line_slice))\n            result[line_slice[0]] = line_slice[1]\n\n    return result\n\ndef read_openke_translation_from_file_with_entities(filename, delimiter='\\t', entity_first=True):\n    \"\"\"Returns map with entity or relations from plain text.\"\"\"\n    result = {}\n    with open(filename, \"r\") as f:\n        _ = next(f) # pass the total entry number\n        for line in f:\n            line_slice = line.rstrip().split(delimiter)\n            if not entity_first:\n                line_slice = list(reversed(line_slice))\n            result[line_slice[0]] = line_slice[1]\n\n    return result\n\ndef read_openke_translation_from_file_with_relations",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n            annotation.target.expanded = frozenset(\n                self.__getinnerreffs__(\n                    objectId=annotation.target.objectId,\n                    subreference=annotation.target.subreference\n                )\n            )\n\n        self.__annotations__ = self.__nemo__.annotations\n\n        self.__nemo__.annotations.add(self)\n\n        self.__nemo__.annotations.add(self.__getannotation__())\n\n        self.__nemo__.annotations.add(self.__getannotation__(target=self.__nemo__))\n\n        self.__nemo__.annotations.add(self.__getannotation__(target=self.__nemo__))\n\n        self.__nemo__.annotations.add(self.__getannotation__(target=self.__nemo__))\n\n        self.__nemo__.annotations.add(self.__getannotation__(target=self.__nemo__))\n\n        self.__nemo__.annotations.add(self.__getannotation__(target=self.__nemo__))\n\n        self.__nemo__.annotations.add(self.__getannotation__(target=self.__nemo__))\n\n        self.__nemo__.annotations.add(self.__getannotation__(target=self.__nemo__))\n\n        self.__",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_config(config_file):\n    \"\"\"\n        Returns a dictionary of config values.\n    \"\"\"\n    config = {}\n\n    with open(config_file) as f:\n        for line in f:\n            section = line.strip().split('=')\n            config[section[0]] = section[1]\n\n    return config\n\ndef get_config_file(config_file):\n    \"\"\"\n        Returns a file-like object with the config values.\n    \"\"\"\n    with open(config_file) as f:\n        return f\n\ndef get_config_section(config_file, section):\n    \"\"\"\n        Returns a section of the config file.\n    \"\"\"\n    with get_config_file(config_file) as f:\n        return f.read().split(section)[0]\n\ndef get_config_section_value(config_file, section, value):\n    \"\"\"\n        Returns a section of the config file.\n    \"\"\"\n    with get_config_file(config_file) as f:\n        return f.read().split(section)[1]\n\ndef get_config_section_bool(config_file, section, value):\n    \"\"\"\n        Returns a section of the config file.\n    \"\"\"\n    with get_config_file(config_",
        "\n\ndef pipe_worker(name, pipe_path, object_type, query, format, unique):\n    \"\"\"\n        Creates a named pipe in the given directory.\n    \"\"\"\n    pipe_name = name + '.pipe'\n    pipe_path = os.path.join(pipe_path, pipe_name)\n    pipe_path = os.path.abspath(pipe_path)\n    pipe_path = os.path.expanduser(pipe_path)\n    pipe_path = os.path.expandvars(pipe_path)\n    pipe_path = os.path.join(pipe_path, format)\n    pipe_path = os.path.abspath(pipe_path)\n    pipe_path = os.path.expandvars(pipe_path)\n    pipe_path = os.path.join(pipe_path, unique)\n    pipe_path = os.path.abspath(pipe_path)\n    pipe_path = os.path.expandvars(pipe_path)\n    pipe_path = os.path.join(pipe_path, 'pipe')\n    pipe_path = os.path.abspath(pipe_path)\n    pipe_path = os.path.expandvars(pipe_path)\n    pipe_path = os.path.join(pipe_path, 'pipe')\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\ndef f_i18n_en(isocode, lang=\"eng\"):\n    \"\"\" Replace isocode by its language equivalent\n\n    :param isocode: Three character long language code\n    :param lang: Lang in which to return the language name\n    :return: Full Text Language Name\n    \"\"\"\n    if lang not in flask_nemo._data.AVAILABLE_TRANSLATIONS:\n        lang = \"eng\"\n\n    try:\n        return flask_nemo._data.ENCODES[isocode][lang]\n    except KeyError:\n        return \"Unknown\"\n\n\ndef f_i18n_en_iso(isocode, lang=\"eng\"):\n    \"\"\" Replace isocode by its language equivalent\n\n    :param isocode: Three character long language code\n    :param lang: Lang in which to return the language name\n    :return: Full Text Language Name\n    \"\"\"\n    if lang not in flask_nemo._data.AVAILABLE_TRANSLATIONS:\n        lang = \"eng\"\n\n    try:\n        return flask_nemo._data.ENISOCODES[isocode][lang]\n    except KeyError:\n        return \"Unknown\"\n\n\ndef f_i18n_en_iso_short(isocode, lang=\"eng\"):\n    \"\"\" Replace isocode by its language equivalent",
        "\n\ndef getFromDict(d, levs):\n    \"\"\" A function to construct a dictionary from a list of strings\n\n    :param d: dictionary to construct from\n    :type d: dict\n    :param levs: list of strings to construct from\n    :type levs: list of strings\n    :return: dictionary with the values of the levs as keys and the values of the levs as values\n    :rtype: dict\n    \"\"\"\n    d = OrderedDict()\n    for v in levs:\n        d[v] = d.get(v, OrderedDict())\n    return d\n\ndef f_hierarchical_citations(citations, reffs):\n    \"\"\" A function to construct a hierarchical dictionary representing the different citation layers of a text\n\n    :param citations: Citations with human-readable equivalent\n    :type citations: [(str, str)]\n    :param reffs: passage references with human-readable equivalent\n    :type reffs: [(str, str)]\n    :return: nested dictionary representing where keys represent the names of the levels and the final values represent the passage reference\n    :rtype: OrderedDict\n    \"\"\"\n    d = OrderedDict()\n    levels = [x for x in citation]\n    for cit, name in reffs:\n        ref = cit.split('-')[",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef f_annotation_filter_by_type(annotations, type_uri):\n    \"\"\" Annotation filtering filter by type\n\n    :param annotations: List of annotations\n    :type annotations: [AnnotationResource]\n    :param type_uri: URI Type on which to filter\n    :type type_uri: str\n    :return: Annotation(s) matching the request\n    :rtype: [AnnotationResource] or AnnotationResource\n    \"\"\"\n    filtered = [\n        annotation\n        for annotation in annotations\n        if annotation.type_uri == type_uri\n    ]\n    return filtered[0]\n\ndef f_annotation_filter_by_type_and_number(annotations, type_uri, number):\n    \"\"\" Annotation filtering filter by type and number\n\n    :param annotations: List of annotations\n    :type annotations: [AnnotationResource]\n    :param type_uri: URI Type on which to filter\n    :type type_uri: str\n    :param number: Number of the annotation to return\n    :type number: int\n    :return: Annotation(s) matching the request\n    :rtype: [AnnotationResource] or AnnotationResource\n    \"\"\"\n    filtered = [\n        annotation\n        for annotation in annotations\n        if annotation.type_uri == type_uri\n        and annotation.number == number\n    ]\n    return",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\ndef _plugin_endpoint_rename_with_instance(fn_name, instance):\n    \"\"\" Rename endpoint function name to avoid conflict when namespacing is set to true\n\n    :param fn_name: Name of the route function\n    :param instance: Instance bound to the function\n    :return: Name of the new namespaced function name\n    \"\"\"\n\n    if instance and instance.namespaced:\n        fn_name = \"r_{0}_{1}\".format(instance.name, fn_name[2:])\n    return fn_name\n\n\ndef _plugin_endpoint_rename_with_instance_and_name(fn_name, instance, name):\n    \"\"\" Rename endpoint function name to avoid conflict when namespacing is set to true\n\n    :param fn_name: Name of the route function\n    :param instance: Instance bound to the function\n    :param name: Name of the new namespaced function name\n    :return: Name of the new namespaced function name\n    \"\"\"\n\n    if instance and instance.namespaced:\n        fn_name = \"r_{0}_{1}_{2}\".format(instance.name, fn_name[2:], name)\n    return fn_name\n\n\ndef _plugin_endpoint_rename_with_instance_and_name_with_instance(fn_name, instance, name, instance",
        "\n\ndef get_locale_from_request(self):\n        \"\"\" Retrieve the best matching locale using request headers\n\n        .. note:: Probably one of the thing to enhance quickly.\n\n        :rtype: str\n        \"\"\"\n        best_match = request.accept_languages.best_match(['de', 'fr', 'en', 'la'])\n        if best_match is None:\n            if len(request.accept_languages) > 0:\n                best_match = request.accept_languages[0][0][:2]\n            else:\n                return self.__default_lang__\n        lang = self.__default_lang__\n        if best_match == \"de\":\n            lang = \"ger\"\n        elif best_match == \"fr\":\n            lang = \"fre\"\n        elif best_match == \"en\":\n            lang = \"eng\"\n        elif best_match == \"la\":\n            lang = \"lat\"\n        return lang\n\ndef get_locale_from_request_header(self):\n        \"\"\" Retrieve the best matching locale using request headers\n\n        .. note:: Probably one of the thing to enhance quickly.\n\n        :rtype: str\n        \"\"\"\n        best_match = request.accept_languages.best_match(['de', 'fr', 'en', 'la'])\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_inventory_by_id(self, inventory_id):\n        \"\"\" Request the api endpoint to retrieve information about the inventory\n\n        :param inventory_id: Inventory ID\n        :return: Main Collection\n        :rtype: Collection\n        \"\"\"\n        if self._inventory is not None:\n            return self._inventory\n\n        self._inventory = self.resolver.getMetadata(inventory_id)\n        return self._inventory\n\ndef get_inventory_by_name(self, inventory_name):\n        \"\"\" Request the api endpoint to retrieve information about the inventory\n\n        :param inventory_name: Inventory Name\n        :return: Main Collection\n        :rtype: Collection\n        \"\"\"\n        if self._inventory is not None:\n            return self._inventory\n\n        self._inventory = self.resolver.getMetadata(inventory_name)\n        return self._inventory\n\ndef get_inventory_by_name_and_id(self, inventory_name, inventory_id):\n        \"\"\" Request the api endpoint to retrieve information about the inventory\n\n        :param inventory_name: Inventory Name\n        :param inventory_id: Inventory ID\n        :return: Main Collection\n        :rtype: Collection\n        \"\"\"\n        if self._inventory is not None:\n            return self._inventory\n\n        self._inventory = self.resolver.",
        ", []\n\ndef get_collection(self, objectId):\n        \"\"\" Retrieve and transform a collection object.\n\n        Returns the inventory collection object with its metadata and a callback function taking a level parameter \\\n        and returning a text collection object.\n\n        :param objectId: Collection Identifier\n        :type objectId: str\n        :return: Returns either the text collection object with its references as tuple\n        :rtype: (Collection, [str]) or [str]\n        \"\"\"\n        return self.resolver.get_collection(objectId)\n\ndef chunk(self, collection, callback):\n        \"\"\" Chunk a collection into chunks.\n\n        :param collection: Collection object bearing metadata\n        :type collection: Collection\n        :param callback: Callback function taking a level parameter and returning a list of strings\n        :type callback: callable\n        :return: Returns either the list of chunks, or the text collection object with its references as tuple\n        :rtype: (Collection, [str]) or [str]\n        \"\"\"\n        return self.resolver.chunk(collection, callback)\n",
        "\n\ndef get_passages(self, objectId, subreference):\n        \"\"\" Retrieve the passages identified by the parameters\n\n        :param objectId: Collection Identifier\n        :type objectId: str\n        :param subreference: Subreference of the passages\n        :type subreference: str\n        :return: An object bearing metadata and its text\n        :rtype: InteractiveTextualNode\n        \"\"\"\n        passages = self.resolver.getTextualNodes(\n            textId=objectId,\n            subreference=subreference,\n            metadata=True\n        )\n        return passages\n\ndef get_passage_by_id(self, objectId, subreference):\n        \"\"\" Retrieve the passage identified by the parameters\n\n        :param objectId: Collection Identifier\n        :type objectId: str\n        :param subreference: Subreference of the passage\n        :type subreference: str\n        :return: An object bearing metadata and its text\n        :rtype: InteractiveTextualNode\n        \"\"\"\n        passage = self.resolver.getTextualNode(\n            textId=objectId,\n            subreference=subreference,\n            metadata=True\n        )\n        return passage\n\ndef get_passages_by_id(self, objectId, subreference):\n        \"\"\" Retrieve the passages identified by the parameters\n",
        ", None\n\ndef get_next(self, objectId, subreference, passage):\n        \"\"\" Get next reference of a browsed subreference\n\n        .. note:: Since 1.0.0c, there is no more prevnext dict. Nemo uses the list of original\\\n        chunked references to retrieve next and previous, or simply relies on the resolver to get siblings\\\n        when the subreference is not found in given original chunks.\n\n        :param objectId: Id of the object\n        :param subreference: Subreference of the object\n        :param passage: Current Passage\n        :return: Next reference\n        :rtype: (str, str)\n        \"\"\"\n        reffs = [reff for reff, _ in self.get_reffs(objectId)]\n        if subreference in reffs:\n            index = reffs.index(subreference)\n            # Not the first item and not the last one\n            if 0 < index < len(reffs) - 1:\n                return reffs[index+1], reffs[index-1]\n            elif index == 0 and index < len(reffs) - 1:\n                return None, reffs[1]\n            elif index > 0 and index == len(reffs) - 1:\n                return reffs[index-1], None\n           ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef make_coins_from_text(self, collection, text, lang=None):\n        \"\"\" Creates a CoINS Title string from information\n\n        :param collection: Collection to create coins from\n        :param text: Text/Passage object\n        :param lang: Locale information\n        :return: Coins HTML title value\n        \"\"\"\n        if lang is None:\n            lang = self.__default_lang__\n        return \"url_ver=Z39.88-2004\"\\\n                 \"&ctx_ver=Z39.88-2004\"\\\n                 \"&rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\"\\\n                 \"&rft_id={cid}\"\\\n                 \"&rft.genre=bookitem\"\\\n                 \"&rft.btitle={title}\"\\\n                 \"&rft.edition={edition}\"\\\n                 \"&rft.au={author}\"\\\n                 \"&rft.atitle={pages}\"\\\n                 \"&rft.language={language}\"\\\n                 \"&rft.pages={pages}\".format(\n                    title=quote(str(text.get_title(lang))), author=quote(str(text.get_creator(lang))),\n                    cid=url_for(\".r_",
        "\n\ndef expose_ancestors(self, member, collection, lang=None):\n        \"\"\" Build an ancestor dict view based on selected information\n\n        :param member: Current Member to build for\n        :param collection: Collection from which we retrieved it\n        :param lang: Language to express data in\n        :return:\n        \"\"\"\n        x = {\n            \"id\": member.id,\n            \"label\": str(member.get_label(lang)),\n            \"model\": str(member.model),\n            \"type\": str(member.type),\n            \"size\": member.size,\n            \"semantic\": self.semantic(member, parent=collection)\n        }\n        if isinstance(member, ResourceCollection):\n            x[\"lang\"] = str(member.lang)\n        return x\n\ndef expose_children(self, member, collection, lang=None):\n        \"\"\" Build an ancestor dict view based on selected information\n\n        :param member: Current Member to build for\n        :param collection: Collection from which we retrieved it\n        :param lang: Language to express data in\n        :return:\n        \"\"\"\n        x = {\n            \"id\": member.id,\n            \"label\": str(member.get_label(lang)),\n            \"model\": str(member.model),\n            \"type\":",
        "\n\ndef make_collections(self, lang=None):\n        \"\"\" Build collection list for given language\n\n        :param lang: Language to express data in\n        :return: List of collections\n        \"\"\"\n        collections = []\n        for collection in self.collections:\n            collections.append(self.make_members(collection, lang=lang))\n        return collections\n\ndef make_collections_from_collections(self, collections, lang=None):\n        \"\"\" Build collection list for given language\n\n        :param lang: Language to express data in\n        :return: List of collections\n        \"\"\"\n        collections = []\n        for collection in collections:\n            collections.append(self.make_members(collection, lang=lang))\n        return collections\n\ndef make_collections_from_collections_and_lang(self, collections, lang=None):\n        \"\"\" Build collection list for given language\n\n        :param lang: Language to express data in\n        :return: List of collections\n        \"\"\"\n        collections = []\n        for collection in collections:\n            collections.append(self.make_members(collection, lang=lang))\n        return collections\n\ndef make_collections_from_collections_and_lang_and_collections(self, collections, lang=None):\n        \"\"\" Build collection list for given language\n\n        :param lang: Language",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef r_passage_semantic(self, objectId, subreference, semantic):\n        \"\"\" Provides a redirect to the passage semantic of given objectId\n\n        :param objectId: Collection identifier\n        :type objectId: str\n        :param subreference: Subreference identifier\n        :type subreference: str\n        :type semantic: str\n        :return: Redirection to the passage semantic of given text\n        \"\"\"\n        collection, reffs = self.get_reffs(objectId=objectId, export_collection=True)\n        first, _ = reffs[0]\n        return redirect(\n            url_for(\"r_passage_semantic\", objectId=objectId, subreference=subreference, semantic=semantic)\n        )\n\ndef r_passage_semantic_with_id(self, objectId, subreference, semantic):\n        \"\"\" Provides a redirect to the passage semantic of given objectId\n\n        :param objectId: Collection identifier\n        :type objectId: str\n        :param subreference: Subreference identifier\n        :type subreference: str\n        :type semantic: str\n        :return: Redirection to the passage semantic of given text\n        \"\"\"\n        collection, reffs = self.get_reffs(objectId=objectId, export_collection=True)\n        first, _ =",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef r_assets_list(self):\n        \"\"\" Route for list of assets.\n\n        :return: Response\n        \"\"\"\n        return send_from_directory(\n            directory=self.assets_list,\n            filename='assets.json'\n        )\n\ndef r_assets_list_all(self):\n        \"\"\" Route for list of assets.\n\n        :return: Response\n        \"\"\"\n        return send_from_directory(\n            directory=self.assets_list,\n            filename='assets.json'\n        )\n\ndef r_assets_list_by_type(self, filetype):\n        \"\"\" Route for list of assets.\n\n        :param filetype: Asset Type\n        :return: Response\n        \"\"\"\n        return send_from_directory(\n            directory=self.assets_list,\n            filename='assets.json'\n        )\n\ndef r_assets_list_by_type_all(self, filetype):\n        \"\"\" Route for list of assets.\n\n        :param filetype: Asset Type\n        :return: Response\n        \"\"\"\n        return send_from_directory(\n            directory=self.assets_list,\n            filename='assets.json'\n        )\n\ndef r_assets_list_by_type_by_name(self, filetype, asset):\n        \"\"\" Route",
        "\n        self.blueprint.add_url_rule(\n            \"{0}.secondary/<filetype>/<asset>\".format(self.static_url_path),\n            view_func=self.r_assets,\n            endpoint=\"secondary_assets\",\n            methods=[\"GET\"]\n        )\n\n        self.blueprint.add_url_rule(\n            \"{0}.secondary/<filetype>/<asset>\".format(self.static_url_path),\n            view_func=self.r_assets,\n            endpoint=\"secondary_assets\",\n            methods=[\"POST\"]\n        )\n\n        self.blueprint.add_url_rule(\n            \"{0}.secondary/<filetype>/<asset>\".format(self.static_url_path),\n            view_func=self.r_assets,\n            endpoint=\"secondary_assets\",\n            methods=[\"PUT\"]\n        )\n\n        self.blueprint.add_url_rule(\n            \"{0}.secondary/<filetype>/<asset>\".format(self.static_url_path),\n            view_func=self.r_assets,\n            endpoint=\"secondary_assets\",\n            methods=[\"DELETE\"]\n        )\n\n        self.blueprint.add_url_rule(\n            \"{0}.secondary/<filetype>/<asset>\".format(self.static",
        "\n\ndef register_blueprint(self, blueprint):\n        \"\"\" Register blueprint\n\n        :param blueprint: Blueprint to register\n        :type blueprint: flask.Blueprint\n        \"\"\"\n        self.blueprints.append(blueprint)\n\ndef register_plugins(self):\n        \"\"\" Register plugins\n\n        :return: None\n        :rtype: None\n        \"\"\"\n        for plugin in self.plugins:\n            plugin.register()\n\ndef register_assets(self):\n        \"\"\" Register assets\n\n        :return: None\n        :rtype: None\n        \"\"\"\n        for asset in self.assets:\n            asset.register()\n\ndef register_filters(self):\n        \"\"\" Register filters\n\n        :return: None\n        :rtype: None\n        \"\"\"\n        for filter in self.filters:\n            filter.register()\n\ndef register_urls(self):\n        \"\"\" Register urls\n\n        :return: None\n        :rtype: None\n        \"\"\"\n        for url, name, methods, instance in self._urls:\n            self.blueprint.add_url_rule(\n                url,\n                view_func=self.view_maker(name, instance),\n                endpoint=_plugin_endpoint_rename(name, instance),\n                methods=methods\n            )\n\ndef register_semantic_url(self",
        "\n\ndef view_factory(name, instance=None):\n        \"\"\" Create a view\n\n        :param name: Name of the route function to use for the view.\n        :type name: str\n        :return: Route function which makes use of Nemo context (such as menu informations)\n        :rtype: function\n        \"\"\"\n        if instance is None:\n            instance = self\n        sig = \"lang\" in [\n            parameter.name\n            for parameter in inspect.signature(getattr(instance, name)).parameters.values()\n        ]\n\n        def route(**kwargs):\n            if sig and \"lang\" not in kwargs:\n                kwargs[\"lang\"] = self.get_locale()\n            if \"semantic\" in kwargs:\n                del kwargs[\"semantic\"]\n            return self.route(getattr(instance, name), **kwargs)\n        return route\n\ndef view_factory_with_lang(self, name, instance=None):\n        \"\"\" Create a view\n\n        :param name: Name of the route function to use for the view.\n        :type name: str\n        :return: Route function which makes use of Nemo context (such as menu informations)\n        :rtype: function\n        \"\"\"\n        if instance is None:\n            instance = self\n        sig = \"lang",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef make_cache_keys_for_template(self, endpoint, kwargs):\n        \"\"\" This function is built to provide cache keys for templates\n\n        :param endpoint: Current endpoint\n        :param kwargs: Keyword Arguments\n        :return: tuple of i18n dependant cache key and i18n ignoring cache key\n        :rtype: tuple(str)\n        \"\"\"\n        keys = sorted(kwargs.keys())\n        i18n_cache_key = endpoint+\"|\"+\"|\".join([kwargs[k] for k in keys])\n        if \"lang\" in keys:\n            cache_key = endpoint+\"|\" + \"|\".join([kwargs[k] for k in keys if k != \"lang\"])\n        else:\n            cache_key = i18n_cache_key\n        return i18n_cache_key, cache_key\n\ndef make_cache_keys_for_template_with_lang(self, endpoint, kwargs):\n        \"\"\" This function is built to provide cache keys for templates\n\n        :param endpoint: Current endpoint\n        :param kwargs: Keyword Arguments\n        :return: tuple of i18n dependant cache key and i18n ignoring cache key\n        :rtype: tuple(str)\n        \"\"\"\n        keys = sorted(kwargs.keys())\n        i18n_cache_key = endpoint+\"|\"",
        "\n\ndef render_template(template, **kwargs):\n        \"\"\" Render a route template and adds information to this route.\n\n        :param template: Template name.\n        :type template: str\n        :param kwargs: dictionary of named arguments used to be passed to the template\n        :type kwargs: dict\n        :return: Http Response with rendered template\n        :rtype: flask.Response\n        \"\"\"\n\n        kwargs[\"cache_key\"] = \"%s\" % kwargs[\"url\"].values()\n        kwargs[\"lang\"] = self.get_locale()\n        kwargs[\"assets\"] = self.assets\n        kwargs[\"main_collections\"] = self.main_collections(kwargs[\"lang\"])\n        kwargs[\"cache_active\"] = self.cache is not None\n        kwargs[\"cache_time\"] = 0\n        kwargs[\"cache_key\"], kwargs[\"cache_key_i18n\"] = self.make_cache_keys(request.endpoint, kwargs[\"url\"])\n        kwargs[\"template\"] = template\n\n        for plugin in self.__plugins_render_views__:\n            kwargs.update(plugin.render(**kwargs))\n\n        return render_template(kwargs[\"template\"], **kwargs)\n\ndef make_cache_keys(endpoint, url):\n        \"\"\" Make a cache key for a given endpoint and url.\n\n        :param",
        "\n\ndef create_blueprint(self):\n        \"\"\" Create a new blueprint\n\n        :return: Nemo blueprint\n        :rtype: flask.Blueprint\n        \"\"\"\n        return Blueprint(self.app.name, self.app.url_map)\n\nclass FakeCacheExtension(object):\n    \"\"\" FakeCacheExtension\n\n    :param cache: The cache to use\n    :type cache: :class:`~flask.cache.Cache`\n    \"\"\"\n    def __init__(self, cache):\n        self.cache = cache\n\n    def get(self, key):\n        \"\"\" Get a value from the cache\n\n        :param key: The key to get\n        :type key: str\n        :return: The value\n        :rtype: str\n        \"\"\"\n        return self.cache.get(key)\n\n    def set(self, key, value):\n        \"\"\" Set a value in the cache\n\n        :param key: The key to set\n        :type key: str\n        :param value: The value to set\n        :type value: str\n        :return: The value\n        :rtype: str\n        \"\"\"\n        return self.cache.set(key, value)\n\n    def delete(self, key):\n        \"\"\" Delete a value from the cache\n\n        :param key: The",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ", key, value)\n\ndef get(self, section, key):\n        \"\"\"\n            Returns the value of the section value if it exists and returns it.\n            Use write_config to actually get the value.\n        \"\"\"\n        if not section in self.config:\n            self.config.add_section(section)\n        return self.config.get(section, key)\n\ndef write_config(self):\n        \"\"\"\n            Writes the config to a file.\n        \"\"\"\n        with open(self.config_file, 'w') as f:\n            f.write(self.config.write_config())\n\ndef read_config(self):\n        \"\"\"\n            Reads the config from a file.\n        \"\"\"\n        with open(self.config_file, 'r') as f:\n            return self.config.read_config(f)\n\ndef get_section(self, section):\n        \"\"\"\n            Returns the section value of the config if it exists and returns it.\n            Use write_config to actually get the value.\n        \"\"\"\n        if not section in self.config:\n            self.config.add_section(section)\n        return self.config.get_section(section)\n\ndef get_section_value(self, section, key):\n        \"\"\"\n            Returns the value of the",
        "\n\ndef set(self, section, key, value):\n        \"\"\"\n            This function tries to set the value in the configfile\n            otherwise will return a default.\n        \"\"\"\n        try:\n            self.config.set(section, key, value)\n        except configparser.NoSectionError:\n            pass\n        except configparser.NoOptionError:\n            pass\n        self.defaults[section][key] = value\n\ndef get_section(self, section):\n        \"\"\"\n            This function tries to retrieve the value from the configfile\n            otherwise will return a default.\n        \"\"\"\n        try:\n            return self.config.get(section)\n        except configparser.NoSectionError:\n            pass\n        except configparser.NoOptionError:\n            pass\n        return self.defaults[section]\n\ndef get_key(self, section, key):\n        \"\"\"\n            This function tries to retrieve the value from the configfile\n            otherwise will return a default.\n        \"\"\"\n        try:\n            return self.config.get(section, key)\n        except configparser.NoSectionError:\n            pass\n        except configparser.NoOptionError:\n            pass\n        return self.defaults[section][key]\n\ndef get_section_key(self, section, key):\n        \"\"\"\n            This",
        "\n\ndef config_file(self):\n        \"\"\"\n            Returns the configuration file\n        \"\"\"\n        home = expanduser('~')\n        config_file = os.path.join(home, '.jackal', 'config.py')\n        return config_file\n\ndef config_file_path(self):\n        \"\"\"\n            Returns the configuration file path\n        \"\"\"\n        home = expanduser('~')\n        config_file_path = os.path.join(home, '.jackal', 'config.py')\n        return config_file_path\n\ndef config_file_path_with_path(self):\n        \"\"\"\n            Returns the configuration file path with path\n        \"\"\"\n        home = expanduser('~')\n        config_file_path = os.path.join(home, '.jackal', 'config.py', 'path')\n        return config_file_path\n\ndef config_file_path_with_path_with_path(self):\n        \"\"\"\n            Returns the configuration file path with path with path\n        \"\"\"\n        home = expanduser('~')\n        config_file_path = os.path.join(home, '.jackal', 'config.py', 'path', 'with path')\n        return config_file_path\n\ndef config_file_path_with_path_with",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_interface_address(interface_name):\n    \"\"\"\n        Returns the interface address of the first not link_local and not loopback interface.\n    \"\"\"\n    interface_address = ''\n    interfaces = psutil.net_if_addrs()\n    for name, details in interfaces.items():\n        for detail in details:\n            if detail.family == socket.AF_INET:\n                ip_address = ipaddress.ip_address(detail.address)\n                if not (ip_address.is_link_local or ip_address.is_loopback):\n                    interface_address = ip_address.address\n                    break\n    return interface_address\n\ndef get_interface_mac(interface_name):\n    \"\"\"\n        Returns the interface MAC address of the first not link_local and not loopback interface.\n    \"\"\"\n    interface_mac = ''\n    interfaces = psutil.net_if_addrs()\n    for name, details in interfaces.items():\n        for detail in details:\n            if detail.family == socket.AF_INET:\n                ip_address = ipaddress.ip_address(detail.address)\n                if not (ip_address.is_link_local or ip_address.is_loopback):\n                    interface_mac = ip_address.mac\n                    break\n    return interface_mac\n\ndef get",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n        # IN_CREATE -> 0x00000001\n        if event.mask == 0x00000001:\n            if event.name.endswith('.json'):\n                print_success(\"Ldapdomaindump file found\")\n                if event.name in ['domain_groups.json', 'domain_users.json']:\n                    if event.name == 'domain_groups.json':\n                        self.domain_groups_file = event.pathname\n                    if event.name == 'domain_users.json':\n                        self.domain_users_file = event.pathname\n                    if self.domain_groups_file and self.domain_users_file:\n                        print_success(\"Importing users\")\n                        subprocess.Popen(['jk-import-domaindump', self.domain_groups_file, self.domain_users_file])\n                elif event.name == 'domain_computers.json':\n                    print_success(\"Importing computers\")\n                    subprocess.Popen(['jk-import-domaindump', event.pathname])\n\n        # IN_DELETE -> 0x00000002\n        if event.mask == 0x00000002:\n            if event.name.endswith('.json'):\n                print_success(\"Ldapdomaindump file found\")\n                if event.name in ['domain_groups.json', 'domain_users",
        "\n\ndef main():\n        \"\"\"\n            Main function\n        \"\"\"\n        self = Watch()\n        self.watch()\n\nif __name__ == '__main__':\n        main()\n",
        "\n        if self.server:\n            self.server.terminate()\n        if self.client:\n            self.client.terminate()\n\ndef main():\n        \"\"\"\n            Main function.\n        \"\"\"\n        # Create the server\n        server = Server()\n        server.start()\n\n        # Create the client\n        client = Client()\n        client.start()\n\n        # Create the relay\n        relay = Relay()\n        relay.start()\n\n        # Create the responder\n        responder = Responder()\n        responder.start()\n\n        # Create the server and client\n        server.create_client(client)\n        server.create_relay(relay)\n        server.create_responder(responder)\n\n        # Create the server and client\n        server.create_server()\n        server.create_client()\n\n        # Create the server and client\n        server.create_server()\n        server.create_client()\n\n        # Create the server and client\n        server.create_server()\n        server.create_client()\n\n        # Create the server and client\n        server.create_server()\n        server.create_client()\n\n        # Create the server and client\n        server.create_server()\n        server.create_client()\n\n        # Create the server and",
        "\n\ndef print_notification(msg):\n        \"\"\"\n            Prints a notification to the console.\n        \"\"\"\n        print(\"[INFO] \" + msg)\n\ndef terminate_processes(self):\n        \"\"\"\n            Terminates all the relay and responding processes.\n        \"\"\"\n        self.relay.terminate()\n        self.responder.terminate()\n\ndef main():\n        \"\"\"\n            This function is the main function for the relay and responding processes.\n        \"\"\"\n        relay = Process(target=relay_process, args=())\n        relay.start()\n        responder = Process(target=responder_process, args=())\n        responder.start()\n        wait()\n\nif __name__ == \"__main__\":\n        main()\n",
        "\n\ndef getAnnotationsByTarget(self, targets, wildcard=\".\", include=None, exclude=None, limit=None, start=1, expand=False,\n                         **kwargs):\n    \"\"\" Retrieve annotations from the query provider\n\n    :param targets: The CTS URN(s) to query as the target of annotations\n    :type targets: [MyCapytain.common.reference.URN], URN or None\n    :param wildcard: Wildcard specifier for how to match the URN\n    :type wildcard: str\n    :param include: URI(s) of Annotation types to include in the results\n    :type include: list(str)\n    :param exclude: URI(s) of Annotation types to include in the results\n    :type exclude: list(str)\n    :param limit: The max number of results to return (Default is None for no limit)\n    :type limit: int\n    :param start: the starting record to return (Default is 1)\n    :type start: int \n    :param expand: Flag to state whether Annotations are expanded (Default is False)\n    :type expand: bool\n    \n    :return: Tuple representing the query results. The first element\n                 The first element is the number of total Annotations found\n                 The second element is the list of Annotations\n    :rtype: (int, list(Annotation))",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        return None\n\ndef get_template_name(self):\n        \"\"\"\n            Retrieves the name of the given template.\n        \"\"\"\n        return self.template_name\n\ndef get_template_description(self):\n        \"\"\"\n            Retrieves the description of the given template.\n        \"\"\"\n        return self.template_description\n\ndef get_template_url(self):\n        \"\"\"\n            Retrieves the url of the given template.\n        \"\"\"\n        return self.template_url\n\ndef get_template_version(self):\n        \"\"\"\n            Retrieves the version of the given template.\n        \"\"\"\n        return self.template_version\n\ndef get_template_author(self):\n        \"\"\"\n            Retrieves the author of the given template.\n        \"\"\"\n        return self.template_author\n\ndef get_template_license(self):\n        \"\"\"\n            Retrieves the license of the given template.\n        \"\"\"\n        return self.template_license\n\ndef get_template_license_url(self):\n        \"\"\"\n            Retrieves the url of the given template.\n        \"\"\"\n        return self.template_license_url\n\ndef get_template_license_version(self):\n        \"\"\"\n            Retrieves the version of the given template.\n        \"\"\"\n        return self.template_license_version\n\ndef get_template_",
        "\n        else:\n            return None\n\ndef get_scan(self, id):\n        \"\"\"\n            Returns the scan with the given id\n        \"\"\"\n        response = requests.get(self.url + 'scans/' + id, verify=False, headers=self.headers)\n        if response:\n            result = json.loads(response.text)\n            return result['scan']\n        else:\n            return None\n\ndef get_template_uuid(self):\n        \"\"\"\n            Returns the template uuid\n        \"\"\"\n        response = requests.get(self.url + 'templates', verify=False, headers=self.headers)\n        if response:\n            result = json.loads(response.text)\n            return result['uuid']\n        else:\n            return None\n\ndef get_template_name(self):\n        \"\"\"\n            Returns the template name\n        \"\"\"\n        response = requests.get(self.url + 'templates', verify=False, headers=self.headers)\n        if response:\n            result = json.loads(response.text)\n            return result['name']\n        else:\n            return None\n\ndef get_template_text_targets(self):\n        \"\"\"\n            Returns the template text targets\n        \"\"\"\n        response = requests.get(self.url + 'templates', verify=False",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n  if ret[0] == ds2.uri:\n    return 1\n  return -1\n\ndef cmpToDataStore_name(base, ds1, ds2):\n  '''Bases the comparison of the datastores on name alone.'''\n  ret = difflib.get_close_matches(base.name, [ds1.name, ds2.name], 1, cutoff=0.5)\n  if len(ret) <= 0:\n    return 0\n  if ret[0] == ds1.name:\n    return -1\n  return 1\n\ndef cmpToDataStore_name_uri(base, ds1, ds2):\n  '''Bases the comparison of the datastores on name alone.'''\n  ret = difflib.get_close_matches(base.name, [ds1.name, ds2.name], 1, cutoff=0.5)\n  if len(ret) <= 0:\n    return 0\n  if ret[0] == ds1.name:\n    return -1\n  return 1\n\ndef cmpToDataStore_name_name(base, ds1, ds2):\n  '''Bases the comparison of the datastores on name alone.'''\n  ret = difflib.get_close_matches(base.name, [ds1.name, ds2.name], 1,",
        ")\n\n    def get_tags(self):\n        \"\"\"\n            Returns a list of all tags in the list of tags.\n        \"\"\"\n        return self.tags\n\n    def get_tag(self, tag):\n        \"\"\"\n            Returns a tag from the list of tags.\n        \"\"\"\n        return self.tags.find(tag)\n\n    def get_tags_by_name(self, name):\n        \"\"\"\n            Returns a list of all tags with a given name.\n        \"\"\"\n        return self.tags.filter(lambda t: t.name == name)\n\n    def get_tag_by_id(self, id):\n        \"\"\"\n            Returns a tag with a given id.\n        \"\"\"\n        return self.tags.find(lambda t: t.id == id)\n\n    def get_tag_by_name_and_id(self, name, id):\n        \"\"\"\n            Returns a tag with a given name and id.\n        \"\"\"\n        return self.tags.filter(lambda t: t.name == name and t.id == id)\n\n    def get_tag_by_name_and_id_and_name(self, name, id, name):\n        \"\"\"\n            Returns a tag with a given name and id and name.\n        \"\"\"\n        return self.tags.",
        ")\n\n    def add_tag(self, tag):\n        \"\"\"\n            Adds a tag to this object\n        \"\"\"\n        self.tags.append(tag)\n\n    def __str__(self):\n        \"\"\"\n            Returns a string representation of this object\n        \"\"\"\n        return str(self.tags)\n\n    def __repr__(self):\n        \"\"\"\n            Returns a string representation of this object\n        \"\"\"\n        return str(self.tags)\n\n    def __eq__(self, other):\n        \"\"\"\n            Returns true if this object and other are equal\n        \"\"\"\n        return self.tags == other.tags\n\n    def __ne__(self, other):\n        \"\"\"\n            Returns true if this object and other are not equal\n        \"\"\"\n        return self.tags != other.tags\n\n    def __lt__(self, other):\n        \"\"\"\n            Returns true if this object and other are less than\n        \"\"\"\n        return self.tags < other.tags\n\n    def __le__(self, other):\n        \"\"\"\n            Returns true if this object and other are less than or equal\n        \"\"\"\n        return self.tags <= other.tags\n\n    def __gt__(self, other):\n        \"\"\"\n            Returns true if this object and other are greater than\n        \"\"\"\n        return",
        "\n\nclass JackalDoc(Document):\n    \"\"\"\n    A document that is a Jackal document.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super(JackalDoc, self).__init__(**kwargs)\n        self.add_meta('_source', {'type': 'JackalDoc'})\n\n    def to_dict(self, include_meta=False):\n        \"\"\"\n            Returns the result as a dictionary, provide the include_meta flag to als show information like index and doctype.\n        \"\"\"\n        result = super(JackalDoc, self).to_dict(include_meta=include_meta)\n        if include_meta:\n            source = result.pop('_source')\n            return {**result, **source}\n        else:\n            return result\n\nclass JackalDocList(DocumentList):\n    \"\"\"\n    A document list that is a Jackal document list.\n    \"\"\"\n    def __init__(self, **kwargs):\n        super(JackalDocList, self).__init__(**kwargs)\n        self.add_meta('_source', {'type': 'JackalDocList'})\n\n    def to_dict(self, include_meta=False):\n        \"\"\"\n            Returns the result as a dictionary",
        "\n\ndef r_annotation(self, sha):\n        \"\"\" Route to retrieve a single annotation\n\n        :param sha: The SHA of the annotation to retrieve\n        :type sha: str\n        :return: a JSON string containing the annotation\n        :rtype: {str: Any}\n        \"\"\"\n\n        try:\n            urn = MyCapytain.common.reference.URN(sha)\n        except ValueError:\n            return \"invalid sha\", 400\n\n        annotation = self.__queryinterface__.getAnnotation(urn)\n        if not annotation:\n            return \"no annotation found for sha\", 404\n\n        return jsonify(annotation)\n\ndef r_annotation_body(self, sha):\n        \"\"\" Route to retrieve a single annotation body\n\n        :param sha: The SHA of the annotation to retrieve\n        :type sha: str\n        :return: a JSON string containing the annotation body\n        :rtype: {str: Any}\n        \"\"\"\n\n        try:\n            urn = MyCapytain.common.reference.URN(sha)\n        except ValueError:\n            return \"invalid sha\", 400\n\n        annotation = self.__queryinterface__.getAnnotation(urn)\n        if not annotation:\n            return \"no annotation found for sha\", 404\n\n        return jsonify(annotation.to_json())\n\ndef r_annotation_collection(",
        ".name if key else key\n\ndef lookup_all(cls, key, get=False):\n        \"\"\"Returns the label for all Enum keys\"\"\"\n        if get:\n            item = cls._item_dict.get(key)\n            return item.name if item else key\n        return cls._item_dict.keys() if key else cls._item_dict.keys()\n\ndef lookup_all_by_name(cls, name, get=False):\n        \"\"\"Returns the label for all Enum keys by name\"\"\"\n        if get:\n            item = cls._item_dict.get(name)\n            return item.name if item else name\n        return cls._item_dict.keys() if name else cls._item_dict.keys()\n\ndef lookup_all_by_value(cls, value, get=False):\n        \"\"\"Returns the label for all Enum keys by value\"\"\"\n        if get:\n            item = cls._item_dict.get(value)\n            return item.name if item else value\n        return cls._item_dict.keys() if value else cls._item_dict.keys()\n\ndef lookup_all_by_value_or_name(cls, value, name, get=False):\n        \"\"\"Returns the label for all Enum keys by value or name\"\"\"\n        if get:\n            item = cls",
        "\n\ndef _get_item_dict(cls):\n        \"\"\"Returns a dictionary of item names to values\"\"\"\n        return cls._item_dict\n\ndef _get_item_dict_by_key(cls, key):\n        \"\"\"Returns a dictionary of item names to values for a given key\"\"\"\n        return cls._item_dict.get(key)\n\ndef _get_item_dict_by_value(cls, value):\n        \"\"\"Returns a dictionary of item names to values for a given value\"\"\"\n        return cls._item_dict.get(value)\n\ndef _get_item_dict_by_value_or_key(cls, value, key):\n        \"\"\"Returns a dictionary of item names to values for a given value or key\"\"\"\n        return cls._item_dict.get(value, cls._item_dict.get(key))\n\ndef _get_item_dict_by_value_or_key_or_default(cls, value, key, default):\n        \"\"\"Returns a dictionary of item names to values for a given value or key or default\"\"\"\n        return cls._item_dict.get(value, cls._item_dict.get(key, default))\n\ndef _get_item_dict_by_value_or_key_or_default_or_default(cls, value, key, default",
        "\n\ndef get_configured_dns_nameservers():\n    \"\"\"\n        Returns the configured DNS nameservers with the use f nmcli.\n    \"\"\"\n    ips = []\n    try:\n        output = subprocess.check_output(['nmcli', 'device', 'show'])\n        output = output.decode('utf-8')\n\n        for line in output.split('\\n'):\n            if 'DNS' in line:\n                pattern = r\"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\"\n                for hit in re.findall(pattern, line):\n                    ips.append(hit)\n    except FileNotFoundError:\n        pass\n    return ips\n\ndef get_configured_dns_nameservers_with_prefix(prefix):\n    \"\"\"\n        Returns the configured DNS nameservers with the use f nmcli.\n    \"\"\"\n    ips = []\n    try:\n        output = subprocess.check_output(['nmcli', 'device', 'show', '-p', prefix])\n        output = output.decode('utf-8')\n\n        for line in output.split('\\n'):\n            if 'DNS' in line:\n                pattern = r\"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\",
        "\n\ndef zone_transfer_all(address, dns_name):\n    \"\"\"\n        Tries to perform a zone transfer.\n    \"\"\"\n    ips = []\n    try:\n        print_notification(\"Attempting dns zone transfer for {} on all\".format(dns_name))\n        z = dns.zone.from_xfr(dns.query.xfr(address, dns_name))\n    except dns.exception.FormError:\n        print_notification(\"Zone transfer not allowed\")\n        return ips\n    names = z.nodes.keys()\n    print_success(\"Zone transfer successfull for {}, found {} entries\".format(address, len(names)))\n    for n in names:\n        node = z[n]\n        data = node.get_rdataset(dns.rdataclass.IN, dns.rdatatype.A)\n        if data:\n            # TODO add hostnames to entries.\n            for item in data.items:\n                address = item.address\n                ips.append(address)\n    return ips\n\ndef zone_transfer_all_with_names(address, dns_name):\n    \"\"\"\n        Tries to perform a zone transfer.\n    \"\"\"\n    ips = []\n    try:\n        print_notification(\"Attempting dns zone transfer for {} on all with names\".format(dns_name))\n       ",
        "\n\ndef zone_transfer(ip, domain):\n    \"\"\"\n        Transfers the IP address to the specified zone.\n    \"\"\"\n    dnsresolver = dns.resolver.Resolver()\n\n    result = dnsresolver.query(domain, 'A')\n    for a in result.response.answer[0]:\n        print_notification(\"Transferring {}\".format(a))\n        try:\n            result = dnsresolver.query(a, 'A')\n            for b in result.response.answer[0]:\n                print_notification(\"Transferring {}\".format(b))\n                ip = ip + '.' + b\n                print_notification(\"Transferring {}\".format(ip))\n                return [ip]\n        except dns.resolver.NXDOMAIN as e:\n            print_error(e)\n    return []\n\ndef print_notification(msg):\n    print(\"{} {}\".format(msg, time.strftime(\"%H:%M:%S\")))\n\ndef print_error(e):\n    print(\"{} {}\".format(e, time.strftime(\"%H:%M:%S\")))\n\ndef print_success(msg):\n    print(\"{} {}\".format(msg, time.strftime(\"%H:%M:%S\")))\n\ndef print_info(msg):\n    print(\"{} {}\".format(msg,",
        "\n\ndef parse_ranges(ranges, include_public):\n    \"\"\"\n        Parses the list of ranges, turns these into ranges based on the netmask given.\n        Set include_public to True to include public IP adresses.\n    \"\"\"\n    hs = HostSearch()\n    rs = RangeSearch()\n    ranges = list(set(ranges))\n    included_ranges = []\n    print_success(\"Found {} ranges\".format(len(ranges)))\n    for rng in ranges:\n        ip_address = ipaddress.ip_address(rng)\n        if include_public or ip_address.is_private:\n            # To stop the screen filling with ranges.\n            if len(ranges) < 15:\n                print_success(\"Found range: {}\".format(rng))\n            host = hs.id_to_object(rng)\n            host.add_tag('dns_discover')\n            host.save()\n            r = str(ipaddress.IPv4Network(\"{}/{}\".format(rng, netmask), strict=False))\n            included_ranges.append(r)\n            print_notification(\"Excluding range {}\".format(rng))\n        else:\n            print_notification(\"Excluding range {}\".format(rng))\n\n    stats = {}\n    stats['included_ranges'] = included_ranges",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef create_search(self, *args, **kwargs):\n        \"\"\"\n            Creates a search object for the elasticsearch instance.\n        \"\"\"\n        return self.client.search(*args, **kwargs)\n\ndef create_index(self, *args, **kwargs):\n        \"\"\"\n            Creates an index object for the elasticsearch instance.\n        \"\"\"\n        return self.client.create_index(*args, **kwargs)\n\ndef create_index_mapping(self, *args, **kwargs):\n        \"\"\"\n            Creates an index mapping object for the elasticsearch instance.\n        \"\"\"\n        return self.client.create_index_mapping(*args, **kwargs)\n\ndef create_index_mapping_mapping(self, *args, **kwargs):\n        \"\"\"\n            Creates an index mapping mapping object for the elasticsearch instance.\n        \"\"\"\n        return self.client.create_index_mapping_mapping(*args, **kwargs)\n\ndef create_index_mapping_mapping_mapping(self, *args, **kwargs):\n        \"\"\"\n            Creates an index mapping mapping mapping object for the elasticsearch instance.\n        \"\"\"\n        return self.client.create_index_mapping_mapping(*args, **kwargs)\n\ndef create_index_mapping_mapping_mapping(self, *args, **kwargs):\n        \"\"\"\n            Creates an index mapping mapping mapping object",
        "(**vars(arguments)))\n\ndef argument_search_with_args(self, *args):\n        \"\"\"\n            Uses the command line arguments to fill the search function and call it with the given arguments.\n        \"\"\"\n        arguments, _ = self.argparser.parse_known_args(args)\n        return self.search(**vars(arguments))\n\ndef argument_search_with_kwargs(self, **kwargs):\n        \"\"\"\n            Uses the command line arguments to fill the search function and call it with the given arguments.\n        \"\"\"\n        arguments, _ = self.argparser.parse_known_args(kwargs)\n        return self.search(**vars(arguments))\n\ndef argument_search_with_kwargs_with_args(self, **kwargs, *args):\n        \"\"\"\n            Uses the command line arguments to fill the search function and call it with the given arguments.\n        \"\"\"\n        arguments, _ = self.argparser.parse_known_args(kwargs, args)\n        return self.search(**vars(arguments))\n\ndef argument_search_with_kwargs_with_args_with_kwargs(self, **kwargs, **kwargs_args):\n        \"\"\"\n            Uses the command line arguments to fill the search function and call it with the given arguments.\n        \"\"\"\n        arguments, _ = self.argparser",
        "\n\ndef create_search(self, *args, **kwargs):\n        \"\"\"\n            Creates a search object for the given arguments.\n        \"\"\"\n        return self.create_index(self.index_name, *args, **kwargs)\n\ndef create_index(self, index_name, *args, **kwargs):\n        \"\"\"\n            Creates a new index with the given name.\n        \"\"\"\n        return self.client.indices.create(index_name=index_name, **kwargs)\n\ndef delete_index(self, index_name):\n        \"\"\"\n            Deletes the given index.\n        \"\"\"\n        return self.client.indices.delete(index_name=index_name)\n\ndef delete_index_by_name(self, index_name):\n        \"\"\"\n            Deletes the given index by name.\n        \"\"\"\n        return self.client.indices.delete_by_name(index_name=index_name)\n\ndef delete_index_by_name_and_type(self, index_name, type_):\n        \"\"\"\n            Deletes the given index by name and type.\n        \"\"\"\n        return self.client.indices.delete_by_name_and_type(index_name=index_name, type_=type_)\n\ndef delete_index_by_name_and_type",
        "(**vars(arguments)))\n\ndef argument_count_with_help(self):\n        \"\"\"\n            Uses the command line arguments to fill the count function and call it.\n        \"\"\"\n        arguments, _ = self.argparser.parse_known_args()\n        return self.count(**vars(arguments), help=True)\n\ndef argument_count_with_help_with_help(self):\n        \"\"\"\n            Uses the command line arguments to fill the count function and call it.\n        \"\"\"\n        arguments, _ = self.argparser.parse_known_args()\n        return self.count(**vars(arguments), help=True, help_with_help=True)\n\ndef argument_count_with_help_with_help_with_help(self):\n        \"\"\"\n            Uses the command line arguments to fill the count function and call it.\n        \"\"\"\n        arguments, _ = self.argparser.parse_known_args()\n        return self.count(**vars(arguments), help=True, help_with_help=True, help_with_help_with_help=True)\n\ndef argument_count_with_help_with_help_with_help(self):\n        \"\"\"\n            Uses the command line arguments to fill the count function and call it.\n        \"\"\"\n        arguments, _ =",
        "\n\ndef get_pipe_from_file(self, object_type):\n        \"\"\"\n            Returns a generator that maps the input of the pipe to an elasticsearch object.\n            Will call id_to_object if it cannot serialize the data from json.\n        \"\"\"\n        with open(self.file_name, 'r') as f:\n            for line in f:\n                try:\n                    data = json.loads(line.strip())\n                    obj = object_type(**data)\n                    yield obj\n                except ValueError:\n                    yield self.id_to_object(line.strip())\n\ndef get_pipe_from_file_with_id(self, object_type):\n        \"\"\"\n            Returns a generator that maps the input of the pipe to an elasticsearch object.\n            Will call id_to_object if it cannot serialize the data from json.\n        \"\"\"\n        with open(self.file_name, 'r') as f:\n            for line in f:\n                try:\n                    data = json.loads(line.strip())\n                    obj = object_type(**data)\n                    yield obj\n                except ValueError:\n                    yield self.id_to_object(line.strip())\n\ndef get_pipe_from_file_with_id_and_type(self, object_type):\n        \"\"\"\n",
        "\n        return result\n\nclass Range(models.Model):\n    \"\"\"\n    A range of ip addresses.\n    \"\"\"\n    ip = models.IPAddressField(max_length=255, unique=True)\n    start = models.DateTimeField(auto_now_add=True)\n    end = models.DateTimeField(auto_now_add=True)\n    created = models.DateTimeField(auto_now_add=True)\n    updated = models.DateTimeField(auto_now_add=True)\n\n    def __unicode__(self):\n        return self.ip\n\n    def save(self, *args, **kwargs):\n        self.created = datetime.datetime.now()\n        super(Range, self).save(*args, **kwargs)\n\n    def delete(self):\n        self.updated = datetime.datetime.now()\n        super(Range, self).delete()\n\n    def __str__(self):\n        return self.ip\n\n    def __repr__(self):\n        return '<Range %r>' % self.ip\n\n    def __eq__(self, other):\n        return self.ip == other.ip\n\n    def __ne__(self, other):\n        return self.ip != other.ip\n\n    def __lt__(self, other):\n        return self",
        "\n\ndef main():\n        \"\"\"\n            Main function for the search command.\n        \"\"\"\n        parser = argparser()\n        args = parser.parse_args()\n        if args.range:\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range\n                print \"Searching for use in range %s\" % args.range",
        "\n\nclass Service(object):\n    \"\"\"\n        Class for storing and retrieving information about a service.\n    \"\"\"\n    def __init__(self, address, protocol, port, state):\n        self.address = address\n        self.protocol = protocol\n        self.port = port\n        self.state = state\n\n    def __repr__(self):\n        return \"<Service %s>\" % self.address\n\n    def __str__(self):\n        return \"<Service %s>\" % self.address\n\n    def __eq__(self, other):\n        return self.address == other.address and self.protocol == other.protocol and self.port == other.port and self.state == other.state\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.address)\n\n    def __str__(self):\n        return \"<Service %s>\" % self.address\n\n    def __repr__(self):\n        return \"<Service %s>\" % self.address\n\n    def __str__(self):\n        return \"<Service %s>\" % self.address\n\n    def __eq__(self, other):\n        return self.address == other.address and self.protocol == other.protocol and",
        "\n        return user\n\nclass User(models.Model):\n    \"\"\"\n    A user model.\n    \"\"\"\n    username = models.CharField(max_length=255)\n    email = models.EmailField()\n    password = models.CharField(max_length=255)\n    is_staff = models.BooleanField(default=False)\n    is_active = models.BooleanField(default=True)\n    date_joined = models.DateTimeField(auto_now_add=True)\n    date_joined_utc = models.DateTimeField(auto_now_add=True, utc=True)\n    last_login = models.DateTimeField(auto_now=True)\n    last_login_utc = models.DateTimeField(auto_now=True, utc=True)\n    last_name = models.CharField(max_length=255)\n    first_name = models.CharField(max_length=255)\n    last_name_lower = models.CharField(max_length=255, lowercase=True)\n    last_name_upper = models.CharField(max_length=255, uppercase=True)\n    gender = models.CharField(max_length=255, choices=GENDER_CHOICES)\n    gender_lower = models.CharField(max_length=",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef line_to_object(self, line):\n        \"\"\"\n            Converts a line of text to an elasticsearch object.\n        \"\"\"\n        try:\n            return json.loads(line)\n        except ValueError:\n            pass\n        except KeyError:\n            pass\n        return None\n\ndef id_to_object(self, id):\n        \"\"\"\n            Converts an id to an elasticsearch object.\n        \"\"\"\n        try:\n            return self.es.get_index(id)\n        except KeyError:\n            pass\n        return None\n\ndef main():\n        \"\"\"\n            Main function.\n        \"\"\"\n        pipe = get_pipe()\n        for line in pipe:\n            print line\n\nif __name__ == '__main__':\n        main()\n",
        "\n\n\ndef _tree2commands(self, adapter, session, lastcmds, xsync, ret):\n  '''Converts an ET protocol tree and converts it to state.Command commands'''\n\n  # do some preliminary sanity checks...\n  # todo: do i really want to be using assert statements?...\n\n  assert xsync[0].tag == constants.NODE_SYNCML\n  assert len(xsync) == 2\n\n  version = xsync[0].findtext('VerProto')\n  if version != constants.SYNCML_VERSION_1_2:\n    raise common.FeatureNotSupported('unsupported SyncML version \"%s\" (expected \"%s\")' \\\n                                       % (version, constants.SYNCML_VERSION_1_2))\n  verdtd = xsync[0].findtext('VerDTD')\n  if verdtd != constants.SYNCML_DTD_VERSION_1_2:\n    raise common.FeatureNotSupported('unsupported SyncML DTD version \"%s\" (expected \"%s\")' \\\n                                       % (verdtd, constants.SYNCML_DTD_VERSION_1_2))\n\n  # TODO: make this configurable as to whether or not any error\n  #       is sent back to the peer as a SyncML \"standardized\" error\n  #       status...\n  code = '%s.%s' % (e.__",
        "\n\ndef initialize_services():\n    \"\"\"\n        Initializes the services\n    \"\"\"\n    Host.init()\n    Range.init()\n    Service.init()\n    User.init()\n    Credential.init()\n    Log.init()\n\n\ndef initialize_users():\n    \"\"\"\n        Initializes the users\n    \"\"\"\n    Host.init()\n    Range.init()\n    Service.init()\n    User.init()\n    Credential.init()\n    Log.init()\n\n\ndef initialize_credentials():\n    \"\"\"\n        Initializes the credentials\n    \"\"\"\n    Host.init()\n    Range.init()\n    Service.init()\n    User.init()\n    Credential.init()\n    Log.init()\n\n\ndef initialize_logs():\n    \"\"\"\n        Initializes the logs\n    \"\"\"\n    Host.init()\n    Range.init()\n    Service.init()\n    User.init()\n    Credential.init()\n    Log.init()\n\n\ndef initialize_hosts():\n    \"\"\"\n        Initializes the hosts\n    \"\"\"\n    Host.init()\n    Range.init()\n    Service.init()\n    User.init()\n    Credential.init()\n    Log.init()\n\n\ndef initialize_ranges():\n    \"\"\"\n        Initializes the ranges\n    \"\"\"",
        "\n\ndef parse_computers(entries):\n    \"\"\"\n        Parse the entries into a list of Computer objects.\n    \"\"\"\n    computers = []\n    for entry in entries:\n        computers.append(parse_single_computer(entry))\n    return computers\n\ndef resolve_ip(hostname):\n    \"\"\"\n        Resolve a hostname to an IP address.\n    \"\"\"\n    try:\n        return ipaddress.ip_address(hostname)\n    except ValueError:\n        return ''\n\ndef get_field(entry, field):\n    \"\"\"\n        Get a field from an entry.\n    \"\"\"\n    return entry.get(field)\n\ndef get_field_value(entry, field):\n    \"\"\"\n        Get a field value from an entry.\n    \"\"\"\n    return entry.get(field, '')\n\ndef get_field_list(entry, field):\n    \"\"\"\n        Get a field list from an entry.\n    \"\"\"\n    return entry.getlist(field)\n\ndef get_field_dict(entry, field):\n    \"\"\"\n        Get a field dict from an entry.\n    \"\"\"\n    return entry.getdict(field)\n\ndef get_field_string(entry, field):\n    \"\"\"\n        Get a field string from an entry.\n    \"\"\"\n    return entry.get",
        "\n\ndef parse_single_computer(system):\n    \"\"\"\n        Parse a single computer from the file.\n    \"\"\"\n    parsed = {}\n    parsed.ip = system.split(':')[0]\n    parsed.description = system.split(':')[1]\n    parsed.dns_hostname = system.split(':')[2]\n    parsed.os = system.split(':')[3]\n    parsed.dc = system.split(':')[4]\n    return parsed\n\ndef print_notification(message):\n    print(\"[{}] {}\".format(datetime.now(), message))\n\ndef print_info(message):\n    print(\"[{}] {}\".format(datetime.now(), message))\n\ndef print_warning(message):\n    print(\"[{}] {}\".format(datetime.now(), message))\n\ndef print_error(message):\n    print(\"[{}] {}\".format(datetime.now(), message))\n\ndef print_critical(message):\n    print(\"[{}] {}\".format(datetime.now(), message))\n\ndef print_success(message):\n    print(\"[{}] {}\".format(datetime.now(), message))\n\ndef print_error_all(message):\n    print(\"[{}] {}\".format(datetime.now(), message))\n\ndef print_success",
        "\n\ndef parse_domain(entry, domain_groups):\n    \"\"\"\n        Parses a single entry from the domaindump\n    \"\"\"\n    result = {}\n    distinguished_name = get_field(entry, 'distinguishedName')\n    result['domain'] = \".\".join(distinguished_name.split(',DC=')[1:])\n    result['name'] = get_field(entry, 'name')\n    result['username'] = get_field(entry, 'sAMAccountName')\n    result['description'] = get_field(entry, 'description')\n    result['sid'] = get_field(entry, 'objectSid').split('-')[-1]\n\n    primary_group = get_field(entry, 'primaryGroupID')\n    member_of = entry['attributes'].get('memberOf', [])\n    groups = []\n    for member in member_of:\n        for e in member.split(','):\n            if e.startswith('CN='):\n                groups.append(e.split(',')[3:])\n    groups.append(domain_groups.get(primary_group, ''))\n    result['groups'] = groups\n\n    flags = []\n    try:\n        uac = int(get_field(entry, 'userAccountControl'))\n\n        for flag, value",
        "\n\ndef parse_user(entry, domain_groups):\n    \"\"\"\n        Parses the user file.\n    \"\"\"\n    user = User()\n    user.name = get_field(entry, 'cn')\n    user.domain.append(get_field(entry, 'domain'))\n    user.description = get_field(entry, 'description')\n    user.groups.extend(get_field(entry, 'groups'))\n    user.flags.extend(get_field(entry, 'flags'))\n    user.sid = get_field(entry, 'objectSid')\n    user.add_tag(\"domaindump\")\n    user.save()\n    return user\n\ndef parse_domain_groups(domain_groups_file):\n    \"\"\"\n        Parses the domain groups file.\n    \"\"\"\n    with open(domain_groups_file) as f:\n        groups = json.loads(f.read())\n    return groups\n\ndef parse_domain_users_file(domain_users_file):\n    \"\"\"\n        Parses the domain users file.\n    \"\"\"\n    with open(domain_users_file) as f:\n        users = json.loads(f.read())\n    return users\n\ndef parse_domain_groups_file(domain_groups_file):\n    \"\"\"\n        Parses the domain",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\ndef quote(query):\n    \"\"\"Quote a string for use in a URL\"\"\"\n    return urllib.quote(query)\n\n\nAUTOCOMPLETE_URL = 'https://api.google.com/autocomplete/v1/autocomplete'\n",
        "\n\ndef quote(query):\n    \"\"\"Quote a string for use in a query string\n\n    :param string query: string to quote\n    :returns: quoted string\n    :rtype: string\n\n    \"\"\"\n    return urllib.quote(query, safe='')\n\ndef _unicode(s):\n    \"\"\"Unicode version of a string\n\n    :param string s: string to unicode\n    :returns: unicode version of the string\n    :rtype: string\n\n    \"\"\"\n    return s.encode('utf-8')\n",
        "\ndef _unicode_to_utf8(string):\n    \"\"\"Try to convert a string to utf-8 using different encodings\"\"\"\n    for encoding in ['utf-8', 'latin1']:\n        try:\n            result = string.encode(encoding)\n            return result\n        except UnicodeDecodeError:\n            pass\n    result = string.encode('utf-8')\n    return result\n\ndef _unicode_to_latin1(string):\n    \"\"\"Try to convert a string to latin1 using different encodings\"\"\"\n    for encoding in ['utf-8', 'latin1']:\n        try:\n            result = string.encode(encoding, 'replace')\n            return result\n        except UnicodeDecodeError:\n            pass\n    result = string.encode('latin1')\n    return result\n\ndef _unicode_to_ascii(string):\n    \"\"\"Try to convert a string to ascii using different encodings\"\"\"\n    for encoding in ['utf-8', 'latin1']:\n        try:\n            result = string.encode(encoding, 'ascii')\n            return result\n        except UnicodeDecodeError:\n            pass\n    result = string.encode('ascii')\n    return result\n\ndef _unicode_to_ascii_with_unicode(string):\n    \"\"\"Try to convert a string to ascii using different encodings\"\"\"\n    for encoding in ['utf-8', 'latin1",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef write(self, content):\n        \"\"\" Write the contents of the Annotation Resource\n\n        :param content: the contents of the resource\n        :type content: str or bytes\n        :return: the contents of the resource\n        :rtype: str or bytes or flask.response\n        \"\"\"\n        if not self.__content__:\n            self.__retriever__ = self.__resolver__.resolve(self.uri)\n            self.__content__ = content\n            self.__mimetype__ = 'application/json'\n        return self.__content__\n\ndef delete(self):\n        \"\"\" Delete the Annotation Resource\n\n        :return: the contents of the resource\n        :rtype: str or bytes or flask.response\n        \"\"\"\n        if self.__content__:\n            self.__retriever__ = self.__resolver__.resolve(self.uri)\n            self.__retriever__.delete(self.uri)\n        return self.__content__\n\ndef get(self):\n        \"\"\" Get the Annotation Resource\n\n        :return: the contents of the resource\n        :rtype: str or bytes or flask.response\n        \"\"\"\n        if self.__content__:\n            return self.__content__\n        return self.__retriever__.get(self.uri)\n\ndef post(self):\n        \"\"\" Post the Annotation Resource\n\n        :param content: the",
        "\n\ndef build_index(triples):\n    \"\"\"build a list of indexes for a given list of triples\"\"\"\n    index_and_mapping = build_index_and_mapping(triples)\n    return index_and_mapping\n\ndef build_mapping(index_and_mapping):\n    \"\"\"build a mapping from a list of indexes to a list of triples\"\"\"\n    mappings = []\n    for index in index_and_mapping:\n        mappings.append(index.mapping)\n    return mappings\n\ndef build_index_and_mapping_from_mapping(mapping):\n    \"\"\"build a list of indexes and a mapping from a list of triples\"\"\"\n    index_and_mapping = build_index_and_mapping(mapping)\n    return index_and_mapping\n\ndef build_mapping_from_index(index):\n    \"\"\"build a mapping from a list of indexes to a list of triples\"\"\"\n    mappings = []\n    for mapping in index:\n        mappings.append(mapping.mapping)\n    return mappings\n\ndef build_index_and_mapping_from_mapping_list(mapping_list):\n    \"\"\"build a list of indexes and a mapping from a list of triples\"\"\"\n    index_and_mapping = build_index_and_mapping_from_mapping(mapping_list)\n    return index_and_mapping\n",
        "\n\ndef recover_triples_from_mapping_with_index(indexes, ents: bidict, rels: bidict):\n    \"\"\"recover triples from mapping with index.\"\"\"\n    triples = []\n    for t in indexes:\n        triples.append(kgedata.Triple(ents.inverse[t.head], rels.inverse[t.relation], ents.inverse[t.tail]))\n    return triples\n\ndef recover_triples_from_mapping_with_index_with_index(indexes, ents: bidict, rels: bidict):\n    \"\"\"recover triples from mapping with index and index.\"\"\"\n    triples = []\n    for t in indexes:\n        triples.append(kgedata.Triple(ents.inverse[t.head], rels.inverse[t.relation], ents.inverse[t.tail]))\n    return triples\n\ndef recover_triples_from_mapping_with_index_with_index_with_index(indexes, ents: bidict, rels: bidict):\n    \"\"\"recover triples from mapping with index and index and index.\"\"\"\n    triples = []\n    for t in indexes:\n        triples.append(kgedata.Triple(ents.inverse[t.head], rels.inverse[t.relation], ents.inverse[t.tail]))\n    return triples\n\n",
        "\n\n\ndef _transform_triple_numpy_array(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)\n\n\ndef _transform_triple_numpy_array_array(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)\n\n\ndef _transform_triple_numpy_array_array(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)\n\n\ndef _transform_triple_numpy_array_array(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)\n\n\ndef _transform_triple_numpy_array_array(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)\n\n\ndef _transform_triple_numpy",
        "\n\ndef _transform_triple_numpy(triples):\n    \"\"\"Transforms a list of triple indexes into a numpy array.\"\"\"\n    return np.array(triples, dtype=np.int64)\n\ndef unpack_triples_numpy(numpy_array):\n    \"\"\"Unpacks a numpy array into a list of triple indexes.\"\"\"\n    return np.stack(list(map(_unpack_triple_numpy, numpy_array)), axis=0)\n\ndef _unpack_triple_numpy(numpy_array):\n    \"\"\"Unpacks a numpy array into a list of triple indexes.\"\"\"\n    return np.array(numpy_array, dtype=np.int64)\n\ndef _transform_triples_numpy_to_numpy(triples):\n    \"\"\"Transforms a list of triple indexes into a numpy array.\"\"\"\n    return np.array(triples, dtype=np.int64)\n\ndef unpack_triples_numpy_to_numpy(numpy_array):\n    \"\"\"Unpacks a numpy array into a list of triple indexes.\"\"\"\n    return np.stack(list(map(_unpack_triple_numpy_to_numpy, numpy_array)), axis=0)\n\ndef _unpack_triple_numpy_to_numpy(numpy_array):\n    \"\"\"Unpacks a numpy array into a list of triple indexes.\"\"\"\n    return",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef remove_direct_link_triples_with_duplicates(train, valid, test):\n    \"\"\"Remove direct links in the training sets with duplicates.\"\"\"\n    pairs = set()\n    merged = valid + test\n    for t in merged:\n        pairs.add((t.head, t.tail))\n\n    filtered = filterfalse(lambda t: (t.head, t.tail) in pairs or (t.tail, t.head) in pairs, train)\n    return list(filtered)\n\ndef remove_direct_link_triples_with_duplicates_with_duplicates(train, valid, test):\n    \"\"\"Remove direct links in the training sets with duplicates and duplicates with duplicates.\"\"\"\n    pairs = set()\n    merged = valid + test\n    for t in merged:\n        pairs.add((t.head, t.tail))\n\n    filtered = filterfalse(lambda t: (t.head, t.tail) in pairs or (t.tail, t.head) in pairs, train)\n    return list(filtered)\n\ndef remove_direct_link_triples_with_duplicates_with_duplicates_with_duplicates(train, valid, test):\n    \"\"\"Remove direct links in the training sets with duplicates and duplicates with duplicates and duplicates with duplicates.\"\"\"\n    pairs = set()\n    merged = valid + test\n",
        "\n\n\ndef shrink_indexes_in_place_with_id(self, triples):\n        \"\"\"Uses a union find to find segment.\"\"\"\n\n        _ent_roots = self.UnionFind(self._ent_id)\n        _rel_roots = self.UnionFind(self._rel_id)\n\n        for t in triples:\n            _ent_roots.add(t.head)\n            _ent_roots.add(t.tail)\n            _rel_roots.add(t.relation)\n\n        for i, t in enumerate(triples):\n            h = _ent_roots.find(t.head)\n            r = _rel_roots.find(t.relation)\n            t = _ent_roots.find(t.tail)\n            triples[i] = kgedata.TripleIndex(h, r, t)\n\n        ents = bidict()\n        available_ent_idx = 0\n        for previous_idx, ent_exist in enumerate(_ent_roots.roots()):\n            if not ent_exist:\n                self._ents.inverse.pop(previous_idx)\n            else:\n                ents[self._ents.inverse[previous_idx]] = available_ent_idx\n            available_ent_idx += 1\n        rels = bidict()\n        available_rel",
        "\n\n\nclass IndexBuilder(object):\n    \"\"\"\n    Builds a Sphinx index from a list of documents.\n\n    This is a convenience class for building Sphinx index from a list of\n    documents.\n    \"\"\"\n    def __init__(self, documents, **kwargs):\n        self.documents = documents\n        self.store = {}\n        self.docnames = {}\n        self.filenames = {}\n        self.objtypes = {}\n        self.shortanchor = {}\n        self.doctypes = {}\n        self.objtypes_by_name = {}\n        self.objtypes_by_prefix = {}\n        self.objtypes_by_last_prefix = {}\n        self.objtypes_by_name_and_shortanchor = {}\n        self.objtypes_by_prefix_and_last_prefix = {}\n        self.objtypes_by_name_and_shortanchor_and_last_prefix = {}\n        self.objtypes_by_name_and_shortanchor_and_last_prefix_and_objtype = {}\n        self.objtypes_by_prefix_and_last_prefix_and_objtype = {}\n        self.objtypes_by_name_and_shortanchor_and_last_prefix_and_objtype_and_objtype = {}\n       ",
        ", p)\n\ndef log_operation_error(entities, operation_name, params=None):\n    \"\"\"Logs an operation done on an entity, possibly with other arguments\n    \"\"\"\n    if isinstance(entities, (list, tuple)):\n        entities = list(entities)\n    else:\n        entities = [entities]\n\n    p = {'name': operation_name, 'on': entities}\n    if params:\n        p['params'] = params\n    _log(TYPE_CODES.OPERATION_ERROR, p)\n\ndef log_operation_success(entities, operation_name, params=None):\n    \"\"\"Logs an operation done on an entity, possibly with other arguments\n    \"\"\"\n    if isinstance(entities, (list, tuple)):\n        entities = list(entities)\n    else:\n        entities = [entities]\n\n    p = {'name': operation_name, 'on': entities}\n    if params:\n        p['params'] = params\n    _log(TYPE_CODES.OPERATION_SUCCESS, p)\n\ndef log_operation_failure(entities, operation_name, params=None):\n    \"\"\"Logs an operation done on an entity, possibly with other arguments\n    \"\"\"\n    if isinstance(entities, (list, tuple)):\n        entities = list(entities)\n    else:\n        entities = [entities",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;",
        "\n\ndef dict_cursor_with_kwargs(func):\n    \"\"\"\n    Decorator that provides a dictionary cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.DICT) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side dictionary cursor\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(cls, *args, **kwargs):\n        with (yield from cls.get_cursor(_CursorType.DICT)) as c:\n            return (yield from func(cls, c, *args, **kwargs))\n\n    return wrapper\n\ndef dict_cursor_with_kwargs_with_kwargs(func):\n    \"\"\"\n    Decorator that provides a dictionary cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.DICT) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side dictionary cursor\n    \"\"\"\n\n    @",
        "\n",
        "\n",
        "\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "\n\ndef update(cls, cur, table: str, values: dict):\n        \"\"\"\n        Creates an update statement with only chosen fields\n\n        Args:\n            table: a string indicating the name of the table\n            values: a dict of fields and values to be updated\n\n        Returns:\n            A 'Record' object with table columns as properties\n\n        \"\"\"\n        keys = cls._COMMA.join(values.keys())\n        value_place_holder = cls._PLACEHOLDER * len(values)\n        query = cls._update_string.format(table, keys, value_place_holder[:-1])\n        yield from cur.execute(query, tuple(values.values()))\n        return (yield from cur.fetchone())\n\ndef delete(cls, cur, table: str):\n        \"\"\"\n        Creates a delete statement with only chosen fields\n\n        Args:\n            table: a string indicating the name of the table\n\n        Returns:\n            A 'Record' object with table columns as properties\n\n        \"\"\"\n        keys = cls._COMMA.join(values.keys())\n        query = cls._delete_string.format(table, keys)\n        yield from cur.execute(query)\n        return (yield from cur.fetchone())\n\ndef select(cls, cur, table: str):\n        \"\"\"\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n    @classmethod\n    def _get_where_clause_with_values(cls, where_keys: list):\n        \"\"\"\n        Creates a where clause with values\n        Supports multiple where clause with and or or both\n\n        Args:\n            where_keys: list of dictionary\n            example of where keys: [{'name':('>', 'cip'),'url':('=', 'cip.com'},{'type':{'<=', 'manufacturer'}}]\n            where_clause will look like ((name>%s and url=%s) or (type <= %s))\n            items within each dictionary get 'AND'-ed and dictionaries themselves get 'OR'-ed\n\n        Returns:\n            a tuple of where clause and values\n\n        \"\"\"\n        where_clause = []\n        values = []\n        for where_key in where_keys:\n            where_clause.append(where_key['name'])\n            values.append(where_key['url'])\n            where_clause.append(where_key['type'])\n        return where_clause, values\n\n    @classmethod\n    def _delete_query(cls, table: str, where_clause: str):\n        \"\"\"\n        Creates a delete query with where clause\n\n        Args:\n            table: a string indicating the name of the table\n            where_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef raw_sql_with_values(cls, cur, query: str, values: tuple):\n        \"\"\"\n        Run a raw sql query with values\n\n        Args:\n            query : query string to execute\n            values : tuple of values to be used with the query\n\n        Returns:\n            result of query as list of named tuple\n\n        \"\"\"\n        yield from raw_sql(cls, cur, query, values)\n        return (yield from cur.fetchall())\n\ndef raw_sql_with_values_with_values(cls, cur, query: str, values: tuple, values2: tuple):\n        \"\"\"\n        Run a raw sql query with values and values2\n\n        Args:\n            query : query string to execute\n            values : tuple of values to be used with the query\n            values2 : tuple of values to be used with the query\n\n        Returns:\n            result of query as list of named tuple\n\n        \"\"\"\n        yield from raw_sql(cls, cur, query, values)\n        yield from raw_sql(cls, cur, query, values2)\n        return (yield from cur.fetchall())\n\ndef raw_sql_with_values_with_values2(cls, cur, query: str, values: tuple, values2: tuple):\n        \"\"\"\n        Run a raw sql",
        "\n\ndef padding_adder(padding):\n    \"\"\"This method is used to add padding to all lines\n    except the first one.\n\n    This method is used to add padding to all lines\n    except the first one.\n    \"\"\"\n    def add_padding(text, ignore_first_line=False):\n        \"\"\"This method is used to add padding to all lines\n        except the first one.\n\n        This method is used to add padding to all lines\n        except the first one.\n        \"\"\"\n        padding = padding + len(text)\n        if ignore_first_line:\n            padding = padding - len(text)\n        return text + padding\n\n    return add_padding\n\ndef serialize_table(out, table):\n    \"\"\"This method is used to append content of the `table`\n    argument to the `out` argument.\n\n    Depending on how many rows in the table, a\n    padding can be added to all rows except the first\n    one.\n\n    Concatenation result is appended to the `out` argument.\n    \"\"\"\n    padding = len(out)\n    # we need to add padding to all rows\n    # except the first one\n    add_padding = padding_adder(padding)\n    table = add_padding(table, ignore_first_row=True)\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        else:\n            # Otherwise, check the children of this child against the next query part.\n            for e in traverse(c, query[1:]):\n                yield e\n\ndef xpath_re(expr):\n    \"\"\"\n    A regular expression that matches any element with a given xpath expression.\n    \"\"\"\n    return re.compile(r'(^|[^/])%s' % expr)\n",
        "\n    return norm\n\ndef parse_query_string(query):\n    \"\"\"\n    Given a simplified XPath query string, returns a list of normalized query parts.\n    \"\"\"\n    parts = query.split('/')\n    norm = []\n    for p in parts:\n        p = p.strip()\n        if p:\n            norm.append(p)\n            if '' not in norm:\n                norm.append('')\n    return norm\n\ndef parse_query_string_with_query(query):\n    \"\"\"\n    Given a simplified XPath query string, returns a list of normalized query parts.\n    \"\"\"\n    parts = query.split('/')\n    norm = []\n    for p in parts:\n        p = p.strip()\n        if p:\n            norm.append(p)\n            if '' not in norm:\n                norm.append('')\n    return norm\n\ndef parse_query_string_with_query_and_query(query):\n    \"\"\"\n    Given a simplified XPath query string, returns a list of normalized query parts.\n    \"\"\"\n    parts = query.split('/')\n    norm = []\n    for p in parts:\n        p = p.strip()\n        if p:\n            norm.append(p)\n            if '' not in norm:\n                norm.append('",
        "\n\ndef append(self, elem):\n        \"\"\"\n        Appends a new element to this element, after the specified index or sibling.\n\n        :param elem: The element to add\n        :returns: The newly-created element\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        if isinstance(elem, self.__class__):\n            if elem.parent != self:\n                raise ValueError('Cannot append after an element with a different parent.')\n            elem = elem.index\n        self._children.append(elem)\n        return elem\n\ndef prepend(self, elem):\n        \"\"\"\n        Prepends a new element to this element, before the specified index or sibling.\n\n        :param elem: The element to add\n        :returns: The newly-created element\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        if isinstance(elem, self.__class__):\n            if elem.parent != self:\n                raise ValueError('Cannot prepend before an element with a different parent.')\n            elem = elem.index\n        self._children.insert(0, elem)\n        return elem\n\ndef remove(self, elem):\n        \"\"\"\n        Removes the specified element from this element.\n\n        :param elem: The element to remove\n        :returns: The removed element\n        :rtype: :class",
        "\n            else:\n                for child in elem.children():\n                    yield child\n\ndef text(self, name=None, reverse=False):\n        \"\"\"\n        A generator yielding text of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :param reverse: If ``True``, text will be yielded in reverse declaration order\n        \"\"\"\n        elems = self._children\n        if reverse:\n            elems = reversed(elems)\n        for elem in elems:\n            if name is None or elem.tagname == name:\n                yield elem.text\n\ndef text_content(self, name=None, reverse=False):\n        \"\"\"\n        A generator yielding text content of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :param reverse: If ``True``, text content will be yielded in reverse declaration order\n        \"\"\"\n        elems = self._children\n        if reverse:\n            elems = reversed(elems)\n        for elem in elems:\n            if name is None or elem.tagname == name:\n                yield elem.text_content\n\ndef text_content_with_attributes(self, name=None, reverse=False):\n        \"\"\"\n        A generator yielding text content with attributes of this node.\n\n        :param name: If specified",
        "\n\ndef _match_tag(self, pred):\n        \"\"\"\n        Helper function to determine if this node matches the given predicate.\n        \"\"\"\n        return _match(pred, 'tag')\n\ndef _match_attr(self, pred):\n        \"\"\"\n        Helper function to determine if this node matches the given predicate.\n        \"\"\"\n        return _match(pred, 'attr')\n\ndef _match_data(self, pred):\n        \"\"\"\n        Helper function to determine if this node matches the given predicate.\n        \"\"\"\n        return _match(pred, 'data')\n\ndef _match_index(self, pred):\n        \"\"\"\n        Helper function to determine if this node matches the given predicate.\n        \"\"\"\n        return _match(pred, 'index')\n\ndef _match_text(self, pred):\n        \"\"\"\n        Helper function to determine if this node matches the given predicate.\n        \"\"\"\n        return _match(pred, 'text')\n\ndef _match_comment(self, pred):\n        \"\"\"\n        Helper function to determine if this node matches the given predicate.\n        \"\"\"\n        return _match(pred, 'comment')\n\ndef _match_text_node(self, pred):\n        \"\"\"\n        Helper function to determine if this node matches the given predicate.\n        \"\"\"\n        return _match(pred",
        "\n\ndef get_parent(self):\n        \"\"\"\n        Returns the parent element of this element, or ``None`` if this element is the root.\n        \"\"\"\n        return self.parent\n\ndef get_children(self):\n        \"\"\"\n        Returns a list of all child elements of this element.\n        \"\"\"\n        return self.children\n\ndef get_first_child(self):\n        \"\"\"\n        Returns the first child element of this element, or ``None`` if this element is the root.\n        \"\"\"\n        return self.first_child\n\ndef get_last_child(self):\n        \"\"\"\n        Returns the last child element of this element, or ``None`` if this element is the root.\n        \"\"\"\n        return self.last_child\n\ndef get_next_sibling(self):\n        \"\"\"\n        Returns the next sibling element of this element, or ``None`` if this element is the root.\n        \"\"\"\n        return self.next_sibling\n\ndef get_previous_sibling(self):\n        \"\"\"\n        Returns the previous sibling element of this element, or ``None`` if this element is the root.\n        \"\"\"\n        return self.previous_sibling\n\ndef get_first_child_or_self(self):\n        \"\"\"\n        Returns the first child element of this element, or ``None`` if this",
        "\n                for gc in gc.iter():\n                    yield gc\n\ndef find(self, name):\n        \"\"\"\n        Find all elements with the given tag name.\n\n        :param name: If specified, only consider elements with this tag name\n        :returns: A generator yielding elements with this tag name\n        \"\"\"\n        for c in self._children:\n            if name is None or c.tagname == name:\n                yield c\n            for gc in c.find(name):\n                yield gc\n\ndef find_all(self, name):\n        \"\"\"\n        Find all elements with the given tag name.\n\n        :param name: If specified, only consider elements with this tag name\n        :returns: A generator yielding elements with this tag name\n        \"\"\"\n        for c in self._children:\n            if name is None or c.tagname == name:\n                yield c\n            for gc in c.find_all(name):\n                yield gc\n\ndef find_all_by_tagname(self, tagname):\n        \"\"\"\n        Find all elements with the given tag name.\n\n        :param tagname: If specified, only consider elements with this tag name\n        :returns: A generator yielding elements with this tag name\n        \"\"\"\n        for c in self._children:\n            if tagname in c.tagnames:\n                yield c",
        " in self.children():\n                return c\n        return None\n\ndef first(self, name=None):\n        \"\"\"\n        Returns the first child of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        for c in self.children(name, reverse=False):\n                return c\n        return None\n\ndef children(self, name=None, reverse=False):\n        \"\"\"\n        Returns all children of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        for c in self.children():\n                if name is not None and c.tagName() != name:\n                        continue\n                yield c\n                for c in c.children(name, reverse=reverse):\n                        yield c\n\ndef first_child(self, name=None):\n        \"\"\"\n        Returns the first child of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        for c in self.children(name, reverse=True):\n                return c\n        return None\n\ndef last_child(self, name=None):\n        \"\"\"",
        "\n\ndef children(self, name=None):\n        \"\"\"\n        Yields all children of this element, back to the root element.\n\n        :param name: If specified, only consider elements with this tag name\n        \"\"\"\n        p = self.parent\n        while p is not None:\n            if name is None or p.tagname == name:\n                yield p\n            p = p.parent\n\ndef text(self):\n        \"\"\"\n        Returns the text content of this element.\n        \"\"\"\n        return self.textContent\n\ndef text_content(self):\n        \"\"\"\n        Returns the text content of this element, or None if this element has no text content.\n        \"\"\"\n        return self.textContent\n\ndef text_content_with_encoding(self, encoding):\n        \"\"\"\n        Returns the text content of this element, or None if this element has no text content,\n        and the encoding is not specified.\n        \"\"\"\n        return self.textContent, encoding\n\ndef text_content_with_encoding_or_none(self, encoding):\n        \"\"\"\n        Returns the text content of this element, or None if this element has no text content,\n        and the encoding is not specified, or the encoding is specified.\n        \"\"\"\n        return self.textContent, encoding or None\n\ndef text_content_",
        "\n        return None\n\ndef prev(self, name=None):\n        \"\"\"\n        Returns the previous sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        if self.parent is None or self.index is None:\n            return None\n        for idx in xrange(self.index - 1, -1, -1):\n            if name is None or self.parent[idx].tagname == name:\n                return self.parent[idx]\n        return None\n\ndef first(self, name=None):\n        \"\"\"\n        Returns the first sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        if self.parent is None or self.index is None:\n            return None\n        for idx in xrange(0, len(self.parent)):\n            if name is None or self.parent[idx].tagname == name:\n                return self.parent[idx]\n        return None\n\ndef last(self, name=None):\n        \"\"\"\n        Returns the last sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :",
        "\n        return None\n\ndef next(self, name=None):\n        \"\"\"\n        Returns the next sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        if self.parent is None or self.index is None:\n            return None\n        for idx in xrange(self.index + 1, -1, -1):\n            if name is None or self.parent[idx].tagname == name:\n                return self.parent[idx]\n        return None\n\ndef first(self, name=None):\n        \"\"\"\n        Returns the first sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`\n        \"\"\"\n        if self.parent is None or self.index is None:\n            return None\n        for idx in xrange(self.index - 1, -1, -1):\n            if name is None or self.parent[idx].tagname == name:\n                return self.parent[idx]\n        return None\n\ndef last(self, name=None):\n        \"\"\"\n        Returns the last sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :r",
        "\n\ndef get_observations_by_date(self, date):\n        \"\"\"\n        Parses the HTML table into a list of dictionaries, each of which represents\n        a single observation.\n        \"\"\"\n        if self.empty:\n            return []\n        rows = list(self.tbody)\n        observations = []\n        for row_observation, row_details in zip(rows[::2], rows[1::2]):\n            data = {}\n            cells = OBSERVATION_XPATH(row_observation)\n            data['name'] = _clean_cell(cells[0])\n            data['date'] = _clean_cell(cells[1])\n            data['magnitude'] = _clean_cell(cells[3])\n            data['obscode'] = _clean_cell(cells[6])\n            cells = DETAILS_XPATH(row_details)\n            data['comp1'] = _clean_cell(cells[0])\n            data['chart'] = _clean_cell(cells[3]).replace('None', '')\n            data['comment_code'] = _clean_cell(cells[4])\n            data['notes'] = _clean_cell(cells[5])\n            observations.append(data)\n        return observations\n\ndef get_observations_by_comp1(self, comp1):\n        \"\"\"",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_cache_key(prefix, *args, **kwargs):\n    \"\"\"\n    Calculate cache key based on `prefix`, `args` and `kwargs` of the function.\n    \"\"\"\n    return prefix + '.'.join(args) + '.'.join(kwargs)\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _get_printable_rows(rows, columns):\n    \"\"\"Return only the part of the row which should be printed.\n    \"\"\"\n    if not rows:\n        return columns\n\n    # Extract the row values, in the order specified.\n    return tuple(row[c] for c in columns)\n\ndef _get_printable_columns_and_rows(columns, rows):\n    \"\"\"Return the columns and rows which should be printed.\n    \"\"\"\n    return _get_printable_columns(columns, _get_printable_rows(rows))\n\ndef _get_printable_columns_and_rows_and_columns(columns, rows):\n    \"\"\"Return the columns and rows which should be printed and the columns\n    which should be printed.\n    \"\"\"\n    return _get_printable_columns(columns, _get_printable_rows_and_columns(rows))\n\ndef _get_printable_columns_and_rows_and_columns_and_rows(columns, rows):\n    \"\"\"Return the columns and rows which should be printed and the columns\n    which should be printed and the rows which should be printed.\n    \"\"\"\n    return _get_printable_columns(columns, _get_printable_rows_and_columns_and_rows(rows))\n\ndef _get",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef row_to_dict(cls, row):\n        \"\"\"\n        Takes a list of fields according to AAVSO visual format specification and\n        converts it to a dictionary of observation data.\n\n        :param cls: current class\n        :param row: a list of fields according to AAVSO visual format specification\n        \"\"\"\n        observation_data = {}\n        for field in row:\n            observation_data[field] = row[field]\n        return observation_data\n\ndef get_observation_data(cls, filename):\n        \"\"\"\n        Takes a filename and returns a dictionary of observation data.\n\n        :param cls: current class\n        :param filename: a filename\n        \"\"\"\n        with open(filename, 'r') as f:\n            data = f.read()\n        return dict_to_row(cls, data)\n\ndef get_observation_data_from_csv(cls, filename):\n        \"\"\"\n        Takes a filename and returns a dictionary of observation data.\n\n        :param cls: current class\n        :param filename: a filename\n        \"\"\"\n        with open(filename, 'r') as f:\n            data = f.read()\n        return row_to_dict(cls, data)\n\ndef get_observation_data_from_csv_with_header(cls, filename, header):",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n    return None\n\ndef get_view_function(app, path, method):\n    '''Get the name of the view function used to prevent having to set the tag manually for every endpoint'''\n    if app.config.get('DEBUG'):\n        return 'debug_%s_%s' % (app.name, path)\n    else:\n        return 'default_%s_%s' % (app.name, path)\n\ndef get_view_function_for_endpoint(app, endpoint):\n    '''Get the name of the view function used to prevent having to set the tag manually for every endpoint'''\n    if app.config.get('DEBUG'):\n        return 'debug_%s_%s' % (app.name, endpoint)\n    else:\n        return 'default_%s_%s' % (app.name, endpoint)\n\ndef get_view_function_for_method(app, method):\n    '''Get the name of the view function used to prevent having to set the tag manually for every endpoint'''\n    if app.config.get('DEBUG'):\n        return 'debug_%s_%s' % (app.name, method)\n    else:\n        return 'default_%s_%s' % (app.name, method)\n\ndef get_view_function_for_endpoint_and_method(app, endpoint,",
        "\n\ndef download_observations_by_observer(observer_code):\n    \"\"\"\n    Downloads all variable star observations by a given observer.\n\n    Performs a series of HTTP requests to AAVSO's WebObs search and\n    downloads the results page by page. Each page is then passed to\n    :py:class:`~pyaavso.parsers.webobs.WebObsResultsParser` and parse results\n    are added to the final observation list.\n    \"\"\"\n    page_number = 1\n    observations = []\n    while True:\n        logger.info('Downloading page %d...', page_number)\n        response = requests.get(WEBOBS_RESULTS_URL, params={\n            'obscode': observer_code,\n            'num_results': 200,\n            'obs_types': 'all',\n            'page': page_number,\n        })\n        logger.debug(response.request.url)\n        parser = WebObsResultsParser(response.text)\n        observations.extend(parser.get_observations())\n        # kinda silly, but there's no need for lxml machinery here\n        if '>Next</a>' not in response.text:\n            break\n        page_number += 1\n    return observations\n\ndef download_observations_by_observer_code(observer_code):\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\ndef _upload_to_mongodb(mongo_collection, metadata):\n    \"\"\"Upload metadata to MongoDB.\n\n    Parameters\n    ----------\n    mongo_collection : `motor.motor_asyncio.AsyncIOMotorCollection`\n        MongoDB collection. This should be the common MongoDB collection for\n        LSST projectmeta JSON-LD records. If provided, ths JSON-LD is upserted\n        into the MongoDB collection.\n    metadata : `dict`\n        JSON-LD-formatted dictionary.\n\n    Raises\n    ------\n    MongoError\n        Raised when the metadata cannot be uploaded to MongoDB.\n    \"\"\"\n    try:\n        await mongo_collection.insert_one(metadata)\n    except MongoError as err:\n        raise MongoError(err.message)\n\n\ndef decode_jsonld(json_data):\n    \"\"\"Decode JSON-LD-formatted dictionary.\n\n    Parameters\n    ----------\n    json_data : `str`\n        JSON-LD-formatted dictionary.\n\n    Returns\n    -------\n    metadata : `dict`\n        JSON-LD-formatted dictionary.\n\n    Raises\n    ------\n    InvalidJSONLDError\n        Raised when the JSON-LD is invalid.\n    \"\"\"\n    try:\n        return json.loads(json_data)\n    except ValueError as err:\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef json_struct_to_xml(json_obj, elem, custom_namespace=None):\n    \"\"\"Converts a JSON object to an XML Element.\n\n    Takes a dict deserialized from JSON, returns an lxml Element.\n\n    Accepts only the full root-level JSON object from an Open511 response.\"\"\"\n    if 'meta' not in json_obj:\n        raise Exception(\"This function requires a conforming JSON object with a 'meta' section.\")\n    json_obj = dict(json_obj)\n    meta = json_obj.pop('meta')\n    elem.append(get_base_open511_element(lang=meta.pop('lang'), version=meta.pop('version')))\n\n    json_struct_to_xml(json_obj, elem, custom_namespace=custom_namespace)\n\n    return elem\n\ndef get_base_open511_element(lang='en', version=None):\n    \"\"\"Returns an lxml Element with the appropriate language and version.\n\n    Takes a dict deserialized from JSON, returns an lxml Element.\n\n    Accepts only the full root-level JSON object from an Open511 response.\"\"\"\n    elem = lxml.Element('open511', lang=lang, version=version)\n    return elem\n\ndef get_base_open511_element_",
        "\n\ndef json_link_to_xml(json_obj, rel):\n    \"\"\"Converts a Open511 JSON fragment to XML.\n\n    Takes a dict deserialized from JSON, returns an lxml Element.\n\n    This won't provide a conforming document if you pass in a full JSON document;\n    it's for translating little fragments, and is mostly used internally.\"\"\"\n    if isinstance(json_obj, (str, unicode)):\n        if json_obj.startswith('!'):\n            return etree.Element('{%s}%s' % (NS_PROTECTED, json_obj[1:]))\n        elif json_obj.startswith('+'):\n            if not custom_namespace:\n                raise Exception(\"JSON fields starts with +, but no custom namespace provided\")\n            return etree.Element('{%s}%s' % (custom_namespace, json_obj[1:]))\n        else:\n            return etree.Element(json_obj)\n    elif isinstance(json_obj, (int, float)):\n        return etree.Element('{%s}%s' % (NS_PROTECTED, str(json_obj)))\n    elif isinstance(json_obj, dict):\n        if frozenset(json_obj.keys()) == frozenset(('type', 'coordinates')):\n            return geojson_to_gml(",
        ".to_xml()\n\n\ndef _reverse_geojson_coords(coords):\n    \"\"\"Reverse the coordinates in a list of GeoJSON coordinates.\"\"\"\n    return [\n        [float(x), float(y)] for x, y in zip(*coords)\n    ]\n\n\ndef _reverse_gml_coords(coords):\n    \"\"\"Reverse the coordinates in a list of GML coordinates.\"\"\"\n    return [\n        [float(x), float(y)] for x, y in zip(*coords)\n    ]\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n",
        "\n\ndef xml_to_json(doc):\n    \"\"\"\n    Converts an lxml Element to a json dict.\n    \"\"\"\n    return json.loads(doc.text)\n\ndef json_doc_to_xml(doc):\n    \"\"\"\n    Converts a json dict to an lxml Element.\n    \"\"\"\n    return lxml.fromstring(doc.text)\n",
        "\n\ndef ensure_format(input_doc, output_format):\n    \"\"\"\n    Ensure that the input_doc is a valid format for the output_format.\n    \"\"\"\n    if not isinstance(input_doc, Element):\n        raise ValueError(\"Input document must be an lxml Element\")\n    if not isinstance(output_format, str):\n        raise ValueError(\"Output format must be a string\")\n    return input_doc\n\ndef format_to_dict(format_info):\n    \"\"\"\n    Convert a format string to a dict.\n    \"\"\"\n    return format_info.func(format_info.input_format)\n\ndef format_to_lxml(format_info):\n    \"\"\"\n    Convert a format string to an lxml Element.\n    \"\"\"\n    return format_info.serializer(format_info.func(format_info.input_format))\n\ndef format_to_json(format_info):\n    \"\"\"\n    Convert a format string to a JSON dict.\n    \"\"\"\n    return format_info.serializer(format_info.func(format_info.input_format))\n\ndef format_to_json_dict(format_info):\n    \"\"\"\n    Convert a format string to a JSON dict.\n    \"\"\"\n    return format_info.serializer(format_info.func(format_info",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef convert_lsstdoc_tex(tex, format, mathjax=False, smart=True,\n                       extra_args=None):\n    \"\"\"Convert a LSTDoc document to a LaTeX document.\n\n    Parameters\n    ----------\n    tex : `str`\n        The LSTDoc document to convert.\n    format : `str`\n        The output format (such as ``'html5'`` or ``'plain'``).\n    mathjax : `bool`, optional\n        Allow pandoc to use MathJax math markup.\n    smart : `True`, optional\n        Allow pandoc to create \"smart\" unicode punctuation.\n    extra_args : `list`, optional\n        Additional command line flags to pass to Pandoc. See\n        `lsstprojectmeta.pandoc.convert.convert_text`.\n\n    Returns\n    -------\n    output_text : `str`\n        Converted content.\n    \"\"\"\n    if format == 'html5':\n        return convert_lsstdoc_html5(tex, mathjax=mathjax, smart=smart,\n                                   extra_args=extra_args)\n    elif format == 'plain':\n        return convert_lsstdoc_plain(tex, mathjax=mathjax, smart=smart,\n                                   extra_args=extra_args)",
        "\n\ndef convert_lsstdoc_tex(title, format, deparagraph=True, mathjax=False,\n                       smart=True, extra_args=None):\n    \"\"\"Convert the document title to a LaTeX document.\n\n    Parameters\n    ----------\n    title : `str`\n        The document title to convert.\n    format : `str`\n        The output format (such as ``'html5'`` or ``'plain'``).\n    deparagraph : `bool`\n        Remove the paragraph tags from single paragraph content.\n    mathjax : `bool`\n        Allow pandoc to use MathJax math markup.\n    smart : `True`\n        Allow pandoc to create \"smart\" unicode punctuation.\n    extra_args : `list`\n        Additional command line flags to pass to Pandoc. See\n        `lsstprojectmeta.pandoc.convert.convert_text`.\n\n    Returns\n    -------\n    output_text : `str`\n        Converted content or `None` if the title is not available in\n        the document.\n    \"\"\"\n    if title is None:\n        return None\n\n    if format == 'html5':\n        return convert_lsstdoc_html5(title, deparagraph, mathjax, smart,\n                                    extra_args=extra_args)",
        "\n\ndef convert_lsstdoc_tex(text, format='html5', deparagraph=True,\n                        mathjax=False, smart=True, extra_args=None):\n    \"\"\"Convert a document to a LaTeX document.\n\n    Parameters\n    ----------\n    text : `str`\n        The document to convert.\n    format : `str`\n        The output format (such as ``'html5'`` or ``'plain'``).\n    deparagraph : `bool`, optional\n        Remove the paragraph tags from single paragraph content.\n    mathjax : `bool`, optional\n        Allow pandoc to use MathJax math markup.\n    smart : `True`, optional\n        Allow pandoc to create \"smart\" unicode punctuation.\n    extra_args : `list`, optional\n        Additional command line flags to pass to Pandoc. See\n        `lsstprojectmeta.pandoc.convert.convert_text`.\n\n    Returns\n    -------\n    output_text : `str`\n        Converted content or `None` if the document is not available in\n        the document.\n    \"\"\"\n    if text is None:\n        return None\n\n    if format == 'html5':\n        return convert_lsstdoc_html5(text, deparagraph, mathjax, smart,\n                                    extra_args",
        "\n\ndef convert_lsstdoc_tex(abstract_latex, format, deparagraph=False,\n                        mathjax=False, smart=True, extra_args=None):\n    \"\"\"Convert the document abstract to a LaTeX document.\n\n    Parameters\n    ----------\n    abstract_latex : `str`\n        The LaTeX document to convert.\n    format : `str`\n        The output format (such as ``'html5'`` or ``'plain'``).\n    deparagraph : `bool`, optional\n        Remove the paragraph tags from single paragraph content.\n    mathjax : `bool`, optional\n        Allow pandoc to use MathJax math markup.\n    smart : `True`, optional\n        Allow pandoc to create \"smart\" unicode punctuation.\n    extra_args : `list`, optional\n        Additional command line flags to pass to Pandoc. See\n        `lsstprojectmeta.pandoc.convert.convert_text`.\n\n    Returns\n    -------\n    output_text : `str`\n        The LaTeX document converted.\n    \"\"\"\n    if format == 'html5':\n        return convert_html5_latex(abstract_latex, deparagraph, mathjax, smart,\n                                   extra_args=extra_args)\n    elif format == 'plain':\n        return convert_plain",
        "\n\ndef convert_lsstdoc_tex(self, author, format, deparagraph=True,\n                       mathjax=False, smart=True, extra_args=None):\n    \"\"\"Convert the document authors to a text representation in the specified\n    output markup format.\n\n    Parameters\n    ----------\n    author : `str`\n        Author name.\n    format : `str`\n        Output format (such as ``'html5'`` or ``'plain'``).\n    deparagraph : `bool`, optional\n        Remove the paragraph tags from single paragraph content.\n    mathjax : `bool`, optional\n        Allow pandoc to use MathJax math markup.\n    smart : `True`, optional\n        Allow pandoc to create \"smart\" unicode punctuation.\n    extra_args : `list`, optional\n        Additional command line flags to pass to Pandoc. See\n        `lsstprojectmeta.pandoc.convert.convert_text`.\n\n    Returns\n    -------\n    output_text : `str`\n        Text representation of the document authors.\n    \"\"\"\n    if format == 'html5':\n        return '<a href=\"http://www.mathjax.org/mathjax/latest/MathJax.html\">' + author + '</a>'\n    elif format == 'plain':\n        return author\n    else:",
        "\n\n        try:\n            content = parsed['class_name']\n            self._document_class_name = content.strip()\n        except KeyError:\n            self._logger.warning('lsstdoc has no documentclass name')\n            self._document_class_name = ''\n\n\ndef _parse_documentclass_name(self):\n        \"\"\"Parse documentclass name.\n\n        Sets the the ``_document_class_name`` attribute.\n        \"\"\"\n        command = LatexCommand(\n            'documentclass_name',\n            {'name': 'name', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no documentclass name')\n            self._document_class_name = ''\n\n        try:\n            content = parsed['name']\n            self._document_class_name = content.strip()\n        except KeyError:\n            self._logger.warning('lsstdoc has no documentclass name')\n            self._document_class_name = ''\n\n\ndef _parse_documentclass_options(self):\n        \"\"\"Parse documentclass options.\n\n        Sets the the ``_document_class_options`` attribute.\n        \"\"\"\n        command = LatexCommand(\n           ",
        "\n\n\ndef _parse_author(self):\n        \"\"\"Parse the author from TeX source.\n\n        Sets these attributes:\n\n        - ``_author``\n        - ``_email``\n        - ``_url``\n        - ``_name``\n        - ``_website``\n        - ``_website_url``\n        - ``_website_name``\n        - ``_website_website``\n        - ``_website_website_url``\n        - ``_website_website_name``\n        - ``_website_website_website``\n        - ``_website_website_website_url``\n        - ``_website_website_website_name``\n        - ``_website_website_website_website``\n        - ``_website_website_website_website_url``\n        - ``_website_website_website_website_name``\n        - ``_website_website_website_website_website``\n        - ``_website_website_website_website_url``\n        - ``_website_website_website_website_name``\n        - ``_website_website_website_website_website``\n        - ``_website_website_website_website_url``\n        - ``_website_website_website_website_name``\n        - ``_website_website_website_website_website``",
        "\n\n\ndef _parse_series(self):\n        \"\"\"Parse the series.\n\n        Sets the ``_series`` attribute.\n        \"\"\"\n        command = LatexCommand(\n            'setSeries',\n            {'name': 'series', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no setSeries')\n            self._series = None\n            return\n\n        self._series = parsed['series']\n\n\ndef _parse_serial(self):\n        \"\"\"Parse the serial.\n\n        Sets the ``_serial`` attribute.\n        \"\"\"\n        command = LatexCommand(\n            'setSerial',\n            {'name': 'serial', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no setSerial')\n            self._serial = None\n            return\n\n        self._serial = parsed['serial']\n\n\ndef _parse_handle(self):\n        \"\"\"Parse the handle.\n\n        Sets the ``_handle`` attribute.\n        \"\"\"\n        command = LatexCommand(\n            'setHandle',\n            {'name':",
        "\n\ndef _parse_copyright(self):\n        r\"\"\"Parse the copyright from TeX source.\n\n        Sets the ``_copyright`` attribute.\n\n        Goal is to parse::\n\n           \\copyright{\n           Copyright,\n           and\n           C.~Copyright}\n\n        Into::\n\n           ['Copyright', 'C. Copyright']\n        \"\"\"\n        command = LatexCommand(\n            'copyright',\n            {'name': 'copyright', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no copyright')\n            self._copyright = ''\n            return\n\n        try:\n            content = parsed['copyright']\n        except KeyError:\n            self._logger.warning('lsstdoc has no copyright')\n            self._copyright = ''\n            return\n\n        # Clean content\n        content = content.replace('\\n', ' ')\n        content = content.replace('~', ' ')\n        content = content.strip()\n\n        # Split content into list of individual copyrights\n        copyrights = []\n        for part in content.split(','):\n            part = part.strip()\n            for split_part in part.split('and '):\n                split",
        "\n\ndef _parse_author(self):\n        \"\"\"Parse the author from the TeX source.\n\n        Sets the ``_author`` attribute.\n        \"\"\"\n        command = LatexCommand(\n            'setDocAuthor',\n            {'name': 'author', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no author')\n            self._author = None\n            return\n\n        try:\n            content = parsed['author']\n        except KeyError:\n            self._logger.warning('lsstdoc has no author')\n            self._author = None\n            return\n\n        content = content.strip()\n        self._author = content\n\n\ndef _parse_copyright(self):\n        \"\"\"Parse the copyright from the TeX source.\n\n        Sets the ``_copyright`` attribute.\n        \"\"\"\n        command = LatexCommand(\n            'setDocCopyright',\n            {'name': 'copyright', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(self._tex))\n        except StopIteration:\n            self._logger.warning('lsstdoc has no copyright')\n            self._copyright = None\n            return\n\n        try",
        "\n\ndef _prep_snippet_for_latex(self, latex_text):\n        \"\"\"Process a LaTeX snippet of content for better transformation with\n        latex.\n\n        Currently runs the CitationLinker to convert BibTeX citations to\n        href links.\n        \"\"\"\n        replace_cite = CitationLinker(self.bib_db)\n        latex_text = replace_cite(latex_text)\n        return latex_text\n\ndef _prep_snippet_for_html(self, latex_text):\n        \"\"\"Process a LaTeX snippet of content for better transformation with\n        html.\n\n        Currently runs the CitationLinker to convert BibTeX citations to\n        href links.\n        \"\"\"\n        replace_cite = CitationLinker(self.bib_db)\n        latex_text = replace_cite(latex_text)\n        return latex_text\n\ndef _prep_snippet_for_html_with_pandoc(self, latex_text):\n        \"\"\"Process a LaTeX snippet of content for better transformation with\n        html with pandoc.\n\n        Currently runs the CitationLinker to convert BibTeX citations to\n        href links.\n        \"\"\"\n        replace_cite = CitationLinker(self.bib_",
        "\n\n    def _load_bib_db_from_file(self, bib_file):\n        r\"\"\"Load the BibTeX bibliography referenced by the document.\n\n        This method triggered by the `bib_db` attribute and populates the\n        `_bib_db` private attribute.\n\n        The ``\\bibliography`` command is parsed to identify the bibliographies\n        referenced by the document.\n        \"\"\"\n        # Get the names of custom bibtex files by parsing the\n        # \\bibliography command and filtering out the default lsstdoc\n        # bibliographies.\n        command = LatexCommand(\n            'bibliography',\n            {'name': 'bib_names', 'required': True, 'bracket': '{'})\n        try:\n            parsed = next(command.parse(bib_file))\n            bib_names = [n.strip() for n in parsed['bib_names'].split(',')]\n        except StopIteration:\n            self._logger.warning('lsstdoc has no bibliography command')\n            bib_names = []\n        custom_bibs = []\n        for custom_bib_name in custom_bib_names:\n            custom_bib_path = os.path.join(\n                os.path.",
        "\n        self._revision_datetime_source = 'git'\n\n\ndef _parse_revision_datetime(self):\n        r\"\"\"Parse the ``\\date`` command, falling back to getting the most recent\n        Git commit date and the current datetime.\n\n        Result is available from the `revision_datetime` attribute.\n        \"\"\"\n        doc_datetime = None\n\n        # First try to parse the \\date command in the latex.\n        # \\date is ignored for draft documents.\n        if not self.is_draft:\n            date_command = LatexCommand(\n                'date',\n                {'name': 'content', 'required': True, 'bracket': '{'})\n            try:\n                parsed = next(date_command.parse(self._tex))\n                command_content = parsed['content'].strip()\n            except StopIteration:\n                command_content = None\n                self._logger.warning('lsstdoc has no date command')\n\n            # Try to parse a date from the \\date command\n            if command_content is not None and command_content != r'\\today':\n                try:\n                    doc_datetime = datetime.datetime.strptime(command_content,\n                                                              '%Y-%m-%d')\n                    # Assume LSST project time (Pacific)\n                    project_tz = timezone('US/Pacific",
        "\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef connect(self, host, port, user, password, timeout=5):\n        \"\"\"Connect to a database server.\"\"\"\n        self._connect_args['host'] = host\n        self._connect_args['port'] = port\n        self._connect_args['user'] = user\n        self._connect_args['password'] = password\n        self._connect_args['timeout'] = timeout\n        return self\n\ndef disconnect(self):\n        \"\"\"Disconnect from a database server.\"\"\"\n        self._connect_args['host'] = None\n        self._connect_args['port'] = None\n        self._connect_args['user'] = None\n        self._connect_args['password'] = None\n        return self\n\ndef execute(self, query, args=None, timeout=5):\n        \"\"\"Execute a query on a database server.\"\"\"\n        self._connect_args['query'] = query\n        self._connect_args['args'] = args\n        self._connect_args['timeout'] = timeout\n        return self\n\ndef execute_batch(self, queries, args=None, timeout=5):\n        \"\"\"Execute a batch of queries on a database server.\"\"\"\n        self._connect_args['queries'] = queries\n        self._connect_args['args'] = args\n        self._connect_args['timeout'] = timeout\n        return",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef settings_by_name(name):\n        \"\"\"Returns settings by name.\"\"\"\n        stmt = \"select {fields} from pg_settings where name = {name}\".format(fields=', '.join(SETTINGS_FIELDS))\n        settings = []\n        for row in self._iter_results(stmt):\n            settings.append(Settings(**row))\n        return settings\n\ndef settings_by_vartype(vartype):\n        \"\"\"Returns settings by vartype.\"\"\"\n        stmt = \"select {fields} from pg_settings where vartype = {vartype}\".format(fields=', '.join(SETTINGS_FIELDS))\n        settings = []\n        for row in self._iter_results(stmt):\n            settings.append(Settings(**row))\n        return settings\n\ndef settings_by_setting(setting):\n        \"\"\"Returns settings by setting.\"\"\"\n        stmt = \"select {fields} from pg_settings where setting = {setting}\".format(fields=', '.join(SETTINGS_FIELDS))\n        settings = []\n        for row in self._iter_results(stmt):\n            settings.append(Settings(**row))\n        return settings\n\ndef settings_by_vartype_and_setting(vartype, setting):\n        \"\"\"Returns settings by vartype and setting.\"\"\"\n        stmt = \"select {fields} from pg_settings where vartype",
        "\n\ndef breakfast_shout(self, message=\"Breakfast is ready\", shout: bool = False):\n        \"\"\"Say something in the morning\"\"\"\n        return self.helper.output(message, shout)\n\ndef breakfast_shout_shout(self, message=\"Breakfast is ready\", shout: bool = False):\n        \"\"\"Say something in the morning\"\"\"\n        return self.helper.output(message, shout)\n\ndef breakfast_shout_shout_shout(self, message=\"Breakfast is ready\", shout: bool = False):\n        \"\"\"Say something in the morning\"\"\"\n        return self.helper.output(message, shout)\n\ndef breakfast_shout_shout_shout(self, message=\"Breakfast is ready\", shout: bool = False):\n        \"\"\"Say something in the morning\"\"\"\n        return self.helper.output(message, shout)\n\ndef breakfast_shout_shout_shout_shout(self, message=\"Breakfast is ready\", shout: bool = False):\n        \"\"\"Say something in the morning\"\"\"\n        return self.helper.output(message, shout)\n\ndef breakfast_shout_shout_shout_shout(self, message=\"Breakfast is",
        ".helper.output(\"Time for lunch\", shout)\n\ndef lunch_with_shout(self, message=\"Time for lunch\", shout: bool = False):\n        \"\"\"Say something in the afternoon\"\"\"\n        return self.helper.output(message, shout)\n\ndef lunch_with_shout_with_message(self, message=\"Time for lunch\", shout: bool = False):\n        \"\"\"Say something in the afternoon\"\"\"\n        return self.helper.output(message, shout, message)\n\ndef lunch_with_shout_with_message_with_shout(self, message=\"Time for lunch\", shout: bool = False):\n        \"\"\"Say something in the afternoon\"\"\"\n        return self.helper.output(message, shout, message, shout)\n\ndef lunch_with_shout_with_message_with_shout_with_message(self, message=\"Time for lunch\", shout: bool = False):\n        \"\"\"Say something in the afternoon\"\"\"\n        return self.helper.output(message, shout, message, shout, message)\n\ndef lunch_with_shout_with_message_with_shout_with_message_with_shout(self",
        "\n\ndef dinner_shout(self, message=\"Dinner is served\", shout: bool = False):\n        \"\"\"Say something in the evening\"\"\"\n        return self.helper.output(message, shout)\n\ndef dinner_shout_shout(self, message=\"Dinner is served\", shout: bool = False):\n        \"\"\"Say something in the evening\"\"\"\n        return self.helper.output(message, shout, shout)\n\ndef dinner_shout_shout_shout(self, message=\"Dinner is served\", shout: bool = False):\n        \"\"\"Say something in the evening\"\"\"\n        return self.helper.output(message, shout, shout, shout)\n\ndef dinner_shout_shout_shout_shout(self, message=\"Dinner is served\", shout: bool = False):\n        \"\"\"Say something in the evening\"\"\"\n        return self.helper.output(message, shout, shout, shout, shout)\n\ndef dinner_shout_shout_shout_shout(self, message=\"Dinner is served\", shout: bool = False):\n        \"\"\"Say something in the evening\"\"\"\n        return self.helper.output(message, shout, shout, sh",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\n\ndef get_ltd_product(session, url):\n    \"\"\"Get the LTD product data from the LTD Keeper API.\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n    url : `str`\n        URL of the technote's product resource in the LTD Keeper API.\n\n    Returns\n    -------\n    product_data : `dict`\n        JSON-LD-formatted dictionary.\n\n    .. `GitHub personal access token guide`: https://ls.st/41d\n    \"\"\"\n    logger = logging.getLogger(__name__)\n\n    try:\n        response = await session.get(url)\n        return await response.json()\n    except Exception:\n        logger.exception('Unexpected error trying to get %s', url)\n        return\n\n\nDOCUMENT_HANDLE_PATTERN = re.compile(r'/metadata.jsonld')\n",
        "\n",
        "\n\n\ndef create_jwt(integration_id, private_key_path):\n    \"\"\"Create a GitHub JWT for an integration.\n\n    Parameters\n    ----------\n    integration_id : `int`\n        Integration ID. This is available in the URL of the integration's\n        **installation** ID.\n    private_key_path : `bytes`\n        The integration's JSON Web Token (JWT). You can create this with\n        `create_jwt`.\n\n    Returns\n    -------\n    jwt_obj : `dict`\n        GitHub JWT object. Includes the fields:\n\n        - ``token``: the token string itself.\n        - ``expires_at``: date time string when the token expires.\n\n    Example\n    -------\n    The typical workflow for authenticating to an integration is:\n\n    .. code-block:: python\n\n       from dochubadapter.github import auth\n       jwt = auth.create_jwt(integration_id, private_key_path)\n       print(jwt_obj['token'])\n\n    Notes\n    -----\n    See\n    https://developer.github.com/early-access/integrations/authentication/#as-an-installation\n    for more information\n    \"\"\"\n    api_root = 'https://api.github.com'\n    url = '{root}/installations/{",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef get_def_macros(tex_source):\n    r\"\"\"Get all macro definitions from TeX source, supporting multiple\n    declaration patterns.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source content.\n\n    Returns\n    -------\n    macros : `dict`\n        Keys are macro names (including leading ``\\``) and values are the\n        content (as `str`) of the macros.\n\n    Notes\n    -----\n    This function uses the following function to scrape macros of different\n    types:\n\n    - `get_def_macro`\n    - `get_newcommand_macro`\n\n    This macro scraping has the following caveats:\n\n    - Macro definition (including content) must all occur on one line.\n    - Macros with arguments are not supported.\n    \"\"\"\n    macros = {}\n    macros['def'] = get_def_macro(tex_source)\n    macros['newcommand'] = get_newcommand_macro(tex_source)\n    return macros\n\ndef get_def_macro(tex_source):\n    r\"\"\"Get all macro definitions from TeX source, supporting multiple\n    declaration patterns.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source content.\n\n    Returns\n",
        "\n\ndef get_def_macro_names(tex_source):\n    r\"\"\"Get all ``\\def`` macro names from TeX source.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source content.\n\n    Returns\n    -------\n    macro_names : `list`\n        Keys are macro names (including leading ``\\``) and values are the\n        content (as `str`) of the macros.\n\n    Notes\n    -----\n    ``\\def`` macros with arguments are not supported.\n    \"\"\"\n    macro_names = []\n    for match in DEF_PATTERN.finditer(tex_source):\n        macro_names.append(match.group('name'))\n    return macro_names\n\ndef get_def_macro_content(tex_source, macro_name):\n    r\"\"\"Get all ``\\def`` macro content from TeX source.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source content.\n    macro_name : `str`\n        Macro name.\n\n    Returns\n    -------\n    macro_content : `str`\n        Macro content.\n\n    Notes\n    -----\n    ``\\def`` macros with arguments are not supported.\n    \"\"\"\n    macro_content = None\n    for match in DEF_PATTERN.",
        "\n",
        "\n\ndef load_module(module_name):\n    \"\"\"Try to load and return a module\n\n    Will add DIRECTORY_NAME to sys.path and tries to import MODULE_NAME.\n\n    For example:\n    load_module(\"yaz_extension\")\n    \"\"\"\n    return importlib.import_module(module_name)\n\ndef load_module_from_path(module_name):\n    \"\"\"Try to load and return a module\n\n    Will add DIRECTORY_NAME to sys.path and tries to import MODULE_NAME.\n\n    For example:\n    load_module_from_path(\"~/.yaz\")\n    \"\"\"\n    directory_name = os.path.expanduser(os.path.expandvars(module_name))\n    if os.path.isdir(directory_name) and directory_name not in sys.path:\n        sys.path.append(directory_name)\n\n    try:\n        return importlib.import_module(module_name)\n    except ImportError:\n        pass\n\ndef load_module_from_path_with_extension(module_name, extension):\n    \"\"\"Try to load and return a module\n\n    Will add DIRECTORY_NAME to sys.path and tries to import MODULE_NAME.\n\n    For example:\n    load_module_from_path_with_extension",
        "\n\ndef make_aware_utc(value, timezone):\n    \"\"\"\n    Makes a naive datetime.datetime in a given time zone aware.\n    \"\"\"\n    if hasattr(timezone, 'localize') and value not in (datetime.datetime.min, datetime.datetime.max):\n        # available for pytz time zones\n        return timezone.localize(value, is_dst=None)\n    else:\n        # may be wrong around DST changes\n        return value.replace(tzinfo=timezone)\n\ndef make_aware_local(value, timezone):\n    \"\"\"\n    Makes a naive datetime.datetime in a given time zone aware.\n    \"\"\"\n    if hasattr(timezone, 'localize') and value not in (datetime.datetime.min, datetime.datetime.max):\n        # available for pytz time zones\n        return timezone.localize(value, is_dst=None)\n    else:\n        # may be wrong around DST changes\n        return value.replace(tzinfo=timezone)\n\ndef make_aware_local_utc(value, timezone):\n    \"\"\"\n    Makes a naive datetime.datetime in a given time zone aware.\n    \"\"\"\n    if hasattr(timezone, 'localize') and value not in (datetime.datetime.min, datetime.datetime.max):\n        # available for pytz time zones",
        "\n\ndef make_aware(value, timezone):\n    \"\"\"\n    Makes an aware datetime.datetime naive in a given time zone.\n    \"\"\"\n    value = make_naive(value, timezone)\n    return value.replace(tzinfo=None)\n\ndef make_aware_utc(value, timezone):\n    \"\"\"\n    Makes an aware datetime.datetime naive in a given time zone.\n    \"\"\"\n    value = make_naive(value, timezone)\n    return value.replace(tzinfo=None)\n\ndef make_aware_local(value, timezone):\n    \"\"\"\n    Makes an aware datetime.datetime naive in a given time zone.\n    \"\"\"\n    value = make_naive(value, timezone)\n    return value.replace(tzinfo=None)\n\ndef make_aware_local_utc(value, timezone):\n    \"\"\"\n    Makes an aware datetime.datetime naive in a given time zone.\n    \"\"\"\n    value = make_naive(value, timezone)\n    return value.replace(tzinfo=None)\n\ndef make_aware_local_local(value, timezone):\n    \"\"\"\n    Makes an aware datetime.datetime naive in a given time zone.\n    \"\"\"\n    value = make_naive(value, timezone)\n    return value.replace(tzinfo",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_next_interval(self, after=None):\n    \"\"\"Returns the next Period this event is in effect, or None if the event\n    has no remaining periods.\"\"\"\n    return next(self.intervals(range_start=after), None)\n\ndef get_next_interval_for_date(self, date):\n    \"\"\"Returns the next Period this event is in effect, or None if the event\n    has no remaining periods.\"\"\"\n    return next(self.intervals(range_start=date), None)\n\ndef get_next_interval_for_date_range(self, date, start, end):\n    \"\"\"Returns the next Period this event is in effect, or None if the event\n    has no remaining periods.\"\"\"\n    return next(self.intervals(range_start=date, range_end=end), None)\n\ndef get_next_interval_for_date_range_end(self, date, start, end):\n    \"\"\"Returns the next Period this event is in effect, or None if the event\n    has no remaining periods.\"\"\"\n    return next(self.intervals(range_start=date, range_end=end), None)\n\ndef get_next_interval_for_date_range_start(self, date, start):\n    \"\"\"Returns the next Period this event is in effect, or None if",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n        # If we're at the end of the event, we're done.\n        if self.end == datetime.datetime.max:\n            return\n\n        # If we're at the start of the event, we're done.\n        if self.start == datetime.datetime.min:\n            return\n\n        # If we're at the beginning of the event, we're done.\n        if self.start == self.end:\n            return\n\n        # If we're at the beginning of the event, we're done.\n        if self.start < self.start:\n            return\n\n        # If we're at the beginning of the event, we're done.\n        if self.start > self.end:\n            return\n\n        # If we're at the beginning of the event, we're done.\n        if self.start < self.start:\n            return\n\n        # If we're at the beginning of the event, we're done.\n        if self.start > self.end:\n            return\n\n        # If we're at the beginning of the event, we're done.\n        if self.start < self.start:\n            return\n\n        # If we're at the beginning of the event, we're done.\n        if self.start > self.end:\n            return\n\n        # If we're",
        " False\n\ndef includes_period(self, query_date, query_time=None):\n        \"\"\"Does this schedule include the provided time?\n        query_date and query_time are date and time objects, interpreted\n        in this schedule's timezone\"\"\"\n\n        if self.start_date and query_date < self.start_date:\n            return False\n        if self.end_date and query_date > self.end_date:\n            return False\n        if query_date.weekday() not in self.weekdays:\n            return False\n\n        if not query_time:\n            return True\n\n        if query_time >= self.period.start and query_time <= self.period.end:\n            return True\n\n        return False\n\ndef includes_all(self, query_date, query_time=None):\n        \"\"\"Does this schedule include the provided time?\n        query_date and query_time are date and time objects, interpreted\n        in this schedule's timezone\"\"\"\n\n        if self.start_date and query_date < self.start_date:\n            return False\n        if self.end_date and query_date > self.end_date:\n            return False\n        if query_date.weekday() not in self.weekdays:\n            return False\n\n        if not query_time",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef weekdays_in_month(self, month):\n        \"\"\"A set of integers representing the weekdays the schedule recurs on,\n        with Monday = 0 and Sunday = 6.\"\"\"\n        if not self.root.xpath('days'):\n            return set(range(7))\n        return set(int(d) - 1 for d in self.root.xpath('days/day/text()'))\n\ndef weekdays_in_year(self, year):\n        \"\"\"A set of integers representing the weekdays the schedule recurs on,\n        with Monday = 0 and Sunday = 6.\"\"\"\n        if not self.root.xpath('days'):\n            return set(range(7))\n        return set(int(d) - 1 for d in self.root.xpath('days/day/text()'))\n\ndef weekdays_in_weekday(self, weekday):\n        \"\"\"A set of integers representing the weekdays the schedule recurs on,\n        with Monday = 0 and Sunday = 6.\"\"\"\n        if not self.root.xpath('days'):\n            return set(range(7))\n        return set(int(d) - 1 for d in self.root.xpath('days/day/text()'))\n\ndef weekdays_in_weekday_in_month(self, weekday,",
        "\n        db.drop(name)\n\n\ndef temp_name():\n    \"\"\"\n    A temporary name for the database.\n\n    Useful for automated tests.\n\n    Returns\n    -------\n    str\n        a unique name for the database.\n    \"\"\"\n    return 'temp_' + str(uuid.uuid4())\n\n\ndef create_db(db, name=None):\n    \"\"\"\n    Create a database.\n\n    Useful for automated tests.\n\n    Parameters\n    ----------\n    db: object\n        a preconfigured DB object\n    name: str, optional\n        name of the database to be created. (default: globally unique name)\n    \"\"\"\n    if name is None:\n        name = temp_name()\n    db.create(name)\n    if not db.exists(name):\n        raise DatabaseError('failed to create database %s!')\n    try:\n        yield name\n    finally:\n        db.drop(name)\n        if db.exists(name):\n            raise DatabaseError('failed to drop database %s!')\n\n\ndef drop_db(db, name=None):\n    \"\"\"\n    Drop a database.\n\n    Useful for automated tests.\n\n    Parameters\n    ----------\n    db: object\n        a preconfigured DB object\n    name: str, optional",
        "\n\n\nasync def _download_file(url, session):\n    \"\"\"Asynchronously request a URL and get the encoded file content of the\n    body.\n\n    Parameters\n    ----------\n    url : `str`\n        URL to download.\n    session : `aiohttp.ClientSession`\n        An open aiohttp session.\n\n    Returns\n    -------\n    content : `str`\n        Content downloaded from the URL.\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    async with session.get(url) as response:\n        # aiohttp decodes the content to a Python string\n        logger.info('Downloading %r', url)\n        return await response.file()\n\n\nasync def _download_json(url, session):\n    \"\"\"Asynchronously request a URL and get the encoded JSON content of the\n    body.\n\n    Parameters\n    ----------\n    url : `str`\n        URL to download.\n    session : `aiohttp.ClientSession`\n        An open aiohttp session.\n\n    Returns\n    -------\n    content : `str`\n        Content downloaded from the URL.\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    async with session.get(url) as response:\n        # aiohttp decodes the content to a Python string\n        logger.info('Downloading %r",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef get_lsst_bibtex(bibtex_filenames=None):\n    \"\"\"Make a pybtex BibliographyData instance from standard lsst-texmf\n    bibliography files and user-supplied bibtex content.\n\n    Parameters\n    ----------\n    bibtex_filenames : sequence of `str`, optional\n        Names of lsst-texmf BibTeX files to include. For example:\n\n        .. code-block:: python\n\n           ['lsst', 'lsst-dm', 'refs', 'books', 'refs_ads']\n\n        Default is `None`, which includes all lsst-texmf bibtex files.\n\n    Returns\n    -------\n    bibtex_data : `pybtex.database.BibliographyData`\n        A pybtex bibliography database that includes all given sources:\n        lsst-texmf bibliographies and ``bibtex``.\n    \"\"\"\n    bibtex_data = {}\n    for bibtex_filename in bibtex_filenames:\n        bibtex_data[bibtex_filename] = get_bibliography(bibtex_filename)\n    return bibtex_data\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\n\nasync def reduce_technote_metadata(github_url, metadata_yaml, github_data,\n                                 ltd_product_data):\n    \"\"\"Reduce the metadata.yaml file for a Sphinx-based technote.\n\n    Parameters\n    ----------\n    github_url : `str`\n        The URL of the Sphinx-based technote.\n    metadata_yaml : `str`\n        The contents of ``metadata.yaml`` for this technote.\n    github_data : `dict`\n        Contents of ``metadata.yaml`` for this technote.\n    ltd_product_data : `dict`\n        Contents of ``metadata.yaml`` for this technote.\n\n    Returns\n    -------\n    metadata : `dict`\n        JSON-LD-formatted dictionary.\n\n    Raises\n    ------\n    NotSphinxTechnoteError\n        Raised when the LTD product cannot be interpreted as a Sphinx-based\n        technote project because it's missing a metadata.yaml file in its\n        GitHub repository. This implies that the LTD product *could* be of a\n        different format.\n\n    .. `GitHub personal access token guide`: https://ls.st/41d\n    \"\"\"\n    try:\n        metadata = await metadata_yaml.load(github_data)\n    except Exception as exception:\n",
        "\n\ndef parse_repo_slug_from_url(url):\n    \"\"\"Parse a GitHub repository slug from a URL.\n\n    Parameters\n    ----------\n    url : `str`\n        URL of the GitHub repository.\n\n    Returns\n    -------\n    repo_slug : `str`\n        The parsed GitHub repository slug.\n\n    \"\"\"\n    return parse_url(url).repo_slug\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef tzlocal(self):\n        \"\"\"Return the timezone. If none is set use system timezone\"\"\"\n        if not self._tzlocal:\n            self._tzlocal = tzlocal.get_localzone()\n        return self._tzlocal\n\ndef tzlocal_utc(self):\n        \"\"\"Return the timezone. If none is set use system timezone\"\"\"\n        if not self._tzlocal_utc:\n            self._tzlocal_utc = tzlocal.get_localzone()\n        return self._tzlocal_utc\n\ndef tzlocal_local(self):\n        \"\"\"Return the timezone. If none is set use system timezone\"\"\"\n        if not self._tzlocal_local:\n            self._tzlocal_local = tzlocal.get_localzone()\n        return self._tzlocal_local\n\ndef tzlocal_local_utc(self):\n        \"\"\"Return the timezone. If none is set use system timezone\"\"\"\n        if not self._tzlocal_local_utc:\n            self._tzlocal_local_utc = tzlocal.get_localzone()\n        return self._tzlocal_local_utc\n\ndef tzlocal_local_local(self):\n        \"\"\"Return the timezone. If none is set use system timezone\"\"\"\n        if not self._tzlocal_local_local:\n            self._tzlocal_local_local =",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;",
        "\n\ndef as_json(self):\n        \"\"\"Return a json representation of the DayOneEntry\"\"\"\n        entry_json = {}\n        entry_json['UUID'] = self.uuid\n        entry_json['Creation Date'] = self.time\n        entry_json['Time Zone'] = self.tz\n        if self.tags:\n            entry_json['Tags'] = self.tags\n        entry_json['Entry Text'] = self.text\n        entry_json['Starred'] = self.starred\n        entry_json['Location'] = self.location\n        return entry_json\n\nclass DayOneEntry(object):\n    \"\"\"\n    A DayOneEntry is a collection of entries that can be created and\n    updated.\n    \"\"\"\n    def __init__(self, uuid, time, tz, tags=None, text=None, starred=False, location=None):\n        \"\"\"\n        Initialize a DayOneEntry object.\n\n        :param uuid: The UUID of the DayOneEntry\n        :type uuid: str\n        :param time: The creation date of the DayOneEntry\n        :type time: datetime\n        :param tz: The time zone of the DayOneEntry\n        :type tz: str\n        :param tags: The list of tags associated with the DayOneEntry\n        :type tags: list\n        :",
        " True\n\ndef load(self, entry, with_location=True, debug=False):\n        \"\"\"Loads a DayOneEntry from a plist\"\"\"\n        entry_dict = {}\n        if isinstance(entry, DayOneEntry):\n            # Get a dict of the DayOneEntry\n            entry_dict = entry.as_dict()\n        else:\n            entry_dict = entry\n\n        # Set the UUID\n        entry_dict['UUID'] = uuid.uuid4().get_hex()\n        if with_location and not entry_dict['Location']:\n            entry_dict['Location'] = self.get_location()\n\n        # Do we have everything needed?\n        if not all ((entry_dict['UUID'], entry_dict['Time Zone'],\n                     entry_dict['Entry Text'])):\n            print \"You must provide: Time zone, UUID, Creation Date, Entry Text\"\n            return False\n\n        if debug is False:\n            file_path = self._file_path(entry_dict['UUID'])\n            plistlib.readPlist(entry_dict, file_path)\n        else:\n            plist = plistlib.readPlistToString(entry_dict)\n            print plist\n\n        return True\n\ndef get_location(self):\n        \"\"\"Returns the location of the DayOneEntry\"\"\"\n        return self",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef get_task_list(white_list=None):\n    \"\"\"Returns a list of Task instances\n\n    The list is comprised of dictionaries containing strings for\n    keys and either dictionaries or Task instances for values.\n\n    When WHITE_LIST is given, only the tasks and plugins in this\n    list will become part of the task list.  The WHITE_LIST may\n    contain either strings, corresponding to the task of plugin\n    __qualname__, or, preferable, the WHITE_LIST contains\n    links to the task function or plugin class instead.\n    \"\"\"\n    assert white_list is None or isinstance(white_list, list), type(white_list)\n\n    if white_list is not None:\n        white_list = set(item if isinstance(item, str) else item.__qualname__ for item in white_list)\n\n    return [task for task\n            in _task_list.values()\n            if white_list is None or task.qualified_name in white_list]\n\ndef get_plugin_list():\n    \"\"\"Returns a list of Plugin instances\n\n    The list is comprised of dictionaries containing strings for\n    keys and either dictionaries or Plugin instances for values.\n\n    When WHITE_LIST is given, only the tasks and plugins in this\n    list will become part of the plugin list",
        "\n\ndef task_class(cls):\n    \"\"\"Declare a class to be a Yaz task\n\n    @yaz.task\n    def talk(message: str = \"Hello World!\"):\n        return message\n\n    Or... group multiple tasks together\n\n    class Tools(yaz.Plugin):\n        @yaz.task\n        def say(self, message: str = \"Hello World!\"):\n            return message\n\n        @yaz.task(option__choices=[\"A\", \"B\", \"C\"])\n        def choose(self, option: str = \"A\"):\n            return option\n    \"\"\"\n    return cls\n\n\nclass Task(object):\n    \"\"\"Declare a function or method to be a Yaz task\n\n    @yaz.task\n    def talk(message: str = \"Hello World!\"):\n        return message\n\n    Or... group multiple tasks together\n\n    class Tools(yaz.Plugin):\n        @yaz.task\n        def say(self, message: str = \"Hello World!\"):\n            return message\n\n        @yaz.task(option__choices=[\"A\", \"B\", \"C\"])\n        def choose(self, option: str = \"A\"):\n            return option\n    \"\"\"\n    def __init__(self, plugin_class=None",
        "\n\n        # we didn't find any parameters, so we can't find any methods\n        raise RuntimeError(\"Task {} does not have a method with a valid signature\".format(self.func))\n\n\nclass BasePlugin(object):\n    \"\"\"Base class for plugins\"\"\"\n\n    def __init__(self, func):\n        self.func = func\n\n    def get_parameters(self):\n        \"\"\"Returns a list of parameters\"\"\"\n        return get_parameters(self.func)\n\n    def get_method(self):\n        \"\"\"Returns the method name\"\"\"\n        return self.func.__name__\n\n    def get_class(self):\n        \"\"\"Returns the class name\"\"\"\n        return self.__class__.__name__\n\n    def get_module(self):\n        \"\"\"Returns the module name\"\"\"\n        return self.__module__\n\n    def get_class_name(self):\n        \"\"\"Returns the class name\"\"\"\n        return self.__class__.__name__\n\n    def get_module_name(self):\n        \"\"\"Returns the module name\"\"\"\n        return self.__module__\n\n    def get_module_path(self):\n        \"\"\"Returns the module path\"\"\"\n        return self.__module__\n\n    def get_module_path_relative(self):\n        \"\"\"Returns the module path relative to the module path\"\"\"\n",
        "\n        return default\n\ndef get_configuration_list(self, key, default=None):\n        \"\"\"Returns the configuration for KEY\"\"\"\n        if key in self.config:\n            return self.config[key]\n        else:\n            return default\n\ndef get_configuration_dict(self, key, default=None):\n        \"\"\"Returns the configuration for KEY\"\"\"\n        if key in self.config:\n            return self.config[key]\n        else:\n            return default\n\ndef get_configuration_list_dict(self, key, default=None):\n        \"\"\"Returns the configuration for KEY\"\"\"\n        if key in self.config:\n            return self.config[key]\n        else:\n            return default\n\ndef get_configuration_dict_list(self, key, default=None):\n        \"\"\"Returns the configuration for KEY\"\"\"\n        if key in self.config:\n            return self.config[key]\n        else:\n            return default\n\ndef get_configuration_list_dict_list(self, key, default=None):\n        \"\"\"Returns the configuration for KEY\"\"\"\n        if key in self.config:\n            return self.config[key]\n        else:\n            return default\n\ndef get_configuration_list_dict_dict(self, key, default=None):\n        \"\"\"Returns the configuration",
        "\n\ndef get_plugin_list():\n    \"\"\"Returns a list of all registered plugins\"\"\"\n    return _yaz_plugin_list\n\ndef get_plugin_instance_cache():\n    \"\"\"Returns a cache of plugin instances\"\"\"\n    global _yaz_plugin_instance_cache\n    return _yaz_plugin_instance_cache\n\ndef get_plugin_list_by_name(name):\n    \"\"\"Returns a list of all registered plugins with a given name\"\"\"\n    return _yaz_plugin_list.get(name, {})\n\ndef get_plugin_instance_by_name(name):\n    \"\"\"Returns a plugin instance by name\"\"\"\n    return get_plugin_instance_cache.get(name, None)\n\ndef get_plugin_instance_by_qualname(qualname):\n    \"\"\"Returns a plugin instance by qualname\"\"\"\n    return get_plugin_instance_cache.get(qualname, None)\n\ndef get_plugin_instance_by_class(plugin_class):\n    \"\"\"Returns a plugin instance by class\"\"\"\n    return get_plugin_instance_by_name(plugin_class.__name__)\n\ndef get_plugin_instance_by_class_and_qualname(plugin_class, qualname):\n    \"\"\"Returns a plugin instance by class and qualname\"\"\"\n    return get",
        "\ndef _maybe_intify(text):\n    \"\"\"Convert a string to an int, or None if it's not an int.\"\"\"\n    try:\n        return int(text)\n    except ValueError:\n        return None\n\ndef gml_to_geojson(root):\n    \"\"\"Convert an Open511 GML document or document fragment to GeoJSON.\n\n    Takes an lxml Element object. Returns a dict ready to be JSON-serialized.\"\"\"\n    j = {}\n\n    if len(root) == 0:  # Tag with no children, return str/int\n        return _maybe_intify(root.text)\n\n    if len(root) == 1 and root[0].tag.startswith('{' + NS_GML):  # GML\n        return gml_to_geojson(root[0])\n\n    for elem in root:\n        name = elem.tag\n        if name == 'link' and elem.get('rel'):\n            name = elem.get('rel') + '_url'\n            if name == 'self_url':\n                name = 'url'\n            if root.tag == 'open511':\n                j['meta'][name] = elem.get('href')\n                continue\n        elif name.startswith('{' + NS_PROTECTED):\n            name = '!'",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef all_subclasses_with_self(cls):\n    \"\"\" Recursively generate of all the subclasses of class cls. \"\"\"\n    for subclass in cls.__subclasses__():\n        yield subclass\n        for subc in all_subclasses(subclass):\n            yield subc\n\ndef all_subclasses_with_self_and_self(cls):\n    \"\"\" Recursively generate of all the subclasses of class cls. \"\"\"\n    for subclass in cls.__subclasses__():\n        yield subclass\n        for subc in all_subclasses(subclass):\n            yield subc\n\ndef all_subclasses_with_self_and_self_and_self(cls):\n    \"\"\" Recursively generate of all the subclasses of class cls. \"\"\"\n    for subclass in cls.__subclasses__():\n        yield subclass\n        for subc in all_subclasses(subclass):\n            yield subc\n        for subc in all_subclasses(subclass):\n            yield subc\n\ndef all_subclasses_with_self_and_self_and_self_and_self(cls):\n    \"\"\" Recursively generate of all the subclasses of class cls. \"\"\"\n    for subclass in cls.__subclasses__():\n        yield subclass\n        for subc in all_subclasses(subclass):\n            yield subc\n        for subc in all_subclasses(subclass):",
        "\n    if key is None:\n        return iterable\n    else:\n        return [x for x in iterable if x[key] == key]\n\ndef unique_justseen_with_key(iterable, key=None):\n    \"List unique elements, preserving order. Remember only the element just seen with a given key.\"\n    # unique_justseen_with_key('AAAABBBCCDAABBB') --> A B C D A B\n    # unique_justseen_with_key('ABBCcAD', str.lower) --> A B C A D\n    try:\n        # PY2 support\n        from itertools import imap as map\n    except ImportError:\n        from builtins import map\n\n    return map(next, map(operator.itemgetter(1), itertools.groupby(iterable, key)))\n\ndef unique_justseen_with_key_and_value(iterable, key=None, value=None):\n    \"List unique elements, preserving order. Remember only the element just seen with a given key and value.\"\n    # unique_justseen_with_key_and_value('AAAABBBCCDAABBB') --> A B C D A B\n    # unique_justseen_with_key_and_value('ABBCcAD', str.lower) --> A B C A D\n    try:\n        #",
        "\n\ndef generic_masked_nan(arr, attrs=None, minv=None, maxv=None, mask_nan=True):\n    \"\"\"\n    Returns a masked array with anything outside of values masked.\n    The minv and maxv parameters take precendence over any dict values.\n    The valid_range attribute takes precendence over the valid_min and\n    valid_max attributes.\n    \"\"\"\n    attrs = attrs or {}\n\n    if 'valid_min' in attrs:\n        minv = safe_attribute_typing(arr.dtype, attrs['valid_min'])\n    if 'valid_max' in attrs:\n        maxv = safe_attribute_typing(arr.dtype, attrs['valid_max'])\n    if 'valid_range' in attrs:\n        vr = attrs['valid_range']\n        minv = safe_attribute_typing(arr.dtype, vr[0])\n        maxv = safe_attribute_typing(arr.dtype, vr[1])\n\n    if mask_nan is True:\n        arr = np.ma.fix_invalid(arr)\n\n    return np.ma.masked_outside(\n        arr,\n        minv,\n        maxv\n    )\n\ndef generic_masked_nan_nan(arr, attrs=None, minv",
        ".default(self, obj)\n\ndef default_dict(self, obj):\n        \"\"\"If input object is a dict it will be converted into a dict\n        \"\"\"\n        if isinstance(obj, dict):\n            return dict(obj.items())\n        # Let the base class default method raise the TypeError\n        return json.JSONEncoder(self, obj)\n\ndef default_list(self, obj):\n        \"\"\"If input object is a list it will be converted into a list\n        \"\"\"\n        if isinstance(obj, list):\n            return list(obj)\n        # Let the base class default method raise the TypeError\n        return json.JSONEncoder(self, obj)\n\ndef default_float(self, obj):\n        \"\"\"If input object is a float it will be converted into a float\n        \"\"\"\n        if isinstance(obj, float):\n            return obj\n        # Let the base class default method raise the TypeError\n        return json.JSONEncoder(self, obj)\n\ndef default_int(self, obj):\n        \"\"\"If input object is an int it will be converted into an int\n        \"\"\"\n        if isinstance(obj, int):\n            return obj\n        # Let the base class default method raise the TypeError\n        return json.JSONEncoder(self, obj)\n\ndef default_str(self, obj):\n        \"\"\"If input",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\ndef update_desc_rcin_path_n_cin(desc,sibs_len,pdesc_level):\n    '''\n        rightCousin\n        nextCousin\n        rightCin\n        nextCin\n        rcin\n        ncin\n        \n        parents are neighbors,and on the right\n    '''\n    psibs_len = pdesc_level.__len__()\n    parent_breadth = desc['parent_breadth_path'][-1]\n    if(desc['sib_seq']==(sibs_len - 1)):\n        if(parent_breadth==(psibs_len -1)):\n            pass\n        else:\n            parent_rsib_breadth = parent_breadth + 1\n            prsib_desc = pdesc_level[parent_rsib_breadth]\n            #because from left to right to handle each level\n            #sons_count will only be updated in the next-round \n            if(prsib_desc['leaf']):\n                pass\n            else:\n                rcin_path = copy.deepcopy(prsib_desc['path'])\n                rcin_path.append(0)\n                desc['rcin_path'] = rcin_path\n    else:\n        pass\n    return(desc)\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        '''\n            _upgrade_breadth_info\n            update breadth, breadth_path, and add desc to desc_level\n        '''\n        desc = self.desc\n        desc_level = scache.desc_level\n        breadth = desc_level.__len__()\n        desc['breadth'] = breadth\n        desc['breadth_path'].append(breadth)\n        desc_level.append(desc)\n\ndef child_start_handler(self,scache):\n        '''\n            _upgrade_breadth_info\n            update breadth, breadth_path, and add desc to desc_level\n        '''\n        desc = self.desc\n        desc_level = scache.desc_level\n        breadth = desc_level.__len__()\n        desc['breadth'] = breadth\n        desc['breadth_path'].append(breadth)\n        desc_level.append(desc)\n\ndef child_start_handler_with_desc(self,scache):\n        '''\n            _upgrade_breadth_info\n            update breadth, breadth_path, and add desc to desc_level\n        '''\n        desc = self.desc\n        desc_level = scache.desc_level\n        breadth = desc_level.__len__()\n        desc['breadth']",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\nclass CommandParserError(Exception):\n    \"\"\"Base class for all command parser errors.\"\"\"\n\n\nclass ParsedCommand(object):\n    \"\"\"A parsed command.\n\n    Parameters\n    ----------\n    name : `str`\n        The name of the command.\n    elements : `list`\n        The parsed elements.\n    start_index : `int`\n        The character index in ``elements`` where the command begins.\n    command_source : `str`\n        The full source of the tex document.\n    \"\"\"\n\n    def __init__(self, name, elements, start_index, command_source):\n        self.name = name\n        self.elements = elements\n        self.start_index = start_index\n        self.command_source = command_source\n\n    def __str__(self):\n        return 'Command {0} at index {1:d} with {2:d} elements'.format(\n            self.name, self.start_index, len(self.elements))\n\n\nclass ParsedCommandError(CommandParserError):\n    \"\"\"A parsed command error.\"\"\"\n\n\nclass ParsedCommandArgumentError(CommandParserError):\n    \"\"\"A parsed command argument error.\"\"\"\n\n\nclass ParsedCommandArgument(object):\n    \"\"\"A parsed command argument.\n\n    Parameters\n    ----------\n    name :",
        "\n\ndef _parse_command(source, name):\n        r\"\"\"Attempt to parse a single token on the first line of this source.\n\n        This method is used for parsing command-like syntax, like ``\\input file``\n        and ``\\input test.tex``. The source should ideally contain `` file`` along\n        with a newline character.\n\n        >>> source = 'Line 1\\n' r'\\input test.tex' '\\nLine 2'\n        >>> LatexCommand._parse_command(source, 'input')\n        'test.tex'\n\n        Bracket delimited arguments (``\\input{test.tex}``) are handled in\n        the normal logic of `_parse_command`.\n        \"\"\"\n        # First match the command name itself so that we find the argument\n        # *after* the command\n        command_pattern = r'\\\\(' + name + r')(?:[\\s{[%])'\n        command_match = re.search(command_pattern, source)\n        if command_match is not None:\n            # Trim `source` so we only look after the command\n            source = source[command_match.end(1):]\n\n        # Find the whitespace-delimited argument itself.\n        pattern = r'(?P<content>\\S+)(?:[ %\\t\\n]+)'\n        match",
        "\n\ndef list_from_xml(cls, xml):\n        \"\"\"Returns a list of TMDDEventConverter elements.\n\n        xml is an XML Element containing one or more <FEU> events\n        \"\"\"\n        objs = []\n        for feu in xml.xpath('//FEU'):\n            detail_els = feu.xpath('event-element-details/event-element-detail')\n            for idx, detail in enumerate(detail_els):\n                objs.append(cls(feu, detail, id_suffix=idx, number_in_group=len(detail_els)))\n        return objs\n\nclass TMDDEventConverter(object):\n    \"\"\"A class for converting TMDD events to XML.\n\n    This class is used to convert TMDD events to XML.\n    \"\"\"\n\n    def __init__(self, feu, detail, id_suffix=None, number_in_group=None):\n        \"\"\"Constructor.\n\n        feu is a TMDDEvent object\n        detail is a TMDDEventDetail object\n        id_suffix is a string to use for the id of the event\n        number_in_group is the number of events in the group\n        \"\"\"\n        self.feu = feu\n        self.detail = detail\n        self.id_suffix = id_suffix\n        self.number",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_type(value):\n    \"\"\" Returns the type of the value.\n        This is used to determine the type of the data.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return np.float64\n    elif isinstance(value, np.ma.core.MaskedConstant):\n        return np.float64\n    elif isinstance(value, np.ma.core.MaskedArray):\n        return np.float64\n    elif isinstance(value, np.ma.core.MaskedArraySlice):\n        return np.float64\n    elif isinstance(value, np.ma.core.MaskedArraySliceSlice):\n        return np.float64\n    elif isinstance(value, np.ma.core.MaskedArraySliceSliceSlice):\n        return np.float64\n    elif isinstance(value, np.ma.core.MaskedArraySliceSliceSliceSlice):\n        return np.float64\n    elif isinstance(value, np.ma.core.MaskedArraySliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSliceSlice",
        "\n\ndef load_from_file(cls, query_name, query_data):\n        \"\"\"Load a pre-made query from a file.\n\n        These queries are distributed with lsstprojectmeta. See\n        :file:`lsstrojectmeta/data/githubv4/README.rst` inside the\n        package repository for details on available queries.\n\n        Parameters\n        ----------\n        query_name : `str`\n            Name of the query, such as ``'technote_repo'``.\n        query_data : `str`\n            Query data.\n\n        Returns\n        -------\n        github_query : `GitHubQuery`\n            A GitHub query or mutation object that you can pass to\n            `github_request` to execute the request itself.\n        \"\"\"\n        template_path = os.path.join(\n            os.path.dirname(__file__),\n            'data/githubv4',\n            query_name + '.graphql')\n\n        with open(template_path) as f:\n            query_data = f.read()\n\n        return cls(query_data, name=query_name)\n\ndef load_from_string(cls, query_name, query_data):\n        \"\"\"Load a pre-made query from a string.\n\n        These queries are distributed with lsst",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\ndef _iter_filepaths_with_extension(extension, root_dir=None):\n    \"\"\"Iterate over all files with a given extension.\n\n    Parameters\n    ----------\n    extension : 'str'\n        The extension of the files to iterate over.\n    root_dir : 'str', optional\n        Only content contained within this root directory is considered.\n        This directory must be, or be contained by, a Git repository. This is\n        the current working directory by default.\n\n    Returns\n    -------\n    iter : iterable of 'str'\n        An iterable of paths to all files with the given extension.\n    \"\"\"\n    if root_dir is None:\n        root_dir = os.path.abspath(os.path.join(os.getcwd(), '.'))\n\n    # Cache the repo object for each query\n    root_dir = os.path.abspath(root_dir)\n    repo = git.repo.base.Repo(path=root_dir, search_parent_directories=True)\n\n    # Iterate over all files with all file extensions, looking for the\n    # newest commit datetime.\n    iters = [_iter_filepaths_with_extension(ext, root_dir=root_dir)\n             for ext in extension]\n\n    # Iterate over all files with all file extensions,",
        "\n\n\ndef _iter_filepaths_with_extension_and_root_dir(extname, root_dir='.'):\n    \"\"\"Iterative over relative filepaths of files in a directory, and\n    sub-directories, with the given extension and root directory.\n\n    Parameters\n    ----------\n    extname : `str`\n        Extension name (such as 'txt' or 'rst'). Extension comparison is\n        case sensitive.\n    root_dir : `str`, optional\n        Root directory. Current working directory by default.\n\n    Yields\n    ------\n    filepath : `str`\n        File path, relative to ``root_dir``, with the given extension and\n        root directory.\n    \"\"\"\n    # needed for comparison with os.path.splitext\n    if not extname.startswith('.'):\n        extname = '.' + extname\n\n    root_dir = os.path.abspath(root_dir)\n\n    for dirname, sub_dirnames, filenames in os.walk(root_dir):\n        for filename in filenames:\n            if os.path.splitext(filename)[-1] == extname:\n                full_filename = os.path.join(dirname, filename)\n                rel_filepath = os.path.relpath(full_filename, start=root_dir)\n                yield rel_filepath\n",
        "\n\ndef get_variables_by_attributes_with_grid_mapping(self, **kwargs):\n        \"\"\" Returns variables that match specific conditions.\n\n        * Can pass in key=value parameters and variables are returned that\n        contain all of the matches.  For example,\n\n        >>> # Get variables with x-axis attribute.\n        >>> vs = nc.get_variables_by_attributes_with_grid_mapping(axis='X')\n        >>> # Get variables with matching \"standard_name\" attribute.\n        >>> nc.get_variables_by_attributes_with_grid_mapping(standard_name='northward_sea_water_velocity')\n\n        * Can pass in key=callable parameter and variables are returned if the\n        callable returns True.  The callable should accept a single parameter,\n        the attribute value.  None is given as the attribute value when the\n        attribute does not exist on the variable. For example,\n\n        >>> # Get Axis variables.\n        >>> vs = nc.get_variables_by_attributes_with_grid_mapping(axis=lambda v: v in ['X', 'Y', 'Z', 'T'])\n        >>> # Get variables that don't have an \"axis\" attribute.\n        >>> vs = nc.get_variables_by_attributes_with_grid_mapping(axis=lambda",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n",
        "\n\ndef ensure_pandoc(content, from_fmt, to_fmt, deparagraph=False, mathjax=False,\n                  smart=True, extra_args=None):\n    \"\"\"Install Pandoc if it is not available.\n\n    This function is a thin wrapper around `pypandoc.ensure_pandoc`.\n\n    Parameters\n    ----------\n    content : `str`\n        Original content.\n\n    from_fmt : `str`\n        Format of the original ``content``. Format identifier must be one of\n        those known by Pandoc. See https://pandoc.org/MANUAL.html for details.\n\n    to_fmt : `str`\n        Output format for the content.\n\n    deparagraph : `bool`, optional\n        If `True`, then the\n        `lsstprojectmeta.pandoc.filters.deparagraph.deparagraph` filter is\n        used to remove paragraph (``<p>``, for example) tags around a single\n        paragraph of content. That filter does not affect content that\n        consists of multiple blocks (several paragraphs, or lists, for\n        example). Default is `False`.\n\n        For example, **without** this filter Pandoc will convert\n        the string ``\"Title text\"`` to ``\"<p>Title text</p>\"`` in",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef _decode_object_pairs(obj, key, value):\n    \"\"\"Decode a JSON-LD object into a dict.\n\n    Parameters\n    ----------\n    obj : `dict`\n        A JSON-LD object.\n    key : `str`\n        The key of the object.\n    value : `str`\n        The value of the object.\n\n    Returns\n    -------\n    dict : `dict`\n        A dict.\n    \"\"\"\n    if isinstance(value, datetime.datetime):\n        return {key: value}\n    return {key: value}\n",
        "\n\ndef _encode_datetime(obj):\n        \"\"\"Encode a datetime object as a JSON string.\n\n        This method overrides the default implementation from\n        `json.JSONEncoder`.\n        \"\"\"\n        return json.JSONEncoder.default(self, obj)\n\ndef _decode_datetime(self, obj):\n        \"\"\"Decode a JSON string into a datetime object.\n\n        This method overrides the default implementation from\n        `json.JSONDecoder`.\n        \"\"\"\n        return json.JSONDecoder.default(self, obj)\n\ndef _encode_list(self, obj):\n        \"\"\"Encode a list as a JSON string.\n\n        This method overrides the default implementation from\n        `json.JSONEncoder`.\n        \"\"\"\n        return json.JSONEncoder.default(self, obj)\n\ndef _decode_list(self, obj):\n        \"\"\"Decode a JSON string into a list.\n\n        This method overrides the default implementation from\n        `json.JSONDecoder`.\n        \"\"\"\n        return json.JSONDecoder.default(self, obj)\n\ndef _encode_dict(self, obj):\n        \"\"\"Encode a dict as a JSON string.\n\n        This method overrides the default implementation from\n        `json.JSONEncoder`.\n        \"\"\"\n        return json.JSONEncoder.default(self, obj)\n\ndef _decode_dict(self",
        "\n        return repos\n\ndef walk_dn(self, root, depth=10):\n        '''Walk the directory tree and return a list of (root, subdirs, files)'''\n\n        dirs = []\n\n        for root, subdirs, files in walk_dn(root, depth=depth):\n            if 'modules' in root:\n                continue\n            if '.git' in subdirs:\n                dirs.append((root, subdirs, files))\n\n        return dirs\n\ndef walk_dn_recursive(self, root, depth=10):\n        '''Walk the directory tree and return a list of (root, subdirs, files)'''\n\n        dirs = []\n\n        for root, subdirs, files in walk_dn_recursive(root, depth=depth):\n            if 'modules' in root:\n                continue\n            if '.git' in subdirs:\n                dirs.append((root, subdirs, files))\n\n        return dirs\n\ndef walk_dn_recursive_recursive(self, root, depth=10):\n        '''Walk the directory tree and return a list of (root, subdirs, files)'''\n\n        dirs = []\n\n        for root, subdirs, files in walk_dn_recursive_recursive(root, depth=depth):\n            if 'modules' in root:\n                continue\n           ",
        "\n        logger.debug('Done installing ' + package)\n\ndef uninstall(self, package):\n        '''Uninstall a python package using pip'''\n\n        logger.debug('Uninstalling ' + package)\n        shell.run(self.pip_path, 'uninstall', package)\n\ndef list_packages(self):\n        '''List all installed packages'''\n\n        logger.debug('Listing all installed packages')\n        shell.run(self.pip_path, 'list',  )\n\ndef list_packages_with_dependencies(self, package):\n        '''List all installed packages with dependencies'''\n\n        logger.debug('Listing all installed packages with dependencies')\n        shell.run(self.pip_path, 'list', package + ' > ' + package + '.json')\n\ndef list_packages_with_dependencies_and_dependencies(self, package):\n        '''List all installed packages with dependencies and dependencies'''\n\n        logger.debug('Listing all installed packages with dependencies and dependencies')\n        shell.run(self.pip_path, 'list', package + ' > ' + package + '.json', package + '.json')\n\ndef list_packages_with_dependencies_and_dependencies_and_dependencies(self, package):\n        '''List all installed packages with dependencies and dependencies and dependencies and dependencies'''\n\n        logger.debug('Listing all",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".fillna(0)\n    return res\n\ndef df_quantile_with_index(df, nb=100, index=False):\n    \"\"\"Returns the nb quantiles for datas in a dataframe\n    \"\"\"\n    quantiles = np.linspace(0, 1., nb)\n    res = pd.DataFrame()\n    for q in quantiles:\n        res = res.append(df.quantile(q, index=index), ignore_index=True)\n    return res\n\ndef df_quantile_with_index_with_index(df, nb=100, index=False, index_name='index'):\n    \"\"\"Returns the nb quantiles for datas in a dataframe\n    \"\"\"\n    quantiles = np.linspace(0, 1., nb)\n    res = pd.DataFrame()\n    for q in quantiles:\n        res = res.append(df.quantile(q, index=index, index_name=index_name), ignore_index=True)\n    return res\n\ndef df_quantile_with_index_with_index_with_index(df, nb=100, index=False, index_name='index', index_name_with_index=False):\n    \"\"\"Returns the nb quantiles for datas in a dataframe\n    \"\"\"\n    quantiles = np.linspace(",
        "\n\ndef rmse_2(a, b):\n    \"\"\"Returns the root mean square error betwwen a and b\n    \"\"\"\n    return np.sqrt(np.square(a - b).mean())\n\ndef rmse_3(a, b):\n    \"\"\"Returns the root mean square error betwwen a and b\n    \"\"\"\n    return np.sqrt(np.square(a - b).mean())\n\ndef rmse_4(a, b):\n    \"\"\"Returns the root mean square error betwwen a and b\n    \"\"\"\n    return np.sqrt(np.square(a - b).mean())\n\ndef rmse_5(a, b):\n    \"\"\"Returns the root mean square error betwwen a and b\n    \"\"\"\n    return np.sqrt(np.square(a - b).mean())\n\ndef rmse_6(a, b):\n    \"\"\"Returns the root mean square error betwwen a and b\n    \"\"\"\n    return np.sqrt(np.square(a - b).mean())\n\ndef rmse_7(a, b):\n    \"\"\"Returns the root mean square error betwwen a and b\n    \"\"\"\n    return np.sqrt(np.square(a - b).mean())\n\ndef rmse_8(a, b):\n    \"\"\"Returns the",
        ".mean() * b.mean())\n\ndef norm_error(a, b):\n    \"\"\"Returns the normalized mean square error of a and b\n    \"\"\"\n    return np.square(a - b).mean() / (a.mean() * b.mean())\n\ndef norm_error_2(a, b):\n    \"\"\"Returns the normalized mean square error of a and b\n    \"\"\"\n    return np.square(a - b).mean() / (a.mean() * b.mean())\n\ndef norm_error_3(a, b):\n    \"\"\"Returns the normalized mean square error of a and b\n    \"\"\"\n    return np.square(a - b).mean() / (a.mean() * b.mean())\n\ndef norm_error_4(a, b):\n    \"\"\"Returns the normalized mean square error of a and b\n    \"\"\"\n    return np.square(a - b).mean() / (a.mean() * b.mean())\n\ndef norm_error_5(a, b):\n    \"\"\"Returns the normalized mean square error of a and b\n    \"\"\"\n    return np.square(a - b).mean() / (a.mean() * b.mean())\n\ndef norm_error_6(a, b):\n    \"\"\"Returns the normalized mean square error of a and b\n   ",
        "\n\ndef bias(a, b):\n    \"\"\"Returns the mean fractionalized bias error\n    \"\"\"\n    return a.mean() + b.mean()\n\ndef mfbe_error(a, b):\n    \"\"\"Returns the mean fractionalized bias error\n    \"\"\"\n    return 2 * bias(a, b) / (a.mean() + b.mean())\n\ndef mfbe_error_2(a, b):\n    \"\"\"Returns the mean fractionalized bias error\n    \"\"\"\n    return 2 * bias(a, b) / (a.mean() + b.mean())\n\ndef mfbe_error_3(a, b):\n    \"\"\"Returns the mean fractionalized bias error\n    \"\"\"\n    return 2 * bias(a, b) / (a.mean() + b.mean())\n\ndef mfbe_error_4(a, b):\n    \"\"\"Returns the mean fractionalized bias error\n    \"\"\"\n    return 2 * bias(a, b) / (a.mean() + b.mean())\n\ndef mfbe_error_5(a, b):\n    \"\"\"Returns the mean fractionalized bias error\n    \"\"\"\n    return 2 * bias(a, b) / (a.mean() + b.mean())\n\ndef mfbe_error_6(a, b):\n    \"\"\"Returns the mean fractionalized",
        "\n\ndef fex2(a, b):\n    \"\"\"Returns the factor of exceedance\n    \"\"\"\n    return (np.sum(a > b, dtype=float) / len(a) - 0.5)\n\ndef fex3(a, b):\n    \"\"\"Returns the factor of exceedance\n    \"\"\"\n    return (np.sum(a > b, dtype=float) / len(a) - 0.5)\n\ndef fex4(a, b):\n    \"\"\"Returns the factor of exceedance\n    \"\"\"\n    return (np.sum(a > b, dtype=float) / len(a) - 0.5)\n\ndef fex5(a, b):\n    \"\"\"Returns the factor of exceedance\n    \"\"\"\n    return (np.sum(a > b, dtype=float) / len(a) - 0.5)\n\ndef fex6(a, b):\n    \"\"\"Returns the factor of exceedance\n    \"\"\"\n    return (np.sum(a > b, dtype=float) / len(a) - 0.5)\n\ndef fex7(a, b):\n    \"\"\"Returns the factor of exceedance\n    \"\"\"\n    return (np.sum(a > b, dtype=float) / len(a) - 0.5)\n\ndef fex",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\",
        ")\n\ndef gmb_norm(a, b):\n    \"\"\"Geometric mean bias norm\n    \"\"\"\n    return np.sqrt(np.log(a) - np.log(b))\n\ndef gmb_norm_2(a, b):\n    \"\"\"Geometric mean bias norm 2\n    \"\"\"\n    return np.sqrt(np.log(a) - np.log(b))\n\ndef gmb_norm_3(a, b):\n    \"\"\"Geometric mean bias norm 3\n    \"\"\"\n    return np.sqrt(np.log(a) - np.log(b))\n\ndef gmb_norm_4(a, b):\n    \"\"\"Geometric mean bias norm 4\n    \"\"\"\n    return np.sqrt(np.log(a) - np.log(b))\n\ndef gmb_norm_5(a, b):\n    \"\"\"Geometric mean bias norm 5\n    \"\"\"\n    return np.sqrt(np.log(a) - np.log(b))\n\ndef gmb_norm_6(a, b):\n    \"\"\"Geometric mean bias norm 6\n    \"\"\"\n    return np.sqrt(np.log(a) - np.log(b))\n\ndef gmb_norm_7(a, b):\n    \"\"\"Geometric mean bias norm 7\n   ",
        "(np.log(a) - np.log(b)) / np.sqrt(np.square(np.log(a) - np.log(b))))\n\ndef gmmv(a, b):\n    \"\"\"Geometric mean variance\n    \"\"\"\n    return np.exp(np.square(np.log(a) - np.log(b)) / np.sqrt(np.square(np.log(a) - np.log(b))))\n\ndef gmmv_2(a, b):\n    \"\"\"Geometric mean variance\n    \"\"\"\n    return np.exp(np.square(np.log(a) - np.log(b)) / np.sqrt(np.square(np.log(a) - np.log(b))))\n\ndef gmmv_3(a, b):\n    \"\"\"Geometric mean variance\n    \"\"\"\n    return np.exp(np.square(np.log(a) - np.log(b)) / np.sqrt(np.square(np.log(a) - np.log(b))))\n\ndef gmmv_4(a, b):\n    \"\"\"Geometric mean variance\n    \"\"\"\n    return np.exp(np.square(np.log(a) - np.log(b)) / np.sqrt(np.",
        "\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132,",
        "\n\ndef bias(a, b):\n    \"\"\"Computes the bias of a against b, typically a is the predictions array, and b\n    the observations array\n\n    Returns:\n        A dataFrame of stat name, stat description, result\n    \"\"\"\n\n    return a - b\n\ndef stderr(a, b):\n    \"\"\"Computes the standard deviation of a against b, typically a is the predictions\n    array, and b the observations array\n\n    Returns:\n        A dataFrame of stat name, stat description, result\n    \"\"\"\n\n    return a - b\n\ndef mae(a, b):\n    \"\"\"Computes the mean absolute error of a against b, typically a is the predictions\n    array, and b the observations array\n\n    Returns:\n        A dataFrame of stat name, stat description, result\n    \"\"\"\n\n    return a - b\n\ndef rmse(a, b):\n    \"\"\"Computes the root mean square error of a against b, typically a is the predictions\n    array, and b the observations array\n\n    Returns:\n        A dataFrame of stat name, stat description, result\n    \"\"\"\n\n    return a - b\n\ndef nmse(a, b):\n    \"\"\"Computes the normalized mean square error of a against b, typically a is the predictions\n    array, and b the observations array\n\n    Returns:",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        sys.path = self.site_path\n        sys.bin = self.bin_path\n\n        # Set the default locale\n        locale.setlocale(locale.LC_ALL, '')\n\n        # Set the default locale to the system locale\n        locale.setlocale(locale.LC_ALL, 'C')\n\n        # Set the default locale to the user locale\n        locale.setlocale(locale.LC_ALL, 'C')\n\n        # Set the default locale to the system locale\n        locale.setlocale(locale.LC_ALL, 'C')\n\n        # Set the default locale to the user locale\n        locale.setlocale(locale.LC_ALL, 'C')\n\n        # Set the default locale to the system locale\n        locale.setlocale(locale.LC_ALL, 'C')\n\n        # Set the default locale to the user locale\n        locale.setlocale(locale.LC_ALL, 'C')\n\n        # Set the default locale to the system locale\n        locale.setlocale(locale.LC_ALL, 'C')\n\n        # Set the default locale to the user locale\n        locale.setlocale(locale.LC_ALL, 'C')\n\n        # Set the default locale to the system locale\n        locale.setlocale(locale.LC_ALL, 'C')\n\n       ",
        "\n\ndef copy(self, path):\n        '''\n        Copy this environment\n        '''\n        self.run_hook('preremove')\n        utils.copy(self.path, path)\n        self.run_hook('postcopy')\n\ndef copy_to(self, path):\n        '''\n        Copy this environment to another path\n        '''\n        self.run_hook('preremove')\n        utils.copy_to(self.path, path)\n        self.run_hook('postcopy_to')\n\ndef copy_from(self, path):\n        '''\n        Copy this environment from another path\n        '''\n        self.run_hook('preremove')\n        utils.copy_from(self.path, path)\n        self.run_hook('postcopy_from')\n\ndef copy_to_dir(self, path):\n        '''\n        Copy this environment to another path\n        '''\n        self.run_hook('preremove')\n        utils.copy_to_dir(self.path, path)\n        self.run_hook('postcopy_to_dir')\n\ndef copy_from_dir(self, path):\n        '''\n        Copy this environment from another path\n        '''\n        self.run_hook('preremove')\n       ",
        "\n\ndef platform(self):\n        '''Platform used to launch this application module'''\n\n        cmd = self.config.get('platform', None)\n        if cmd is None:\n            return\n\n        cmd = cmd[platform]\n        return cmd['path'], cmd['args']\n\ndef main(self):\n        '''Main function used to launch this application module'''\n\n        cmd = self.config.get('command', None)\n        if cmd is None:\n            return\n\n        cmd = cmd[platform]\n        return cmd['path'], cmd['args']\n\ndef main_command(self):\n        '''Main command used to launch this application module'''\n\n        cmd = self.config.get('command', None)\n        if cmd is None:\n            return\n\n        cmd = cmd[platform]\n        return cmd['path'], cmd['args']\n\ndef main_platform(self):\n        '''Main platform used to launch this application module'''\n\n        cmd = self.config.get('platform', None)\n        if cmd is None:\n            return\n\n        cmd = cmd[platform]\n        return cmd['path'], cmd['args']\n\ndef main_platform_command(self):\n        '''Main platform command used to launch this application module'''\n\n        cmd = self.config.get('platform', None)\n",
        "\n\ndef get_home_path():\n    '''Return the home directory of the virtual environment.\n\n    This is the path to the CPENV_HOME directory.\n    '''\n    return os.path.expanduser('~')\n\ndef get_virtual_environment(name):\n    '''Return a virtual environment by name.\n\n    This is the path to the virtual environment.\n    '''\n    return VirtualEnvironment(name)\n\ndef get_virtual_environment_by_name(name):\n    '''Return a virtual environment by name.\n\n    This is the path to the virtual environment.\n    '''\n    return VirtualEnvironment.get_by_name(name)\n\ndef get_virtual_environment_by_path(path):\n    '''Return a virtual environment by path.\n\n    This is the path to the virtual environment.\n    '''\n    return VirtualEnvironment.get_by_path(path)\n\ndef get_virtual_environment_by_name_or_path(name, path):\n    '''Return a virtual environment by name or path.\n\n    This is the path to the virtual environment.\n    '''\n    return VirtualEnvironment.get_by_name_or_path(name, path)\n\ndef get_virtual_environment_by_name_or_path_and_config(name, path, config):\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef resolve(module_name):\n    '''Resolves a module name to a module object\n\n    :param module_name: name of module to resolve\n    '''\n\n    r = resolve_cache[module_name]\n    if r is None:\n        r = resolve_cache[module_name] = resolve(module_name)\n    return r\n\n\ndef resolve_cache:\n    '''Cache of resolved modules\n    '''\n\n    cache = {}\n    return cache\n\n\ndef resolve(module_name):\n    '''Resolves a module name to a module object\n\n    :param module_name: name of module to resolve\n    '''\n\n    r = resolve_cache[module_name]\n    if r is None:\n        r = resolve_cache[module_name] = resolve(module_name)\n    return r\n\n\ndef resolve_cache:\n    '''Cache of resolved modules\n    '''\n\n    cache = {}\n    return cache\n\n\ndef resolve_module(module_name):\n    '''Resolves a module name to a module object\n\n    :param module_name: name of module to resolve\n    '''\n\n    r = resolve_cache[module_name]\n    if r is None:\n        r = resolve_cache[module_name] = resolve(module_name)\n    return",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_active_modules():\n    '''Get the active modules from CPENV_ACTIVE_MODULES environment variable'''\n\n    modules = set(os.environ['CPENV_ACTIVE_MODULES'].split(os.pathsep))\n    return modules\n\ndef get_active_module(module_name):\n    '''Get the active module from CPENV_ACTIVE_MODULES environment variable'''\n\n    modules = set(get_active_modules())\n    return modules.find(module_name)\n\ndef get_active_modules_list():\n    '''Get the active modules from CPENV_ACTIVE_MODULES environment variable'''\n\n    modules = set(get_active_modules())\n    return modules\n\ndef get_active_module_path(module_name):\n    '''Get the active module path from CPENV_ACTIVE_MODULES environment variable'''\n\n    modules = set(get_active_modules())\n    return modules.find(module_name)\n\ndef get_active_module_path_list():\n    '''Get the active module path from CPENV_ACTIVE_MODULES environment variable'''\n\n    modules = set(get_active_modules())\n    return modules\n\ndef get_active_module_path_by_name(module_name):\n    '''Get the active module path from CPENV_ACTIVE_MODULE",
        "\n\ndef get_active_modules():\n    '''Return a set of modules that are currently active'''\n\n    modules = set(os.environ['CPENV_ACTIVE_MODULES'].split(os.pathsep))\n    return modules\n\ndef get_module_path(module):\n    '''Return the path of a module'''\n\n    return os.pathsep.join([m.path for m in get_active_modules()]) + os.pathsep + module\n\ndef get_module_name(module):\n    '''Return the name of a module'''\n\n    return module.split('.')[-1]\n\ndef get_module_version(module):\n    '''Return the version of a module'''\n\n    return module.split('.')[-2]\n\ndef get_module_description(module):\n    '''Return the description of a module'''\n\n    return module.split('.')[-3]\n\ndef get_module_author(module):\n    '''Return the author of a module'''\n\n    return module.split('.')[-4]\n\ndef get_module_license(module):\n    '''Return the license of a module'''\n\n    return module.split('.')[-5]\n\ndef get_module_license_url(module):\n    '''Return the license url of a module'''\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\nimport",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        click.echo('You can also add a new module to an environment:')\n        click.echo('    cpenv module add my_module ./path/to/my_module')\n        click.echo('Or track your module on git and add it directly from the repo:')\n        click.echo('    cpenv module add my_module git@github.com:user/my_module.git')\n        click.echo('You can also add a new module to a git repository:')\n        click.echo('    cpenv module add my_module git@github.com:user/my_module.git')\n        click.echo('You can also add a new module to a git repository:')\n        click.echo('    cpenv module add my_module git@github.com:user/my_module.git')\n        click.echo('You can also add a new module to a git repository:')\n        click.echo('    cpenv module add my_module git@github.com:user/my_module.git')\n        click.echo('You can also add a new module to a git repository:')\n        click.echo('    cpenv module add my_module git@github.com:user/my_module.git')\n        click.echo('You can also add a new module to",
        "\n\ndef remove(name):\n    '''Remove a module from an environment. PATH can be a git repository path or\n    a filesystem path. '''\n\n    if not name:\n        ctx = click.get_current_context()\n        click.echo(ctx.get_help())\n        examples = (\n            '\\nExamples:\\n'\n            '    cpenv module remove my_module\\n'\n            '    cpenv module remove my_module.git\\n'\n            '    cpenv module remove my_module.git --branch=master --type=shared'\n        )\n        click.echo(examples)\n        return\n\n    env = cpenv.get_active_env()\n    if not env:\n        click.echo('\\nActivate an environment to remove a local module.\\n')\n        return\n\n    if click.confirm('\\nRemove {} from active env {}?'.format(name, env.name)):\n        click.echo('Removing module...', nl=False)\n        try:\n            cpenv.remove_module(name)\n        except:\n            click.echo(bold_red('FAILED'))\n            raise\n        else:\n            click.echo(bold_green('OK!'))\n\ndef list(name):\n    '''List all modules in an environment. PATH",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "(resolver, path)\n\n\ndef is_environment(path):\n    '''Returns True if the path is a VirtualEnvironment'''\n\n    return path.startswith('/')\n\n\ndef unipath(path):\n    '''Unipaths a path to a relative or absolute path'''\n\n    return path.replace('\\\\', '/')\n\n\ndef resolve_environment(resolver, path):\n    '''Resolves VirtualEnvironments with a relative or absolute path'''\n\n    path = unipath(path)\n\n    if is_environment(path):\n        return VirtualEnvironment(path)\n\n    raise ResolveError(resolver, path)\n\n\ndef resolve_path(resolver, path):\n    '''Resolves VirtualEnvironments with a relative or absolute path'''\n\n    path = unipath(path)\n\n    if is_environment(path):\n        return VirtualEnvironment(path)\n\n    raise ResolveError(resolver, path)\n\n\ndef resolve_path_to_environment(resolver, path):\n    '''Resolves VirtualEnvironments with a relative or absolute path'''\n\n    path = unipath(path)\n\n    if is_environment(path):\n        return VirtualEnvironment(path)\n\n    raise ResolveError(resolver, path)\n\n\ndef resolve_path_to_virtual_environment(resolver, path):\n    '''Resolves Virtual",
        "\n\ndef is_environment(path):\n    '''Returns True if the path is a VirtualEnvironment'''\n\n    return path.startswith('CPENV_HOME')\n\ndef unipath(base, path):\n    '''Unipaths a path to a relative path'''\n\n    return base + path[len(base):]\n",
        ".resolve(resolver, path)\n\n\ndef cache_resolver_for_path(resolver, path):\n    '''Resolves VirtualEnvironments in EnvironmentCache for a given path'''\n\n    env = resolver.cache.find(path)\n    if env:\n        return env\n\n    raise ResolveError.resolve(resolver, path)\n\n\ndef cache_resolver_for_path_and_env(resolver, path, env):\n    '''Resolves VirtualEnvironments in EnvironmentCache for a given path and env'''\n\n    env = resolver.cache.find(path)\n    if env:\n        return env\n\n    raise ResolveError.resolve(resolver, path)\n\n\ndef cache_resolver_for_path_and_env_and_env(resolver, path, env, env2):\n    '''Resolves VirtualEnvironments in EnvironmentCache for a given path and env and env2'''\n\n    env = resolver.cache.find(path)\n    if env:\n        return env\n\n    raise ResolveError.resolve(resolver, path)\n\n\ndef cache_resolver_for_path_and_env_and_env2(resolver, path, env, env2, env3):\n    '''Resolves VirtualEnvironments in EnvironmentCache for a given path and env and env2 and env3'''\n\n    env = resolver.cache.find(path)\n    if",
        ".resolve(path)\n\n    raise ResolveError(path)\n\ndef resolve_module(resolver, path):\n    '''Resolves module in previously resolved environment.'''\n\n    if resolver.resolved:\n\n        if isinstance(resolver.resolved[0], VirtualEnvironment):\n            env = resolver.resolved[0]\n            mod = env.get_module(path)\n\n            if mod:\n                return mod\n\n    raise ResolveError(path)\n\ndef resolve_module_path(resolver, path):\n    '''Resolves module in previously resolved environment.'''\n\n    if resolver.resolved:\n\n        if isinstance(resolver.resolved[0], VirtualEnvironment):\n            env = resolver.resolved[0]\n            mod = env.get_module_path(path)\n\n            if mod:\n                return mod\n\n    raise ResolveError(path)\n\ndef resolve_module_path_recursive(resolver, path):\n    '''Resolves module in previously resolved environment.'''\n\n    if resolver.resolved:\n\n        if isinstance(resolver.resolved[0], VirtualEnvironment):\n            env = resolver.resolved[0]\n            mod = env.get_module_path_recursive(path)\n\n            if mod:\n                return mod\n\n    raise ResolveError(path)\n\ndef resolve_module_path_recursive_recursive(resolver,",
        "\n    resolver.resolve(mod)\n\n\ndef active_env_module_resolver_with_env(resolver, path):\n    '''Resolves modules in currently active environment with given environment.'''\n\n    from .api import get_active_env\n\n    env = get_active_env()\n    if not env:\n        raise ResolveError\n\n    mod = env.get_module(path)\n    if not mod:\n        raise ResolveError\n\n    resolver.resolve(mod)\n\n\ndef active_env_module_resolver_with_env_and_path(resolver, path):\n    '''Resolves modules in currently active environment with given environment and path.'''\n\n    from .api import get_active_env\n\n    env = get_active_env()\n    if not env:\n        raise ResolveError\n\n    mod = env.get_module(path)\n    if not mod:\n        raise ResolveError\n\n    resolver.resolve(mod)\n\n\ndef active_env_module_resolver_with_env_and_path_and_env(resolver, path):\n    '''Resolves modules in currently active environment with given environment and path and environment.'''\n\n    from .api import get_active_env\n\n    env = get_active_env()\n    if not env:\n        raise ResolveError\n\n   ",
        "\n\ndef redirect_to_env_paths(paths):\n    '''Returns a list of paths to redirect to'''\n\n    if not isinstance(paths, list):\n        paths = [paths]\n\n    return [unipath(p, '.cpenv') for p in paths]\n\ndef is_redirecting(path):\n    '''Returns true if the path is a redirecting path'''\n\n    return os.path.isfile(unipath(path, '.cpenv'))\n\ndef unipath(path, ext):\n    '''Returns the path without extension'''\n\n    return os.path.join(path, os.path.basename(path))\n\ndef walk_up(path):\n    '''Walks up the tree and returns the root and the current directory and\n    the current file'''\n\n    root, _, _ = os.path.split(path)\n    return root, root, os.path.splitext(os.path.basename(path))\n\ndef resolve(resolver, path):\n    '''Resolves environment from .cpenv file...recursively walks up the tree\n    in attempt to find a .cpenv file'''\n\n    if not os.path.exists(path):\n        raise ResolveError\n\n    if os.path.isfile(path):\n        path = os.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "\n\ndef transpose(a, axes):\n    \"\"\"Transpose a matrix.\n\n    Args:\n      a (array_like): Input array.\n      axes (list): A list of axes to transpose.\n\n    Returns:\n      res (ndarray)\n    \"\"\"\n    if isinstance(a, np.ndarray):\n        return np.transpose(a, axes)\n    if axes not in range(a.ndim):\n        raise ValueError(\n                'transpose: axes (%d) must be >=0 and < %d' % (axes, a.ndim))\n    return a.transpose(axes)\n\ndef transpose_axis(a, axis, start=0):\n    \"\"\"Transpose a matrix, starting at a given axis.\n\n    Args:\n      a (array_like): Input array.\n      axis (int): The axis to transpose.  The positions of the other axes \n        do not change relative to one another.\n      start (int, optional): The axis is transposed until it lies before this \n        position.  The default, 0, results in a \"complete\" roll.\n\n    Returns:\n      res (ndarray)\n    \"\"\"\n    if isinstance(a, np.ndarray):\n        return np.transpose_axis(a, axis, start)\n    if axis not in range(a",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef gather(ar):\n    \"\"\"Gather a sequence of arrays together.\n    Will aim to gather `ndarray`, `RemoteArray`, and `DistArray` without moving\n    their data, if they happen to be on different engines.\n\n    Args:\n      ar (sequence of array_like): Arrays to be gathered. They must have\n        the same shape, except in the dimension corresponding to `axis`.\n\n    Returns: \n      res: `ndarray`, if inputs were all local\n           `RemoteArray`, if inputs were all on the same remote engine\n           `DistArray`, if inputs were already scattered on different engines\n    \"\"\"\n    from distob import engine\n    if len(ar) is 0:\n        raise ValueError('need at least one array to gather')\n    if len(ar) == 1:\n        return ar[0]\n    if len(ar) == 2:\n        return RemoteArray(ar[0], ar[1])\n    if len(ar) == 3:\n        return DistArray(ar[0], ar[1], ar[2])\n    if len(ar) == 4:\n        return Remote(ar[0], ar[1], ar[2], ar[3])\n    raise ValueError('incompatible shapes for gather')\n\ndef _remote_to_array(ar):\n    \"\"\"Convert a",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef std(a, axis=None, dtype=None, out=None, keepdims=False):\n    \"\"\"\n    Compute the standard deviation along the specified axis.\n\n    Returns the standard deviation of the array elements.  The standard\n    deviation is taken over the flattened array by default, otherwise over the\n    specified axis.\n    `float64` intermediate and return values are used for integer inputs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose standard deviation is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which the standard deviations are computed. The default is to\n        compute the standard deviation of the flattened array.\n        If this is a tuple of ints, a standard deviation is performed over multiple axes,\n        instead of a single axis or all the axes as before.\n    dtype : data-type, optional\n        Type to use in computing the standard deviation.  For integer inputs, the default\n        is `float64`; for floating point inputs, it is the same as the\n        input dtype.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n       ",
        "\n\ndef _valid_distaxis_ignore(shapes, ax):\n        \"\"\"`ax` is a valid candidate for a distributed axis if the given\n        subarray shapes are all the same when ignoring axis `ax`\"\"\"\n        compare_shapes = np.vstack(shapes)\n        if ax < compare_shapes.shape[1]:\n            compare_shapes[:, ax] = -1\n        return np.count_nonzero(compare_shapes - compare_shapes[0]) == 0\n\ndef _valid_distaxis_ignore_axis(shapes, ax):\n        \"\"\"`ax` is a valid candidate for a distributed axis if the given\n        subarray shapes are all the same when ignoring axis `ax`\"\"\"\n        compare_shapes = np.vstack(shapes)\n        if ax < compare_shapes.shape[1]:\n            compare_shapes[:, ax] = -1\n        return np.count_nonzero(compare_shapes - compare_shapes[0]) == 0\n\ndef _valid_distaxis_ignore_axis_ignore(shapes, ax):\n        \"\"\"`ax` is a valid candidate for a distributed axis if the given\n        subarray shapes are all the same when ignoring axis `ax`\"\"\"\n        compare_shapes = np.vstack(shapes)\n        if ax < compare_shapes.shape[1]:\n            compare_shapes",
        "\n\n\ndef run_with_env(args, **kwargs):\n    '''Returns True if successful, False if failure'''\n\n    kwargs.setdefault('env', os.environ)\n    kwargs.setdefault('shell', True)\n\n    try:\n        subprocess.check_call(' '.join(args), **kwargs)\n        return True\n    except subprocess.CalledProcessError:\n        logger.debug('Error running: {}'.format(args))\n        return False\n\n\ndef run_with_shell(args, **kwargs):\n    '''Returns True if successful, False if failure'''\n\n    kwargs.setdefault('env', os.environ)\n    kwargs.setdefault('shell', True)\n\n    try:\n        subprocess.check_call(' '.join(args), **kwargs)\n        return True\n    except subprocess.CalledProcessError:\n        logger.debug('Error running: {}'.format(args))\n        return False\n\n\ndef run_with_shell_env(args, **kwargs):\n    '''Returns True if successful, False if failure'''\n\n    kwargs.setdefault('env', os.environ)\n    kwargs.setdefault('shell', True)\n\n    try:\n        subprocess.check_call(' '.join(args), **kwargs)\n        return True\n    except subprocess.CalledProcessError:\n        logger.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\ndef prompt_yesno(prefix=None, colored=True):\n    '''Generate a prompt with a given prefix\n\n    linux/osx: [prefix] yes/no\n          win: [prefix] yes/no\n    '''\n\n    if platform == 'win':\n        return '[{0}] $P$G'.format(prefix)\n    else:\n        if colored:\n            return (\n                '[{0}] '  # White prefix\n                '\\\\[\\\\033[01;32m\\\\]yes/no\\\\[\\\\033[00m\\\\] '  # Green yes/no\n                '\\\\[\\\\033[01;34m\\\\]yes/no\\\\[\\\\033[00m\\\\] '  # Blue yes/no\n            ).format(prefix)\n        return '[{0}] \\\\yes/no \\\\yes/no'.format(prefix)\n\n\ndef prompt_yesno_with_default(prefix=None, colored=True):\n    '''Generate a prompt with a given prefix\n\n    linux/osx: [prefix] yes/no default\n          win: [prefix] yes/no default\n    '''\n\n    if platform == 'win':\n        return '[{0}] $P$G'.format(prefix)\n    else:\n        if colored:\n            return (\n                '[{0",
        "\n\ndef prompt(prompt_prefix):\n    '''Prompt for a user'''\n\n    if prompt_prefix:\n        os.environ['PROMPT'] = prompt_prefix\n\n    return os.environ['PROMPT']\n\ndef cmd():\n    '''Execute a command'''\n\n    return subprocess.check_output(['bash', '-c', 'echo \"hello\" > /dev/null'])\n\ndef prompt(prompt_prefix):\n    '''Prompt for a user'''\n\n    if prompt_prefix:\n        os.environ['PROMPT'] = prompt_prefix\n\n    return os.environ['PROMPT']\n\ndef exit(code=1):\n    '''Exit a subshell'''\n\n    if code:\n        subprocess.call(['bash', '-c', 'exit %d' % code], env=os.environ.data)\n\ndef wait(timeout=None):\n    '''Wait for a subshell to exit'''\n\n    if timeout:\n        subprocess.call(['bash', '-c', 'sleep %d' % timeout], env=os.environ.data)\n\ndef wait_until(condition, timeout=None):\n    '''Wait for a subshell to exit'''\n\n    if timeout:\n        subprocess.call(['bash', '-c', 'sleep %d' % timeout], env=os",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        return decorator\n\n    def add_status_job(self, fn, name=None, timeout=3):\n        \"\"\"Add a status job to the application.\n\n        ::\n\n            @app.status_job\n            def postgresql():\n                # query/ping postgresql\n\n            @app.status_job(name=\"Active Directory\")\n            def active_directory():\n                # query active directory\n\n            @app.status_job(timeout=5)\n            def paypal():\n                # query paypal, timeout after 5 seconds\n\n        \"\"\"\n        if name is None:\n            name = fn.__name__\n        self.jobs[name] = self.jobs.get(name, []) + [fn]\n        self.jobs[name].append(fn)\n        self.jobs[name].append(self.jobs[name].pop())\n        self.jobs[name].append(self.jobs[name].pop())\n        self.jobs[name].append(self.jobs[name].pop())\n        self.jobs[name].append(self.jobs[name].pop())\n        self.jobs[name].append(self.jobs[name].pop())\n        self.jobs[name].append(self.jobs[name].pop())\n        self.jobs[name].append(self.jobs[",
        "\n\n\ndef _pipesearch(text, cmd, color):\n    \"\"\"Page through text by feeding it to another program.  Invoking a\n    pager through this might support colors.\n    \"\"\"\n    import subprocess\n    env = dict(os.environ)\n\n    # If we're piping to less we might support colors under the\n    # condition that\n    cmd_detail = cmd.rsplit('/', 1)[-1].split()\n    if color is None and cmd_detail[0] == 'less':\n        less_flags = os.environ.get('LESS', '') + ' '.join(cmd_detail[1:])\n        if not less_flags:\n            env['LESS'] = '-R'\n            color = True\n        elif 'r' in less_flags or 'R' in less_flags:\n            env['LESS'] = '-K'\n            color = True\n\n    if not color:\n        text = strip_ansi(text)\n\n    c = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,\n                         env=env)\n    encoding = get_best_encoding(c.stdin)\n    try:\n        c.stdin.write(text.encode(encoding, 'replace'))\n        c.stdin.close()\n    except (IOError, KeyboardInterrupt",
        "\n\ndef profil_annuel_debut(df, func='mean'):\n    \"\"\"\n    Calcul du profil annuel debut\n\n    Param\u00e8tres:\n    df: DataFrame de donn\u00e9es dont l'index est une s\u00e9rie temporelle\n        (cf module xair par exemple)\n    func: function permettant le calcul. Soit un nom de fonction numpy ('mean', 'max', ...)\n        soit la fonction elle-m\u00eame (np.mean, np.max, ...)\n    Retourne:\n    Un DataFrame de moyennes par mois\n    \"\"\"\n\n    func = _get_funky(func)\n    res = df.groupby(lambda x: x.month).aggregate(func)\n    # On met des noms de mois \u00e0 la place des num\u00e9ros dans l'index\n    res.index = [cal.month_name[i] for i in range(1,13)]\n    return res\n\ndef profil_annuel_fin(df, func='mean'):\n    \"\"\"\n    Calcul du profil annuel fin\n\n    Param\u00e8tres:\n    df: DataFrame de donn\u00e9es dont l'index est une s\ufffd",
        "(hook_name, *args)\n\ndef run_hook(hook_name, *args):\n    '''Attempt to run a hook by name with args'''\n\n    hook_finder = HookFinder(get_hook_path())\n    hook = hook_finder(hook_name)\n    if hook:\n        hook.run(*args)\n\ndef get_global_hook_path():\n    '''Return the path to the global hook'''\n\n    return os.path.join(os.path.dirname(__file__), 'global_hook.py')\n\ndef get_hook_path():\n    '''Return the path to the hook'''\n\n    return os.path.join(os.path.dirname(__file__), 'hook.py')\n\ndef run_hook_with_args(hook_name, *args):\n    '''Attempt to run a hook by name with args'''\n\n    hook_finder = HookFinder(get_hook_path())\n    hook = hook_finder(hook_name)\n    if hook:\n        hook.run(*args)\n\ndef run_hook_with_args_and_args(hook_name, *args, **kwargs):\n    '''Attempt to run a hook by name with args and kwargs'''\n\n    hook_finder = HookFinder(get_hook_path())\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n        for env in list(self):\n            if env.exists:\n                env.validate()\n\n        return True\n\ndef get(self, key):\n        '''Get an environment entry from the cache.'''\n\n        for env in list(self):\n            if env.key == key:\n                return env\n\n        return None\n\ndef set(self, key, value):\n        '''Set an environment entry in the cache.'''\n\n        for env in list(self):\n            if env.key == key:\n                env.value = value\n                return env\n\n        return None\n\ndef remove(self, key):\n        '''Remove an environment entry from the cache.'''\n\n        for env in list(self):\n            if env.key == key:\n                self.remove(env)\n                return env\n\n        return None\n\ndef list(self):\n        '''Return all the entries in the cache.'''\n\n        return list(self.keys())\n\ndef keys(self):\n        '''Return all the keys in the cache.'''\n\n        return list(self.keys())\n\ndef clear(self):\n        '''Clear all the entries in the cache.'''\n\n        for env in list(self):\n            self.remove(env)\n\ndef exists(self, key):\n        '''",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "(encode)\n\ndef load(self):\n        '''Load the environment cache from disk.'''\n\n        with open(self.path, 'r') as f:\n            env_data = yaml.safe_load(f)\n\n        for env in env_data:\n            self.add(env)\n\ndef load_all():\n        '''Load all the environments from disk.'''\n\n        for env in self:\n            env.load()\n\ndef load_env(name):\n        '''Load an environment from disk.'''\n\n        for env in self:\n            if env.name == name:\n                return env\n\ndef load_env_by_name(name):\n        '''Load an environment from disk.'''\n\n        for env in self:\n            if env.name == name:\n                return env\n\ndef load_all_env():\n        '''Load all the environments from disk.'''\n\n        for env in self:\n            env.load()\n\ndef load_env_by_name_and_path(name, path):\n        '''Load an environment from disk.'''\n\n        for env in self:\n            if env.name == name and env.path == path:\n                return env\n\ndef load_env_by_name_and_path_and_type(name, path, type",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ".local()\n\ndef local(obj):\n    \"\"\"Retrieve objects that have been distributed, making them local again\"\"\"\n    if hasattr(obj, '__distob_local__'):\n        return obj.__distob_local__()\n    elif (isinstance(obj, collections.Sequence) and \n            not isinstance(obj, string_types)):\n        return [local(subobj) for subobj in obj]\n    else:\n        return obj.local()\n\ndef local_gather(obj):\n    \"\"\"Retrieve objects that have been distributed, making them local again\"\"\"\n    if hasattr(obj, '__distob_local_gather__'):\n        return obj.__distob_local_gather__()\n    elif (isinstance(obj, collections.Sequence) and \n            not isinstance(obj, string_types)):\n        return [local_gather(subobj) for subobj in obj]\n    else:\n        return obj.local_gather()\n\ndef local_gather_all(obj):\n    \"\"\"Retrieve objects that have been distributed, making them local again\"\"\"\n    if hasattr(obj, '__distob_local_gather_all__'):\n        return obj.__distob_local_gather_all__()\n    elif (isinstance(obj, collections.Sequence) and \n            not isinstance(obj,",
        ", *args, **kwargs)\n\ndef vectorize(f):\n    \"\"\"Vectorize a function in parallel to each element of the input\"\"\"\n    return f(*(args + kwargs.values()))\n\ndef flatten(f):\n    \"\"\"Flatten a function in parallel to each element of the input\"\"\"\n    return f(*(args + kwargs.values()))\n\ndef flatten_all(f):\n    \"\"\"Flatten a function in parallel to each element of the input\"\"\"\n    return flatten(f)(*(args + kwargs.values()))\n\ndef flatten_all_parallel(f):\n    \"\"\"Flatten a function in parallel to each element of the input\"\"\"\n    return flatten_all(f)(*(args + kwargs.values()))\n\ndef flatten_parallel(f):\n    \"\"\"Flatten a function in parallel to each element of the input\"\"\"\n    return flatten(f)(*(args + kwargs.values()))\n\ndef flatten_parallel_all(f):\n    \"\"\"Flatten a function in parallel to each element of the input\"\"\"\n    return flatten_parallel(f)(*(args + kwargs.values()))\n\ndef flatten_parallel_all_parallel(f):\n    \"\"\"Flatten a function in parallel to each element of the input\"\"\"\n    return flatten_parallel_all(f)(*(args + kwargs.values()))\n\ndef flatten_parallel_parallel(",
        "\n\ndef register_proxy_type_from_class(cls, real_type, proxy_type):\n        \"\"\"Configure engines so that remote methods returning values of type\n        `real_type` will instead return by proxy, as type `proxy_type`\n        \"\"\"\n        if distob.engine is None:\n            cls._initial_proxy_types[real_type] = proxy_type\n        elif isinstance(distob.engine, ObjectHub):\n            distob.engine._runtime_reg_proxy_type(real_type, proxy_type)\n        else:\n            # TODO: remove next line after issue #58 in dill is fixed.\n            distob.engine._singleeng_reg_proxy_type(real_type, proxy_type)\n            pass\n\ndef register_proxy_type_from_class_with_name(cls, real_type, proxy_type):\n        \"\"\"Configure engines so that remote methods returning values of type\n        `real_type` will instead return by proxy, as type `proxy_type`\n        \"\"\"\n        if distob.engine is None:\n            cls._initial_proxy_types[real_type] = proxy_type\n        elif isinstance(distob.engine, ObjectHub):\n            distob.engine._runtime_reg_proxy_type(real_type, proxy_type)",
        "\n    return False\n\n\ndef is_git_branch(path):\n    '''Returns True if path is a git branch.'''\n\n    if path.startswith('git@') or path.startswith('https://'):\n        return True\n\n    if os.path.exists(unipath(path, '.git')):\n        return True\n\n    return False\n\n\ndef is_git_tag(path):\n    '''Returns True if path is a git tag.'''\n\n    if path.startswith('git@') or path.startswith('https://'):\n        return True\n\n    if os.path.exists(unipath(path, '.git')):\n        return True\n\n    return False\n\n\ndef is_git_tag_name(path):\n    '''Returns True if path is a git tag name.'''\n\n    if path.startswith('git@') or path.startswith('https://'):\n        return True\n\n    if os.path.exists(unipath(path, '.git')):\n        return True\n\n    return False\n\n\ndef is_git_tag_sha(path):\n    '''Returns True if path is a git tag sha.'''\n\n    if path.startswith('git@') or path.startswith('https://'):\n        return True\n\n",
        "(home)\n\ndef is_user_environment(path):\n    '''Returns True if path is in CPENV_USER'''\n\n    user = unipath(os.environ.get('CPENV_USER', 'cpenv'))\n    path = unipath(path)\n\n    return path.startswith(user)\n\ndef is_user_home_environment(path):\n    '''Returns True if path is in CPENV_USER_HOME'''\n\n    user_home = unipath(os.environ.get('CPENV_USER_HOME', 'cpenv'))\n    path = unipath(path)\n\n    return path.startswith(user_home)\n\ndef is_user_user_environment(path):\n    '''Returns True if path is in CPENV_USER_USER'''\n\n    user_user = unipath(os.environ.get('CPENV_USER_USER', 'cpenv'))\n    path = unipath(path)\n\n    return path.startswith(user_user)\n\ndef is_user_user_home_environment(path):\n    '''Returns True if path is in CPENV_USER_USER_HOME'''\n\n    user_user_home = unipath(os.environ.get('CPENV_USER_USER_HOME', 'c",
        "\n\ndef is_redirecting_to_cpenv(path):\n    '''Returns True if path contains a .cpenv file'''\n\n    candidate = unipath(path, '.cpenv')\n    return os.path.exists(candidate) and os.path.isfile(candidate)\n\ndef is_redirecting_to_cpenv_file(path):\n    '''Returns True if path contains a .cpenv file'''\n\n    candidate = unipath(path, '.cpenv')\n    return os.path.exists(candidate) and os.path.isfile(candidate)\n\ndef is_redirecting_to_cpenv_file_with_extension(path):\n    '''Returns True if path contains a .cpenv file with a given extension'''\n\n    candidate = unipath(path, '.cpenv')\n    return os.path.exists(candidate) and os.path.isfile(candidate) and os.path.splitext(candidate)[1] == '.cpenv'\n\ndef is_redirecting_to_cpenv_file_with_extension_and_extension(path):\n    '''Returns True if path contains a .cpenv file with a given extension and extension'''\n\n    candidate = unipath(path, '.cpenv')\n   ",
        ".strip()\n\ndef get_env_path(path):\n    '''Get environment path from redirect file'''\n\n    with open(path, 'r') as f:\n        redirected = f.read()\n\n    return redirected\n\ndef get_env_path_from_file(path):\n    '''Get environment path from redirect file'''\n\n    with open(path, 'r') as f:\n        redirected = f.read()\n\n    return redirected\n\ndef get_env_path_from_env_vars(path):\n    '''Get environment path from redirect file'''\n\n    with open(path, 'r') as f:\n        redirected = f.read()\n\n    return shlex.split(redirected)\n\ndef get_env_path_from_env_vars_from_file(path):\n    '''Get environment path from redirect file'''\n\n    with open(path, 'r') as f:\n        redirected = f.read()\n\n    return shlex.split(redirected)\n\ndef get_env_path_from_env_vars_from_env_vars(path):\n    '''Get environment path from redirect file'''\n\n    with open(path, 'r') as f:\n        redirected = f.read()\n\n    return shlex.split(redirected)\n\ndef get_env",
        "))\n\ndef expanduser(path):\n    '''Returns an absolute expanded path'''\n\n    return os.path.expandvars(os.path.expanduser(path))\n\ndef expandvars(path):\n    '''Returns an absolute expanded path'''\n\n    return os.path.expandvars(os.path.expandvars(path))\n\ndef expanduservars(path):\n    '''Returns an absolute expanded path'''\n\n    return os.path.expandvars(os.path.expandvars(os.path.expanduservars(path)))\n\ndef expanduseruser(path):\n    '''Returns an absolute expanded path'''\n\n    return os.path.expandvars(os.path.expandvars(os.path.expanduseruser(path)))\n\ndef expanduseruservars(path):\n    '''Returns an absolute expanded path'''\n\n    return os.path.expandvars(os.path.expandvars(os.path.expanduseruservars(path)))\n\ndef expanduseruseruser(path):\n    '''Returns an absolute expanded path'''\n\n    return os.path.expandvars(os.path.expandvars(os.path.expanduseruseruser(path)))\n\ndef expanduseruseruservars(path):\n    '''Returns an absolute expanded path'''\n\n    return os.path.expandvars(os.path.expand",
        "), os.path.sep)\n\ndef expandpath(path):\n    '''Expand a path to a relative path.'''\n\n    return os.path.relpath(expandpath(os.path.dirname(path)), os.path.abspath(path))\n\ndef expandpath(path):\n    '''Expand a path to a relative path.'''\n\n    return os.path.relpath(expandpath(os.path.dirname(path)), os.path.abspath(path))\n\ndef abspath(path):\n    '''Return the absolute path of a path.'''\n\n    return os.path.abspath(expandpath(os.path.dirname(path)))\n\ndef dirname(path):\n    '''Return the directory name of a path.'''\n\n    return os.path.dirname(expandpath(os.path.dirname(path)))\n\ndef basename(path):\n    '''Return the basename of a path.'''\n\n    return os.path.basename(expandpath(os.path.dirname(path)))\n\ndef dirname_ext(path):\n    '''Return the directory name of a path with extension.'''\n\n    return os.path.dirname(expandpath(os.path.dirname(path)))\n\ndef basename_ext(path):\n    '''Return the basename of a path with extension.'''\n\n",
        ".join(package_root, *paths))\n\n\ndef get_package_data(package):\n    '''Returns a dictionary of package data.\n\n    :param package: The name of the package to get the data for.\n    :type package: str\n    :returns: A dictionary of package data.\n    :rtype: dict\n    '''\n    return {\n        'name': package,\n        'version': package,\n        'description': package,\n        'long_description': package,\n        'author': package,\n        'author_email': package,\n        'url': package,\n        'license': package,\n        'classifiers': package,\n        'packages': package,\n        'scripts': package,\n        'scripts_source': package,\n        'scripts_test': package,\n        'scripts_test_source': package,\n        'scripts_test_test': package,\n        'scripts_test_test_source': package,\n        'scripts_test_test_test': package,\n        'scripts_test_test_test_source': package,\n        'scripts_test_test_test_test': package,\n        'scripts_test_test_test_test_source': package,\n        'scripts_test_test_test_test_test': package,\n        'scripts_",
        "\n\ndef ensure_directory_exists(path, *args):\n    '''Like os.makedirs but keeps quiet if path already exists'''\n    if os.path.exists(path):\n        return\n\n    os.makedirs(path, *args)\n\ndef ensure_file_exists(path, *args):\n    '''Like os.makedirs but keeps quiet if path already exists'''\n    if os.path.exists(path):\n        return\n\n    os.makedirs(path, *args)\n\ndef ensure_file_not_exists(path, *args):\n    '''Like os.makedirs but keeps quiet if path already exists'''\n    if os.path.exists(path):\n        return\n\n    os.makedirs(path, *args)\n\ndef ensure_directory_not_exists(path, *args):\n    '''Like os.makedirs but keeps quiet if path already exists'''\n    if os.path.exists(path):\n        return\n\n    os.makedirs(path, *args)\n\ndef ensure_file_not_exists(path, *args):\n    '''Like os.makedirs but keeps quiet if path already exists'''\n    if os.path.exists(path):\n        return\n\n    os.makedirs(path, *",
        "\n\n\ndef walk_dn_recursive(start_dir, depth=10):\n    '''\n    Walk down a directory tree recursively. Same as os.walk but allows for a depth limit\n    via depth argument\n    '''\n\n    start_depth = len(os.path.split(start_dir))\n    end_depth = start_depth + depth\n\n    for root, subdirs, files in os.walk(start_dir):\n        for f in files:\n            yield os.path.join(root, f)\n\n        if len(os.path.split(root)) >= end_depth:\n            break\n\n\ndef walk_dn_recursive_recursive(start_dir, depth=10):\n    '''\n    Walk down a directory tree recursively recursively. Same as os.walk but allows for a depth limit\n    via depth argument\n    '''\n\n    start_depth = len(os.path.split(start_dir))\n    end_depth = start_depth + depth\n\n    for root, subdirs, files in os.walk(start_dir):\n        for f in files:\n            yield os.path.join(root, f)\n\n        for subdir in subdirs:\n            yield walk_dn_recursive(subdir, depth)\n\n\ndef walk_dn_recursive_recursive_recursive(",
        "\n\ndef walk_down(start_dir, depth=20):\n    '''\n    Walk down a directory tree\n    '''\n    root = start_dir\n\n    for i in xrange(depth):\n        contents = os.listdir(root)\n        subdirs, files = [], []\n        for f in contents:\n            if os.path.isdir(os.path.join(root, f)):\n                subdirs.append(f)\n            else:\n                files.append(f)\n\n        yield root, subdirs, files\n\n        parent = os.path.dirname(root)\n        if parent and not parent == root:\n            root = parent\n        else:\n            break\n\ndef walk_files(start_dir, depth=20):\n    '''\n    Walk up a directory tree\n    '''\n    root = start_dir\n\n    for i in xrange(depth):\n        contents = os.listdir(root)\n        subdirs, files = [], []\n        for f in contents:\n            if os.path.isfile(os.path.join(root, f)):\n                subdirs.append(f)\n            else:\n                files.append(f)\n\n        yield root, subdirs, files\n\n        parent = os.path.dirname(root)\n",
        "\n\ndef preprocess_list(l):\n    '''\n    Preprocess a list to be used as environment variables.\n\n    :param l: list to be processed\n    '''\n\n    out_env = []\n    for v in l:\n        out_env.append(preprocess_dict(v))\n\n    return out_env\n\ndef preprocess_dict_list(d):\n    '''\n    Preprocess a dict to be used as environment variables.\n\n    :param d: dict to be processed\n    '''\n\n    out_env = []\n    for k, v in d.items():\n        out_env.append(preprocess_dict(v))\n\n    return out_env\n\ndef preprocess_dict_dict(d):\n    '''\n    Preprocess a dict to be used as environment variables.\n\n    :param d: dict to be processed\n    '''\n\n    out_env = {}\n    for k, v in d.items():\n        out_env[k] = preprocess_dict(v)\n\n    return out_env\n\ndef preprocess_dict_list_dict(d):\n    '''\n    Preprocess a dict to be used as environment variables.\n\n    :param d: dict to be processed\n    '''\n\n    out_env = {}\n    for k, v in d.items",
        "\n    elif isinstance(d[k], tuple):\n        _join_seq(d, k, v)\n\n    elif isinstance(d[k], dict):\n        _join_seq(d, k, v)\n\n    elif isinstance(d[k], bool):\n        d[k] = bool(v)\n\n    elif isinstance(d[k], int):\n        d[k] = int(v)\n\n    elif isinstance(d[k], float):\n        d[k] = float(v)\n\n    elif isinstance(d[k], str):\n        d[k] = v\n\n    elif isinstance(d[k], unicode):\n        d[k] = v\n\n    elif isinstance(d[k], unicode):\n        d[k] = v.encode('utf-8')\n\n    elif isinstance(d[k], unicode):\n        d[k] = v.decode('utf-8')\n\n    elif isinstance(d[k], unicode):\n        d[k] = v.encode('utf-8')\n\n    elif isinstance(d[k], unicode):\n        d[k] = v.decode('utf-8')\n\n    elif isinstance(d[k], unicode):\n        d[k] = v.encode('utf-8')\n\n    elif isinstance(",
        "\n\ndef join_dicts_with_keys(*dicts):\n    '''Join a bunch of dicts with a key'''\n\n    out_dict = {}\n\n    for d in dicts:\n        for k, v in d.iteritems():\n\n            if not type(v) in JOINERS:\n                raise KeyError('Invalid type in dict: {}'.format(type(v)))\n\n            JOINERS[type(v)](out_dict, k, v)\n\n    return out_dict\n\ndef join_dicts_with_values(*dicts):\n    '''Join a bunch of dicts with a value'''\n\n    out_dict = {}\n\n    for d in dicts:\n        for k, v in d.iteritems():\n\n            if not type(v) in JOINERS:\n                raise KeyError('Invalid type in dict: {}'.format(type(v)))\n\n            JOINERS[type(v)](out_dict, k, v)\n\n    return out_dict\n\ndef join_dicts_with_keys_and_values(*dicts):\n    '''Join a bunch of dicts with a key and a value'''\n\n    out_dict = {}\n\n    for d in dicts:\n        for k, v in d.iteritems():\n\n            if not type(v) in JOINERS:\n                raise KeyError('Invalid",
        "\n\ndef get_env_var(env, key):\n    '''\n    Get an environment variable from a dict.\n\n    :param env: Environment dict like os.environ.data\n    :param key: Variable name\n    '''\n\n    return env.get(key, None)\n\ndef get_env_var_list(env, key):\n    '''\n    Get an environment variable from a dict.\n\n    :param env: Environment dict like os.environ.data\n    :param key: Variable name\n    '''\n\n    return env.get(key, [])\n\ndef get_env_var_list_by_key(env, key):\n    '''\n    Get an environment variable from a dict.\n\n    :param env: Environment dict like os.environ.data\n    :param key: Variable name\n    '''\n\n    return env.get(key, [])\n\ndef get_env_var_list_by_key_list(env, key):\n    '''\n    Get an environment variable from a dict.\n\n    :param env: Environment dict like os.environ.data\n    :param key: Variable name\n    '''\n\n    return env.get(key, [])\n\ndef get_env_var_list_by_key_list_by_key(env, key):\n   ",
        "\n\ndef get_env_var(name, default=None):\n    '''\n    Get an environment variable from a dict.\n\n    :param name: Name of the environment variable\n    :param default: Default value to return if the variable is not found\n    '''\n    return os.environ.get(name, default)\n\ndef get_env_var_list(name, default=None):\n    '''\n    Get an environment variable from a dict.\n\n    :param name: Name of the environment variable\n    :param default: Default value to return if the variable is not found\n    '''\n    return os.environ.get(name, default).split(os.pathsep)\n\ndef get_env_var_list_from_file(name, default=None):\n    '''\n    Get an environment variable from a file.\n\n    :param name: Name of the environment variable\n    :param default: Default value to return if the variable is not found\n    '''\n    return os.environ.get(name, default).split(os.pathsep)\n\ndef get_env_var_list_from_file_list(name, default=None):\n    '''\n    Get an environment variable from a file.\n\n    :param name: Name of the environment variable\n    :param default: Default value to return if the variable",
        "\n\ndef get_env_vars():\n    '''\n    Get all environment variables\n\n    :return: Environment dict\n    '''\n\n    return os.environ.copy()\n\ndef get_env_vars_from_file(filename):\n    '''\n    Get all environment variables from a file\n\n    :param filename: Path to the file\n    :return: Environment dict\n    '''\n\n    with open(filename, 'r') as f:\n        return expand_envvars(f.read().splitlines())\n\ndef get_env_vars_from_file_with_default(filename, default):\n    '''\n    Get all environment variables from a file with a default value\n\n    :param filename: Path to the file\n    :param default: Default value\n    :return: Environment dict\n    '''\n\n    with open(filename, 'r') as f:\n        return expand_envvars(f.read().splitlines(), default)\n\ndef get_env_vars_from_file_with_default_and_override(filename, default, override):\n    '''\n    Get all environment variables from a file with a default value and a override value\n\n    :param filename: Path to the file\n    :param default: Default value\n    :param override: Override value\n    :return: Environment dict\n    '''\n\n",
        "\n\ndef get_store_env_path():\n    '''Returns a random filepath.'''\n\n    tempdir = tempfile.gettempdir()\n    temp_name = 'envstore{0:0>3d}'\n    temp_path = unipath(tempdir, temp_name.format(random.getrandbits(9)))\n    if not os.path.exists(temp_path):\n        return temp_path\n    else:\n        return get_store_env_tmp()\n\ndef get_store_env_path_with_prefix(prefix):\n    '''Returns a random filepath with a prefix.'''\n\n    tempdir = tempfile.gettempdir()\n    temp_name = 'envstore{0:0>3d}{1:0>3d}'\n    temp_path = unipath(tempdir, temp_name.format(random.getrandbits(9), prefix))\n    if not os.path.exists(temp_path):\n        return temp_path\n    else:\n        return get_store_env_tmp()\n\ndef get_store_env_path_with_suffix(suffix):\n    '''Returns a random filepath with a suffix.'''\n\n    tempdir = tempfile.gettempdir()\n    temp_name = 'envstore{0:0>3d}{1:0>",
        "\n\ndef get_store_env_tmp():\n    '''Return a temporary file path to store the current environment.\n    '''\n\n    return tempfile.mkdtemp()\n\ndef get_store_env_env():\n    '''Return the current environment as a dict.\n    '''\n\n    return os.environ.data\n\ndef get_store_env_dict():\n    '''Return the current environment as a dict.\n    '''\n\n    return os.environ.data\n\ndef get_store_env_dict_copy():\n    '''Return the current environment as a dict.\n    '''\n\n    return os.environ.data.copy()\n\ndef get_store_env_dict_copy_copy():\n    '''Return the current environment as a dict.\n    '''\n\n    return os.environ.data.copy()\n\ndef get_store_env_dict_copy_copy_copy():\n    '''Return the current environment as a dict.\n    '''\n\n    return os.environ.data.copy()\n\ndef get_store_env_dict_copy_copy_copy_copy():\n    '''Return the current environment as a dict.\n    '''\n\n    return os.environ.data.copy()\n\ndef get_store_env_dict_copy_copy_copy_copy():\n    '''Return the current",
        " + uri\n\ndef downstream_url(self, uri):\n        \"Returns the URL to the downstream data source for the given URI based on configuration\"\n        return self.application.options.downstream + self.request.uri + uri\n\ndef get_uri(self, uri):\n        \"Returns the URI for the given URI based on configuration\"\n        return self.application.options.upstream + self.request.uri + uri\n\ndef get_uri_from_config(self, uri):\n        \"Returns the URI for the given URI based on configuration\"\n        return self.application.options.upstream + self.request.uri + uri\n\ndef get_uri_from_config_with_query(self, uri, query):\n        \"Returns the URI for the given URI based on configuration\"\n        return self.application.options.upstream + self.request.uri + uri + '?' + query\n\ndef get_uri_from_config_with_query_and_query_string(self, uri, query, query_string):\n        \"Returns the URI for the given URI based on configuration\"\n        return self.application.options.upstream + self.request.uri + uri + '?' + query + '&' + query_string\n\ndef get_uri_from_config_with_query_and_query_string_and_query",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\n        return 0\n\ndef parse_cache_control(cache_control):\n    \"\"\"Parses cache-control header.\n\n    Returns a dictionary of options.\n\n    \"\"\"\n    options = {}\n    for option in cache_control.split(','):\n        option = option.strip()\n        if option.startswith('max-age='):\n            try:\n                options['max-age'] = int(option[5:])\n            except ValueError:\n                pass\n        elif option.startswith('s-maxage='):\n            try:\n                options['s-maxage'] = int(option[5:])\n            except ValueError:\n                pass\n        elif option.startswith('must-revalidate='):\n            try:\n                options['must-revalidate'] = True\n            except ValueError:\n                pass\n        elif option.startswith('proxy-revalidate='):\n            try:\n                options['proxy-revalidate'] = True\n            except ValueError:\n                pass\n        elif option.startswith('private='):\n            try:\n                options['private'] = True\n            except ValueError:\n                pass\n        elif option.startswith('public='):\n            try:\n                options['public'] = True\n            except ValueError:\n                pass\n        else:\n            print 'Unknown cache-control option",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_file_extension(filename):\n    \"\"\"\n    Get the file extension of a filename\n\n    :param str filename: Filename to get the extension of\n    :return: File extension\n    :rtype: str\n    :raises ValueError: If *filename* is not a valid filename\n    \"\"\"\n    if not filename:\n        raise ValueError(\"filename must be a valid filename\")\n\n    if not filename.endswith(\".\"):\n        raise ValueError(\"filename must end with a dot\")\n\n    return filename[:-1]\n\ndef get_file_extension_without_extension(filename):\n    \"\"\"\n    Get the file extension without extension of a filename\n\n    :param str filename: Filename to get the extension of\n    :return: File extension without extension\n    :rtype: str\n    :raises ValueError: If *filename* is not a valid filename\n    \"\"\"\n    if not filename:\n        raise ValueError(\"filename must be a valid filename\")\n\n    if not filename.endswith(\".\"):\n        raise ValueError(\"filename must end with a dot\")\n\n    return filename[:-1]\n\ndef get_file_extension_without_extension_and_extension(filename):\n    \"\"\"\n    Get the file extension without extension and extension of a filename\n\n    :param str filename: Filename to get the extension of",
        "\n\ndef get_uuid():\n    \"\"\"\n    Get a UUID string\n\n    :return: UUID string\n    :rtype: str\n    :raises ValueError: If no UUID is available\n    \"\"\"\n    uuid = uuid.uuid4()\n    if not uuid:\n        raise ValueError(\"No UUID available\")\n    return format_uuid(uuid)\n\ndef get_random_uuid():\n    \"\"\"\n    Get a random UUID string\n\n    :return: UUID string\n    :rtype: str\n    :raises ValueError: If no UUID is available\n    \"\"\"\n    uuid = uuid.uuid4()\n    if not uuid:\n        raise ValueError(\"No UUID available\")\n    return format_uuid(uuid)\n\ndef get_random_uuid_with_length(length=8):\n    \"\"\"\n    Get a random UUID string with a given length\n\n    :param int length: Length of the UUID string to generate\n    :return: UUID string\n    :rtype: str\n    :raises ValueError: If no UUID is available\n    \"\"\"\n    uuid = uuid.uuid4()\n    if not uuid:\n        raise ValueError(\"No UUID available\")\n    return format_uuid(uuid, length)\n\ndef get_random_uuid_with_length_and_prefix(length=8, prefix=\"\"):\n    \"\"\"",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        sys.exit(1)\n\n    return response.json()\n",
        "\n\ndef setting_list(self, name_hyphen):\n        \"\"\"\n        Retrieves the setting value whose name is indicated by name_hyphen.\n\n        Values starting with $ are assumed to reference environment variables,\n        and the value stored in environment variables is retrieved. It's an\n        error if thes corresponding environment variable it not set.\n        \"\"\"\n        if name_hyphen in self._instance_settings:\n            return self._instance_settings[name_hyphen][1]\n        else:\n            msg = \"No setting named '%s'\" % name_hyphen\n            raise UserFeedback(msg)\n\ndef setting_list_with_default(self, name_hyphen, default):\n        \"\"\"\n        Retrieves the setting value whose name is indicated by name_hyphen.\n\n        Values starting with $ are assumed to reference environment variables,\n        and the value stored in environment variables is retrieved. It's an\n        error if thes corresponding environment variable it not set.\n        \"\"\"\n        if name_hyphen in self._instance_settings:\n            return self._instance_settings[name_hyphen][1]\n        else:\n            return default\n\ndef setting_list_with_default_with_default(self, name_hyphen, default, default_value):\n        \"\"\"\n        Retrieves the setting value whose name is indicated",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef setting_values():\n        \"\"\"Return a dictionary of setting values.\"\"\"\n        return {\n            \"DEBUG\": settings.DEBUG,\n            \"TEMPLATE_DEBUG\": settings.TEMPLATE_DEBUG,\n            \"TEMPLATE_DEBUG_CONTEXT\": settings.TEMPLATE_DEBUG_CONTEXT,\n            \"TEMPLATE_DEBUG_REQUEST\": settings.TEMPLATE_DEBUG_REQUEST,\n            \"TEMPLATE_DEBUG_THROW\": settings.TEMPLATE_DEBUG_THROW,\n            \"TEMPLATE_DEBUG_TRACING\": settings.TEMPLATE_DEBUG_TRACING,\n            \"TEMPLATE_DEBUG_TRACING_REQUEST\": settings.TEMPLATE_DEBUG_TRACING_REQUEST,\n            \"TEMPLATE_DEBUG_TRACING_THROW\": settings.TEMPLATE_DEBUG_TRACING_THROW,\n            \"TEMPLATE_DEBUG_TRACING_TRACING\": settings.TEMPLATE_DEBUG_TRACING_TRACING,\n            \"TEMPLATE_DEBUG_TRACING_REQUEST_THROW\": settings.TEMPLATE_DEBUG_TRACING_REQUEST_THROW,\n            \"TEMPLATE_DEBUG_TRACING_THROW\": settings.TEMPLATE_DEBUG_TRACING_THROW,\n            \"TEMPLATE_DEBUG_TRACING_TRACING\": settings.TEMPLATE_DEBUG_TRACING_TRACING,\n            \"TEMPLATE_DEBUG_TRACING_REQUEST_TH",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_plugin_settings(cls):\n        \"\"\"\n        Returns the plugin settings for the given class.\n        \"\"\"\n        return cls._class_settings.get('plugin-settings')\n\ndef get_plugin_class(cls):\n        \"\"\"\n        Returns the plugin class for the given class.\n        \"\"\"\n        return cls._class_settings.get('plugin-class')\n\ndef get_plugin_name(cls):\n        \"\"\"\n        Returns the plugin name for the given class.\n        \"\"\"\n        return cls._class_settings.get('plugin-name')\n\ndef get_plugin_version(cls):\n        \"\"\"\n        Returns the plugin version for the given class.\n        \"\"\"\n        return cls._class_settings.get('plugin-version')\n\ndef get_plugin_description(cls):\n        \"\"\"\n        Returns the plugin description for the given class.\n        \"\"\"\n        return cls._class_settings.get('plugin-description')\n\ndef get_plugin_author(cls):\n        \"\"\"\n        Returns the plugin author for the given class.\n        \"\"\"\n        return cls._class_settings.get('plugin-author')\n\ndef get_plugin_license(cls):\n        \"\"\"\n        Returns the plugin license for the given class.\n        \"\"\"\n        return cls._class_settings.get('plugin-",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef addLogbook(self, menu):\n        '''Add logbook menu set.'''\n        if self.logMenuCount < 1:\n            self.logMenus.append(menu)\n            self.logMenuCount += 1\n\ndef removeLogbook(self, menu=None):\n        '''Remove logbook menu set.'''\n        if self.logMenuCount > 1 and menu is not None:\n            menu.removeMenu()\n            self.logMenus.remove(menu)\n            self.logMenuCount -= 1\n\ndef addLogbookMenu(self, menu):\n        '''Add logbook menu set.'''\n        if self.logMenuCount < 1:\n            self.logMenus.append(menu)\n            self.logMenuCount += 1\n\ndef removeLogbookMenu(self, menu=None):\n        '''Remove logbook menu set.'''\n        if self.logMenuCount > 1 and menu is not None:\n            menu.removeMenu()\n            self.logMenus.remove(menu)\n            self.logMenuCount -= 1\n\ndef addLogbookMenu(self, menu):\n        '''Add logbook menu set.'''\n        if self.logMenuCount < 1:\n            self.logMenus.append(menu)\n            self.logMenuCount += 1\n\ndef removeLogbookMenu(",
        "\n\ndef selectedPrograms(self):\n        '''Return selected log books by type.'''\n        mcclogs = []\n        physlogs = []\n        for i in range(len(self.logMenus)):\n            logType = self.logMenus[i].selectedType()\n            log = self.logMenus[i].selectedProgram()\n            if logType == \"MCC\":\n                if log not in mcclogs:\n                    mcclogs.append(log)\n            elif logType == \"Physics\":\n                if log not in physlogs:\n                    physlogs.append(log)\n        return mcclogs, physlogs\n\ndef selectedProgramsByType(self, type):\n        '''Return selected log books by type.'''\n        mcclogs = []\n        physlogs = []\n        for i in range(len(self.logMenus)):\n            logType = self.logMenus[i].selectedType()\n            log = self.logMenus[i].selectedProgram()\n            if logType == type:\n                if log not in mcclogs:\n                    mcclogs.append(log)\n            elif logType == \"Physics\":\n                if log not in physlogs:\n                    physlogs.append(log)\n        return mcclogs, physlogs\n\ndef selectedProgram",
        "\n\ndef acceptedUser2(self, logType):\n        '''Verify enetered user name is on accepted MCC logbook list.'''\n        from urllib2 import urlopen, URLError, HTTPError\n        import json\n        \n        isApproved = False\n        \n        userName = str(self.logui.userName.text())\n        if userName == \"\":\n            return False  # Must have a user name to submit entry\n        \n        if logType == \"MCC\":\n            networkFault = False\n            data = []\n            log_url = \"https://mccelog.slac.stanford.edu/elog/dev/mgibbs/dev_json_user_list.php/?username=\" + userName\n            try:\n                data = urlopen(log_url, None, 5).read()\n                data = json.loads(data)\n            except URLError as error:\n                print(\"URLError: \" + str(error.reason))\n                networkFault = True\n            except HTTPError as error:\n                print(\"HTTPError: \" + str(error.reason))\n                networkFault = True\n            \n            # If network fails, ask user to verify\n            if networkFault:\n                msgBox = QMessageBox()\n                msgBox.setText(\"Cannot connect to MCC Log Server!\")\n                msgBox.setInformative",
        "\n\ndef pretty_print(self, elem):\n        \"\"\"Pretty print xml elements\"\"\"\n        \n        from xml.etree import ElementTree\n        from re import sub\n        \n        rawString = ElementTree.tostring(elem, 'utf-8')\n        parsedString = sub(r'(?=<[^/].*>)', '\\n', rawString)  # Adds newline after each closing tag\n        \n        return parsedString[1:]\n\ndef pretty_print_xml(self, elem):\n        \"\"\"Pretty print xml elements\"\"\"\n        \n        from xml.etree import ElementTree\n        from re import sub\n        \n        rawString = ElementTree.tostring(elem, 'utf-8')\n        parsedString = sub(r'(?=<[^/].*>)', '\\n', rawString)  # Adds newline after each closing tag\n        \n        return pretty_print(parsedString)\n\ndef pretty_print_xml_with_indent(self, elem):\n        \"\"\"Pretty print xml elements\"\"\"\n        \n        from xml.etree import ElementTree\n        from re import sub\n        \n        rawString = ElementTree.tostring(elem, 'utf-8')\n        parsedString = sub(r'(?=<[^/].*>)', '\\n', rawString)  # Adds newline after each closing tag\n        \n        return pretty_print(parsedString, indent=",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef sendToLogbook2(self, fileName, logType, location=None):\n        '''Process log information and push to selected logbooks.'''\n        import subprocess\n        \n        success = True\n        if logType == \"MCC\":\n            fileString = \"\"\n            if not self.imagePixmap.isNull():\n                fileString = fileName + \".\" + self.imageType\n        \n            logcmd = \"xml2elog \" + fileName + \".xml \" + fileString\n            process = subprocess.Popen(logcmd, shell=True)\n            process.wait()\n            if process.returncode != 0:\n                success = False\n        else:\n            from shutil import copy\n\n            path = \"/u1/\" + location.lower() + \"/physics/logbook/data/\"  # Prod path\n            path = \"/home/softegr/alverson/log_test/\"  # Dev path\n            try:\n                if not self.imagePixmap.isNull():\n                    copy(fileName + \".png\", path)\n                    if self.imageType == \"png\":\n                        copy(fileName + \".ps\", path)\n                    else:\n                        copy(fileName + \".\" + self.imageType, path)\n            \n                # Copy .xml file last to ensure images will be picked up by cron job\n                #",
        "\n        \n        self.setCentralWidget(self.logButton)\n        \n        self.setLayout(self._logSelectLayout)\n        \n        self.setObjectName(\"logSelect\")\n        \n        self.setObjectName(\"logSelectLayout\")\n        \n        self.setObjectName(\"logSelectButton\")\n        \n        self.setObjectName(\"logSelectButtonLayout\")\n        \n        self.setObjectName(\"logSelectButton\")\n        \n        self.setObjectName(\"logSelectButtonLayout\")\n        \n        self.setObjectName(\"logSelectButton\")\n        \n        self.setObjectName(\"logSelectButtonLayout\")\n        \n        self.setObjectName(\"logSelectButton\")\n        \n        self.setObjectName(\"logSelectButtonLayout\")\n        \n        self.setObjectName(\"logSelectButton\")\n        \n        self.setObjectName(\"logSelectButtonLayout\")\n        \n        self.setObjectName(\"logSelectButton\")\n        \n        self.setObjectName(\"logSelectButtonLayout\")\n        \n        self.setObjectName(\"logSelectButton\")\n        \n        self.setObjectName(\"logSelectButtonLayout\")\n        \n        self.setObjectName(\"logSelectButton\")\n        \n        self.setObjectName(\"logSelectButtonLayout\")\n        \n        self.setObjectName(\"logSelectButton\")\n        \n        self.setObjectName(\"logSelectButtonLayout\")",
        "\n        self.parent.layout.addWidget(self._logSelectLayout)\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('logSelectLayout')\n        self._logSelectLayout.setObjectName('log",
        "\n        else:\n            self.logType.clear()\n            self.logType.addItems(list(self.logList.keys()))\n            self.changeLogType()\n\ndef changeLogType(self):\n        '''Change log type.'''\n        if self.logType.currentIndex() == 0:\n            self.logType.addItem(\"\")\n        else:\n            self.logType.removeItem(self.logType.currentIndex())\n\ndef removeLogbooks(self, type=None, logs=[], default=\"\"):\n        '''Remove list of logbooks.'''\n        if type is not None and len(logs) != 0:\n            if type in self.logList:\n                for logbook in logs:\n                    if logbook not in self.logList.get(type)[0]:\n                        self.logList.get(type)[0].remove(logbook)\n            else:\n                self.logList[type] = []\n                self.logList[type].remove(logs)\n            \n            # If default given, auto-select upon menu creation\n            if len(self.logList[type]) > 1 and default != \"\":\n                self.logList.get(type)[1] == default\n            else:\n                self.logList.get(type).remove(default",
        "(type)\n        else:\n            print \"Type not found.\"\n\ndef changeLogType(self, type=None):\n        '''Change log type.'''\n        if type is not None:\n            if type in self.logList:\n                self.logList[type].remove(self.logList[type].index(self.logList[type].index(type)))\n                self.logList[type].append(type)\n                self.changeLogType()\n            else:\n                print \"Type not found.\"\n\ndef addLogbook(self, type=None, logbook=None):\n        '''Add logbook to list.'''\n        if type is not None and type in self.logList:\n            if type in self.logList[type]:\n                self.logList[type].append(logbook)\n                self.changeLogType()\n            else:\n                print \"Type not found.\"\n\ndef removeLogbook(self, type=None, logbook=None):\n        '''Remove logbook from list.'''\n        if type is not None and type in self.logList:\n            if type in self.logList[type]:\n                self.logList[type].remove(logbook)\n                self.changeLogType()\n            else:\n                print \"Type not found.\"\n\ndef",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.GetOperation;\nimport com.hazelcast.nio",
        ".addMenu()\n\ndef addMenu(self):\n        '''Add menus to parent gui.'''\n        self.parent.multiLogLayout.addLayout(self.logSelectLayout)\n        self.getPrograms(logType, programName)\n\ndef addMenu(self):\n        '''Add menus to parent gui.'''\n        self.parent.multiLogLayout.addLayout(self.logSelectLayout)\n        self.getPrograms(logType, programName)\n\ndef addMenu(self):\n        '''Add menus to parent gui.'''\n        self.parent.multiLogLayout.addLayout(self.logSelectLayout)\n        self.getPrograms(logType, programName)\n\ndef addMenu(self):\n        '''Add menus to parent gui.'''\n        self.parent.multiLogLayout.addLayout(self.logSelectLayout)\n        self.getPrograms(logType, programName)\n\ndef addMenu(self):\n        '''Add menus to parent gui.'''\n        self.parent.multiLogLayout.addLayout(self.logSelectLayout)\n        self.getPrograms(logType, programName)\n\ndef addMenu(self):\n        '''Add menus to parent gui.'''\n        self.parent.multiLogLayout.addLayout(self.logSelectLayout)\n        self",
        "\n        layout.clear()\n\ndef removeLayout(self, layout):\n        '''Iteratively remove graphical objects from layout.'''\n        for cnt in reversed(range(layout.count())):\n            item = layout.takeAt(cnt)\n            widget = item.widget()\n            if widget is not None:\n                widget.deleteLater()\n            else:\n                '''If sublayout encountered, iterate recursively.'''\n                self.removeLayout(item.layout())\n\ndef removeLayout(self, layout):\n        '''Iteratively remove graphical objects from layout.'''\n        for cnt in reversed(range(layout.count())):\n            item = layout.takeAt(cnt)\n            widget = item.widget()\n            if widget is not None:\n                widget.deleteLater()\n            else:\n                '''If sublayout encountered, iterate recursively.'''\n                self.removeLayout(item.layout())\n\ndef removeLayout(self, layout):\n        '''Iteratively remove graphical objects from layout.'''\n        for cnt in reversed(range(layout.count())):\n            item = layout.takeAt(cnt)\n            widget = item.widget()\n            if widget is not None:\n                widget.deleteLater()\n            else:\n                '''If sublayout encountered, iterate recursively.'''\n                self.removeLayout(",
        "\n\n    if ax is not None:\n        ax.set_title(toplabel)\n        if xlabel is not None:\n            ax.set_xlabel(xlabel)\n        if ylabel is not None:\n            ax.set_ylabel(ylabel)\n        if zlabel is not None:\n            ax.set_zlabel(zlabel)\n\n    if cb is not None:\n        cb.set_label(clabel)\n\n    return axes\n\ndef addaxes(ax=None, toplabel=None, xlabel=None, ylabel=None, zlabel=None, clabel=None, cb=None, windowlabel=None, fig=None, axes=None):\n    \"\"\"Adds axes to a plot.\"\"\"\n\n    if (axes is None) and (ax is not None):\n        axes = ax\n\n    if (windowlabel is not None) and (fig is not None):\n        fig.canvas.set_window_title(windowlabel)\n\n    if fig is not None:\n        fig = _plt.gcf()\n\n    if fig is not None and axes is None:\n        axes = fig.get_axes()\n        if axes == []:\n            logger.error('No axes found!')\n\n    if axes is not None:\n        if toplabel is not None:\n            axes",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".join(fixture)\n\ndef loaddata(args):\n    \"\"\"Load the database with model schema. Shorthand for `paver manage loaddata`.\n    \"\"\"\n    cmd = args and 'loaddata %s' % ' '.join(options.args) or 'loaddata --noinput'\n    call_manage(cmd)\n    for fixture in options.paved.django.syncdb.fixtures:\n        call_manage(\"loaddata %s\" % fixture)\n\ndef loaddata_all(args):\n    \"\"\"Load the database with model schema. Shorthand for `paver manage loaddata_all`.\n    \"\"\"\n    cmd = args and 'loaddata_all %s' % ' '.join(options.args) or 'loaddata_all --noinput'\n    call_manage(cmd)\n    for fixture in options.paved.django.syncdb.fixtures:\n        call_manage(\"loaddata_all %s\" % fixture)\n\ndef loaddata_all_all(args):\n    \"\"\"Load the database with model schema. Shorthand for `paver manage loaddata_all_all`.\n    \"\"\"\n    cmd = args and 'loaddata_all_all %s' % ' '.join(options.args) or 'loaddata_all_all --noinput'\n    call_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        assert set(definition.get('key_synonyms', {}).keys()) <= set(definition['supported_keys']), \\\n               '\\'The values of the \\'key_synonyms\\' mapping must be in \\'supported_keys\\''\n        assert set(definition.get('key_synonyms', {}).values()) <= set(definition['supported_keys']), \\\n               '\\'The values of the \\'key_synonyms\\' mapping must be in \\'supported_keys\\''\n        assert set(definition.get('key_synonyms', {}).keys()) <= set(definition['supported_keys']), \\\n               '\\'The values of the \\'key_synonyms\\' mapping must be in \\'supported_keys\\''\n        assert set(definition.get('key_synonyms', {}).values()) <= set(definition['supported_keys']), \\\n               '\\'The values of the \\'key_synonyms\\' mapping must be in \\'supported_keys\\''\n        assert set(definition.get('key_synonyms', {}).keys()) <= set(definition['supported_keys']), \\\n               '\\'The values of the \\'key_synonyms\\' mapping must be in \\'supported_keys\\''\n        assert set(definition.get('key_synonyms', {}).values()) <= set(definition['supported_keys']), \\\n               '\\'The values of the \\'key_synonyms\\' mapping must",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_all_by_key(self, key=None):\n        '''\n        Returns all data entries for a particular key. Default is the main key.\n\n        Args:\n\n            key (str): key whose values to return (default: main key)\n\n        Returns:\n\n            List of all data entries for the key\n        '''\n        key = self.definition.main_key if key is None else key\n        key = self.definition.key_synonyms.get(key, key)\n        entries = self._get_all(key)\n        if key in self.definition.scalar_nonunique_keys:\n            return set(entries)\n        return entries\n\ndef _get_all(self, key):\n        '''\n        Returns all data entries for a particular key. Default is the main key.\n\n        Args:\n\n            key (str): key whose values to return (default: main key)\n\n        Returns:\n\n            List of all data entries for the key\n        '''\n        key = self.definition.main_key if key is None else key\n        key = self.definition.key_synonyms.get(key, key)\n        entries = self.definition.data_entries.get(key)\n        if entries is None:\n            entries = self.definition.data_entries.",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\",
        "\n\ndef get_messages(self, limit=None, offset=None):\n        \"\"\"\n        Get Messages\n\n        http://dev.wheniwork.com/#get-messages\n        \"\"\"\n        url = \"/2/messages\"\n\n        if limit is not None:\n            url += \"?limit=%s\" % limit\n        if offset is not None:\n            url += \"?offset=%s\" % offset\n\n        return self._get_resource(url)[\"messages\"]\n\ndef get_message_by_id(self, message_id):\n        \"\"\"\n        Get Message by ID\n\n        http://dev.wheniwork.com/#get-message-by-id\n        \"\"\"\n        url = \"/2/messages/%s\" % message_id\n\n        return self.message_from_json(self._get_resource(url)[\"message\"])\n\ndef get_messages_by_ids(self, ids):\n        \"\"\"\n        Get Messages by IDs\n\n        http://dev.wheniwork.com/#get-messages-by-ids\n        \"\"\"\n        url = \"/2/messages\"\n\n        for id in ids:\n            url += \"?id=%s\" % id\n\n        return self._get_resource(url)[\"messages\"]\n\ndef get_message_by_title(self, title):",
        "\ndef update_message(self, message_id, params={}):\n        \"\"\"\n        Updates a message\n\n        http://dev.wheniwork.com/#create/update-message\n        \"\"\"\n        url = \"/2/messages/%s\" % message_id\n        body = params\n\n        data = self._put_resource(url, body)\n        return self.message_from_json(data[\"message\"])\n\ndef delete_message(self, message_id):\n        \"\"\"\n        Deletes a message\n\n        http://dev.wheniwork.com/#create/update-message\n        \"\"\"\n        url = \"/2/messages/%s\" % message_id\n\n        self._delete_resource(url)\n\ndef get_messages(self, params={}):\n        \"\"\"\n        Returns a list of messages\n\n        http://dev.wheniwork.com/#list/messages\n        \"\"\"\n        url = \"/2/messages/\"\n        body = params\n\n        data = self._get_resource(url, body)\n        return self.messages_from_json(data[\"messages\"])\n\ndef get_message(self, message_id):\n        \"\"\"\n        Returns a message\n\n        http://dev.wheniwork.com/#get/messages/%s\n        \"\"\"\n        url = \"/2/messages",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_messages(self, ids):\n        \"\"\"\n        Get messages.\n\n        http://dev.wheniwork.com/#get-messages\n        \"\"\"\n        url = \"/2/messages/?%s\" % urlencode([('ids', \",\".join(ids))])\n\n        data = self._get_resource(url)\n        return data\n\n\ndef get_messages_by_user(self, user_id):\n        \"\"\"\n        Get messages by user.\n\n        http://dev.wheniwork.com/#get-messages-by-user\n        \"\"\"\n        url = \"/2/messages/?%s\" % urlencode([('user_id', user_id)])\n\n        data = self._get_resource(url)\n        return data\n\n\ndef get_messages_by_user_id(self, user_id):\n        \"\"\"\n        Get messages by user id.\n\n        http://dev.wheniwork.com/#get-messages-by-user-id\n        \"\"\"\n        url = \"/2/messages/?%s\" % urlencode([('user_id', user_id)])\n\n        data = self._get_resource(url)\n        return data\n\n\ndef get_messages_by_user_id_and_type(self, user_id, type):\n       ",
        "\n\ndef get_site_by_id(self, site_id):\n        \"\"\"\n        Returns site data.\n\n        http://dev.wheniwork.com/#get-existing-site\n        \"\"\"\n        url = \"/2/sites/%s\" % site_id\n\n        return self.site_from_json(self._get_resource(url)[\"site\"])\n\ndef get_site_by_name(self, site_name):\n        \"\"\"\n        Returns site data.\n\n        http://dev.wheniwork.com/#get-existing-site\n        \"\"\"\n        url = \"/2/sites/%s\" % site_name\n\n        return self.site_from_json(self._get_resource(url)[\"site\"])\n\ndef get_site_by_slug(self, site_slug):\n        \"\"\"\n        Returns site data.\n\n        http://dev.wheniwork.com/#get-existing-site\n        \"\"\"\n        url = \"/2/sites/%s\" % site_slug\n\n        return self.site_from_json(self._get_resource(url)[\"site\"])\n\ndef get_site_by_slug_and_id(self, site_slug, site_id):\n        \"\"\"\n        Returns site data.\n\n        http://dev.",
        "\ndef get_site(self, site_id):\n        \"\"\"\n        Returns a single site.\n\n        http://dev.wheniwork.com/#listing-sites\n        \"\"\"\n        url = \"/2/sites/%s\" % site_id\n\n        data = self._get_resource(url)\n        site = self.site_from_json(data)\n\n        return site\n\ndef get_site_by_name(self, name):\n        \"\"\"\n        Returns a single site by name.\n\n        http://dev.wheniwork.com/#listing-sites\n        \"\"\"\n        url = \"/2/sites/%s\" % name\n\n        data = self._get_resource(url)\n        site = self.site_from_json(data)\n\n        return site\n\ndef get_site_by_slug(self, slug):\n        \"\"\"\n        Returns a single site by slug.\n\n        http://dev.wheniwork.com/#listing-sites\n        \"\"\"\n        url = \"/2/sites/%s\" % slug\n\n        data = self._get_resource(url)\n        site = self.site_from_json(data)\n\n        return site\n\ndef get_site_by_id(self, site_id):\n        \"\"\"\n        Returns a single site by id.",
        "\ndef update_site(self, site_id, params={}):\n        \"\"\"\n        Updates a site\n\n        http://dev.wheniwork.com/#create-update-site\n        \"\"\"\n        url = \"/2/sites/%s\" % site_id\n        body = params\n\n        data = self._put_resource(url, body)\n        return self.site_from_json(data[\"site\"])\n\ndef delete_site(self, site_id):\n        \"\"\"\n        Deletes a site\n\n        http://dev.wheniwork.com/#delete-site\n        \"\"\"\n        url = \"/2/sites/%s\" % site_id\n\n        self._delete_resource(url)\n\ndef get_site(self, site_id):\n        \"\"\"\n        Returns a site\n\n        http://dev.wheniwork.com/#get-site\n        \"\"\"\n        url = \"/2/sites/%s\" % site_id\n\n        data = self._get_resource(url)\n        return self.site_from_json(data[\"site\"])\n\ndef get_sites(self):\n        \"\"\"\n        Returns a list of sites\n\n        http://dev.wheniwork.com/#get-sites\n        \"\"\"\n        url = \"/2/sites/\"\n\n        data = self._",
        "\n\ndef admin_link_move_down(obj, link_text='down'):\n    \"\"\"Returns a link to a view that moves the passed in object down in rank.\n\n    :param obj:\n        Object to move\n    :param link_text:\n        Text to display in the link.  Defaults to \"down\"\n    :returns:\n        HTML link code to view for moving the object\n    \"\"\"\n    if obj.rank == 1:\n        return ''\n\n    content_type = ContentType.objects.get_for_model(obj)\n    link = reverse('awl-rankedmodel-move', args=(content_type.id, obj.id, \n        obj.rank + 1))\n\n    return '<a href=\"%s\">%s</a>' % (link, link_text)\n\ndef admin_link_delete(obj):\n    \"\"\"Returns a link to a view that deletes the passed in object.\n\n    :param obj:\n        Object to delete\n    :returns:\n        HTML link code to view for deleting the object\n    \"\"\"\n    return '<a href=\"%s\">%s</a>' % (reverse('awl-rankedmodel-delete', args=(obj.id,)),\n        'Delete')\n\ndef admin_link_delete_all(obj):\n    \"\"\"Returns a link to",
        "\n\ndef admin_link_move_up(obj, link_text='up'):\n    \"\"\"Returns a link to a view that moves the passed in object up in rank.\n\n    :param obj:\n        Object to move\n    :param link_text:\n        Text to display in the link.  Defaults to \"up\"\n    :returns:\n        HTML link code to view for moving the object\n    \"\"\"\n    if obj.rank == obj.grouped_filter().count():\n        return ''\n\n    content_type = ContentType.objects.get_for_model(obj)\n    link = reverse('awl-rankedmodel-move', args=(content_type.id, obj.id, \n        obj.rank - 1))\n\n    return '<a href=\"%s\">%s</a>' % (link, link_text)\n\ndef admin_link_delete(obj):\n    \"\"\"Returns a link to a view that deletes the passed in object.\n\n    :param obj:\n        Object to delete\n    :returns:\n        HTML link code to view for deleting the object\n    \"\"\"\n    return '<a href=\"%s\">%s</a>' % (reverse('awl-rankedmodel-delete', args=(obj.id,)),\n        'Delete')\n\ndef admin_link_delete_all(obj):\n",
        "\n\ndef showfig_aspect(fig, aspect=\"auto\"):\n    \"\"\"\n    Shows a figure with a typical orientation so that x and y axes are set up as expected.\n    \"\"\"\n\n    ax = fig.gca()\n\n    # Swap y axis if needed\n    alim = list(ax.axis())\n    if alim[3] < alim[2]:\n        temp    = alim[2]\n        alim[2] = alim[3]\n        alim[3] = temp\n        ax.axis(alim)\n\n    ax.set_aspect(aspect)\n    fig.show()\n\ndef showfig_aspect_auto(fig):\n    \"\"\"\n    Shows a figure with a typical orientation so that x and y axes are set up as expected.\n    \"\"\"\n\n    ax = fig.gca()\n\n    # Swap y axis if needed\n    alim = list(ax.axis())\n    if alim[3] < alim[2]:\n        temp    = alim[2]\n        alim[2] = alim[3]\n        alim[3] = temp\n        ax.axis(alim)\n\n    ax.set_aspect(\"auto\")\n    fig.show()\n\ndef showfig_aspect_auto_aspect(",
        "\n\ndef _setup_index_range(index, start, stop):\n    \"\"\"Shifts indicies as needed to account for one based indexing\n\n    Positive indicies need to be reduced by one to match with zero based\n    indexing.\n\n    Zero is not a valid input, and as such will throw a value error.\n\n    Arguments:\n        index -     index to shift\n        start -     start index\n        stop -     stop index\n    \"\"\"\n    index = int(index)\n    if index > 0:\n        index -= 1\n    elif index == 0:\n        # Zero indicies should not be allowed by default.\n        raise ValueError\n    return index, start, stop\n\ndef _setup_index_range_range(index, start, stop):\n    \"\"\"Shifts indicies as needed to account for one based indexing\n\n    Positive indicies need to be reduced by one to match with zero based\n    indexing.\n\n    Zero is not a valid input, and as such will throw a value error.\n\n    Arguments:\n        index -     index to shift\n        start -     start index\n        stop -     stop index\n    \"\"\"\n    index = int(index)\n    if index > 0:\n        index -= 1\n    elif index == 0:\n        # Zero indicies should not be allowed by default.\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _cut_range(self, start, end):\n        \"\"\"Returns a list of positions that are within the given range\n\n        Arguments:\n            start -     start position\n            end -     end position\n        \"\"\"\n        return self._extendrange(start, end + 1)\n\ndef _extendrange(self, start, end):\n        \"\"\"Returns a list of positions that are within the given range\n\n        Arguments:\n            start -     start position\n            end -     end position\n        \"\"\"\n        return [start, end]\n\ndef group_val(s):\n        \"\"\"Returns the value of a group of values\n\n        Arguments:\n            s -     string to parse\n        \"\"\"\n        return int(s) if s else None\n\ndef group_val_or_none(s):\n        \"\"\"Returns the value of a group of values or None\n\n        Arguments:\n            s -     string to parse\n        \"\"\"\n        return s if s else None\n\ndef group_val_or_none_or_none(s):\n        \"\"\"Returns the value of a group of values or None or None\n\n        Arguments:\n            s -     string to parse\n        \"\"\"\n        return s if s else None\n\ndef group_val_or_none_or_none_or_none(s):\n        \"\"\"Returns",
        "\n\ndef _setup_index(self, index):\n        \"\"\"Returns index of given character in line\n\n        Arguments:\n            index -  index of character\n        \"\"\"\n        if index < 0:\n            index += len(self.line)\n        return index\n\ndef _setup_index_from_string(self, index):\n        \"\"\"Returns index of given character in line\n\n        Arguments:\n            index -  index of character\n        \"\"\"\n        if index < 0:\n            index += len(self.line)\n        return index\n\ndef _setup_index_from_int(self, index):\n        \"\"\"Returns index of given character in line\n\n        Arguments:\n            index -  index of character\n        \"\"\"\n        if index < 0:\n            index += len(self.line)\n        return index\n\ndef _setup_index_from_float(self, index):\n        \"\"\"Returns index of given character in line\n\n        Arguments:\n            index -  index of character\n        \"\"\"\n        if index < 0:\n            index += len(self.line)\n        return index\n\ndef _setup_index_from_string_with_separator(self, index):\n        \"\"\"Returns index of given character in line\n\n        Arguments:\n            index -  index of character\n        \"\"\"\n        if index <",
        "\n\ndef _extendrange_with_separator(self, start, end):\n        \"\"\"Creates list of values in a range with output delimiters.\n\n        Arguments:\n            start -     range start\n            end -       range end\n        \"\"\"\n        range_positions = []\n        for i in range(start, end):\n            if i != 0:\n                range_positions.append(str(i))\n            if i < end:\n                range_positions.append(self.separator)\n        return range_positions\n\ndef _extendrange_with_separator_and_separator(self, start, end):\n        \"\"\"Creates list of values in a range with output delimiters.\n\n        Arguments:\n            start -     range start\n            end -       range end\n        \"\"\"\n        range_positions = []\n        for i in range(start, end):\n            if i != 0:\n                range_positions.append(str(i))\n            if i < end:\n                range_positions.append(self.separator)\n                range_positions.append(self.separator)\n        return range_positions\n\ndef _extendrange_with_separator_and_separator_and_separator(self, start, end):\n        \"\"\"Creates list of values in a range with output delimiters.\n\n        Arguments:\n            start -     range start\n           ",
        "\n\ndef unlock_file(filename):\n    \"\"\"Unlocks the file by writing a '.lock' file.\n       Returns True when the file is unlocked and\n       False when the file was unlocked already\"\"\"\n\n    lockfile = \"%s.lock\"%filename\n    if isfile(lockfile):\n        with open(lockfile, \"r\") as f:\n            pass\n        return True\n    else:\n        return False\n\ndef isfile(filename):\n    \"\"\"Returns True if the file exists and is readable\"\"\"\n\n    return os.path.isfile(filename) and os.access(filename, os.X_OK)\n\ndef mkdir(path):\n    \"\"\"Creates a directory and returns the path\"\"\"\n\n    return os.makedirs(path)\n\ndef mkdir_p(path):\n    \"\"\"Creates a directory and returns the path\"\"\"\n\n    return os.makedirs(path, exist_ok=True)\n\ndef mkdir_p_recursive(path):\n    \"\"\"Creates a directory and returns the path\"\"\"\n\n    return os.makedirs(path, exist_ok=True, recursive=True)\n\ndef mkdir_p_recursive_recursive(path):\n    \"\"\"Creates a directory and returns the path\"\"\"\n\n    return os.makedirs(path, exist_ok=True, recursive=True, recursive_",
        "\n\ndef lock_file(filename):\n    \"\"\"Locks the file by create a '.lock' file.\n       Returns True when the file is locked and\n       False when the file was locked already\"\"\"\n\n    lockfile = \"%s.lock\"%filename\n    if not isfile(lockfile):\n        os.makedirs(lockfile)\n        return True\n    else:\n        return False\n\ndef isfile(filename):\n    \"\"\"Returns True if the file exists and is readable\"\"\"\n\n    return os.path.isfile(filename) and os.access(filename, os.R_OK)\n\ndef get_file_contents(filename):\n    \"\"\"Returns the contents of the file\"\"\"\n\n    return open(filename, 'r').read()\n\ndef get_file_contents_with_lock(filename):\n    \"\"\"Returns the contents of the file with a lock\"\"\"\n\n    lockfile = \"%s.lock\"%filename\n    if isfile(lockfile):\n        return open(lockfile, 'r').read()\n    else:\n        return None\n\ndef get_file_contents_with_lock_and_unlock(filename):\n    \"\"\"Returns the contents of the file with a lock and unlock\"\"\"\n\n    lockfile = \"%s.lock\"%filename\n    if isfile(lockfile):\n        return open(lockfile, '",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\nclass Solution(object):\n    def pathSum(self, a, b):\n        \"\"\"\n        :type a: List[List[int]]\n        :type b: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not a or not b:\n            return []\n\n        a_hash = hash(a)\n        b_hash = hash(b)\n\n        a_path = self.path(a_hash, b_hash)\n        b_path = self.path(b_hash, a_hash)\n\n        return [a_path + b_path]\n\n\nif __name__ == '__main__':\n    solution = Solution()\n    print solution.pathSum([[1, 2, 3], [4, 5, 6]], [1, 2, 3])\n",
        "\n\n\ndef _rindex_with_index(mylist: Sequence[T], x: T, index: int) -> Sequence[T]:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return mylist[::-1][index]\n\n\ndef _rindex_with_index_with_index(mylist: Sequence[T], x: T, index: int, index2: int) -> Sequence[T]:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return mylist[::-1][index2]\n\n\ndef _rindex_with_index_with_index2(mylist: Sequence[T], x: T, index: int, index2: int, index3: int) -> Sequence[T]:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return mylist[::-1][index3]\n\n\ndef _rindex_with_index_with_index3(mylist: Sequence[T], x: T, index: int, index2: int, index3: int, index4: int) -> Sequence[T]:\n    \"\"\"Index of the last occurrence of x in the sequence.\"\"\"\n    return mylist[::-1][index4]\n\n\ndef _rindex_with_index_with_index4(mylist:",
        "\n\ndef create_superuser(username='superuser', email='superuser@superuser.com', password='superuser'):\n    \"\"\"Create and save a superuser.\n\n    :param username:\n        Superuser account's username.  Defaults to 'superuser'\n    :param email:\n        Superuser account's email address.  Defaults to 'superuser@superuser.com'\n    :param password:\n        Superuser account's password.  Defaults to 'superuser'\n    :returns:\n        Django user with staff and superuser privileges\n    \"\"\"\n    admin = User.objects.create_user(username, email, password)\n    admin.is_staff = True\n    admin.is_superuser = True\n    admin.save()\n    return admin\n\ndef create_staff_user(username='staffuser', email='staffuser@staffuser.com', password='staffuser'):\n    \"\"\"Create and save a staff user.\n\n    :param username:\n        Staff user's username.  Defaults to 'staffuser'\n    :param email:\n        Staff user's email address.  Defaults to 'staffuser@staffuser.com'\n    :param password:\n        Staff user's password.  Defaults to 'staffuser'\n    :returns:\n        Django user with staff and superuser privileges",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef logout(self):\n        \"\"\"Logs out the superuser account.\"\"\"\n        self.client.logout()\n        self.authed = False\n\ndef get_user(self):\n        \"\"\"Returns the current user.\"\"\"\n        return self.client.user\n\ndef get_user_id(self):\n        \"\"\"Returns the current user's ID.\"\"\"\n        return self.client.user.id\n\ndef get_user_name(self):\n        \"\"\"Returns the current user's name.\"\"\"\n        return self.client.user.name\n\ndef get_user_email(self):\n        \"\"\"Returns the current user's email.\"\"\"\n        return self.client.user.email\n\ndef get_user_avatar(self):\n        \"\"\"Returns the current user's avatar.\"\"\"\n        return self.client.user.avatar_url\n\ndef get_user_is_admin(self):\n        \"\"\"Returns True if the current user is an admin.\"\"\"\n        return self.client.user.is_admin\n\ndef get_user_is_staff(self):\n        \"\"\"Returns True if the current user is a staff user.\"\"\"\n        return self.client.user.is_staff\n\ndef get_user_is_superuser(self):\n        \"\"\"Returns True if the current user is a superuser.\"\"\"\n        return self.client.user.is",
        "\n\ndef authed_post(self, url, data=None, response_code=200, headers={}, follow=False):\n        \"\"\"Does a django test client ``post`` against the given url after\n        logging in the admin first.\n\n        :param url:\n            URL to fetch\n        :param data:\n            Data to send in the request\n        :param response_code:\n            Expected response code from the URL fetch.  This value is\n            asserted.  Defaults to 200\n        :param headers:\n            Optional dictionary of headers to send in the request\n        :param follow:\n            When True, the post call will follow any redirect requests.\n            Defaults to False.\n        :returns:\n            Django testing ``Response`` object\n        \"\"\"\n        if not self.authed:\n            self.authorize()\n\n        response = self.client.post(url, data=data, follow=follow, **headers)\n        self.assertEqual(response_code, response.status_code)\n        return response\n\ndef authed_put(self, url, data=None, response_code=200, headers={}, follow=False):\n        \"\"\"Does a django test client ``put`` against the given url after\n        logging in the admin first.\n\n        :param url:\n            URL to fetch\n        :param data:\n",
        "\n\ndef authed_get(self, url, response_code=200, follow=False, headers={}):\n        \"\"\"Does a django test client ``get`` against the given url after\n        logging in the admin first.\n\n        :param url:\n            URL to fetch\n        :param response_code:\n            Expected response code from the URL fetch.  This value is\n            asserted.  Defaults to 200\n        :param headers:\n            Optional dictionary of headers to send in with the request\n        :returns:\n            Django testing ``Response`` object\n        \"\"\"\n        if not self.authed:\n            self.authorize()\n\n        response = self.client.get(url, follow=follow, **headers)\n        self.assertEqual(response_code, response.status_code)\n        return response\n\ndef authed_put(self, url, data, response_code=200, follow=False, headers={}):\n        \"\"\"Does a django test client ``put`` against the given url after\n        logging in the admin first.\n\n        :param url:\n            URL to fetch\n        :param data:\n            Dictionary to form contents to post\n        :param response_code:\n            Expected response code from the URL fetch.  This value is\n            asserted.  Defaults to 200\n        :param headers:\n            Optional",
        "\n\ndef lookup_field(field_name, instance, admin_model):\n        \"\"\"Returns the value displayed in the column on the web interface for\n        a given instance.\n\n        :param field_name:\n            Name of the field/column to fetch\n        :instance:\n            Object instance that is the row in the admin change list\n        :admin_model:\n            Instance of a :class:`admin.ModelAdmin` object that is responsible\n            for displaying the change list\n        \"\"\"\n        try:\n            return admin_model.get_field(field_name).get_display(instance)\n        except AttributeError:\n            return None\n\n\ndef lookup_field_choices(field_name, instance, admin_model):\n        \"\"\"Returns the choices displayed in the column on the web interface for\n        a given instance.\n\n        :param field_name:\n            Name of the field/column to fetch\n        :instance:\n            Object instance that is the row in the admin change list\n        :admin_model:\n            Instance of a :class:`admin.ModelAdmin` object that is responsible\n            for displaying the change list\n        \"\"\"\n        try:\n            return admin_model.get_field(field_name).get_choices(instance)\n        except AttributeError:\n            return None\n\n\ndef lookup_field_choices_",
        "\n\ndef immin(self):\n        \"\"\"\n        Lowest value of input image.\n        \"\"\"\n        if not hasattr(self, '_immin'):\n            immin = _np.min(self.images[0])\n            for img in self.images:\n                immin = _np.min(img)\n                if immin < immin:\n                    immin = immin\n\n            self._immin = immin\n\n        return self._immin\n\ndef immax(self):\n        \"\"\"\n        Highest value of input image.\n        \"\"\"\n        if not hasattr(self, '_immax'):\n            immax = _np.max(self.images[0])\n            for img in self.images:\n                immax = _np.max(img)\n                if immax > immax:\n                    immax = immax\n\n            self._immax = immax\n\n        return self._immax\n\ndef immin(self):\n        \"\"\"\n        Lowest value of input image.\n        \"\"\"\n        if not hasattr(self, '_immin'):\n            immin = _np.min(self.images[0])\n            for img in self.images:\n                immin = _np.min(img)\n                if immin < immin:\n                    im",
        "\n\ndef imgmax(self):\n        \"\"\"\n        Highest value of input image.\n        \"\"\"\n        if not hasattr(self, '_imgmax'):\n            imgmax = _np.max(self.images[0])\n            for img in self.images:\n                imax = _np.max(img)\n                if imax > imgmax:\n                    imgmax = imax\n\n            self._imgmax = imgmax\n        return _np.max(self.image)\n\ndef imgmean(self):\n        \"\"\"\n        Mean value of input image.\n        \"\"\"\n        if not hasattr(self, '_imgmean'):\n            imgmean = _np.mean(self.images[0])\n            for img in self.images:\n                imax = _np.mean(img)\n                if imax > imgmean:\n                    imgmean = imax\n\n            self._imgmean = imgmean\n        return _np.mean(self.image)\n\ndef imgstd(self):\n        \"\"\"\n        Standard deviation of input image.\n        \"\"\"\n        if not hasattr(self, '_imgstd'):\n            imgstd = _np.std(self.images[0])\n            for img in self.images:\n                imax = _np.std(img)\n                if imax >",
        ", *args, **kwargs)\n\ndef wrap_uncaught_greenlet_exceptions(func):\n    \"\"\" wraps a function that does not print exceptions to the screen \"\"\"\n    def wrapped(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except:\n            print \"Caught exception: \", sys.exc_info()[0]\n            return None\n    return wrapped\n\ndef join(func, *args, **kwargs):\n    \"\"\" joins a greenlet that does not print exceptions to the screen \"\"\"\n    return gevent.join(wrap_uncaught_greenlet_exceptions(func), *args, **kwargs)\n\ndef joinall(func, *args, **kwargs):\n    \"\"\" joins a greenlet that does not print exceptions to the screen \"\"\"\n    return gevent.joinall(wrap_uncaught_greenlet_exceptions(func), *args, **kwargs)\n\ndef joinall_with_timeout(func, *args, **kwargs):\n    \"\"\" joins a greenlet that does not print exceptions to the screen \"\"\"\n    return gevent.joinall_with_timeout(wrap_uncaught_greenlet_exceptions(func), *args, **kwargs)\n\ndef joinall_with_timeout_and_exception(func, *args, **kwargs):\n    \"\"\" joins a greenlet that does not",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef open_s3_with_key(bucket, key):\n    \"\"\"\n    Opens connection to S3 returning bucket and key\n    \"\"\"\n    conn = boto.connect_s3(options.paved.s3.access_id, options.paved.s3.secret)\n    try:\n        bucket = conn.get_bucket(bucket)\n    except boto.exception.S3ResponseError:\n        bucket = conn.create_bucket(bucket)\n    return bucket, key\n\ndef open_s3_with_key_and_bucket(bucket, key, bucket):\n    \"\"\"\n    Opens connection to S3 returning bucket and key\n    \"\"\"\n    conn = boto.connect_s3(options.paved.s3.access_id, options.paved.s3.secret)\n    try:\n        bucket = conn.get_bucket(bucket)\n    except boto.exception.S3ResponseError:\n        bucket = conn.create_bucket(bucket)\n    return bucket, key\n\ndef open_s3_with_key_and_bucket_and_key(bucket, key, bucket, key):\n    \"\"\"\n    Opens connection to S3 returning bucket and key\n    \"\"\"\n    conn = boto.connect_s3(options.paved.s3.access_id,",
        " Exception(\"Failed to upload %s\" % (file_key))\n\n        info(\"Uploaded %s to %s\" % (file_key, bucket_name))\n\n    info(\"Finished uploading %s to %s\" % (file_key, bucket_name))\n\n\ndef upload_s3_to_s3(file_path, bucket_name, file_key, force=False, acl='private'):\n    \"\"\"Upload a local file to S3.\n    \"\"\"\n    file_path = path(file_path)\n    bucket = open_s3(bucket_name)\n\n    if file_path.isdir():\n        # Upload the contents of the dir path.\n        paths = file_path.listdir()\n        paths_keys = list(zip(paths, ['%s/%s' % (file_key, p.name) for p in paths]))\n    else:\n        # Upload just the given file path.\n        paths_keys = [(file_path, file_key)]\n\n    for p, k in paths_keys:\n        headers = {}\n        s3_key = bucket.get_key(k)\n        if not s3_key:\n            from boto.s3.key import Key\n            s3_key = Key(bucket, k)\n\n        content_",
        " raise\n\n    info(\"Done.\")\n\n\ndef upload_s3(bucket_name, file_key, file_path, force=False):\n    \"\"\"Upload a remote file to S3.\n    \"\"\"\n    file_path = path(file_path)\n    bucket = open_s3(bucket_name)\n\n    info(\"Uploading %s...\" % (file_key))\n\n    try:\n        with open(file_path, 'rb') as fo:\n            s3_key = bucket.new_key(file_key)\n            s3_key.set_contents_from_file(fo)\n    except Exception as e:\n        error(\"Failed: %s\" % e)\n        raise\n\n    info(\"Done.\")\n\n\ndef delete_s3(bucket_name, file_key):\n    \"\"\"Delete a remote file from S3.\n    \"\"\"\n    bucket = open_s3(bucket_name)\n\n    info(\"Deleting %s...\" % (file_key))\n\n    try:\n        bucket.delete_key(file_key)\n    except Exception as e:\n        error(\"Failed: %s\" % e)\n        raise\n\n    info(\"Done.\")\n\n\ndef open_s3(bucket_name):\n    \"\"\"Open a S3",
        "\n\ndef delete_ical(request, slug):\n    \"\"\" Deletes an ical .ics file for an event using python-card-me. \"\"\"\n    event = get_object_or_404(Event, slug=slug)\n    event.delete()\n    return HttpResponse(status=204)\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        self._sxxp_n = alpha*self.emit_n\n\ndef set_Courant_Snyder_n(self, beta, alpha, emit=None, emit_n=None):\n        \"\"\"\n        Sets the beam moments indirectly using Courant-Snyder parameters.\n\n        Parameters\n        ----------\n        beta : float\n            Courant-Snyder parameter :math:`\\\\beta`.\n        alpha : float\n            Courant-Snyder parameter :math:`\\\\alpha`.\n        emit : float\n            Beam emittance :math:`\\\\epsilon`.\n        emit_n : float\n            Normalized beam emittance :math:`\\\\gamma \\\\epsilon`.\n        \"\"\"\n\n        self._store_emit(emit=emit, emit_n=emit_n)\n        \n        self._sx   = _np.sqrt(beta*self.emit)\n        self._sxp  = _np.sqrt((1+alpha**2)/beta*self.emit)\n        self._sxxp = -alpha*self.emit\n        self._sxxp_n = alpha*self.emit_n\n\ndef set_Courant_Snyder_n_n(self, beta, alpha, emit=None, emit_n=None):\n        \"\"\"\n        Sets",
        "\n\n\ndef normalize_slice_list(slice_list, length):\n    \"\"\"\n    Given a list of slice objects, return appropriate values for use in the range function\n\n    :param slice_list: The list of slice objects or integers provided in the `[]` notation\n    :param length: For negative indexing we need to know the max length of the object.\n    \"\"\"\n    if isinstance(slice_list, list):\n        start, stop, step = slice_list[0], slice_list[1], slice_list[2]\n        if start is None:\n            start = 0\n\n        if stop is None:\n            stop = length\n\n        if step is None:\n            step = 1\n\n        if start < 0:\n            start += length\n\n        if stop < 0:\n            stop += length\n    elif isinstance(slice_list, int):\n        start = slice_list\n        if start < 0:\n            start += length\n        stop = start + 1\n        step = 1\n    else:\n        raise TypeError\n\n    if (0 <= start <= length) and (0 <= stop <= length):\n        return start, stop, step\n\n    raise IndexError\n\n\ndef normalize_slice_dict(slice_dict, length):\n    \"\"\"\n    Given a dictionary of slice objects, return appropriate values for use",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.internal.nio.Connection;\nimport com.hazelcast.internal.nio.ConnectionState;\nimport com.hazelcast.internal.protocol.ClientMessage;\nimport com.hazelcast.internal.protocol.codec.MapRemove",
        "\n\nclass EventForm(forms.ModelForm):\n    \"\"\"\n    A form for creating a new event.\n    \"\"\"\n    class Meta:\n        model = Event\n        fields = ('name', 'start_date', 'description')\n\n    def clean(self):\n        cleaned = super(EventForm, self).clean()\n        if cleaned['name'] == '':\n            raise forms.ValidationError(u'Please enter a name.')\n        if cleaned['start_date'] == '':\n            raise forms.ValidationError(u'Please enter a start date.')\n        if cleaned['description'] == '':\n            raise forms.ValidationError(u'Please enter a description.')\n        return cleaned\n\nclass EventDetailForm(forms.ModelForm):\n    \"\"\"\n    A form for editing an existing event.\n    \"\"\"\n    class Meta:\n        model = Event\n        fields = ('name', 'start_date', 'description')\n\n    def clean(self):\n        cleaned = super(EventDetailForm, self).clean()\n        if cleaned['name'] == '':\n            raise forms.ValidationError(u'Please enter a name.')\n        if cleaned['start_date'] == '':\n            raise forms.ValidationError(u'Please enter a start date.')\n        if cleaned['description'] == '':\n            raise forms.ValidationError",
        "\n\n\nclass GeventLoop(object):\n    \"\"\"\n    A `GeventLoop` object that spawns a greenlet that sleeps for `interval` seconds between `callback` executions.\n    When leaving the context stops the greenlet.\n    The yielded object is the `GeventLoop` object so the loop can be stopped from within the context.\n\n    For example:\n    ```\n    with loop_in_background(60.0, purge_cache) as purge_cache_job:\n        ...\n        ...\n        if should_stop_cache():\n            purge_cache_job.stop()\n    ```\n    \"\"\"\n    def __init__(self, interval, callback):\n        self.interval = interval\n        self.callback = callback\n        self.started = False\n\n    def start(self):\n        self.started = True\n        self.callback()\n\n    def stop(self):\n        self.started = False\n        self.callback()\n\n    def has_started(self):\n        return self.started\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.stop()\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".spawn(self._loop)\n        self._started = True\n        self._loop.start()\n\n    def stop(self):\n        \"\"\"\n        Stops the loop. Calling a stopped loop is an error.\n        \"\"\"\n        assert self.has_started(), \"called stop() on an active GeventLoop\"\n        self._stop_event.set()\n        self._loop.stop()\n        self._started = False\n\n    def has_started(self):\n        \"\"\"\n        Returns True if the loop has been started.\n        \"\"\"\n        return self._started\n\n    def _loop(self):\n        \"\"\"\n        The main loop.\n        \"\"\"\n        while not self._stop_event.is_set():\n            try:\n                self._loop.join()\n            except KeyboardInterrupt:\n                self._stop_event.set()\n                break\n\n    def __del__(self):\n        \"\"\"\n        Stops the loop. Calling a stopped loop is an error.\n        \"\"\"\n        self.stop()\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the loop.\n        \"\"\"\n        return \"GeventLoop\"\n\n    def __repr__(self):\n        \"\"\"\n        Returns a string representation of the loop.\n        \"\"\"\n        return \"GeventLoop",
        ".join()\n\ndef run(self, *args, **kwargs):\n        \"\"\"Runs the running loop.\n\n        :param args: The arguments to pass to the loop.\n        :param kwargs: The keyword arguments to pass to the loop.\n        \"\"\"\n        assert self.has_started(), \"called run() on a non-active GeventLoop\"\n        self._stop_event.clear()\n        self._greenlet.run(*args, **kwargs)\n        self._clear()\n\ndef run_until_stopped(self, *args, **kwargs):\n        \"\"\"Runs the running loop until it has stopped.\n\n        :param args: The arguments to pass to the loop.\n        :param kwargs: The keyword arguments to pass to the loop.\n        \"\"\"\n        assert self.has_started(), \"called run_until_stopped() on a non-active GeventLoop\"\n        self._stop_event.clear()\n        self._greenlet.run_until_stopped(*args, **kwargs)\n        self._clear()\n\ndef run_until_stopped_or_timeout(self, *args, **kwargs):\n        \"\"\"Runs the running loop until it has stopped or timed out.\n\n        :param args: The arguments to pass to the loop.\n        :param kwargs: The keyword arguments to pass to the loop.\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef _regex_replacement_with_regex(self, target, replacement, regex):\n      \"\"\"Regex substitute target with replacement with regex\"\"\"\n      match = re.compile(target)\n      self.data = match.sub(replacement, self.data, regex)\n\ndef _regex_replacement_with_regex_with_regex(self, target, replacement, regex, regex_with_regex):\n      \"\"\"Regex substitute target with replacement with regex with regex\"\"\"\n      match = re.compile(target)\n      self.data = match.sub(replacement, self.data, regex_with_regex, regex)\n\ndef _regex_replacement_with_regex_with_regex_with_regex(self, target, replacement, regex, regex_with_regex, regex_with_regex_with_regex):\n      \"\"\"Regex substitute target with replacement with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with regex with",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _REPLACERS(self):\n      \"\"\"Returns a list of tuples of the form (rule, replacement).\n      Each tuple is a list of strings, where each string is a regular expression.\n      Each string is a replacement string.\n      \"\"\"\n      return [\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],\n          [r\"(^|\\s)\", r\"$1\"],",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.GetOperation;\nimport com.hazelcast.",
        "\n                })\n\n        return True\n\n    def __cut_to_size(self):\n        \"\"\"Cut the tasks to the size of the server\"\"\"\n        return self.__cut_to_size(self.size)\n\n    def __cut_to_size(self, size):\n        \"\"\"Cut the tasks to the size of the server\"\"\"\n        return self.__cut_to_size(size, self.size)\n\n    def __cut_to_size(self, size, size_limit):\n        \"\"\"Cut the tasks to the size of the server\"\"\"\n        return self.__cut_to_size(size, size_limit, self.size)\n\n    def __cut_to_size(self, size, size_limit, size_limit):\n        \"\"\"Cut the tasks to the size of the server\"\"\"\n        return self.__cut_to_size(size, size_limit, size_limit, self.size)\n\n    def __cut_to_size(self, size, size_limit, size_limit, size):\n        \"\"\"Cut the tasks to the size of the server\"\"\"\n        return self.__cut_to_size(size, size_limit, size_limit, size, self.size)\n\n    def __cut_to_size(self, size, size_limit, size_limit, size,",
        "\n                })\n\n        for chunk in self.__cut_to_size():\n            server.delete(\n                'tasks_admin',\n                chunk.as_payload(),\n                replacements={\n                    'slug': chunk.challenge.slug})\n\n        for chunk in self.__cut_to_size():\n            server.delete(\n                'tasks_admin',\n                chunk.as_payload(),\n                replacements={\n                    'slug': chunk.challenge.slug})\n\n        for chunk in self.__cut_to_size():\n            server.delete(\n                'tasks_admin',\n                chunk.as_payload(),\n                replacements={\n                    'slug': chunk.challenge.slug})\n\n        for chunk in self.__cut_to_size():\n            server.delete(\n                'tasks_admin',\n                chunk.as_payload(),\n                replacements={\n                    'slug': chunk.challenge.slug})\n\n        for chunk in self.__cut_to_size():\n            server.delete(\n                'tasks_admin',\n                chunk.as_payload(),\n                replacements={\n                    'slug': chunk.challenge.slug})\n\n        for chunk in self.__cut_to_size():\n            server.delete(\n                'tasks_admin',\n                chunk.as_payload(),\n                replacements={\n                    'slug': chunk",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        " else:\n        return False\n\n\ndef yes_no_prompt(msg, default=True):\n    \"\"\"\n    Prompts the user for yes or no.\n    \"\"\"\n    ret = custom_prompt(msg, [\"y\", \"n\"], \"y\" if default else \"n\")\n    if ret == \"y\":\n        return True\n    else:\n        return False\n\n\ndef custom_prompt(msg, choices, default):\n    \"\"\"\n    Prompts the user for a choice.\n    \"\"\"\n    while True:\n        choice = input(msg + \" [y/n]: \")\n        if choice in choices:\n            return choice\n        else:\n            print \"Invalid choice: \" + choice\n            return default\n\n\ndef get_user_input(msg):\n    \"\"\"\n    Returns the user's input.\n    \"\"\"\n    return input(msg + \" [y/n]: \")\n\n\ndef get_user_input_with_default(msg, default):\n    \"\"\"\n    Returns the user's input with a default.\n    \"\"\"\n    return get_user_input(msg) + \" \" + default\n\n\ndef get_user_input_with_default_and_choices(msg, default, choices):\n    \"\"\"\n    Returns the user's input with a default and choices.\n    \"\"\"\n",
        "\n\ndef prompt(msg, options, default):\n    \"\"\"\n    Prompts the user with custom options.\n    \"\"\"\n    return custom_prompt(msg, options, default)\n\ndef confirm(msg, options, default):\n    \"\"\"\n    Prompts the user with custom options.\n    \"\"\"\n    return custom_prompt(msg, options, default)\n\ndef ask(msg, options, default):\n    \"\"\"\n    Prompts the user with custom options.\n    \"\"\"\n    return custom_prompt(msg, options, default)\n\ndef ask_yes(msg, options, default):\n    \"\"\"\n    Prompts the user with custom options.\n    \"\"\"\n    return custom_prompt(msg, options, default)\n\ndef ask_no(msg, options, default):\n    \"\"\"\n    Prompts the user with custom options.\n    \"\"\"\n    return custom_prompt(msg, options, default)\n\ndef ask_yes_no(msg, options, default):\n    \"\"\"\n    Prompts the user with custom options.\n    \"\"\"\n    return custom_prompt(msg, options, default)\n\ndef ask_yes_no_multiple(msg, options, default):\n    \"\"\"\n    Prompts the user with custom options.\n    \"\"\"\n    return custom_prompt(msg, options, default)\n\ndef ask_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        self._guesses_made = 0\n        self._guesses_remaining = mode.guesses_allowed\n        self._guesses_made_remaining = mode.guesses_allowed\n        self._guesses_made_made = 0\n        self._guesses_remaining_made = mode.guesses_allowed\n        self._guesses_made_made_remaining = mode.guesses_allowed\n        self._guesses_remaining_made_made = 0\n        self._guesses_remaining_made_made_remaining = mode.guesses_allowed\n        self._guesses_remaining_made_made_remaining = mode.guesses_allowed\n        self._guesses_remaining_made_made_remaining = mode.guesses_allowed\n        self._guesses_remaining_made_made_remaining = mode.guesses_allowed\n        self._guesses_remaining_made_made_remaining = mode.guesses_allowed\n        self._guesses_remaining_made_made_remaining = mode.guesses_allowed\n        self._guesses_remaining_made_made_remaining = mode.guesses_allowed\n        self._guesses_remaining_made_made_remaining = mode.guesses_allowed\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\ndef from_string(s):\n        \"\"\"\n        Returns a Tag object from a string\n        \"\"\"\n        t = Tag(s.split('.')[0], int(s.split('.')[1]), int(s.split('.')[2]))\n        if s.split('.')[3] != None:\n            t.revision = Revision.from_string(s.split('.')[3])\n        return t\n\ndef from_revision(r):\n        \"\"\"\n        Returns a Tag object from a revision\n        \"\"\"\n        t = Tag(r.version.major, r.version.minor, r.version.patch)\n        if r.revision is not None:\n            t.revision = r.revision.clone()\n        return t\n\ndef from_revision_string(s):\n        \"\"\"\n        Returns a Tag object from a revision string\n        \"\"\"\n        t = Tag(s.split('.')[0], int(s.split('.')[1]), int(s.split('.')[2]))\n        if s.split('.')[3] != None:\n            t.revision = Revision.from_string(s.split('.')[3])\n        return t\n\ndef from_revision_revision(r):\n        \"\"\"\n        Returns a Tag object from a revision revision\n        \"\"\"\n       ",
        "\n        return t\n\nclass Revision(object):\n    \"\"\"\n    Represents a revision of a tag\n    \"\"\"\n    def __init__(self, label, number):\n        self.label = label\n        self.number = number\n\n    def __str__(self):\n        return \"Revision %s %s\" % (self.label, self.number)\n\nclass Tag(object):\n    \"\"\"\n    Represents a tag\n    \"\"\"\n    def __init__(self, label, number):\n        self.label = label\n        self.number = number\n\n    def __str__(self):\n        return \"Tag %s %s\" % (self.label, self.number)\n\nclass TagList(object):\n    \"\"\"\n    Represents a list of tags\n    \"\"\"\n    def __init__(self, tags):\n        self.tags = tags\n\n    def __str__(self):\n        return \"TagList %s\" % self.tags\n\nclass TagSet(object):\n    \"\"\"\n    Represents a set of tags\n    \"\"\"\n    def __init__(self, tags):\n        self.tags = tags\n\n    def __str__(self):\n        return \"TagSet %s\" % self.tags\n\nclass TagSetIterator(object):\n",
        "\n\ndef parse_revision(s):\n        \"\"\"\n        Parses a string into a Tag\n        \"\"\"\n        try:\n            m = _regex.match(s)\n            t = Tag(int(m.group('major')),\n                    int(m.group('minor')),\n                    int(m.group('patch')))\n            return t \\\n                    if m.group('label') is None \\\n                    else t.with_revision(m.group('label'), int(m.group('number')))\n        except AttributeError:\n            return None\n\ndef parse_tag(s):\n        \"\"\"\n        Parses a string into a Tag\n        \"\"\"\n        try:\n            m = _regex.match(s)\n            t = Tag(int(m.group('major')),\n                    int(m.group('minor')),\n                    int(m.group('patch')))\n            return t \\\n                    if m.group('label') is None \\\n                    else t.with_revision(m.group('label'), int(m.group('number')))\n        except AttributeError:\n            return None\n\ndef parse_tag_revision(s):\n        \"\"\"\n        Parses a string into a Tag\n        \"\"\"\n        try:\n            m = _regex.match(s)\n            t = Tag(",
        "\n\n    plt.show()\n\ndef main():\n    \"\"\"Main function.\"\"\"\n\n    tile()\n\nif __name__ == '__main__':\n    main()\n",
        "\n\ndef delete_time(sender, **kwargs):\n    \"\"\"\n    When a Comment is deleted, updates the Update to set \"last_updated\" time\n    \"\"\"\n    comment = kwargs['instance']\n    if comment.content_type.app_label == \"happenings\" and comment.content_type.name == \"Update\":\n        from .models import Update\n        item = Update.objects.get(id=comment.object_pk)\n        item.save()\n\ndef comment_reply(sender, **kwargs):\n    \"\"\"\n    When a Comment is added, updates the Update to set \"last_updated\" time\n    \"\"\"\n    comment = kwargs['instance']\n    if comment.content_type.app_label == \"happenings\" and comment.content_type.name == \"Update\":\n        from .models import Update\n        item = Update.objects.get(id=comment.object_pk)\n        item.save()\n\ndef comment_reply_comment(sender, **kwargs):\n    \"\"\"\n    When a Comment is deleted, updates the Update to set \"last_updated\" time\n    \"\"\"\n    comment = kwargs['instance']\n    if comment.content_type.app_label == \"happenings\" and comment.content_type.name == \"Update\":\n        from .models import Update",
        "\n\ndef extra_template_context(request):\n    \"\"\"Adds useful global items to the context for use in templates.\n\n    * *request*: the request object\n    * *TEMPLATE_NAME*: name of the template\n    * *TEMPLATE_DIR*: path to the template directory\n    * *TEMPLATE_LOADER*: loader to use for the template\n    * *TEMPLATE_CONTEXT*: context for the template\n    \"\"\"\n    d = {\n        'request':request,\n        'TEMPLATE_NAME':request.GET.get('TEMPLATE_NAME', 'index.html'),\n        'TEMPLATE_DIR':request.GET.get('TEMPLATE_DIR', 'templates'),\n        'TEMPLATE_LOADER':request.GET.get('TEMPLATE_LOADER', 'django.template.loaders.filesystem.Loader'),\n        'TEMPLATE_CONTEXT':extra_context(request),\n    }\n\n    return d\n\ndef extra_template_name(request):\n    \"\"\"Adds useful global items to the context for use in templates.\n\n    * *request*: the request object\n    * *TEMPLATE_NAME*: name of the template\n    * *TEMPLATE_DIR*: path to the template directory\n    * *TEMPLATE_LOADER*: loader to use for the template\n    * *TEMPLATE_CONTEXT*: context for the template\n    \"\"\"\n",
        "\n        )\n\n    def as_payload(self):\n        \"\"\"Return the challenge as a json payload\"\"\"\n\n        return {\n            'slug': self.slug,\n            'name': self.name,\n            'description': self.description,\n            'start_date': self.start_date,\n            'end_date': self.end_date,\n            'start_time': self.start_time,\n            'end_time': self.end_time,\n            'start_date_type': self.start_date_type,\n            'end_date_type': self.end_date_type,\n            'start_time_type': self.start_time_type,\n            'end_time_type': self.end_time_type,\n            'start_date_format': self.start_date_format,\n            'end_date_format': self.end_date_format,\n            'start_time_format': self.start_time_format,\n            'end_time_format': self.end_time_format,\n            'start_date_timezone': self.start_date_timezone,\n            'end_date_timezone': self.end_date_timezone,\n            'start_time_timezone': self.start_time_timezone,\n            'end",
        "\n        )\n\n    def as_payload(self):\n        \"\"\"Return a JSON representation of the challenge\"\"\"\n\n        return {\n            'slug': self.slug,\n            'name': self.name,\n            'description': self.description,\n            'status': self.status,\n            'created_at': self.created_at,\n            'updated_at': self.updated_at,\n            'user_id': self.user_id,\n            'user_name': self.user_name,\n            'user_email': self.user_email,\n            'user_avatar': self.user_avatar,\n            'user_avatar_url': self.user_avatar_url,\n            'user_avatar_url_https': self.user_avatar_url_https,\n            'user_avatar_url_http': self.user_avatar_url_http,\n            'user_avatar_url_https_https': self.user_avatar_url_https_https,\n            'user_avatar_url_http_https': self.user_avatar_url_http_https,\n            'user_avatar_url_http_http': self.user_avatar_url_http_http,\n            'user_avatar_url_https_http': self.user_avatar_url_https",
        "\n        return True\n\ndef get_challenge(self, server):\n        \"\"\"Get a challenge from the server\"\"\"\n\n        try:\n            challenge = server.get(\n                'challenge',\n                replacements={'slug': self.slug})\n        except Exception:\n            return False\n\n        return challenge\n\ndef get_challenge_by_slug(self, server):\n        \"\"\"Get a challenge by slug from the server\"\"\"\n\n        try:\n            challenge = server.get(\n                'challenge',\n                replacements={'slug': self.slug})\n        except Exception:\n            return False\n\n        return challenge\n\ndef get_challenge_by_id(self, server):\n        \"\"\"Get a challenge by id from the server\"\"\"\n\n        try:\n            challenge = server.get(\n                'challenge',\n                replacements={'id': self.id})\n        except Exception:\n            return False\n\n        return challenge\n\ndef get_challenge_by_name(self, server):\n        \"\"\"Get a challenge by name from the server\"\"\"\n\n        try:\n            challenge = server.get(\n                'challenge',\n                replacements={'name': self.name})\n        except Exception:\n            return False\n\n        return challenge\n\ndef get_challenge_by_description(self, server):\n        \"\"\"Get a challenge",
        "\n\ndef get_positions(self):\n        \"\"\"\n        Returns all positions.\n\n        http://dev.wheniwork.com/#get-all-positions\n        \"\"\"\n        url = \"/2/positions\"\n\n        return self.positions_from_json(self._get_resource(url)[\"positions\"])\n\ndef get_position_by_id(self, position_id):\n        \"\"\"\n        Returns position data.\n\n        http://dev.wheniwork.com/#get-existing-position\n        \"\"\"\n        url = \"/2/positions/%s\" % position_id\n\n        return self.position_from_json(self._get_resource(url)[\"position\"])\n\ndef get_positions_by_category(self, category_id):\n        \"\"\"\n        Returns all positions.\n\n        http://dev.wheniwork.com/#get-all-positions\n        \"\"\"\n        url = \"/2/positions/%s/categories/%s\" % (category_id, category_id)\n\n        return self.positions_from_json(self._get_resource(url)[\"positions\"])\n\ndef get_position_by_name(self, name):\n        \"\"\"\n        Returns position data.\n\n        http://dev.wheniwork.com/#get-existing-position\n        \"\"\"",
        "\ndef get_positions_by_name(self, name):\n        \"\"\"\n        Returns a list of positions by name.\n\n        http://dev.wheniwork.com/#listing-positions-by-name\n        \"\"\"\n        url = \"/2/positions/%s\" % name\n\n        data = self._get_resource(url)\n        positions = []\n        for entry in data['positions']:\n            positions.append(self.position_from_json(entry))\n\n        return positions\n\ndef get_positions_by_id(self, id):\n        \"\"\"\n        Returns a list of positions by id.\n\n        http://dev.wheniwork.com/#listing-positions-by-id\n        \"\"\"\n        url = \"/2/positions/%s\" % id\n\n        data = self._get_resource(url)\n        positions = []\n        for entry in data['positions']:\n            positions.append(self.position_from_json(entry))\n\n        return positions\n\ndef get_positions_by_slug(self, slug):\n        \"\"\"\n        Returns a list of positions by slug.\n\n        http://dev.wheniwork.com/#listing-positions-by-slug\n        \"\"\"\n        url = \"/2/positions/%s\" % slug\n\n        data = self._get_resource",
        "\ndef update_position(self, params={}):\n        \"\"\"\n        Updates a position\n\n        http://dev.wheniwork.com/#create-update-position\n        \"\"\"\n        url = \"/2/positions/\"\n        body = params\n\n        data = self._post_resource(url, body)\n        return self.position_from_json(data[\"position\"])\n\ndef delete_position(self, params={}):\n        \"\"\"\n        Deletes a position\n\n        http://dev.wheniwork.com/#create-update-position\n        \"\"\"\n        url = \"/2/positions/\"\n        body = params\n\n        data = self._delete_resource(url, body)\n        return self.position_from_json(data[\"position\"])\n\ndef get_positions(self, params={}):\n        \"\"\"\n        Returns all positions\n\n        http://dev.wheniwork.com/#get-positions\n        \"\"\"\n        url = \"/2/positions/\"\n        body = params\n\n        data = self._get_resource(url, body)\n        return self.positions_from_json(data[\"positions\"])\n\ndef get_position(self, params={}):\n        \"\"\"\n        Returns a position\n\n        http://dev.wheniwork.com/#get-position\n        \"\"\"\n        url = \"/",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        " False\n\ndef is_color(value):\n    \"\"\"Returns True if the value given is a valid CSS color, i.e. matches one\n    of the regular expressions in the module or is in the list of\n    predetefined values by the browser.\n    \"\"\"\n    global PREDEFINED, HEX_MATCH, RGB_MATCH, RGBA_MATCH, HSL_MATCH, HSLA_MATCH\n    value = value.strip()\n\n    # hex match\n    if HEX_MATCH.match(value) or RGB_MATCH.match(value) or \\\n            RGBA_MATCH.match(value) or HSL_MATCH.match(value) or \\\n            HSLA_MATCH.match(value) or value in PREDEFINED:\n        return True\n\n    return False\n\ndef is_color_rgb(value):\n    \"\"\"Returns True if the value given is a valid CSS color, i.e. matches one\n    of the regular expressions in the module or is in the list of\n    predetefined values by the browser.\n    \"\"\"\n    global PREDEFINED, HEX_MATCH, RGB_MATCH, RGBA_MATCH, HSL_MATCH, HSLA_MATCH\n    value = value.strip()\n\n    # hex match\n    if HEX_MATCH.match(value) or RGB_MATCH.match(value) or \\\n",
        "\n\n\ndef reynolds_number_from_sea_water(length, speed, temperature=25):\n    \"\"\"\n    Reynold number utility function that return Reynold number for vehicle at specific length and speed.\n    Optionally, it can also take account of temperature effect of sea water.\n\n        Kinematic viscosity from: http://web.mit.edu/seawater/2017_MIT_Seawater_Property_Tables_r2.pdf\n\n    :param length: metres length of the vehicle\n    :param speed: m/s speed of the vehicle\n    :param temperature: degree C \n    :return: Reynolds number of the vehicle (dimensionless)\n    \"\"\"\n    kinematic_viscosity = interpolate.interp1d([0, 10, 20, 25, 30, 40],\n                                               np.array([18.54, 13.60, 10.50, 9.37, 8.42, 6.95]) / 10 ** 7)\n    # Data from http://web.mit.edu/seawater/2017_MIT_Seawater_Property_Tables_r2.pdf\n    Re = length * speed / kinematic_viscosity(temperature)\n    return Re\n\n\ndef reynolds_number_from",
        "\n\n\ndef froude_number_from_speed(speed):\n    \"\"\"\n    Froude number utility function that return Froude number for vehicle at specific speed.\n\n    :param speed: m/s speed of the vehicle\n    :return: Froude number of the vehicle (dimensionless)\n    \"\"\"\n    g = 9.80665  # conventional standard value m/s^2\n    Fr = speed / np.sqrt(g * speed)\n    return Fr\n\n\ndef froude_number_from_length(length):\n    \"\"\"\n    Froude number utility function that return Froude number for vehicle at specific length.\n\n    :param length: metres length of the vehicle\n    :return: Froude number of the vehicle (dimensionless)\n    \"\"\"\n    g = 9.80665  # conventional standard value m/s^2\n    Fr = length / np.sqrt(g * length)\n    return Fr\n\n\ndef froude_number_from_speed_and_length(speed, length):\n    \"\"\"\n    Froude number utility function that return Froude number for vehicle at specific speed and length.\n\n    :param speed: m/s speed of the vehicle\n    :param length: metres length of the vehicle\n    :return: Fro",
        "\n\ndef cr(slenderness, prismatic_coef, froude_number):\n    \"\"\"\n    Computes residual resistance coefficient of the ship.\n\n    :param slenderness: Slenderness coefficient dimensionless :math:`L/(\u2207^{1/3})` where L is length of ship, \u2207 is displacement\n    :param prismatic_coef: Prismatic coefficient dimensionless :math:`\u2207/(L\\cdot A_m)` where L is length of ship, \u2207 is displacement Am is midsection area of the ship\n    :param froude_number: Froude number of the ship dimensionless \n    :return: Residual resistance of the ship\n    \"\"\"\n    return slenderness * prismatic_coef * froude_number\n\ndef cr_nearest(slenderness, prismatic_coef, froude_number):\n    \"\"\"\n    Computes residual resistance coefficient of the ship.\n\n    :param slenderness: Slenderness coefficient dimensionless :math:`L/(\u2207^{1/3})` where L is length of ship, \u2207 is displacement\n    :param prismatic_coef: Prismatic coefficient dimensionless :math:`\u2207/(L\\cdot A",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "\n\ndef surface_area(self):\n        \"\"\"\n        Return surface area of the ship.\n\n        :return: surface area of the ship\n        \"\"\"\n        return self.surface_area_factor * self.surface_area\n\ndef surface_area_factor(self):\n        \"\"\"\n        Return surface area factor of the ship.\n\n        :return: surface area factor of the ship\n        \"\"\"\n        return self.surface_area_factor\n\ndef surface_area_factor_factor(self):\n        \"\"\"\n        Return surface area factor factor of the ship.\n\n        :return: surface area factor factor of the ship\n        \"\"\"\n        return self.surface_area_factor_factor\n\ndef surface_area_factor_factor_factor(self):\n        \"\"\"\n        Return surface area factor factor factor of the ship.\n\n        :return: surface area factor factor factor of the ship\n        \"\"\"\n        return self.surface_area_factor_factor_factor\n\ndef surface_area_factor_factor_factor(self):\n        \"\"\"\n        Return surface area factor factor factor of the ship.\n\n        :return: surface area factor factor factor of the ship\n        \"\"\"\n        return self.surface_area_factor_factor_factor_factor\n\ndef surface_area_factor_factor_factor_factor(self):\n        \"\"\"",
        "\n\ndef maximum_deck_area_with_water_plane(self, water_plane_coef=0.88):\n        \"\"\"\n        Return the maximum deck area of the ship\n\n        :param water_plane_coef: optional water plane coefficient\n        :return: Area of the deck\n        \"\"\"\n        AD = self.beam * self.length * water_plane_coef\n        return AD\n\ndef maximum_deck_area_with_water_plane_with_water_plane_coef(self, water_plane_coef=0.88, water_plane_coef_coef=0.88):\n        \"\"\"\n        Return the maximum deck area of the ship\n\n        :param water_plane_coef: optional water plane coefficient\n        :param water_plane_coef_coef: optional water plane coefficient\n        :return: Area of the deck\n        \"\"\"\n        AD = self.beam * self.length * water_plane_coef * water_plane_coef\n        return AD\n\ndef maximum_deck_area_with_water_plane_with_water_plane_coef_with_water_plane_coef(self, water_plane_coef=0.88, water_plane_coef_coef=0.88, water_plane_coef_coef_coef=0.88):\n        \"\"\"",
        "\n\ndef prop_power_for_sea(self, propulsion_eff=0.7, sea_margin=0.2):\n        \"\"\"\n        Total propulsion power of the ship.\n\n        :param propulsion_eff: Shaft efficiency of the ship\n        :param sea_margin: Sea margin take account of interaction between ship and the sea, e.g. wave\n        :return: Watts shaft propulsion power of the ship\n        \"\"\"\n        PP = (1 + sea_margin) * self.resistance() * self.speed/propulsion_eff\n        return PP\n\ndef prop_power_for_sea_with_water(self, propulsion_eff=0.7, sea_margin=0.2):\n        \"\"\"\n        Total propulsion power of the ship.\n\n        :param propulsion_eff: Shaft efficiency of the ship\n        :param sea_margin: Sea margin take account of interaction between ship and the sea, e.g. wave\n        :return: Watts shaft propulsion power of the ship\n        \"\"\"\n        PP = (1 + sea_margin) * self.resistance() * self.speed/prop",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_zip(self, exercise, file, params):\n        \"\"\"\n        Get zipfile from TMC for given exercise\n        \"\"\"\n\n        resp = self.get(\n            exercise.return_url,\n            params=params,\n            files={\n                \"submission[file]\": ('submission.zip', file)\n            },\n            data={\n                \"commit\": \"Submit\"\n            }\n        )\n        return self._to_json(resp)\n\ndef get_zip_by_id(self, exercise, id, params):\n        \"\"\"\n        Get zipfile from TMC for given exercise\n        \"\"\"\n\n        resp = self.get(\n            exercise.return_url,\n            params=params,\n            files={\n                \"submission[id]\": ('submission.zip', id)\n            },\n            data={\n                \"commit\": \"Submit\"\n            }\n        )\n        return self._to_json(resp)\n\ndef get_zip_by_name(self, exercise, name, params):\n        \"\"\"\n        Get zipfile from TMC for given exercise\n        \"\"\"\n\n        resp = self.get(\n            exercise.return_url,\n            params=params,\n            files={\n                \"submission[name]\": ('submission.zip', name)\n            },\n            data={\n",
        "\n\nclass BaseHandler(object):\n    \"\"\"\n    Base class for all handlers.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.server_url = kwargs.pop(\"server_url\", None)\n        self.request = kwargs.pop(\"request\", None)\n        self.response = kwargs.pop(\"response\", None)\n        self.request_method = kwargs.pop(\"request_method\", None)\n        self.request_path = kwargs.pop(\"request_path\", None)\n        self.request_query = kwargs.pop(\"request_query\", None)\n        self.request_body = kwargs.pop(\"request_body\", None)\n        self.request_headers = kwargs.pop(\"request_headers\", None)\n        self.request_cookies = kwargs.pop(\"request_cookies\", None)\n        self.request_files = kwargs.pop(\"request_files\", None)\n        self.request_files_dict = kwargs.pop(\"request_files_dict\", None)\n        self.request_files_list = kwargs.pop(\"request_files_list\", None)\n        self.request_files_list_dict = kwargs.pop(\"request_files_list_dict\", None)\n        self.request_files_list_list = kwargs.pop(\"request_files_",
        "\n\n    def _to_json_with_errors(self, resp):\n        \"\"\"\n            Extract json from a response.\n            Assumes response is valid otherwise.\n            Internal use only.\n        \"\"\"\n        try:\n            json = resp.json()\n        except ValueError as e:\n            reason = \"TMC Server did not send valid JSON: {0}\"\n            raise APIError(reason.format(repr(e)))\n\n        return json\n\n    def _to_json_with_errors_and_errors(self, resp):\n        \"\"\"\n            Extract json from a response.\n            Assumes response is valid otherwise.\n            Internal use only.\n        \"\"\"\n        try:\n            json = resp.json()\n        except ValueError as e:\n            reason = \"TMC Server did not send valid JSON: {0}\"\n            raise APIError(reason.format(repr(e)))\n\n        return json\n\n    def _to_json_with_errors_and_errors_and_errors(self, resp):\n        \"\"\"\n            Extract json from a response.\n            Assumes response is valid otherwise.\n            Internal use only.\n        \"\"\"\n        try:\n            json = resp.json()\n        except ValueError as e:\n            reason = \"TMC Server did not send valid JSON: {0}\"\n            raise APIError(",
        "\n\ndef safe_join(greenlets, timeout=None, raise_error=False):\n    \"\"\"\n    Wrapper for gevent.join if the greenlet that waits for the joins is killed, it kills all the greenlets it joins for.\n    \"\"\"\n    greenlets = list(greenlets)\n    try:\n        gevent.join(greenlets, timeout, raise_error)\n    except gevent.GreenletExit:\n        [greenlet.kill() for greenlet in greenlets if not greenlet.ready()]\n        raise\n    return greenlets\n\ndef safe_joinall_with_timeout(greenlets, timeout=None, raise_error=False):\n    \"\"\"\n    Wrapper for gevent.joinall if the greenlet that waits for the joins is killed, it kills all the greenlets it joins for.\n    \"\"\"\n    greenlets = list(greenlets)\n    try:\n        gevent.joinall_with_timeout(greenlets, timeout, raise_error)\n    except gevent.GreenletExit:\n        [greenlet.kill() for greenlet in greenlets if not greenlet.ready()]\n        raise\n    return greenlets\n\ndef safe_joinall_with_timeout_and_raise_error(greenlets, timeout=None, raise_error=False):\n    \"\"\"",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\nclass InvalidArgument(Exception):\n        \"\"\"\n        Raised when an argument is invalid.\n        \"\"\"\n        pass\n\nclass InvalidArgumentError(Exception):\n        \"\"\"\n        Raised when an argument is invalid.\n        \"\"\"\n        pass\n\nclass InvalidArgumentTypeError(Exception):\n        \"\"\"\n        Raised when an argument is invalid.\n        \"\"\"\n        pass\n\nclass InvalidArgumentValueError(Exception):\n        \"\"\"\n        Raised when an argument is invalid.\n        \"\"\"\n        pass\n\nclass InvalidArgumentTypeError(Exception):\n        \"\"\"\n        Raised when an argument is invalid.\n        \"\"\"\n        pass\n\nclass InvalidArgumentValueError(Exception):\n        \"\"\"\n        Raised when an argument is invalid.\n        \"\"\"\n        pass\n\nclass InvalidArgumentTypeError(Exception):\n        \"\"\"\n        Raised when an argument is invalid.\n        \"\"\"\n        pass\n\nclass InvalidArgumentTypeError(Exception):\n        \"\"\"\n        Raised when an argument is invalid.\n        \"\"\"\n        pass\n\nclass InvalidArgumentTypeError(Exception):\n        \"\"\"\n        Raised when an argument is invalid.\n        \"\"\"\n        pass\n\nclass InvalidArgumentTypeError(Exception):\n        \"\"\"\n        Raised when an argument is invalid.\n        \"\"\"\n        pass\n\nclass InvalidArgumentTypeError(Exception):\n        \"\"\"\n        Raised when an argument is",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef print_help():\n    '''print help.\n\n    Prettified by json.\n    `long_description` is removed\n    '''\n    x = json.dumps(environment.options,\n                   indent=4,\n                   sort_keys=True,\n                   skipkeys=True,\n                   cls=MyEncoder)\n    print(x)\n\ndef print_version():\n    '''print version.\n\n    Prettified by json.\n    `long_description` is removed\n    '''\n    x = json.dumps(environment.options,\n                   indent=4,\n                   sort_keys=True,\n                   skipkeys=True,\n                   cls=MyEncoder)\n    print(x)\n\ndef print_help_version():\n    '''print help version.\n\n    Prettified by json.\n    `long_description` is removed\n    '''\n    x = json.dumps(environment.options,\n                   indent=4,\n                   sort_keys=True,\n                   skipkeys=True,\n                   cls=MyEncoder)\n    print(x)\n\ndef print_help_version_help():\n    '''print help version help.\n\n    Prettified by json.\n    `long_description` is removed\n    '''\n    x = json.dumps(environment.options,",
        "\n\nclass UnknownCommandError(Exception):\n    \"\"\"\\\n    Raised when a command is unknown.\n    \"\"\"\n    pass\n\nclass DecodeError(Exception):\n    \"\"\"\\\n    Raised when a command is unable to decode.\n    \"\"\"\n    pass\n\nclass Message:\n    \"\"\"\\\n    A message is a binary protobuf message.\n    \"\"\"\n    def __init__(self, receiver: MessageReceiver):\n        \"\"\"\\\n        Initializes a new message.\n        \"\"\"\n        self.receiver = receiver\n\n    def encode(self, data: RawMessage) -> RawMessage:\n        \"\"\"\\\n        Encodes a message into a binary protobuf message.\n        \"\"\"\n        return self.receiver.encode(data)\n\n    def decode(self, data: RawMessage) -> Message:\n        \"\"\"\\\n        Decodes a binary protobuf message into a message.\n        \"\"\"\n        return self.receiver.decode(data)\n\n    def __str__(self):\n        \"\"\"\\\n        Returns a string representation of the message.\n        \"\"\"\n        return self.receiver.__str__()\n\n    def __repr__(self):\n        \"\"\"\\\n        Returns a string representation of the message.\n        \"\"\"\n        return self.receiver.__repr__()\n\n    def __eq__(self, other: Message):\n        \"\"\"\\",
        "\n\nclass Node(object):\n    \"\"\"Represents a graph node.\n\n    :param graph: \n        graph object that this node belongs to\n    :param parent: \n        parent node of this node\n    :param children: \n        list of children nodes of this node\n    :param parents: \n        list of parents nodes of this node\n    :param data_content_type: \n        content type of this node\n    :param data: \n        data associated with this node\n    :param data_content_type: \n        content type of this node\n    :param data_content_id: \n        content id of this node\n    :param data_content_id: \n        content id of this node\n    :param data_content_type_id: \n        content type id of this node\n    :param data_content_id_id: \n        content id id of this node\n    :param data_content_type_id_id: \n        content type id id of this node\n    :param data_content_type_id_id: \n        content type id id of this node\n    :param data_content_type_id_id: \n        content type id id of this node\n    :param data_content_type_id_id: \n        content type id id of this node\n    :param data_content_type_id",
        "\n\ndef _depth_ascend(self, node, ancestors):\n        \"\"\"Recursively descend into the tree, and add the node to the\n        ancestors set.\n        \"\"\"\n        if node is None:\n            return\n\n        ancestors.add(node)\n        for child in node.children:\n            _depth_ascend(child, ancestors)\n\n\ndef is_ancestor_of(self, node):\n        \"\"\"Returns True if this node is an ancestor of the given node.\"\"\"\n        if node is None:\n            return False\n\n        return self.parent == node\n\ndef is_ancestor_of_or_self(self, node):\n        \"\"\"Returns True if this node is an ancestor of the given node or\n        self if it is the same node as the given node.\"\"\"\n        if node is None:\n            return False\n\n        return self.parent == node or self.parent == node\n\ndef is_ancestor_of_or_self_or_self(self, node):\n        \"\"\"Returns True if this node is an ancestor of the given node or\n        self if it is the same node as the given node or self if it is the same\n        node as the given node.\"\"\"\n        if node is None:\n            return False\n\n        return self.parent == node or self.parent == node or self.parent == node\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _depth_descend(self, visited, depth=0):\n        \"\"\"Recursively descend into this node and its children.\"\"\"\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_leaf():\n            return\n        if self.is_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\nclass BaseDataNode(object):\n    \"\"\"Base class for all data nodes.\n\n    This class is used to represent a node in the graph.  It is used to\n    represent a node in the graph.  It is used to represent a node in the\n    graph.  It is used to represent a node in the graph.  It is used to\n    represent a node in the graph.  It is used to represent a node in the\n    graph.  It is used to represent a node in the graph.  It is used to\n    represent a node in the graph.  It is used to represent a node in the\n    graph.  It is used to represent a node in the graph.  It is used to\n    represent a node in the graph.  It is used to represent a node in the\n    graph.  It is used to represent a node in the graph.  It is used to\n    represent a node in the graph.  It is used to represent a node in the\n    graph.  It is used to represent a node in the graph.  It is used to\n    represent a node in the graph.  It is used to represent a node in the\n    graph.  It is used to represent a node in the graph.  It is used to\n    represent a node in the graph.  It is used to represent a node in the\n",
        "\n\ndef prune(self):\n        \"\"\"Removes all nodes from the graph that would be pruned if prune were called\n        on this element.\n        \"\"\"\n        targets = self.descendents_root()\n        try:\n            targets.remove(self.graph.root)\n        except ValueError:\n            # root wasn't in the target list, no problem\n            pass\n\n        targets.append(self)\n        return targets\n\ndef prune_all(self):\n        \"\"\"Removes all nodes from the graph that would be pruned if prune were called\n        on this element.\n        \"\"\"\n        targets = self.descendents_root()\n        try:\n            targets.remove(self.graph.root)\n        except ValueError:\n            # root wasn't in the target list, no problem\n            pass\n\n        targets.append(self)\n        return targets\n\ndef prune_all_nodes(self):\n        \"\"\"Removes all nodes from the graph that would be pruned if prune were called\n        on this element.\n        \"\"\"\n        targets = self.descendents_root()\n        try:\n            targets.remove(self.graph.root)\n        except ValueError:\n            # root wasn't in the target list, no problem\n            pass\n\n        targets.append(self)\n        return targets\n\ndef prune_all_edges(self):",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_locations(self):\n        \"\"\"\n        Returns all locations.\n\n        http://dev.wheniwork.com/#get-all-locations\n        \"\"\"\n        url = \"/2/locations\"\n\n        return self.locations_from_json(self._get_resource(url)[\"locations\"])\n\ndef get_location_by_id(self, location_id):\n        \"\"\"\n        Returns location data.\n\n        http://dev.wheniwork.com/#get-existing-location\n        \"\"\"\n        url = \"/2/locations/%s\" % location_id\n\n        return self.location_from_json(self._get_resource(url)[\"location\"])\n\ndef get_locations_by_name(self, name):\n        \"\"\"\n        Returns all locations.\n\n        http://dev.wheniwork.com/#get-all-locations\n        \"\"\"\n        url = \"/2/locations/%s\" % name\n\n        return self.locations_from_json(self._get_resource(url)[\"locations\"])\n\ndef get_location_by_name_and_id(self, name, location_id):\n        \"\"\"\n        Returns location data.\n\n        http://dev.wheniwork.com/#get-existing-location\n        \"\"\"\n        url = \"/2",
        "\ndef get_locations_by_name(self, name):\n        \"\"\"\n        Returns a list of locations by name.\n\n        http://dev.wheniwork.com/#listing-locations-by-name\n        \"\"\"\n        url = \"/2/locations/%s\" % name\n\n        data = self._get_resource(url)\n        locations = []\n        for entry in data['locations']:\n            locations.append(self.location_from_json(entry))\n\n        return locations\n\ndef get_location_by_id(self, id):\n        \"\"\"\n        Returns a location by id.\n\n        http://dev.wheniwork.com/#listing-locations-by-id\n        \"\"\"\n        url = \"/2/locations/%s\" % id\n\n        data = self._get_resource(url)\n        location = self.location_from_json(data)\n\n        return location\n\ndef get_location_by_name(self, name):\n        \"\"\"\n        Returns a location by name.\n\n        http://dev.wheniwork.com/#listing-locations-by-name\n        \"\"\"\n        url = \"/2/locations/%s\" % name\n\n        data = self._get_resource(url)\n        location = self.location_from_json(data)\n\n        return",
        "\n\ndef chisq_red_error(self):\n        \"\"\"\n        The reduced chi-square of the linear least squares\n        \"\"\"\n        if self._chisq_red_error is None:\n            self._chisq_red_error = chisquare(self.y_unweighted.transpose(), _np.dot(self.X_unweighted, self.beta), self.y_error, ddof=3, verbose=False)\n        return self._chisq_red_error\n\ndef chisq_red_error_error(self):\n        \"\"\"\n        The reduced chi-square of the linear least squares\n        \"\"\"\n        if self._chisq_red_error_error is None:\n            self._chisq_red_error_error = chisquare(self.y_unweighted.transpose(), _np.dot(self.X_unweighted, self.beta), self.y_error, ddof=3, verbose=False)\n        return self._chisq_red_error_error\n\ndef chisq_red_error_error_error(self):\n        \"\"\"\n        The reduced chi-square of the linear least squares\n        \"\"\"\n        if self._chisq_red_error_error_error is None:\n            self._chisq",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "\n\ndef from_client(cls, client, slug, identifier):\n        \"\"\"Retrieve a task from the client\"\"\"\n        task = client.get(\n            'task',\n            replacements={\n                'slug': slug,\n                'identifier': identifier})\n        return cls(**task)\n\ndef from_task(cls, task):\n        \"\"\"Retrieve a task from a task object\"\"\"\n        return cls(**task)\n\ndef from_task_list(cls, task_list):\n        \"\"\"Retrieve a task from a task list\"\"\"\n        return cls(**task_list)\n\ndef from_task_list_with_tasks(cls, task_list, tasks):\n        \"\"\"Retrieve a task from a task list with tasks\"\"\"\n        return cls(**task_list + tasks)\n\ndef from_task_list_with_tasks_and_tasks(cls, task_list, tasks, tasks_and_tasks):\n        \"\"\"Retrieve a task from a task list with tasks and tasks\"\"\"\n        return cls(**task_list + tasks + tasks_and_tasks)\n\ndef from_task_list_with_tasks_and_tasks_and_tasks(cls, task_list, tasks, tasks_and_tasks_and_tasks):\n        \"\"\"Retrieve a task from a task list with tasks and tasks and tasks and tasks and tasks",
        "\n\ndef no_coloring():\n    \"\"\" Returns True if no coloring is needed \"\"\"\n    return False\n\ndef color(s):\n    \"\"\" Returns a string with color \"\"\"\n    return formatter(Colors.BLUE, s)\n\ndef green(s):\n    \"\"\" Returns a string with color \"\"\"\n    return formatter(Colors.GREEN, s)\n\ndef yellow(s):\n    \"\"\" Returns a string with color \"\"\"\n    return formatter(Colors.YELLOW, s)\n\ndef red(s):\n    \"\"\" Returns a string with color \"\"\"\n    return formatter(Colors.RED, s)\n\ndef magenta(s):\n    \"\"\" Returns a string with color \"\"\"\n    return formatter(Colors.MAGENTA, s)\n\ndef cyan(s):\n    \"\"\" Returns a string with color \"\"\"\n    return formatter(Colors.CYAN, s)\n\ndef white(s):\n    \"\"\" Returns a string with color \"\"\"\n    return formatter(Colors.WHITE, s)\n\ndef black(s):\n    \"\"\" Returns a string with color \"\"\"\n    return formatter(Colors.BLACK, s)\n\ndef reset(s):\n    \"\"\" Returns a string with color \"\"\"\n    return formatter(Colors.RESET, s)\n\ndef reset_white(s):\n    \"\"\" Returns a string with color \"\"\"\n    return formatter(Colors",
        "\n\ndef get_user_by_id(self, user_id):\n        \"\"\"\n        Returns user profile data.\n\n        http://dev.wheniwork.com/#get-existing-user\n        \"\"\"\n        url = \"/2/users/%s\" % user_id\n\n        return self.user_from_json(self._get_resource(url)[\"user\"])\n\ndef get_user_by_email(self, email):\n        \"\"\"\n        Returns user profile data.\n\n        http://dev.wheniwork.com/#get-existing-user\n        \"\"\"\n        url = \"/2/users/email/%s\" % email\n\n        return self.user_from_json(self._get_resource(url)[\"user\"])\n\ndef get_user_by_name(self, name):\n        \"\"\"\n        Returns user profile data.\n\n        http://dev.wheniwork.com/#get-existing-user\n        \"\"\"\n        url = \"/2/users/name/%s\" % name\n\n        return self.user_from_json(self._get_resource(url)[\"user\"])\n\ndef get_user_by_username(self, username):\n        \"\"\"\n        Returns user profile data.\n\n        http://dev.wheniwork.com/#get-existing-",
        "\n\ndef get_user(self, user_id):\n        \"\"\"\n        Returns a user.\n\n        http://dev.wheniwork.com/#listing-users\n        \"\"\"\n        url = \"/2/users/%s\" % user_id\n\n        data = self._get_resource(url)\n        return self.user_from_json(data)\n\ndef get_user_by_email(self, email):\n        \"\"\"\n        Returns a user by email.\n\n        http://dev.wheniwork.com/#listing-users\n        \"\"\"\n        url = \"/2/users/email/%s\" % email\n\n        data = self._get_resource(url)\n        return self.user_from_json(data)\n\ndef get_user_by_id(self, user_id):\n        \"\"\"\n        Returns a user by id.\n\n        http://dev.wheniwork.com/#listing-users\n        \"\"\"\n        url = \"/2/users/%s\" % user_id\n\n        data = self._get_resource(url)\n        return self.user_from_json(data)\n\ndef get_user_by_name(self, name):\n        \"\"\"\n        Returns a user by name.\n\n        http://dev.wheniwork.com/#listing-users\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef merge(dst, src):\n    \"\"\"Recursively merge the destination dict-like object with the source dict-like object.\n\n    Useful for merging options and Bunches together!\n\n    Based on:\n    http://code.activestate.com/recipes/499335-recursively-merge-a-dictionary-without-hitting-py/#c2\n    \"\"\"\n    stack = [(dst, src)]\n    while stack:\n        current_dst, current_src = stack.pop()\n        for key in current_src:\n            if key not in current_dst:\n                current_dst[key] = current_src[key]\n            else:\n                if isdict(current_src[key]) and isdict(current_dst[key]):\n                    stack.append((current_dst[key], current_src[key]))\n                else:\n                    current_dst[key] = current_src[key]\n    return dst\n\ndef merge_dicts(dst, src):\n    \"\"\"Recursively merge the destination dict-like object with the source dict-like object.\n\n    Useful for merging options and Bunches together!\n\n    Based on:\n    http://code.activestate.com/recipes/499335-recursively-merge-a-dictionary-",
        ") + args)\n\ndef pip_uninstall(*args):\n    \"\"\"Send the given arguments to `pip uninstall`.\n    \"\"\"\n    shv('pip uninstall %s' % (', '.join(args)))\n\ndef pip_update(*args):\n    \"\"\"Send the given arguments to `pip update`.\n    \"\"\"\n    shv('pip update %s' % (', '.join(args)))\n\ndef pip_list(*args):\n    \"\"\"Send the given arguments to `pip list`.\n    \"\"\"\n    shv('pip list %s' % (', '.join(args)))\n\ndef pip_list_packages(*args):\n    \"\"\"Send the given arguments to `pip list-packages`.\n    \"\"\"\n    shv('pip list-packages %s' % (', '.join(args)))\n\ndef pip_list_packages_with_dependencies(*args):\n    \"\"\"Send the given arguments to `pip list-packages-with-dependencies`.\n    \"\"\"\n    shv('pip list-packages-with-dependencies %s' % (', '.join(args)))\n\ndef pip_list_packages_with_dependencies_with_dependencies(*args):\n    \"\"\"Send the given arguments to `pip list-packages-with-dependencies-with-dependencies`.\n    \"\"\"\n    shv('pip list-packages-with-dependencies-with-dependencies",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\ndef update_shift(self, params={}):\n        \"\"\"\n        Updates a shift\n\n        http://dev.wheniwork.com/#create/update-shift\n        \"\"\"\n        url = \"/2/shifts/\"\n        body = params\n\n        data = self._post_resource(url, body)\n        shift = self.shift_from_json(data[\"shift\"])\n\n        return shift\n\ndef delete_shift(self, params={}):\n        \"\"\"\n        Deletes a shift\n\n        http://dev.wheniwork.com/#create/update-shift\n        \"\"\"\n        url = \"/2/shifts/\"\n        body = params\n\n        data = self._delete_resource(url, body)\n        shift = self.shift_from_json(data[\"shift\"])\n\n        return shift\n\ndef get_shift(self, params={}):\n        \"\"\"\n        Gets a shift\n\n        http://dev.wheniwork.com/#create/update-shift\n        \"\"\"\n        url = \"/2/shifts/\"\n        body = params\n\n        data = self._get_resource(url, body)\n        shift = self.shift_from_json(data[\"shift\"])\n\n        return shift\n\ndef get_shifts(self, params={}):\n        \"\"\"\n        Gets all shifts",
        "\ndef get_shifts(self):\n        \"\"\"\n        Get all shifts.\n\n        http://dev.wheniwork.com/#get-shifts\n        \"\"\"\n        url = \"/2/shifts\"\n\n        data = self._get_resource(url)\n\n        return data\n\ndef get_shift(self, id):\n        \"\"\"\n        Get a single shift.\n\n        http://dev.wheniwork.com/#get-shift\n        \"\"\"\n        url = \"/2/shifts/%s\" % id\n\n        data = self._get_resource(url)\n\n        return data\n\ndef get_shifts_by_user(self, user):\n        \"\"\"\n        Get all shifts for a given user.\n\n        http://dev.wheniwork.com/#get-shifts-by-user\n        \"\"\"\n        url = \"/2/shifts?user=%s\" % user\n\n        data = self._get_resource(url)\n\n        return data\n\ndef get_shifts_by_user_and_project(self, user, project):\n        \"\"\"\n        Get all shifts for a given user and project.\n\n        http://dev.wheniwork.com/#get-shifts-by-user-and-project\n        \"\"\"\n        url = \"/2/shifts",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_all_images_count_from_event(self):\n        \"\"\"\n        Gets count of all images from both event and updates.\n        \"\"\"\n        self_imgs = self.image_set.count()\n        update_ids = self.update_set.values_list('id', flat=True)\n        u_images = UpdateImage.objects.filter(update__id__in=update_ids).count()\n        count = self_imgs + u_images\n\n        return count\n\ndef get_all_images_count_from_updates(self):\n        \"\"\"\n        Gets count of all images from both event and updates.\n        \"\"\"\n        self_imgs = self.image_set.count()\n        update_ids = self.update_set.values_list('id', flat=True)\n        u_images = UpdateImage.objects.filter(update__id__in=update_ids).count()\n        count = self_imgs + u_images\n\n        return count\n\ndef get_all_images_count_from_updates_with_image_ids(self):\n        \"\"\"\n        Gets count of all images from both event and updates.\n        \"\"\"\n        self_imgs = self.image_set.count()\n        update_ids = self.update_set.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\nclass Spinner(object):\n    def __init__(self, msg=\"\", waitmsg=\"Please wait\"):\n        self.msg = msg\n        self.waitmsg = waitmsg\n        self.start_spinning()\n\n    def start_spinning(self):\n        self.spinning = True\n\n    def stop_spinning(self):\n        self.spinning = False\n\n    def join(self):\n        self.spinning = False\n        self.spinning = True\n        self.spinning.join()\n\n    def msg(self, msg):\n        self.msg = msg\n\n    def waitmsg(self, waitmsg):\n        self.waitmsg = waitmsg\n\n    def __str__(self):\n        return self.msg\n\n    def __repr__(self):\n        return \"<Spinner: %s>\" % self.msg\n\n    def __eq__(self, other):\n        return self.msg == other.msg\n\n    def __ne__(self, other):\n        return self.msg != other.msg\n\n    def __lt__(self, other):\n        return self.msg < other.msg\n\n    def __le__(self, other):\n        return self.msg <= other.msg\n\n    def __gt__(self, other",
        "\n\nclass Menu(object):\n        \"\"\"\n        A menu object.\n        \"\"\"\n        def __init__(self, title, items, selected=None):\n                \"\"\"\n                Initializes a new menu object.\n                \"\"\"\n                self.title = title\n                self.items = items\n                self.selected = selected\n\n        def __str__(self):\n                \"\"\"\n                Returns a string representation of the menu.\n                \"\"\"\n                return self.title\n\n        def __repr__(self):\n                \"\"\"\n                Returns a string representation of the menu.\n                \"\"\"\n                return self.__str__()\n\n        def __eq__(self, other):\n                \"\"\"\n                Returns true if the menu is equal to another menu.\n                \"\"\"\n                return self.title == other.title and self.items == other.items and self.selected == other.selected\n\n        def __ne__(self, other):\n                \"\"\"\n                Returns true if the menu is not equal to another menu.\n                \"\"\"\n                return not self.__eq__(other)\n\n        def __len__(self):\n                \"\"\"\n                Returns the number of items in the menu.\n                \"\"\"\n                return len(self.items)\n\n        def __getitem__(self, index):\n                \"\"\"\n                Returns the item at the given index.",
        "\n\n    def _process_new_rank_obj(self):\n        \"\"\"\n        Processes the new rank of the object.\n        \"\"\"\n        self.rank = self.rank + 1\n        self.save()\n\n    def _process_moved_rank_obj(self):\n        \"\"\"\n        Processes the rank of the object.\n        \"\"\"\n        self.rank = self.rank - 1\n        self.save()\n\n    def _rank_at_load(self):\n        \"\"\"\n        Rank the object based on the current rank.\n        \"\"\"\n        self.rank = self.rank + 1\n        self.save()\n\n    def _rank_at_save(self):\n        \"\"\"\n        Rank the object based on the current rank.\n        \"\"\"\n        self.rank = self.rank - 1\n        self.save()\n\n    def _rank_at_delete(self):\n        \"\"\"\n        Rank the object based on the current rank.\n        \"\"\"\n        self.rank = self.rank - 1\n        self.save()\n\n    def _rank_at_update(self):\n        \"\"\"\n        Rank the object based on the current rank.\n        \"\"\"\n        self.rank = self.rank + 1\n        self.save()\n\n    def _rank_at_",
        ".all()\n\ndef rank(self):\n        \"\"\"Returns the rank of the item.\"\"\"\n        return self.grouped_filter().order_by('rank').select_for_update().first().rank\n\ndef rank_by_name(self):\n        \"\"\"Returns the rank of the item by name.\"\"\"\n        return self.grouped_filter().order_by('name').select_for_update().first().rank\n\ndef rank_by_name_and_rank(self):\n        \"\"\"Returns the rank of the item by name and rank.\"\"\"\n        return self.grouped_filter().order_by('name', 'rank').select_for_update().first().rank\n\ndef rank_by_name_and_rank_and_name(self):\n        \"\"\"Returns the rank of the item by name and rank and name.\"\"\"\n        return self.grouped_filter().order_by('name', 'rank', 'name').select_for_update().first().rank\n\ndef rank_by_name_and_rank_and_name_and_rank(self):\n        \"\"\"Returns the rank of the item by name and rank and name and rank.\"\"\"\n        return self.grouped_filter().order_by('name', 'rank', 'name', 'rank').select_for_update().first().rank\n\ndef rank_by_name_and_rank_",
        "\n\ndef get_field_names_for_model(model, ignore_auto=True, ignore_relations=True, \n        exclude=[]):\n    \"\"\"Returns the field names of a Django model object.\n\n    :param model: the Django model class or object instance to get the fields\n        from\n    :param ignore_auto: ignore any fields of type AutoField. Defaults to True\n    :param ignore_relations: ignore any fields that involve relations such as\n        the ForeignKey or ManyToManyField\n    :param exclude: exclude anything in this list from the results\n\n    :returns: generator of found field names\n    \"\"\"\n\n    from django.db.models import (AutoField, ForeignKey, ManyToManyField, \n        ManyToOneRel, OneToOneRel, OneToOneField, OneToOneFieldRel)\n\n    for field in model._meta.get_fields():\n        if ignore_auto and isinstance(field, AutoField):\n            continue\n\n        if ignore_relations and (isinstance(field, ForeignKey) or\n                isinstance(field, ManyToManyField) or\n                isinstance(field, ManyToOneRel) or\n                isinstance(field, OneToOneRel) or\n                isinstance(field, OneToOneField)):\n            # optimization is killing coverage measure, have to put no-op that\n            # does something\n            a = 1; a",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\n\ndef _setup_axes():\n    \"\"\"\n    Setup the axes for plotting.\n\n    Returns\n    -------\n    fig, ax : :class:`matplotlib.figure.Figure`, :class:`matplotlib.axes.Axes`\n        The figure and axes.\n\n    \"\"\"\n    fig, ax = _setup_figure()\n    ax.set_aspect('equal')\n    ax.set_aspect_inches(1.0, 1.0)\n    ax.set_aspect_fits_yaxis(True)\n    ax.set_aspect_inches_adjust(0.5, 0.5)\n    ax.set_aspect_fits_xaxis(True)\n    ax.set_aspect_inches_adjust(0.5, 0.5)\n    ax.set_aspect_fits_yaxis(True)\n    ax.set_aspect_inches_adjust(0.5, 0.5)\n    ax.set_aspect_inches_adjust(0.5, 0.5)\n    ax.set_aspect_inches_adjust(0.5, 0.5)\n    ax.set_aspect_inches_adjust(0.5, 0.5)\n    ax.set_aspect_inches_adjust(0.5, 0.5",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".func_code\n    return inner\n\ndef course_id(func):\n    \"\"\"\n    Passes the course id as the first argument to func.\n    \"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        course_id = Course.get_selected().id\n        return func(course_id, *args, **kwargs)\n    return inner\n\ndef course_name(func):\n    \"\"\"\n    Passes the course name as the first argument to func.\n    \"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        course_name = Course.get_selected().name\n        return func(course_name, *args, **kwargs)\n    return inner\n\ndef course_description(func):\n    \"\"\"\n    Passes the course description as the first argument to func.\n    \"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        course_description = Course.get_selected().description\n        return func(course_description, *args, **kwargs)\n    return inner\n\ndef course_type(func):\n    \"\"\"\n    Passes the course type as the first argument to func.\n    \"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        course_",
        ".__call__\n    return inner\n\ndef exercise_selected(func):\n    \"\"\"\n    Passes the selected exercise as the first argument to func.\n    \"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        exercise = Exercise.get_selected()\n        return func(exercise, *args, **kwargs)\n    return inner\n\ndef exercise_selected_with_id(func):\n    \"\"\"\n    Passes the selected exercise as the first argument to func.\n    \"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        exercise = Exercise.get_selected_with_id(kwargs['id'])\n        return func(exercise, *args, **kwargs)\n    return inner\n\ndef exercise_selected_with_name(func):\n    \"\"\"\n    Passes the selected exercise as the first argument to func.\n    \"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        exercise = Exercise.get_selected_with_name(kwargs['name'])\n        return func(exercise, *args, **kwargs)\n    return inner\n\ndef exercise_selected_with_description(func):\n    \"\"\"\n    Passes the selected exercise as the first argument to func.\n    \"\"\"\n    @wraps(",
        "\n    return inner\n\n\ndef true_exit(func):\n    \"\"\"\n    If func returns True the program exits immediately.\n    \"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        ret = func(*args, **kwargs)\n        if ret is True:\n            if \"TMC_TESTING\" in os.environ:\n                raise TMCExit()\n            else:\n                sys.exit(0)\n        return ret\n    return inner\n\n\ndef test_exit(func):\n    \"\"\"\n    If func returns True the program exits immediately.\n    \"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        ret = func(*args, **kwargs)\n        if ret is True:\n            if \"TMC_TESTING\" in os.environ:\n                raise TMCExit()\n            else:\n                sys.exit(0)\n        return ret\n    return inner\n\n\ndef test_true_exit(func):\n    \"\"\"\n    If func returns True the program exits immediately.\n    \"\"\"\n    @wraps(func)\n    def inner(*args, **kwargs):\n        ret = func(*args, **kwargs)\n        if ret is True:\n            if \"TMC_TESTING\" in os.environ:\n                raise TMC",
        "\n    return True\n\ndef select(course=False, tid=None, auto=False):\n    \"\"\"\n    Select a course.\n    \"\"\"\n    if not tid:\n        tid = select_tid()\n    if not tid:\n        return False\n    if course:\n        select_course(tid)\n    else:\n        select_course()\n    return True\n\ndef select_course(tid=None):\n    \"\"\"\n    Select a course.\n    \"\"\"\n    if not tid:\n        tid = select_tid()\n    if not tid:\n        return False\n    if tid:\n        select_course(tid)\n    else:\n        select_course()\n    return True\n\ndef select_tid(tid=None):\n    \"\"\"\n    Select a course.\n    \"\"\"\n    if not tid:\n        tid = select_tid()\n    if not tid:\n        return False\n    if tid:\n        select_course(tid)\n    else:\n        select_course()\n    return True\n\ndef select_course(tid=None):\n    \"\"\"\n    Select a course.\n    \"\"\"\n    if not tid:\n        tid = select_tid()\n    if not tid:\n        return False\n    if tid:\n        select_course(tid)\n    else:\n        select",
        "\n\ndef download_exercise(exercise, force=False, update_java=False, update=False):\n    \"\"\"\n    Download an exercise from the server.\n    \"\"\"\n\n    if update:\n        exercise.update_downloaded()\n\n    if update_java:\n        exercise.update_java()\n\n    if force:\n        exercise.force_download()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_completed()\n\n    if exercise.is_completed:\n        exercise.update_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef run_exercise(exercise, command):\n    \"\"\"\n    Spawns a process with `command path-of-exercise`\n    \"\"\"\n    Popen(['nohup', command, exercise.path()], stdout=DEVNULL, stderr=DEVNULL)\n\n\ndef run_exercises(exercises):\n    \"\"\"\n    Spawns a process with `command path-of-exercises`\n    \"\"\"\n    for exercise in exercisecises:\n        run(exercise, 'exercise')\n\n\ndef run_exercise_with_args(exercise, command, args):\n    \"\"\"\n    Spawns a process with `command path-of-exercise`\n    \"\"\"\n    Popen(['nohup', command, exercise.path()], stdout=DEVNULL, stderr=DEVNULL, args=args)\n\n\ndef run_exercise_with_args_and_output(exercise, command, args, output):\n    \"\"\"\n    Spawns a process with `command path-of-exercise`\n    \"\"\"\n    Popen(['nohup', command, exercise.path()], stdout=DEVNULL, stderr=DEVNULL, args=args, stdout=output)\n\n\ndef run_exercise_with_args_and_output_and_error(exercise",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".course(course)\n\ndef submit_exercise(exercise, pastebin=False, request_review=False):\n    \"\"\"\n    Submit the selected exercise to the server.\n    \"\"\"\n    if pastebin:\n        return exercise.pastebin(request_review=request_review)\n    else:\n        return exercise.submit(request_review=request_review)\n\ndef submit_exercise_with_review(exercise, pastebin=False, request_review=False):\n    \"\"\"\n    Submit the selected exercise to the server.\n    \"\"\"\n    if pastebin:\n        return exercise.pastebin(request_review=request_review)\n    else:\n        return exercise.submit(request_review=request_review)\n\ndef submit_exercise_with_review_and_review_id(exercise, pastebin=False, request_review=False):\n    \"\"\"\n    Submit the selected exercise to the server.\n    \"\"\"\n    if pastebin:\n        return exercise.pastebin(request_review=request_review)\n    else:\n        return exercise.submit(request_review=request_review)\n\ndef submit_exercise_with_review_and_review_id_and_course(exercise, pastebin=False, request_review=False):\n    \"\"\"\n    Submit the",
        ", review=review)\n\ndef submit(pastebin=False, tid=None, review=False):\n    \"\"\"\n    Sends the selected exercise to the TMC pastebin.\n    \"\"\"\n    if tid is None:\n        tid = get_tid()\n    if review:\n        submit(pastebin=pastebin, tid=tid, review=review)\n    else:\n        submit(pastebin=pastebin, tid=tid)\n\ndef submit(pastebin=False, tid=None, review=False):\n    \"\"\"\n    Sends the selected exercise to the TMC pastebin.\n    \"\"\"\n    if tid is None:\n        tid = get_tid()\n    if review:\n        submit(pastebin=pastebin, tid=tid, review=review)\n    else:\n        submit(pastebin=pastebin, tid=tid)\n\ndef get_tid():\n    \"\"\"\n    Returns the TMC pastebin ID.\n    \"\"\"\n    return get_option('pastebin')\n\ndef get_option(option):\n    \"\"\"\n    Returns the value of the option.\n    \"\"\"\n    return get_option('pastebin', option)\n\ndef get_option_value(option):\n    \"\"\"\n    Returns the value of the option.\n    \"\"\"\n    return get_option('pastebin', option",
        "\n                download_exercise(ex, update=True)\n\n\ndef download_exercise(ex, update=False):\n    \"\"\"\n    Download the exercise data from server.\n    \"\"\"\n    if update:\n        print(\"Updating exercise data.\")\n        for exercise in api.get_exercises(ex.course):\n            old = None\n            try:\n                old = Exercise.byid(exercise[\"id\"])\n            except peewee.DoesNotExist:\n                old = None\n            if old is not None:\n                old.name = exercise[\"name\"]\n                old.course = ex.course\n                old.is_attempted = exercise[\"attempted\"]\n                old.is_completed = exercise[\"completed\"]\n                old.deadline = exercise.get(\"deadline\")\n                old.is_downloaded = os.path.isdir(old.path())\n                old.return_url = exercise[\"return_url\"]\n                old.zip_url = exercise[\"zip_url\"]\n                old.submissions_url = exercise[(\"exercise_\"\n                                                               \"submissions_\"\n                                                               \"url\")]\n                old.save()\n                download_exercise(old, update=True)\n            else:\n                ex = Exercise.create(tid=exercise[\"id\"],\n                                    ",
        "\n\ndef is_type(a, b):\n    \"\"\"Determine if a is of type b\"\"\"\n    return isinstance(a, b)\n\ndef is_integer(x):\n    \"\"\"Determine if x is an integer\"\"\"\n    return is_type(x, int)\n\ndef is_float(x):\n    \"\"\"Determine if x is a float\"\"\"\n    return is_type(x, float)\n\ndef is_string(x):\n    \"\"\"Determine if x is a string\"\"\"\n    return is_type(x, str)\n\ndef is_array(x):\n    \"\"\"Determine if x is an array\"\"\"\n    return is_type(x, list)\n\ndef is_dict(x):\n    \"\"\"Determine if x is a dictionary\"\"\"\n    return is_type(x, dict)\n\ndef is_list(x):\n    \"\"\"Determine if x is a list\"\"\"\n    return is_type(x, list)\n\ndef is_tuple(x):\n    \"\"\"Determine if x is a tuple\"\"\"\n    return is_type(x, tuple)\n\ndef is_tuple_like(x):\n    \"\"\"Determine if x is a tuple like\"\"\"\n    return is_type(x, tuple)\n\ndef is_list_like(x):\n    \"\"\"Determine if x is a list like\"\"\"\n    return",
        ")\n\ndef dmap_all(fn, record):\n    \"\"\"map for a directory\"\"\"\n    values = (fn(v) for k, v in record.items())\n    return dict(itertools.izip(record, values))\n\ndef dmap_all_recursive(fn, record):\n    \"\"\"map for a directory\"\"\"\n    values = (fn(v) for k, v in record.items())\n    return dict(itertools.izip(record, values, recursive=True))\n\ndef dmap_all_recursive_recursive(fn, record):\n    \"\"\"map for a directory\"\"\"\n    values = (fn(v) for k, v in record.items())\n    return dict(itertools.izip(record, values, recursive=True, recursive=True))\n\ndef dmap_all_recursive_recursive_recursive(fn, record):\n    \"\"\"map for a directory\"\"\"\n    values = (fn(v) for k, v in record.items())\n    return dict(itertools.izip(record, values, recursive=True, recursive=True, recursive=True))\n\ndef dmap_all_recursive_recursive_recursive(fn, record):\n    \"\"\"map for a directory\"\"\"\n    values = (fn(v) for k, v in record.items())\n    return dict(iter",
        "\n\ndef determine_type(value):\n    \"\"\"Determine the type of the value\"\"\"\n    if isinstance(value, str):\n        return str\n    elif isinstance(value, int):\n        return int\n    elif isinstance(value, float):\n        return float\n    elif isinstance(value, bool):\n        return bool\n    elif isinstance(value, dict):\n        return apply_types(use_types, guess_type, value)\n    elif isinstance(value, list):\n        return apply_types(use_types, guess_type, value)\n    elif isinstance(value, tuple):\n        return apply_types(use_types, guess_type, value)\n    else:\n        return value\n\ndef force_type(use_type, value):\n    \"\"\"Force the type of the value\"\"\"\n    if isinstance(use_type, str):\n        return use_type\n    elif isinstance(use_type, int):\n        return use_type\n    elif isinstance(use_type, float):\n        return use_type\n    elif isinstance(use_type, bool):\n        return use_type\n    elif isinstance(use_type, dict):\n        return apply_types(use_types, guess_type, value)\n    elif isinstance(use_type, list):\n        return apply_types(use_types, guess",
        "\n\ndef format_to_csv_with_header(filename, skiprows=0, delimiter=\"\"):\n    \"\"\"Convert a file to a .csv file with header\"\"\"\n    if not delimiter:\n        delimiter = \"\\t\"\n\n    input_file = open(filename, \"r\")\n\n    if skiprows:\n        [input_file.readline() for _ in range(skiprows)]\n \n    new_filename = os.path.splitext(filename)[0] + \".csv\"\n    output_file = open(new_filename, \"w\")\n\n    header = input_file.readline().split()\n    reader = csv.DictReader(input_file, fieldnames=header, delimiter=delimiter)\n    writer = csv.DictWriter(output_file, fieldnames=header, delimiter=\",\")\n    \n    # Write header\n    writer.writerow(dict((x, x) for x in header))\n    \n    # Write rows\n    for line in reader:\n        if None in line: del line[None]\n        writer.writerow(line)\n    \n    input_file.close()\n    output_file.close()\n    print \"Saved %s.\" % new_filename\n\ndef format_to_csv_with_header_and_rows(filename, skiprows=0, delimiter=\"",
        "\n\ndef admin_obj_list_link(obj, display=''):\n    \"\"\"Returns a link to the django admin change list with a filter set to\n    only the object given.\n\n    :param obj:\n        Object to create the admin change list display link for\n    :param display:\n        Text to display in the link.  Defaults to string call of the object\n    :returns:\n        Text containing HTML for a link\n    \"\"\"\n    # get the url for the change list for this object\n    url = reverse('admin:%s_%s_changelist' % (obj._meta.app_label,\n        obj._meta.model_name))\n    url += '?id__exact=%s' % obj.id\n\n    text = str(obj)\n    if display:\n        text = display\n\n    return format_html('<a href=\"{}\">{}</a>', url, text)\n\ndef admin_obj_list_link_with_filter(obj, display=''):\n    \"\"\"Returns a link to the django admin change list with a filter set to\n    only the object given.\n\n    :param obj:\n        Object to create the admin change list display link for\n    :param display:\n        Text to display in the link.  Defaults to string call of the object\n    :returns:\n        Text",
        "\n\ndef _obj_display_list(obj, display=''):\n    \"\"\"Returns string representation of an object, either the default or based\n    on the display template passed in.\n    \"\"\"\n    result = ''\n    if not display:\n        result = str(obj)\n    else:\n        template = Template(display)\n        context = Context({'obj':obj})\n        result = template.render(context)\n\n    return result\n\ndef _obj_display_dict(obj, display=''):\n    \"\"\"Returns string representation of an object, either the default or based\n    on the display template passed in.\n    \"\"\"\n    result = ''\n    if not display:\n        result = str(obj)\n    else:\n        template = Template(display)\n        context = Context({'obj':obj})\n        result = template.render(context)\n\n    return result\n\ndef _obj_display_list_dict(obj, display=''):\n    \"\"\"Returns string representation of an object, either the default or based\n    on the display template passed in.\n    \"\"\"\n    result = ''\n    if not display:\n        result = str(obj)\n    else:\n        template = Template(display)\n        context = Context({'obj':obj})\n        result = template.render(context)\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n",
        "\n",
        ")\n\ndef sigma_prime_2(self):\n        \"\"\"\n        Divergence of matched beam\n        \"\"\"\n        return _np.sqrt(self.emit/self.beta(self.E))\n\ndef sigma_prime_3(self):\n        \"\"\"\n        Divergence of matched beam\n        \"\"\"\n        return _np.sqrt(self.emit/self.beta(self.E))\n\ndef sigma_prime_4(self):\n        \"\"\"\n        Divergence of matched beam\n        \"\"\"\n        return _np.sqrt(self.emit/self.beta(self.E))\n\ndef sigma_prime_5(self):\n        \"\"\"\n        Divergence of matched beam\n        \"\"\"\n        return _np.sqrt(self.emit/self.beta(self.E))\n\ndef sigma_prime_6(self):\n        \"\"\"\n        Divergence of matched beam\n        \"\"\"\n        return _np.sqrt(self.emit/self.beta(self.E))\n\ndef sigma_prime_7(self):\n        \"\"\"\n        Divergence of matched beam\n        \"\"\"\n        return _np.sqrt(self.emit/self.beta(self.E))\n\ndef sigma_prime_8(self):\n        \"\"\"\n        Divergence of matched beam\n        \"\"\"\n        return _np.sqrt(self.",
        "\n\ndef n_p_2(self):\n        \"\"\"\n        The plasma density in SI units.\n        \"\"\"\n        return 2*_sltr.GeV2joule(self.E)*_spc.epsilon_0 / (self.beta*_spc.elementary_charge)**2\n\ndef n_p_3(self):\n        \"\"\"\n        The plasma density in SI units.\n        \"\"\"\n        return 2*_sltr.GeV2joule(self.E)*_spc.epsilon_0 / (self.beta*_spc.elementary_charge)**3\n\ndef n_p_4(self):\n        \"\"\"\n        The plasma density in SI units.\n        \"\"\"\n        return 2*_sltr.GeV2joule(self.E)*_spc.epsilon_0 / (self.beta*_spc.elementary_charge)**4\n\ndef n_p_5(self):\n        \"\"\"\n        The plasma density in SI units.\n        \"\"\"\n        return 2*_sltr.GeV2joule(self.E)*_spc.epsilon_0 / (self.beta*_spc.elementary_charge)**5\n\ndef n_p_6(self):",
        "\n\nif __name__ == '__main__':\n    main(sys.argv[1], sys.argv[2])\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.n",
        "\n\ndef print_tags(handler, label=None):\n    \"\"\"\n    Prints all tags\n    \"\"\"\n    click.echo('=> Tags:')\n    print_information(handler, label)\n\n    for tag in handler.tags:\n        click.echo('  {tag}'.format(tag=tag))\n\n\ndef print_latest_revision(handler, label=None):\n    \"\"\"\n    Prints latest revision\n    \"\"\"\n    click.echo('=> Latest revision: {tag}'.format(\n        tag=click.style(str(handler.latest_revision or 'N/A'), fg='yellow' if\n                        handler.latest_revision else 'magenta')\n    ))\n\n    if label is not None:\n        latest_revision = handler.latest_revision(label)\n        click.echo('=> Latest relative revision ({label}): {tag}'.format(\n            label=click.style(label, fg='blue'),\n            tag=click.style(str(latest_revision or 'N/A'),\n                                fg='yellow' if latest_revision else 'magenta')\n        ))\n\n\ndef print_latest_stable(handler, label=None):\n    \"\"\"\n    Prints latest stable\n    \"\"\"\n    click.echo('=> Latest stable: {tag}'.format(\n        tag=",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n    return default\n\n\ndef get_array(f, key, default=None):\n    \"\"\"\n    Gets an array from datasets.\n\n    .. versionadded:: 1.4\n    \"\"\"\n\n    if key in f.keys():\n        val = f[key].value\n\n        if default is None:\n            return val\n        else:\n            if _np.shape(val) == _np.shape(default):\n                return val\n\n    return default\n\n\ndef get_array_or_none(f, key, default=None):\n    \"\"\"\n    Gets an array from datasets.\n\n    .. versionadded:: 1.4\n    \"\"\"\n\n    if key in f.keys():\n        val = f[key].value\n\n        if default is None:\n            return val\n        else:\n            if _np.shape(val) == _np.shape(default):\n                return val\n\n    return default\n\n\ndef get_array_or_none_or_none(f, key, default=None):\n    \"\"\"\n    Gets an array from datasets.\n\n    .. versionadded:: 1.4\n    \"\"\"\n\n    if key in f.keys():\n        val = f[key].value\n\n        if default is None:\n            return val\n        else:\n            if _np.shape",
        "]\n\ndef get_state_list(self):\n        \"\"\"Get the current directory state\"\"\"\n        return [os.path.join(dp, f)\n                for dp, _, fn in os.walk(self.dir)\n                for f in fn]\n\ndef get_state_list_by_name(self, name):\n        \"\"\"Get the current directory state\"\"\"\n        return [os.path.join(dp, f)\n                for dp, _, fn in os.walk(self.dir)\n                for f in fn if f.startswith(name)]\n\ndef get_state_list_by_name_and_dir(self, name, dir):\n        \"\"\"Get the current directory state\"\"\"\n        return [os.path.join(dp, f)\n                for dp, _, fn in os.walk(self.dir)\n                for f in fn if f.startswith(name) and f == dir]\n\ndef get_state_list_by_name_and_dir_and_file(self, name, dir, f):\n        \"\"\"Get the current directory state\"\"\"\n        return [os.path.join(dp, f)\n                for dp, _, fn in os.walk(self.dir)\n                for f in fn if f.startswith(name) and f == dir",
        "\n        if self.current == self.factor:\n            self.current = 0\n            self.factor = self.current / self.factor\n        return self.current\n\ndef progress(self, factor):\n        \"\"\"Add one tick to progress bar\"\"\"\n        self.factor = factor\n        self.current = 0\n        return self.current\n\ndef progress_bar(self, factor):\n        \"\"\"Add one tick to progress bar\"\"\"\n        self.factor = factor\n        self.current = 0\n        return self.current\n\ndef progress_bar_with_tick(self, factor):\n        \"\"\"Add one tick to progress bar\"\"\"\n        self.factor = factor\n        self.current = 0\n        return self.current\n\ndef progress_bar_with_tick_and_tick(self, factor):\n        \"\"\"Add one tick to progress bar\"\"\"\n        self.factor = factor\n        self.current = 0\n        return self.current\n\ndef progress_bar_with_tick_and_tick_and_tick(self, factor):\n        \"\"\"Add one tick to progress bar\"\"\"\n        self.factor = factor\n        self.current = 0\n        return self.current\n\ndef progress_bar_with_tick_and_tick_and_tick(self, factor):\n        \"\"\"Add one tick to progress bar\"\"\"\n       ",
        "\n\ndef pop(self):\n        \"\"\"Pop the top item from the list\n\n        >>> l = DLL()\n        >>> l.push(1)\n        >>> l.push(2)\n        >>> l.push(3)\n        >>> l.pop()\n        >>> l\n        [1, 2, 3]\n        \"\"\"\n        if not self._first:\n            raise IndexError(\"No top item\")\n        node = self._first\n        self._first = self._last = None\n        self._size -= 1\n        del self._index[node.value]\n        return node\n\ndef delete(self, k):\n        \"\"\"Delete k from the top of the list\n\n        >>> l = DLL()\n        >>> l.push(1)\n        >>> l.push(2)\n        >>> l.push(3)\n        >>> l.delete(1)\n        >>> l\n        [2, 3]\n        \"\"\"\n        if not self._first:\n            raise IndexError(\"No top item\")\n        node = self._first\n        while node:\n            if node.value == k:\n                node.delete()\n                break\n            node = node.parent\n        del self._index[k]\n        self._size -= 1\n\ndef delete_all(self):\n        \"\"\"Delete all items from the",
        ".value\n\ndef decrement(cls, name):\n        \"\"\"Call this method to decrement the named counter.  This is atomic on\n        the database.\n\n        :param name:\n            Name for a previously created ``Counter`` object \n        \"\"\"\n        with transaction.atomic():\n            counter = Counter.objects.select_for_update().get(name=name)\n            counter.value -= 1\n            counter.save()\n\n        return counter.value\n\ndef get_counter(cls, name):\n        \"\"\"Call this method to get the named counter.  This is atomic on\n        the database.\n\n        :param name:\n            Name for a previously created ``Counter`` object \n        \"\"\"\n        with transaction.atomic():\n            counter = Counter.objects.select_for_update().get(name=name)\n            return counter\n\ndef get_counter_by_name(cls, name):\n        \"\"\"Call this method to get the named counter.  This is atomic on\n        the database.\n\n        :param name:\n            Name for a previously created ``Counter`` object \n        \"\"\"\n        with transaction.atomic():\n            counter = Counter.objects.select_for_update().get(name=name)\n            return counter\n\ndef get_counter_by_name_and_value(cls, name, value):\n        \"\"\"",
        "\n\ndef print_error(self, message):\n        \"\"\"\n        print error message on screen\n\n        .. note::\n\n            error message only write to `sys.stderr`\n\n\n        :param str message: message to print\n        :return: None\n        \"\"\"\n        sys.stderr.write(\"%s... Error...\\n\" % message)\n        sys.stderr.flush()\n        pass\n\n\ndef print_success(self, message):\n        \"\"\"\n        print success message on screen\n\n        .. note::\n\n            success message only write to `sys.stdout`\n\n\n        :param str message: message to print\n        :return: None\n        \"\"\"\n        sys.stdout.write(\"%s... Success...\\n\" % message)\n        sys.stdout.flush()\n        pass\n\n\ndef print_warning(self, message):\n        \"\"\"\n        print warning message on screen\n\n        .. note::\n\n            warning message only write to `sys.stderr`\n\n\n        :param str message: message to print\n        :return: None\n        \"\"\"\n        sys.stderr.write(\"%s... Warning...\\n\" % message)\n        sys.stderr.flush()\n        pass\n\n\ndef print_info(self, message):\n        \"\"\"\n        print info message on screen\n\n        .. note",
        "\n\ndef error_message(self, message, fh=None, prefix=\"[error]:\", suffix=\"...\"):\n        \"\"\"\n        print error type message,\n        if file handle is `sys.stdout`, print color message\n\n\n        :param str message: message to print\n        :param file fh: file handle,default is `sys.stdout`\n        :param str prefix: message prefix,default is `[error]`\n        :param str suffix: message suffix ,default is `...`\n        :return: None\n        \"\"\"\n\n        msg = prefix + message + suffix\n        fh = fh or sys.stdout\n\n        if fh is sys.stdout:\n            termcolor.cprint(msg, color=\"red\")\n        else:\n            fh.write(msg)\n\n        pass\n\ndef info_message(self, message, fh=None, prefix=\"[info]:\", suffix=\"...\"):\n        \"\"\"\n        print info type message,\n        if file handle is `sys.stdout`, print color message\n\n\n        :param str message: message to print\n        :param file fh: file handle,default is `sys.stdout`\n        :param str prefix: message prefix,default is `[info]`\n        :param str suffix: message suffix ,default is `...`\n        :return: None\n        \"\"\"",
        "\n\ndef error_message_with_file(self, message, fh=None, prefix=\"[error]:\",\n                           suffix=\"...\"):\n        \"\"\"\n        print error type message\n        if file handle is `sys.stderr`, print color message\n\n        :param str message: message to print\n        :param file fh: file handle, default is `sys.stdout`\n        :param str prefix: message prefix,default is `[error]`\n        :param str suffix: message suffix ,default is '...'\n        :return: None\n        \"\"\"\n\n        msg = prefix + message + suffix\n        fh = fh or sys.stderr\n\n        if fh is sys.stderr:\n            termcolor.cprint(msg, color=\"red\")\n        else:\n            fh.write(msg)\n        pass\n\ndef error_message_with_file_with_prefix(self, message, fh=None, prefix=\"[error]:\",\n                                    suffix=\"...\"):\n        \"\"\"\n        print error type message\n        if file handle is `sys.stderr`, print color message\n\n        :param str message: message to print\n        :param file fh: file handle, default is `sys.stdout`\n        :param str prefix: message prefix,default is `[error]`\n        :param str suffix: message suffix ,default is '...'\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef url_correct_export(self, point, auth=None, export=None):\n        '''\n        Returns a Corrected URL to be used for a Request\n        as per the REST API.\n        '''\n        newUrl = self.__url + point + '.json'\n        if auth or export:\n            newUrl += \"?\"\n        if auth:\n            if not newUrl.endswith('?'):\n                newUrl += \"&\"\n            newUrl += \"auth=\" + auth\n        if export:\n            if not newUrl.endswith('?'):\n                newUrl += \"&\"\n            newUrl += \"format=export\"\n        return newUrl\n\ndef url_correct_export_export(self, point, auth=None, export=None):\n        '''\n        Returns a Corrected URL to be used for a Request\n        as per the REST API.\n        '''\n        newUrl = self.__url + point + '.json'\n        if auth or export:\n            newUrl += \"?\"\n        if auth:\n            if not newUrl.endswith('?'):\n                newUrl += \"&\"\n            newUrl += \"auth=\" + auth\n        if export:\n            if not newUrl.endswith('?'):\n                newUrl += \"&\"\n            newUrl += \"format=export\"\n        return newUrl\n\ndef url_",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate",
        "\n\ndef unpickle(filepath):\n    \"\"\"Unpickle and decompress.\"\"\"\n    arr = pkl.loads(open(filepath, 'rb').read())\n    with open(filepath, 'rb') as f:\n        s = 0\n        while s < len(arr):\n            e = min(s + blosc.MAX_BUFFERSIZE, len(arr))\n            carr = blosc.decompress(arr[s:e], typesize=8)\n            f.write(carr)\n            s = e\n\ndef load_pickle(filepath):\n    \"\"\"Load pickle.\"\"\"\n    with open(filepath, 'rb') as f:\n        return pkl.loads(f.read())\n\ndef save_pickle(obj, filepath):\n    \"\"\"Save pickle.\"\"\"\n    with open(filepath, 'wb') as f:\n        pkl.dumps(obj, f, -1)\n\ndef load_pickle_file(filepath):\n    \"\"\"Load pickle file.\"\"\"\n    with open(filepath, 'rb') as f:\n        return pkl.loads(f.read())\n\ndef save_pickle_file(obj, filepath):\n    \"\"\"Save pickle file.\"\"\"\n    with open(filepath, 'wb') as f:\n        pkl.dumps(obj, f, -1)\n\ndef load",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        return None\n\ndef load_git_config(self):\n        \"\"\"\n        try use gitconfig info.\n        author,email etc.\n        \"\"\"\n        git_config_path = os.path.expanduser('~/.git/config')\n\n        if os.path.exists(git_config_path):\n            parser = Parser()\n            parser.read(git_config_path)\n            parser.sections()\n            return parser\n\n        pass\n\ndef load_git_config_file(self, filename):\n        \"\"\"\n        try use gitconfig info.\n        author,email etc.\n        \"\"\"\n        git_config_path = os.path.expanduser('~/.git/config')\n\n        if os.path.exists(git_config_path):\n            parser = Parser()\n            parser.read(git_config_path)\n            parser.sections()\n            parser.read(filename)\n            return parser\n\n        pass\n\ndef load_git_config_file_list(self, filename):\n        \"\"\"\n        try use gitconfig info.\n        author,email etc.\n        \"\"\"\n        git_config_path = os.path.expanduser('~/.git/config')\n\n        if os.path.exists(git_config_path):\n            parser = Parser()",
        "\n\ndef add_arguments_for_python(cls):\n        \"\"\"\n        Init project.\n        \"\"\"\n        return [\n            (('--yes',), dict(action='store_true', help='clean .git repo')),\n            (('--variable', '-s'),\n             dict(nargs='+', help='set extra variable,format is name:value')),\n            (('--skip-builtin',),\n             dict(action='store_true', help='skip replace builtin variable')),\n        ]\n\n\ndef add_arguments_for_python_with_python_version(cls):\n        \"\"\"\n        Init project.\n        \"\"\"\n        return [\n            (('--yes',), dict(action='store_true', help='clean .git repo')),\n            (('--variable', '-s'),\n             dict(nargs='+', help='set extra variable,format is name:value')),\n            (('--skip-builtin',),\n             dict(action='store_true', help='skip replace builtin variable')),\n            (('--python-version', '-v'),\n             dict(nargs='+', help='set python version')),\n        ]\n\n\ndef add_arguments_for_python_with_python_version_and_python_version_and_python_version(cls):\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef orientation_funcs:\n    \"\"\"\n    A dictionary mapping orientation values to a function that takes an Image instance and returns a\n    PIL Image instance.\n    \"\"\"\n    return {\n        0: lambda im: im,\n        90: lambda im: im.rotate(90),\n        180: lambda im: im.rotate(180),\n        270: lambda im: im.rotate(270),\n        180_90: lambda im: im.rotate(180, 90),\n        270_180: lambda im: im.rotate(270, 180),\n        270_270: lambda im: im.rotate(270, 270),\n        270_180_90: lambda im: im.rotate(270, 180, 90),\n        270_270_180: lambda im: im.rotate(270, 180, 180),\n        270_270_270: lambda im: im.rotate(270, 270, 180),\n        270_270_270_180: lambda im: im.rotate(270, 270, 180, 90),\n        270_270_270_270: lambda im: im.rotate(270, 270, 270, 180),\n        270_270_270_270_180: lambda im: im.rotate(270, 270, 270,",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        ".echo(\"Creating %s...\" % title)\n    site = Site(title, url)\n    site.save()\n\n    # Create a new blog.\n    click.echo(\"Got it. Creating blog...\")\n    blog = Blog(title, url)\n    blog.save()\n\n    # Create a new blog post.\n    click.echo(\"Got it. Creating blog post...\")\n    blog_post = BlogPost(title, url)\n    blog_post.save()\n\n    # Create a new blog post tag.\n    click.echo(\"Got it. Creating blog post tag...\")\n    blog_tag = BlogTag(title, url)\n    blog_tag.save()\n\n    # Create a new blog post tag.\n    click.echo(\"Got it. Creating blog post tag...\")\n    blog_tag_2 = BlogTag(title, url)\n    blog_tag_2.save()\n\n    # Create a new blog post tag.\n    click.echo(\"Got it. Creating blog post tag...\")\n    blog_tag_3 = BlogTag(title, url)\n    blog_tag_3.save()\n\n    # Create a new blog post tag.\n    click.echo(\"Got it. Creating blog post tag...\")\n    blog_tag_4 = BlogTag(title, url)",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n                for branch in self._git.branch(color=\"never\").splitlines()]\n\ndef get_commits(self):\n        \"\"\"Returns a list of commits\"\"\"\n        return [self._sanitize(commit)\n                for commit in self._git.commit(color=\"never\").splitlines()]\n\ndef get_commits_by_branch(self, branch):\n        \"\"\"Returns a list of commits by a branch\"\"\"\n        return [self._sanitize(commit)\n                for commit in self._git.commit(color=\"never\", branch=branch).splitlines()]\n\ndef get_commits_by_commit(self, commit):\n        \"\"\"Returns a list of commits by a commit\"\"\"\n        return [self._sanitize(commit)\n                for commit in self._git.commit(color=\"never\", commit=commit).splitlines()]\n\ndef get_commits_by_message(self, message):\n        \"\"\"Returns a list of commits by a message\"\"\"\n        return [self._sanitize(commit)\n                for commit in self._git.commit(color=\"never\", message=message).splitlines()]\n\ndef get_commits_by_message_and_branch(self, message, branch):\n        \"\"\"Returns a list of commits by a message and a branch\"\"\"\n        return [self._sanitize(commit)\n               ",
        "(self._git.branch(color=\"never\").splitlines()\n                     if branch.startswith(\"*\"))\n\ndef get_current_branch_name(self):\n        \"\"\"Returns the currently active branch name\"\"\"\n        return next((self._sanitize(branch)\n                     for branch in self._git.branch(color=\"never\").splitlines()\n                     if branch.startswith(\"*\")),\n                    None)\n\ndef get_current_branch_name_with_prefix(self, prefix):\n        \"\"\"Returns the currently active branch name with a prefix\"\"\"\n        return next((self._sanitize(branch)\n                     for branch in self._git.branch(color=\"never\").splitlines()\n                     if branch.startswith(prefix)),\n                    None)\n\ndef get_current_branch_name_with_suffix(self, suffix):\n        \"\"\"Returns the currently active branch name with a suffix\"\"\"\n        return next((self._sanitize(branch)\n                     for branch in self._git.branch(color=\"never\").splitlines()\n                     if branch.endswith(suffix)),\n                    None)\n\ndef get_current_branch_name_with_prefix_and_suffix(self, prefix, suffix):\n        \"\"\"Returns the currently active branch name with a prefix and suffix\"\"\"\n        return next((self._sanitize(branch)\n",
        ")\n\ndef create_commit(self, message):\n        \"\"\"Create a commit\"\"\"\n        return str(self._git.add('.', message))\n\ndef create_tag(self, name, message):\n        \"\"\"Create a tag\"\"\"\n        return str(self._git.tag(name, message))\n\ndef create_commit_message(self, message):\n        \"\"\"Create a commit message\"\"\"\n        return str(self._git.commit(message))\n\ndef create_tag_message(self, name, message):\n        \"\"\"Create a tag message\"\"\"\n        return str(self._git.tag(name, message))\n\ndef create_commit_message_with_tag(self, message, tag):\n        \"\"\"Create a commit message with a tag\"\"\"\n        return str(self._git.commit(message, tag))\n\ndef create_tag_message_with_tag(self, name, message, tag):\n        \"\"\"Create a tag message with a tag\"\"\"\n        return str(self._git.tag(name, message, tag))\n\ndef create_commit_message_with_tag_and_message(self, message, tag, message):\n        \"\"\"Create a commit message with a tag and message\"\"\"\n        return str(self._git.commit(message, tag, message))\n\ndef create_tag_message_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef maybe(func, default=None):\n    \"\"\"\n    Create a callable that applies ``func`` to every value in a sequence.\n\n    If the value is not a sequence then an empty list is returned.\n\n    :type  func: `callable`\n    :param func: Callable to be applied to the first result.\n    \"\"\"\n    def _maybe(result):\n        if _isSequenceTypeNotText(result):\n            return func(result)\n        return []\n    return maybe(_maybe, default=default)\n\ndef _isSequenceTypeNotText(result):\n    return isinstance(result, Sequence) and not isinstance(result, Text)\n",
        "\n\ndef Number(value, encoding=None):\n    \"\"\"\n    Parse a value as a number.\n\n    :type  value: `float` or `int`\n    :param value: Number value to parse\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat ``float`` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `float`\n    :return: Parsed number or ``None`` if ``value`` is neither `float` nor `int`.\n    \"\"\"\n    if encoding is None:\n        encoding = 'utf-8'\n    if isinstance(value, float):\n        return value\n    elif isinstance(value, int):\n        return value\n    return None\n\ndef Boolean(value, encoding=None):\n    \"\"\"\n    Parse a value as a boolean.\n\n    :type  value: `bool`\n    :param value: Boolean value to parse\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat ``bool`` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `bool`\n    :return: Parsed boolean or ``None`` if ``value`` is neither `bool` nor `int`.\n    \"\"\"\n    if encoding is None:\n        encoding = 'utf-8",
        "\n\n\ndef Float(value, base=10, encoding=None):\n    \"\"\"\n    Parse a value as a float.\n\n    :type  value: `unicode` or `bytes`\n    :param value: Text value to parse\n\n    :type  base: `unicode` or `bytes`\n    :param base: Base to assume ``value`` is specified in.\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat ``bytes`` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `float`\n    :return: Parsed float or ``None`` if ``value`` could not be parsed as a\n        float.\n    \"\"\"\n    try:\n        return float(Text(value, encoding), base)\n    except (TypeError, ValueError):\n        return None\n\n\ndef Text(value, encoding=None):\n    \"\"\"\n    Parse a value as a string.\n\n    :type  value: `unicode` or `bytes`\n    :param value: Text value to parse\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat ``bytes`` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `str`\n    :return: Parsed string or ``None`` if ``value`` could not",
        "\n\n\ndef Text(value, encoding=None):\n    \"\"\"\n    Parse a value as a text.\n\n    :type  value: `unicode` or `bytes`\n    :param: Text value to parse.\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat `bytes` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `str`\n    :return: Parsed text or ``None`` if ``value`` did not match ``utf-8`` or ``utf-16``\n        values.\n    \"\"\"\n    value = Text(value, encoding)\n    if value is not None:\n        value = value.lower().strip()\n    return value\n\n\ndef Number(value, decimal=None, encoding=None):\n    \"\"\"\n    Parse a value as a number.\n\n    :type  value: `unicode` or `bytes`\n    :param: Text value to parse.\n\n    :type  decimal: `float`\n    :param decimal: Decimal value to parse.\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat `bytes` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `float`\n    :return: Parsed number or ``None`` if ``value``",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\ndef Float(value, encoding=None):\n    \"\"\"\n    Parse a value as a float.\n\n    :type  value: `unicode` or `bytes`\n    :param value: Text value to parse, which should be the number of seconds\n        since the epoch.\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat `bytes` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `float`\n    :return: Parsed float or ``None`` if ``value`` could not be parsed.\n    \"\"\"\n    try:\n        return float(value)\n    except ValueError:\n        return None\n\n\ndef Time(value, _divisor=1., tz=UTC, encoding=None):\n    \"\"\"\n    Parse a value as a time in seconds.\n\n    :type  value: `unicode` or `bytes`\n    :param value: Text value to parse, which should be the number of seconds\n        since the epoch.\n\n    :type  _divisor: `float`\n    :param _divisor: Number to divide the value by.\n\n    :type  tz: `tzinfo`\n    :param tz: Timezone, defaults to UTC.\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to",
        "\n\n\ndef parse_query(query):\n    \"\"\"\n    Parse query parameters.\n\n    :type  query: `dict` mapping `bytes` to `list` of `bytes`\n    :param query: Mapping of query argument names to lists of argument values,\n        this is the form that Twisted Web's `IRequest.args\n        <twisted:twisted.web.iweb.IRequest.args>` value takes.\n\n    :rtype: `dict` mapping `bytes` to `object`\n    :return: Mapping of query argument names to parsed argument values.\n    \"\"\"\n    return parse(\n        {key: parser(query.get(key, [])) for key, parser in expected.items()},\n        query)\n\n\ndef parse_query_string(query):\n    \"\"\"\n    Parse query parameters.\n\n    :type  query: `dict` mapping `bytes` to `list` of `bytes`\n    :param query: Mapping of query argument names to lists of argument values,\n        this is the form that Twisted Web's `IRequest.args\n        <twisted:twisted.web.iweb.IRequest.args>` value takes.\n\n    :rtype: `dict` mapping `bytes` to `object`\n    :return: Mapping of query argument names to parsed argument values.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _computeAllowedMethods(resource):\n    \"\"\"\n    Compute the allowed methods for a given resource.\n\n    See `IResource.allowedMethods <twisted:twisted.web.resource.IResource.allowedMethods>`.\n    \"\"\"\n    allowedMethods = resource.allowedMethods\n    if allowedMethods is None:\n        allowedMethods = resource.allowedMethods = _computeAllowedMethods(resource)\n    return allowedMethods\n\n\nclass UnsupportedMethod(Exception):\n    \"\"\"\n    Raised when a resource method is not supported.\n    \"\"\"\n    pass\n\n\nclass UnsupportedResource(Exception):\n    \"\"\"\n    Raised when a resource is not supported.\n    \"\"\"\n    pass\n\n\nclass UnsupportedMethod(object):\n    \"\"\"\n    Raised when a resource method is not supported.\n    \"\"\"\n    def __init__(self, allowedMethods):\n        self.allowedMethods = allowedMethods\n\n    def __call__(self, request):\n        raise UnsupportedMethod(self.allowedMethods)\n\n\nclass UnsupportedResource(object):\n    \"\"\"\n    Raised when a resource is not supported.\n    \"\"\"\n    def __init__(self, allowedMethods):\n        self.allowedMethods = allowedMethods\n\n    def __call__(self, request):\n        raise UnsupportedResource(self.allowedMethods)\n\n\nclass Unsupported",
        "\n\nclass _Redirect(Redirect):\n    \"\"\"\n    A redirect that is treated as a redirect to another resource.\n    \"\"\"\n\n    def __init__(self, url):\n        super(_Redirect, self).__init__(url)\n\n    def __str__(self):\n        return str(self.url)\n\n    def __repr__(self):\n        return \"<Redirect %r>\" % self.url\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.url == other.url\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.url)\n\n    def __str__(self):\n        return \"<Redirect %r>\" % self.url\n\n    def __repr__(self):\n        return \"<Redirect %r>\" % self.url\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.url == other.url\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.url)\n\n    def __str__(self):\n       ",
        "\n\ndef _handleRenderError(self, request, result):\n        \"\"\"\n        Handle the result from `IResource.render`.\n\n        If the result is a `Deferred` then return `NOT_DONE_YET` and add\n        a callback to write the result to the request when it arrives.\n        \"\"\"\n        def _requestFinished(result, cancel):\n            cancel()\n            return result\n        if not isinstance(result, Deferred):\n            result = succeed(result)\n\n        def _whenDone(result):\n            render = getattr(result, 'render', lambda request: result)\n            renderResult = render(request)\n            if renderResult != NOT_DONE_YET:\n                request.write(renderResult)\n                request.finish()\n            return result\n        request.notifyFinish().addBoth(_requestFinished, result.cancel)\n        result.addCallback(self._adaptToResource)\n        result.addCallback(_whenDone)\n        result.addErrback(request.processingFailed)\n        return NOT_DONE_YET\n\ndef _handleRenderError(self, request, result):\n        \"\"\"\n        Handle the result from `IResource.render`.\n\n        If the result is a `Deferred` then return `NOT_DONE_YET` and add\n        a callback to write the result to the",
        "\n\n\nclass Acceptable(object):\n    \"\"\"\n    A handler that accepts any content type.\n    \"\"\"\n    def __init__(self, handler):\n        self._handler = handler\n        self._fallback = False\n\n    def accept(self, request):\n        \"\"\"\n        Accept the request.\n\n        :param request: The request to accept.\n        :type request: twisted.web.iweb.IRequest\n        :return: A resource that can be used to serve the request.\n        :rtype: twisted.web.iweb.IResource\n        \"\"\"\n        return _negotiateHandler(self, request)\n\n    def fallback(self, request):\n        \"\"\"\n        Fallback to the first handler that accepts the request.\n\n        :param request: The request to fallback to.\n        :type request: twisted.web.iweb.IRequest\n        :return: A resource that can be used to serve the request.\n        :rtype: twisted.web.iweb.IResource\n        \"\"\"\n        return self._fallback = True\n\n    def __repr__(self):\n        return \"<Acceptable %r>\" % self._handler\n\n\nclass NotAcceptable(object):\n    \"\"\"\n    A handler that does not accept any content type.\n    \"\"\"\n    def __init__",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n\ndef _splitHeaders(headers):\n    \"\"\"\n    Split a ``Content-Type`` header into a list of headers.\n\n    @type  headers: `twisted.web.http_headers.Headers`\n    @param headers: Request headers.\n\n    @rtype: `list`\n    @return: List of headers.\n    \"\"\"\n    return [\n        (h.get(b'charset', b'utf-8'), h)\n        for h in headers.getRawHeaders(b'Content-Type', [])]\n",
        "\n",
        "\n\ndef bind(path, with_path=None):\n    \"\"\"\n    Bind a python module file to `Settings._wrapped`\n\n    :param str path: a python module file,\n        if user set it,write config to `Settings._wrapped`\n    :param str with_path: search path\n    \"\"\"\n\n    if path:\n        Settings.bind(path, with_path=with_path)\n\n    Settings._wrapped = Settings()\n\ndef get_settings():\n    \"\"\"\n    Get `Settings` instance\n    \"\"\"\n\n    return Settings._wrapped\n\ndef get_settings_path():\n    \"\"\"\n    Get `Settings` instance\n    \"\"\"\n\n    return Settings._wrapped.path\n\ndef get_settings_with_path():\n    \"\"\"\n    Get `Settings` instance\n    \"\"\"\n\n    return Settings._wrapped.with_path\n\ndef get_settings_with_path_path():\n    \"\"\"\n    Get `Settings` instance\n    \"\"\"\n\n    return Settings._wrapped.with_path_path\n\ndef get_settings_with_path_path_path():\n    \"\"\"\n    Get `Settings` instance\n    \"\"\"\n\n    return Settings._wrapped.with_path_path_path\n\ndef get_settings_with_path_path_path_path():\n    \"\"\"\n   ",
        "\n\nclass Settings(object):\n    \"\"\"\n    settings class\n    \"\"\"\n\n    _path = None\n    _wrapped = None\n\n    def __init__(self):\n        pass\n\n    def __getattr__(self, name):\n        if name in self.__dict__:\n            return self.__dict__[name]\n        else:\n            raise AttributeError(name)\n\n    def __setattr__(self, name, value):\n        if name in self.__dict__:\n            self.__dict__[name] = value\n        else:\n            raise AttributeError(name)\n\n    def __delattr__(self, name):\n        if name in self.__dict__:\n            del self.__dict__[name]\n        else:\n            raise AttributeError(name)\n\n    def __str__(self):\n        return str(self.__dict__)\n\n    def __repr__(self):\n        return str(self.__dict__)\n\n    def __eq__(self, other):\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other):\n        return self.__dict__ != other.__dict__\n\n    def __lt__(self, other):\n        return self.__dict__ < other.__dict__\n\n    def __le__(self",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef broadcast(self, use_open_peers=True, queue=True, **kw):\n        \"\"\"\n        broadcast a transaction immediately. Failed transactions are picked up by the TxBroadcaster\n\n        :param ip: specific peer IP to send tx to\n        :param port: port of specific peer\n        :param use_open_peers: use Arky's broadcast method\n        \"\"\"\n\n        if not use_open_peers:\n            ip = kw.get('ip')\n            port = kw.get('port')\n            peer = 'http://{}:{}'.format(ip, port)\n            res = arky.rest.POST.peer.transactions(peer=peer, transactions=[self.tx.tx])\n\n        else:\n            res = arky.core.sendPayload(self.tx.tx)\n\n        if self.tx.success != '0.0%':\n            self.tx.error = None\n            self.tx.success = True\n        else:\n            self.tx.error = res['messages']\n            self.tx.success = False\n\n        self.tx.tries += 1\n        self.tx.res = res\n\n        if queue:\n            self.tx.send = True\n\n        self.__save()\n        return res\n\ndef __save(self):\n        self.",
        "\n        else:\n            self.send(use_open_peers, **kw)\n\ndef check_confirmations_or_send(self, use_open_peers=False, **kw):\n        \"\"\"\n        check if a tx is confirmed, else send it.\n\n        :param use_open_peers: select random peers fro api/peers endpoint\n        \"\"\"\n        if self.confirmations() == 0:\n            self.send(use_open_peers, **kw)\n        else:\n            self.send(use_open_peers, **kw)\n\ndef check_confirmations_or_send_with_fee(self, use_open_peers=False, fee=0.01, **kw):\n        \"\"\"\n        check if a tx is confirmed, else send it.\n\n        :param use_open_peers: select random peers fro api/peers endpoint\n        :param fee: fee to send\n        \"\"\"\n        if self.confirmations() == 0:\n            self.send(use_open_peers, fee=fee, **kw)\n        else:\n            self.send(use_open_peers, fee=fee, **kw)\n\ndef check_confirmations_or_send_with_fee_with_fee(self, use_open_peers=False, fee=0.01",
        "\n\n\ndef get_command(command):\n    \"\"\"\n    Get sub-command\n\n    :param command: `str` matched sub-parser\n    :return: `str` matched sub-parser\n    \"\"\"\n    from cliez.conf import COMPONENT_ROOT\n\n    root = COMPONENT_ROOT\n\n    if root is None:\n        sys.stderr.write(\"cliez.conf.COMPONENT_ROOT not set.\\n\")\n        sys.exit(2)\n\n    if not os.path.exists(root):\n        sys.stderr.write(\n            \"please set a valid path for `cliez.conf.COMPONENT_ROOT`\\n\")\n        sys.exit(2)\n\n    try:\n        path = os.listdir(os.path.join(root, 'components'))\n        return path[path.index(command) + 1]\n    except FileNotFoundError:\n        return ''\n\n\ndef get_command_args(command):\n    \"\"\"\n    Get sub-command arguments\n\n    :param command: `str` matched sub-parser\n    :return: `list` matched sub-parser\n    \"\"\"\n    from cliez.conf import COMPONENT_ROOT\n\n    root = COMPONENT_ROOT\n\n    if root is None:\n        sys.stderr.write(\"cliez.conf.",
        "\n",
        "\n\ndef command_list():\n    \"\"\"\n    get command list\n\n    :return: list of command names\n    \"\"\"\n    return [\n        'help',\n        'version',\n        'version-info',\n        'help-info',\n        'help-version',\n        'version-info-info',\n        'version-info-info-info',\n        'version-info-info-info-info',\n        'version-info-info-info-info-info',\n        'version-info-info-info-info-info',\n        'version-info-info-info-info-info-info',\n        'version-info-info-info-info-info-info',\n        'version-info-info-info-info-info-info-info',\n        'version-info-info-info-info-info-info-info',\n        'version-info-info-info-info-info-info-info',\n        'version-info-info-info-info-info-info-info',\n        'version-info-info-info-info-info-info-info',\n        'version-info-info-info-info-info-info-info',\n        'version-info-info-info-info-info-info-info',\n        'version-info",
        "\n\ndef underscore_to_hump(name):\n    \"\"\"\n    Convert underscore to Hump style\n\n    :param name: str\n    :return: str\n    \"\"\"\n    new_name = ''\n\n    pos = 0\n    for c in name:\n        if pos == 0:\n            new_name = c.upper()\n        elif 65 <= ord(c) <= 90:\n            new_name += '_' + c.upper()\n            pass\n        else:\n            new_name += c\n        pos += 1\n        pass\n    return new_name\n\ndef hump_to_underscore_and_underscore(name):\n    \"\"\"\n    Convert Hump style to underscore and underscore\n\n    :param name: str\n    :return: str\n    \"\"\"\n    new_name = ''\n\n    pos = 0\n    for c in name:\n        if pos == 0:\n            new_name = c.lower()\n        elif 65 <= ord(c) <= 90:\n            new_name += '_' + c.lower()\n            pass\n        else:\n            new_name += c\n        pos += 1\n        pass\n    return new_name\n\ndef underscore_to_hump_and_underscore(name):\n    \"\"\"\n    Convert underscore to Hump style and underscore\n\n   ",
        "\n\ndef get_fuel_price(self, station_id: str) -> GetFuelPriceResponse:\n        \"\"\"Fetches fuel price for a given station.\"\"\"\n        response = requests.get(\n            '{}/prices/{}'.format(API_URL_BASE, station_id),\n            headers=self._get_headers(),\n            timeout=self._timeout,\n        )\n\n        if not response.ok:\n            raise FuelCheckError.create(response)\n\n        return GetFuelPriceResponse.deserialize(response.json())\n\ndef get_fuel_price_by_id(self, station_id: str, fuel_id: str) -> GetFuelPriceResponse:\n        \"\"\"Fetches fuel price for a given station and fuel id.\"\"\"\n        response = requests.get(\n            '{}/prices/{}'.format(API_URL_BASE, station_id),\n            headers=self._get_headers(),\n            timeout=self._timeout,\n        )\n\n        if not response.ok:\n            raise FuelCheckError.create(response)\n\n        return GetFuelPriceResponse.deserialize(response.json())\n\ndef get_fuel_price_by_id_by_station_id(self, station_id: str, fuel_id: str) -> GetFuelPrice",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_fuel_prices_within_radius_with_brand(\n            self, latitude: float, longitude: float, radius: int,\n            fuel_type: str, brands: Optional[List[str]] = None\n    ) -> List[StationPrice]:\n        \"\"\"Gets all the fuel prices within the specified radius with the\n        specified brand.\n\n        :param latitude: latitude of the fuel price\n        :param longitude: longitude of the fuel price\n        :param radius: radius of the fuel price\n        :param fuel_type: fuel type of the fuel price\n        :param brands: list of brand codes of the fuel price\n        :return: list of station prices\n        \"\"\"\n\n        if brands is None:\n            brands = []\n        response = requests.post(\n            '{}/prices/nearby'.format(API_URL_BASE),\n            json={\n                'fueltype': fuel_type,\n                'latitude': latitude,\n                'longitude': longitude,\n                'radius': radius,\n                'brand': brands,\n            },\n            headers=self._get_headers(),\n            timeout=self._timeout,\n        )\n\n        if not response.ok:\n            raise FuelCheckError.create(response)\n\n       ",
        "\n\nclass FuelCheckError(Exception):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"Base class for all FuelCheck errors.\"\"\"\n\n\nclass FuelCheckError(FuelCheckError):\n    \"\"\"",
        "\n\ndef get_reference_data_by_id(\n            self,\n            reference_id: str,\n            modified_since: Optional[datetime.datetime] = None\n    ) -> GetReferenceDataResponse:\n        \"\"\"\n        Fetches API reference data by ID.\n\n        :param reference_id: The reference ID.\n        :param modified_since: The response will be empty if no\n        changes have been made to the reference data since this\n        timestamp, otherwise all reference data will be returned.\n        \"\"\"\n\n        if modified_since is None:\n            modified_since = datetime.datetime(year=2010, month=1, day=1)\n\n        response = requests.get(\n            '{}/lovs/{}'.format(API_URL_BASE, reference_id),\n            headers={\n                'if-modified-since': self._format_dt(modified_since),\n                **self._get_headers(),\n            },\n            timeout=self._timeout,\n        )\n\n        if not response.ok:\n            raise FuelCheckError.create(response)\n\n        # return response.text\n        return GetReferenceDataResponse.deserialize(response.json())\n\ndef get_reference_data_by_name(\n            self,\n            reference_name: str,\n            modified_since: Optional[",
        "\n        vars['license_url'] = 'http://www.apache.org/licenses/LICENSE-2.0'\n        vars['license_url_short'] = 'Apache'\n        vars['license_url_long'] = 'http://www.apache.org/licenses/LICENSE-2.0'\n        vars['license_url_full'] = 'http://www.apache.org/licenses/LICENSE-2.0'\n        vars['license_url_short_full'] = 'Apache'\n        vars['license_url_long_full'] = 'http://www.apache.org/licenses/LICENSE-2.0'\n        vars['license_url_full_short'] = 'Apache'\n        vars['license_url_long_short'] = 'Apache'\n        vars['license_url_full_long'] = 'http://www.apache.org/licenses/LICENSE-2.0'\n        vars['license_url_short_long'] = 'Apache'\n        vars['license_url_long_short'] = 'Apache'\n        vars['license_url_full_short_long'] = 'Apache'\n        vars['license_url_full_long'] = 'Apache'\n        vars['license_url_short_long",
        "\n\ndef Any(name, encoding=None):\n    \"\"\"\n    Match a route parameter.\n\n    `Any` is a synonym for `Text`.\n\n    :type  name: `bytes`\n    :param name: Route parameter name.\n\n    :type  encoding: `bytes`\n    :param encoding: Default encoding to assume if the ``Content-Type``\n        header is lacking one.\n\n    :return: ``callable`` suitable for use with `route` or `subroute`.\n    \"\"\"\n    return Text(name, encoding)\n\ndef ContentEncoding(name, encoding=None):\n    \"\"\"\n    Match a route parameter.\n\n    `Any` is a synonym for `Text`.\n\n    :type  name: `bytes`\n    :param name: Route parameter name.\n\n    :type  encoding: `bytes`\n    :param encoding: Default encoding to assume if the ``Content-Type``\n        header is lacking one.\n\n    :return: ``callable`` suitable for use with `route` or `subroute`.\n    \"\"\"\n    return Text(name, encoding)\n\ndef ContentLength(name, encoding=None):\n    \"\"\"\n    Match a route parameter.\n\n    `Any` is a synonym for `Text`.\n\n    :type  name: `bytes`\n    :param",
        "\n\ndef Float(name, base=10, encoding=None):\n    \"\"\"\n    Match a float route parameter.\n\n    :type  name: `bytes`\n    :param name: Route parameter name.\n\n    :type  base: `int`\n    :param base: Base to interpret the value in.\n\n    :type  encoding: `bytes`\n    :param encoding: Default encoding to assume if the ``Content-Type``\n        header is lacking one.\n\n    :return: ``callable`` suitable for use with `route` or `subroute`.\n    \"\"\"\n    def _match(request, value):\n        return name, query.Float(\n            value,\n            base=base,\n            encoding=contentEncoding(request.requestHeaders, encoding))\n    return _match\n\ndef Decimal(name, base=10, encoding=None):\n    \"\"\"\n    Match a decimal route parameter.\n\n    :type  name: `bytes`\n    :param name: Route parameter name.\n\n    :type  base: `int`\n    :param base: Base to interpret the value in.\n\n    :type  encoding: `bytes`\n    :param encoding: Default encoding to assume if the ``Content-Type``\n        header is lacking one.\n\n    :return: ``callable`` suitable for use with",
        "\n\n\ndef _matchRequest(request, segments, partialMatching):\n    \"\"\"\n    Match a request path against our path components.\n\n    The path components are always matched relative to their parent is in the\n    resource hierarchy, in other words it is only possible to match URIs nested\n    more deeply than the parent resource. If no components are given the null\n    route is matched, this is the case where ``segments`` is empty.\n\n    :type  request: ``HttpRequest``\n    :param request: HttpRequest to match against.\n\n    :type  segments: ``sequence`` of `bytes`\n    :param segments: Sequence of path segments, from the request, to match\n        against.\n\n    :type  partialMatching: `bool`\n    :param partialMatching: Allow partial matching against the request path?\n\n    :rtype: 2-`tuple` of `dict` keyed on `bytes` and `list` of `bytes`\n    :return: Pair of parameter results, mapping parameter names to processed\n        values, and a list of the remaining request path segments. If there is\n        no route match the result will be ``None`` and the original request path\n        segments.\n    \"\"\"\n    if len(segments) == len(request.path):\n        return request.path, segments\n\n    for us, them in izip_long",
        "\n\ndef resource(f):\n    \"\"\"\n    Decorate a callable to produce a resource.\n\n    This simply produces a new callable that invokes the original callable, and\n    calls ``resource`` on the ``routerAttribute``.\n\n    If the router producer has multiple routers the attribute can be altered to\n    choose the appropriate one, for example:\n\n    .. code-block:: python\n\n        class _ComplexRouter(object):\n            router = Router()\n            privateRouter = Router()\n\n            @router.route('/')\n            def publicRoot(self, request, params):\n                return SomethingPublic(...)\n\n            @privateRouter.route('/')\n            def privateRoot(self, request, params):\n                return SomethingPrivate(...)\n\n        PublicResource = routedResource(_ComplexRouter)\n        PrivateResource = routedResource(_ComplexRouter, 'privateRouter')\n\n    :type  f: ``callable``\n    :param f: Callable producing an object with a `Router` attribute, for\n        example, a type.\n\n    :type  routerAttribute: `str`\n    :param routerAttribute: Name of the `Router` attribute on the result of\n        calling ``f``.\n\n    :rtype: `callable`\n    :return: Callable producing an `IResource`.\n    \"\"\"\n   ",
        "\n        return router\n\nclass Router(object):\n    \"\"\"\n    A router that can be used to route requests to a particular object.\n    \"\"\"\n    def __init__(self, routes=None):\n        \"\"\"\n        Create a new `Router` instance, with it's own set of routes, for ``routes``.\n        \"\"\"\n        self._routes = list(routes or [])\n        self._self = None\n\n    def __call__(self, obj):\n        \"\"\"\n        Return a new `Router` instance, with it's own set of routes, for ``obj``.\n        \"\"\"\n        return _forObject(self, obj)\n\n    def __repr__(self):\n        \"\"\"\n        Return a string representation of the router.\n        \"\"\"\n        return '<Router %r>' % self._routes\n\n    def __str__(self):\n        \"\"\"\n        Return a string representation of the router.\n        \"\"\"\n        return '<Router %r>' % self._routes\n\n    def __eq__(self, other):\n        \"\"\"\n        Return ``True`` if the router's routes are equal to ``other``.\n        \"\"\"\n        return self._routes == other._routes\n\n    def __ne__(self, other):\n        \"\"\"\n        Return ``True`` if the router's routes are not equal to ``",
        ", matcher)\n\n    def _getRoutes(self):\n        \"\"\"\n        Return a list of all possible routes.\n        \"\"\"\n        return self._routes\n\n    def _getRoute(self, name):\n        \"\"\"\n        Return a route handler and matcher for the given name.\n        \"\"\"\n        for route, handler, matcher in self._routes:\n            if route[0] == name:\n                return handler, matcher\n        return None, None\n\n    def _getRouteHandler(self, name):\n        \"\"\"\n        Return a route handler for the given name.\n        \"\"\"\n        for route, handler in self._routes:\n            if route[0] == name:\n                return handler\n        return None\n\n    def _getRouteMatcher(self, name):\n        \"\"\"\n        Return a route matcher for the given name.\n        \"\"\"\n        for route, matcher in self._routes:\n            if route[0] == name:\n                return matcher\n        return None\n\n    def _getRouteHandlerAndMatcher(self, name):\n        \"\"\"\n        Return a tuple of the route handler and matcher for the given name.\n        \"\"\"\n        for route, handler, matcher in self._routes:\n            if route[0] == name:\n                return handler, matcher\n        return None, None\n\n    def _getRouteHandler",
        "\n        return _factory\n\n    def _addRoute(self, f, handler):\n        \"\"\"\n        Add a route to the router.\n\n        :param f: The function to add the route to.\n        :param handler: The handler to add to the route.\n        \"\"\"\n        self._routes.append((f, handler))\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        See `txspinneret.route.route`.\n\n        This decorator can be stacked with itself to specify multiple routes\n        with a single handler.\n        \"\"\"\n        def _factory(f):\n            self._addRoute(f, route(*args, **kwargs))\n            return f\n        return _factory\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        See `txspinneret.route.route`.\n\n        This decorator can be stacked with itself to specify multiple routes\n        with a single handler.\n        \"\"\"\n        def _factory(f):\n            self._addRoute(f, route(*args, **kwargs))\n            return f\n        return _factory\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        See `txspinneret.route.route`.\n\n        This decorator can be stacked with itself to specify multiple routes",
        "\n        return _factory\n\n\nclass Route(object):\n    \"\"\"\n    A route is a set of handlers that can be used to route requests.\n\n    This class is a decorator that can be used to specify multiple routes\n    with a single handler.\n    \"\"\"\n\n    def __init__(self, *handlers):\n        self._handlers = handlers\n\n    def __call__(self, f):\n        \"\"\"\n        See `txspinneret.route.Route.call`.\n\n        This decorator can be stacked with itself to specify multiple routes\n        with a single handler.\n        \"\"\"\n        def _factory(f):\n            self._addRoute(f, subroute(*handlers))\n            return f\n        return _factory\n\n    def __call__(self, f, *args, **kwargs):\n        \"\"\"\n        See `txspinneret.route.Route.call`.\n\n        This decorator can be stacked with itself to specify multiple routes\n        with a single handler.\n        \"\"\"\n        def _factory(f):\n            self._addRoute(f, subroute(*handlers), *args, **kwargs)\n            return f\n        return _factory\n\n    def __call__(self, f, *args, **kwargs):\n        \"\"\"\n        See `txspinneret.route.Route.call`.\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_items(filename, uuid):\n    \"\"\"\n    Read entries from JSON file\n    \"\"\"\n    with open(os.fsencode(str(filename)), \"r\") as f:\n        data = json.load(f)\n        results = [i for i in data if i[\"uuid\"] == str(uuid)]\n        if results:\n            return results\n        return []\n\ndef get_item_by_uuid(filename, uuid):\n    \"\"\"\n    Read entry from JSON file\n    \"\"\"\n    with open(os.fsencode(str(filename)), \"r\") as f:\n        data = json.load(f)\n        results = [i for i in data if i[\"uuid\"] == str(uuid)]\n        if results:\n            return results[0]\n        return None\n\ndef get_items_by_uuid(filename, uuid):\n    \"\"\"\n    Read entries from JSON file\n    \"\"\"\n    with open(os.fsencode(str(filename)), \"r\") as f:\n        data = json.load(f)\n        results = [i for i in data if i[\"uuid\"] == str(uuid)]\n        if results:\n            return results\n        return []\n\ndef get_item_by_name(filename, name):\n    \"\"\"\n    Read entry from JSON",
        "\n\ndef get_item(filename):\n    \"\"\"\n    Load entry from JSON file\n    \"\"\"\n    with atomic_read(os.fsencode(str(filename))) as temp_file:\n        with open(os.fsencode(str(filename))) as products_file:\n            # load the JSON data into memory\n            products_data = json.load(products_file)\n            # check if UUID already exists\n            uuid_list = [i for i in filter(\n                lambda z: z[\"uuid\"] == str(item[\"uuid\"]), products_data)]\n            if len(uuid_list) == 0:\n                return None\n            return products_data[uuid_list[0]]\n\ndef get_all_items():\n    \"\"\"\n    Load all items from JSON file\n    \"\"\"\n    with atomic_read(os.fsencode(str(PRODUCTS_FILE))) as temp_file:\n        with open(os.fsencode(str(PRODUCTS_FILE))) as products_file:\n            products_data = json.load(products_file)\n            return products_data\n\ndef get_all_products():\n    \"\"\"\n    Load all products from JSON file\n    \"\"\"\n    with atomic_read(os.fsencode(str(PRODUCTS_FILE))) as temp_file:\n        with open(os.",
        "\n\n\ndef update_products(filename, products):\n    \"\"\"\n    Update products in the JSON file\n    \"\"\"\n    with atomic_write(os.fsencode(str(filename))) as temp_file:\n        with open(os.fsencode(str(filename))) as products_file:\n            # load the JSON data into memory\n            products_data = json.load(products_file)\n            # apply modifications to the JSON data wrt UUID\n            # TODO: handle this in a neat way\n            if 'products' in products_data[-1]:\n                # handle orders object\n                [products_data[i][\"products\"][0].update(item) for (\n                    i, j) in enumerate(products_data) if j[\"uuid\"] == str(\n                        products[i][\"uuid\"])]\n            else:\n                # handle products object\n                [products_data[i].update(item) for (i, j) in enumerate(\n                    products_data) if j[\"uuid\"] == str(products[i][\"uuid\"])]\n            # save the modified JSON data into the temp file\n            json.dump(products_data, temp_file)\n            return True\n\n\ndef update_orders(filename, orders):\n    \"\"\"\n    Update orders in the JSON file\n    \"\"\"\n    with atomic",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef check_writable(self, timeout):\n        \"\"\"\n        Poll ``self.stdout`` and return True if it is writable.\n\n        :param float timeout: seconds to wait I/O\n        :return: True if writable, else False\n        :rtype: boolean\n        \"\"\"\n        rlist, wlist, xlist = select.select([self._stdout], [], [], timeout)\n        return bool(len(wlist))\n\ndef check_error(self, timeout):\n        \"\"\"\n        Poll ``self.stdout`` and return True if it is error.\n\n        :param float timeout: seconds to wait I/O\n        :return: True if error, else False\n        :rtype: boolean\n        \"\"\"\n        rlist, wlist, xlist = select.select([self._stdout], [], [], timeout)\n        return bool(len(wlist))\n\ndef check_timeout(self, timeout):\n        \"\"\"\n        Poll ``self.stdout`` and return True if it is timeout.\n\n        :param float timeout: seconds to wait I/O\n        :return: True if timeout, else False\n        :rtype: boolean\n        \"\"\"\n        rlist, wlist, xlist = select.select([self._stdout], [], [], timeout)\n        return bool(len(wlist",
        "\n    ]\n\n\ndef get_indices(s: Any) -> List[str]:\n    \"\"\" Retrieve a list of characters and escape codes where each escape\n        code uses only one index. The indexes will not match up with the\n        indexes in the original string.\n    \"\"\"\n    return [\n        c for c in s if c in string.printable\n    ]\n\n\ndef get_indices_list_with_unicode(s: Any) -> List[str]:\n    \"\"\" Retrieve a list of characters and escape codes where each escape\n        code uses only one index. The indexes will not match up with the\n        indexes in the original string.\n    \"\"\"\n    return [\n        c for c in s if c in string.printable\n    ]\n\n\ndef get_indices_list_with_unicode_with_index(s: Any) -> List[str]:\n    \"\"\" Retrieve a list of characters and escape codes where each escape\n        code uses only one index. The indexes will not match up with the\n        indexes in the original string.\n    \"\"\"\n    return [\n        c for c in s if c in string.printable\n    ]\n\n\ndef get_indices_list_with_unicode_with_index_with_unicode(s: Any) -> List[str]:\n    \"\"\" Retrieve a list of characters and escape codes where",
        ": str)\n\n\ndef codepat: str = re.compile(r'[0-9a-fA-F]')\n\n\ndef color_to_rgb(color: str) -> str:\n    \"\"\" Convert a color string to a RGB color string.\n        Returns empty string for \"falsey\" inputs.\n    \"\"\"\n    return codepat.sub('', color) if color else ''\n\n\ndef rgb_to_color(rgb: str) -> str:\n    \"\"\" Convert a RGB color string to a color string.\n        Returns empty string for \"falsey\" inputs.\n    \"\"\"\n    return codepat.sub('', rgb) if rgb else ''\n\n\ndef rgb_to_hex(rgb: str) -> str:\n    \"\"\" Convert a RGB color string to a hex color string.\n        Returns empty string for \"falsey\" inputs.\n    \"\"\"\n    return codepat.sub('', rgb) if rgb else ''\n\n\ndef hex_to_rgb(hex: str) -> str:\n    \"\"\" Convert a hex color string to a RGB color string.\n        Returns empty string for \"falsey\" inputs.\n    \"\"\"\n    return codepat.sub('', hex) if hex else ''\n\n\ndef hex_to_color(hex: str) -> str:\n    \"\"\" Convert a hex color string to a color",
        "\n        self.rel_bundle_path = builder.config.rel_bundle_path\n        self.abs_bundle_path = builder.config.abs_bundle_path\n        self.abs_path = builder.config.abs_path\n        self.asset = asset\n        self.builder = builder\n        self.output_dir = builder.config.output_dir\n        self.output_file = builder.config.output_file\n        self.output_file_ext = builder.config.output_file_ext\n        self.output_file_ext_lower = builder.config.output_file_ext_lower\n        self.output_file_ext_upper = builder.config.output_file_ext_upper\n        self.output_file_ext_lower_upper = builder.config.output_file_ext_lower_upper\n        self.output_file_ext_lower_upper_upper = builder.config.output_file_ext_lower_upper_upper\n        self.output_file_ext_lower_upper_upper_upper = builder.config.output_file_ext_lower_upper_upper_upper\n        self.output_file_ext_lower_upper_upper_upper = builder.config.output_file_ext_lower_upper_upper_upper\n        self.output_file_ext",
        "\n        return self\n\n    def add_files(self, *args):\n        \"\"\"\n        Add multiple files or list of files to bundle\n\n        :type: file_path: str|unicode\n        \"\"\"\n        for file_path in args:\n            self.files.append(FilePath(file_path, self))\n        return self\n\n    def add_directory(self, *args):\n        \"\"\"\n        Add single directory or list of directories to bundle\n\n        :type: directory_path: str|unicode\n        \"\"\"\n        for directory_path in args:\n            self.directories.append(DirectoryPath(directory_path, self))\n        return self\n\n    def add_directories(self, *args):\n        \"\"\"\n        Add multiple directories or list of directories to bundle\n\n        :type: directory_path: str|unicode\n        \"\"\"\n        for directory_path in args:\n            self.directories.append(DirectoryPath(directory_path, self))\n        return self\n\n    def add_file_list(self, *args):\n        \"\"\"\n        Add single file or list of files to bundle\n\n        :type: file_path: str|unicode\n        \"\"\"\n        for file_path in args:\n            self.files.append(FilePath(file_path, self))\n        return self\n\n    def add",
        "\ndef add_directory_list(self, *args, **kwargs):\n        \"\"\"\n        Add directory or directories list to bundle\n\n        :param exclusions: List of excluded paths\n\n        :type path: str|unicode\n        :type path: list\n        \"\"\"\n        exc = kwargs.get('exclusions', None)\n        for path in args:\n            self.files.append(DirectoryPath(path, self, exclusions=exc))\n\ndef add_directory_list_with_exclusions(self, *args, **kwargs):\n        \"\"\"\n        Add directory or directories list to bundle\n\n        :param exclusions: List of excluded paths\n\n        :type path: str|unicode\n        :type path: list\n        \"\"\"\n        exc = kwargs.get('exclusions', None)\n        for path in args:\n            self.files.append(DirectoryPath(path, self, exclusions=exc))\n\ndef add_directory_list_with_exclusions_and_exclude(self, *args, **kwargs):\n        \"\"\"\n        Add directory or directories list to bundle\n\n        :param exclusions: List of excluded paths\n\n        :type path: str|unicode\n        :type path: list\n        \"\"\"\n        exc = kwargs.get('exclusions', None)\n        for path in args:\n            self.files.append(DirectoryPath(",
        "\n\nclass AbstractPath(object):\n    \"\"\"\n    Base class for all paths\n    \"\"\"\n\n    def __init__(self, bundle, *args):\n        self.bundle = bundle\n        self.files = []\n\n    def add_file(self, path, *args):\n        \"\"\"\n        Add a file to the path\n\n        :type: path: static_bundle.paths.AbstractPath\n        :type: args: list\n        \"\"\"\n        self.files.append(path)\n\n    def get_path(self, path):\n        \"\"\"\n        Get the path for a given path\n\n        :type: path: static_bundle.paths.AbstractPath\n        :rtype: static_bundle.paths.AbstractPath\n        \"\"\"\n        for f in self.files:\n            if f.get_path(path):\n                return f\n        return None\n\n    def get_path_list(self):\n        \"\"\"\n        Get the list of paths for the bundle\n\n        :rtype: list\n        \"\"\"\n        return self.files\n\n    def get_path_list_by_name(self, name):\n        \"\"\"\n        Get the list of paths for a given name\n\n        :type: name: str\n        :rtype: list\n        \"\"\"\n        return [f for f in",
        "\n\ndef add_prepare_handler_chain(self, prepare_handlers):\n        \"\"\"\n        Add prepare handler to bundle\n\n        :type: prepare_handler: static_bundle.handlers.AbstractPrepareHandler\n        \"\"\"\n        if not isinstance(prepare_handlers, static_bundle.BUNDLE_ITERABLE_TYPES):\n            prepare_handlers = [prepare_handlers]\n        if self.prepare_handlers_chain is None:\n            self.prepare_handlers_chain = []\n        for handler in prepare_handlers:\n            self.prepare_handlers_chain.append(handler)\n\ndef add_prepare_handler_chain_with_name(self, prepare_handlers, name):\n        \"\"\"\n        Add prepare handler to bundle\n\n        :type: prepare_handler: static_bundle.handlers.AbstractPrepareHandler\n        :type: name: str\n        \"\"\"\n        if not isinstance(prepare_handlers, static_bundle.BUNDLE_ITERABLE_TYPES):\n            prepare_handlers = [prepare_handlers]\n        if self.prepare_handlers_chain is None:\n            self.prepare_handlers_chain = []\n        for handler in prepare_handlers:\n            self.prepare_handlers_chain.append(handler)\n        self.prepare_handlers_chain[name] = handler\n\ndef add_prepare_handler_chain_with_name_",
        "\n\ndef collect_files(self):\n        \"\"\"\n        Called when builder run collect files in builder group\n\n        :rtype: list[static_bundle.files.StaticFileResult]\n        \"\"\"\n        return []\n\nclass LessCompilerPrepareHandler(object):\n    \"\"\"\n    Prepare handler for LessCompiler\n    \"\"\"\n    def __init__(self):\n        self.prepare_handlers_chain = None\n\n    def prepare(self, result_files, self):\n        \"\"\"\n        Prepare handler for LessCompiler\n\n        :param result_files: list of files to be collected\n        :param self: LessCompiler instance\n        :return: list of files collected\n        \"\"\"\n        return result_files\n\nclass LessCompilerPrepareHandlerChain(object):\n    \"\"\"\n    Prepare handler chain for LessCompiler\n    \"\"\"\n    def __init__(self):\n        self.prepare_handlers = []\n\n    def add(self, prepare_handler):\n        \"\"\"\n        Add prepare handler\n\n        :param prepare_handler: prepare handler\n        :return: self\n        \"\"\"\n        self.prepare_handlers.append(prepare_handler)\n\n    def prepare(self, result_files, self):\n        \"\"\"\n        Prepare handler chain for LessCompiler\n\n        :param result_files: list of files to be collected\n        :param",
        "\n\ndef main():\n    \"\"\"Main function.\"\"\"\n    parser = argparse.ArgumentParser(description=\"\"\"\n    Get the number of files in the folder.\n    \"\"\")\n    parser.add_argument(\"-p\", \"--path\", help=\"\"\"\n    The path to the folder.\n    \"\"\")\n    parser.add_argument(\"-w\", \"--warning\", help=\"\"\"\n    The number of files to be ignored.\n    \"\"\")\n    parser.add_argument(\"-c\", \"--critical\", help=\"\"\"\n    The number of files to be ignored.\n    \"\"\")\n    parser.add_argument(\"-r\", \"--recursive\", help=\"\"\"\n    If true, recursively get the files.\n    \"\"\")\n    parser.add_argument(\"-o\", \"--output\", help=\"\"\"\n    The output file.\n    \"\"\")\n    parser.add_argument(\"-v\", \"--verbose\", help=\"\"\"\n    If true, print the output.\n    \"\"\")\n    parser.add_argument(\"-q\", \"--quiet\", help=\"\"\"\n    If true, print the output.\n    \"\"\")\n    parser.add_argument(\"-v\", \"--verbose-quiet\", help=\"\"\"\n    If true, print the output.\n    \"\"\")\n    parser.add_argument(\"-v\", \"--verbose-quiet-all\", help=\"",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_translation_keys(self):\n        \"\"\"\n        Get the translation keys\n        \"\"\"\n        return self.translation_keys\n\ndef get_translation_values(self):\n        \"\"\"\n        Get the translation values\n        \"\"\"\n        return self.translation_values\n\ndef get_translation_values_by_key(self, key):\n        \"\"\"\n        Get the translation values by key\n        \"\"\"\n        return self.translation_values[key]\n\ndef get_translation_values_by_key_by_value(self, key, value):\n        \"\"\"\n        Get the translation values by key and value\n        \"\"\"\n        return self.translation_values[key][value]\n\ndef get_translation_values_by_key_by_value_by_key(self, key, value, key):\n        \"\"\"\n        Get the translation values by key and value by key\n        \"\"\"\n        return self.translation_values[key][value][key]\n\ndef get_translation_values_by_key_by_value_by_value(self, key, value, key, value):\n        \"\"\"\n        Get the translation values by key and value by key and value\n        \"\"\"\n        return self.translation_values[key][value][key][value]\n\ndef get_translation_values_by_key_",
        "\n\ndef get_json_from_file(filename, prettyprint=False, translate=True):\n        \"\"\"\n        Get the data in JSON form\n        \"\"\"\n        with open(filename, 'r') as f:\n            return get_json(f, prettyprint, translate)\n\ndef get_json_from_file_with_translation(filename, prettyprint=False, translate=True):\n        \"\"\"\n        Get the data in JSON form\n        \"\"\"\n        with open(filename, 'r') as f:\n            return get_json(f, prettyprint, translate, True)\n\ndef get_json_from_file_with_translation_and_translation(filename, prettyprint=False, translate=True, translation=True):\n        \"\"\"\n        Get the data in JSON form\n        \"\"\"\n        with open(filename, 'r') as f:\n            return get_json(f, prettyprint, translate, True, translation)\n\ndef get_json_from_file_with_translation_and_translation_and_translation(filename, prettyprint=False, translate=True, translation=True, translation_and_translation=True):\n        \"\"\"\n        Get the data in JSON form\n        \"\"\"\n        with open(filename, 'r') as f:\n            return get_json(f, prettyprint, translate, True",
        "\n\ndef get_json(self, prettyprint=False, translate=True):\n        \"\"\"\n        Get the data as JSON tuples\n        \"\"\"\n        j = []\n        for i in self.data:\n            if prettyprint:\n                j.append(i.get_json(prettyprint, translate))\n            else:\n                j.append(i.get_json())\n        return j\n\ndef get_json_tuples_from_csv(self, csv_file, prettyprint=False, translate=True):\n        \"\"\"\n        Get the data as JSON tuples\n        \"\"\"\n        j = []\n        for i in self.data:\n            if prettyprint:\n                j.append(i.get_json(prettyprint, translate))\n            else:\n                j.append(i.get_json())\n        return j\n\ndef get_json_tuples_from_csv_with_header(self, csv_file, header, prettyprint=False, translate=True):\n        \"\"\"\n        Get the data as JSON tuples\n        \"\"\"\n        j = []\n        for i in self.data:\n            if prettyprint:\n                j.append(i.get_json(prettyprint, translate))\n            else:\n                j.append(i.get_json(header))\n        return j\n\ndef get",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef check_url(self, url):\n        \"\"\"\n        Check if the given url is a valid url, and if not, raise an exception.\n\n        :param url(str)\n        \"\"\"\n        if not url.startswith('http'):\n            raise ValueError('The given url must start with http.')\n        if not url.endswith('/'):\n            raise ValueError('The given url must end with /.')\n\ndef get_peer(self):\n        \"\"\"\n        Return the current peer, or None if none is currently connected.\n\n        :return(str)\n        \"\"\"\n        return self.PEERS.pop()\n\ndef get_peers(self):\n        \"\"\"\n        Return a list of all connected peers, or None if none is currently connected.\n\n        :return(list)\n        \"\"\"\n        return self.PEERS\n\ndef get_peer_count(self):\n        \"\"\"\n        Return the number of connected peers, or None if none is currently connected.\n\n        :return(int)\n        \"\"\"\n        return len(self.PEERS)\n\ndef get_peer_url(self, index):\n        \"\"\"\n        Return the url of the given peer, or None if none is currently connected.\n\n        :param index(int)\n        :return(str)\n        \"\"\"\n",
        "\n\ndef check_url(self, url):\n        \"\"\"\n        check if url is valid\n\n        :param url(str):\n        \"\"\"\n        if not url.startswith('http'):\n            raise ValueError('url paramater did not pass url validation')\n\ndef get_peers(self):\n        \"\"\"\n        return list of peers\n        \"\"\"\n        return self.PEERS\n\ndef get_peer(self, peer):\n        \"\"\"\n        return peer\n        \"\"\"\n        return self.PEERS[peer]\n\ndef get_peers_by_name(self, name):\n        \"\"\"\n        return list of peers by name\n        \"\"\"\n        return self.PEERS[name]\n\ndef get_peer_by_name(self, name):\n        \"\"\"\n        return peer by name\n        \"\"\"\n        return self.PEERS[name]\n\ndef get_peers_by_ip(self, ip):\n        \"\"\"\n        return list of peers by ip\n        \"\"\"\n        return self.PEERS[ip]\n\ndef get_peer_by_ip(self, ip):\n        \"\"\"\n        return peer by ip\n        \"\"\"\n        return self.PEERS[ip]\n\ndef get_peers_by_ip_and_name(self, ip, name):\n        \"\"\"\n        return list of",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\",
        "\n\n\nclass ModelService(orb.Service):\n    \"\"\"\n    A service that exposes an ORB table dynamically as a service.\n    \"\"\"\n    def __init__(self, service, db):\n        self.service = service\n        self.db = db\n\n    def __call__(self, *args, **kwargs):\n        return self.service(*args, **kwargs)\n\n    def __repr__(self):\n        return '<ModelService %r>' % self.service\n\n    def __str__(self):\n        return '<ModelService %r>' % self.service\n\n    def __eq__(self, other):\n        return isinstance(other, ModelService) and self.service == other.service\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(self.service)\n\n    def __repr__(self):\n        return '<ModelService %r>' % self.service\n\n    def __str__(self):\n        return '<ModelService %r>' % self.service\n\n    def __eq__(self, other):\n        return isinstance(other, ModelService) and self.service == other.service\n\n    def __ne__(self, other):\n        return not self",
        "\n\nif __name__ == '__main__':\n    sys.exit(main())\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef parse_float(s):\n    \"\"\" Parse a string as a float.\n        Exit with a message on failure.\n    \"\"\"\n    try:\n        val = float(s)\n    except ValueError:\n        print_err('\\nInvalid float: {}'.format(s))\n        sys.exit(1)\n    return val\n\ndef parse_string(s):\n    \"\"\" Parse a string as a string.\n        Exit with a message on failure.\n    \"\"\"\n    try:\n        val = s.strip()\n    except ValueError:\n        print_err('\\nInvalid string: {}'.format(s))\n        sys.exit(1)\n    return val\n\ndef parse_list(s):\n    \"\"\" Parse a string as a list.\n        Exit with a message on failure.\n    \"\"\"\n    try:\n        val = s.split(',')\n    except ValueError:\n        print_err('\\nInvalid list: {}'.format(s))\n        sys.exit(1)\n    return val\n\ndef parse_dict(s):\n    \"\"\" Parse a string as a dictionary.\n        Exit with a message on failure.\n    \"\"\"\n    try:\n        val = s.split(':')\n    except ValueError:\n        print_err('\\nInvalid dictionary: {}'.format(s",
        "\n\ndef print_err(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef print_info(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef print_success(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef print_warning(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef print_error(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef print_info_with_newline(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef print_success_with_newline(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef print_warning_with_newline(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef print_error_with_newline(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef print_info_with_newline_and_newline(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef print_success_with_newline_and_newline(msg):\n    print('\\n'.join(msg.splitlines()))\n\ndef",
        "\n        return self._process.read_until(b'\\x00')\n\n    def _flush(self):\n        \"\"\"\n        Flush the output buffer.\n        \"\"\"\n        self._process.write(b'\\x00')\n\n    def _process(self):\n        \"\"\"\n        Process the output buffer.\n        \"\"\"\n        self._process.write(b'\\x00')\n\n    def _process_error(self):\n        \"\"\"\n        Process the error buffer.\n        \"\"\"\n        self._process.write(b'\\x00')\n\n    def _process_timeout(self):\n        \"\"\"\n        Process the timeout buffer.\n        \"\"\"\n        self._process.write(b'\\x00')\n\n    def _process_stdout(self):\n        \"\"\"\n        Process the stdout buffer.\n        \"\"\"\n        self._process.write(b'\\x00')\n\n    def _process_stderr(self):\n        \"\"\"\n        Process the stderr buffer.\n        \"\"\"\n        self._process.write(b'\\x00')\n\n    def _process_stdin(self):\n        \"\"\"\n        Process the stdin buffer.\n        \"\"\"\n        self._process.write(b'\\x00')\n\n    def _process_stdin_error(self):\n        \"\"\"\n        Process the stdin error buffer.\n        \"\"\"\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n        request._tracy_exclude = False\n\n        # Don't trace excluded routes.\n        if request.path in self.excluded_routes:\n            request._tracy_exclude = True\n            return\n\n        # Don't trace excluded routes.\n        if request.path in self.excluded_routes:\n            request._tracy_exclude = True\n            return\n\n        # Don't trace excluded routes.\n        if request.path in self.excluded_routes:\n            request._tracy_exclude = True\n            return\n\n        # Don't trace excluded routes.\n        if request.path in self.excluded_routes:\n            request._tracy_exclude = True\n            return\n\n        # Don't trace excluded routes.\n        if request.path in self.excluded_routes:\n            request._tracy_exclude = True\n            return\n\n        # Don't trace excluded routes.\n        if request.path in self.excluded_routes:\n            request._tracy_exclude = True\n            return\n\n        # Don't trace excluded routes.\n        if request.path in self.excluded_routes:\n            request._tracy_exclude = True\n            return\n\n        # Don't trace excluded routes.\n        if request.path in self.excluded_routes:\n            request._tracy_exclude = True\n            return\n",
        "\n\ndef _before(self, response):\n        \"\"\"Calculates the request duration, and adds a transaction\n        ID to the header.\n        \"\"\"\n        # Ignore excluded routes.\n        if getattr(request, '_tracy_exclude', False):\n            return response\n\n        duration = None\n        if getattr(request, '_tracy_start_time', None):\n            duration = monotonic() - request._tracy_start_time\n\n        # Add Trace_ID header.\n        trace_id = None\n        if getattr(request, '_tracy_id', None):\n            trace_id = request._tracy_id\n        response.headers[trace_header_id] = trace_id\n\n        return response\n\ndef _before_response(self, response):\n        \"\"\"Calculates the request duration, and adds a transaction\n        ID to the header.\n        \"\"\"\n        # Ignore excluded routes.\n        if getattr(request, '_tracy_exclude', False):\n            return response\n\n        duration = None\n        if getattr(request, '_tracy_start_time', None):\n            duration = monotonic() - request._tracy_start_time\n\n        # Add Trace_ID header.\n        trace_id = None\n        if getattr(request, '_tracy_id', None):\n            trace_id =",
        "\n\ndef strip_codes(line):\n        \"\"\" Strip codes from a line.\n        \"\"\"\n        return line.replace(' ', '')\n\ndef find_word_end(self, line, word):\n        \"\"\" Find the end of a word.\n        \"\"\"\n        for i in range(len(line)):\n                if line[i] == word:\n                        return i\n        return -1\n\ndef main():\n        \"\"\" Main function.\n        \"\"\"\n        # Read the input.\n        input_file = open('input.txt', 'r')\n        input_lines = input_file.readlines()\n        input_file.close()\n\n        # Expand the input.\n        input_lines = expand_words(input_lines)\n\n        # Find the end of the word.\n        word_end = find_word_end(input_lines, ' ')\n\n        # Print the result.\n        print(input_lines[word_end:])\n\nif __name__ == '__main__':\n        main()\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_codes(text):\n        \"\"\" Get codes from text. \"\"\"\n        codes = []\n        for c in text:\n            if c in codes:\n                codes.remove(c)\n            else:\n                codes.append(c)\n        return codes\n\ndef get_indices_list(text):\n        \"\"\" Get indices from text. \"\"\"\n        indices = []\n        for c in text:\n            if c in indices:\n                indices.remove(c)\n            else:\n                indices.append(c)\n        return indices\n\ndef get_text(text):\n        \"\"\" Get text from text. \"\"\"\n        return text.replace('\\n', ' ')\n\ndef get_text_with_codes(text, codes):\n        \"\"\" Get text with codes from text. \"\"\"\n        return text.replace('\\n', ' ') + ' '.join(codes)\n\ndef get_text_with_indices(text, indices):\n        \"\"\" Get text with indices from text. \"\"\"\n        return text.replace('\\n', ' ') + ' '.join(indices)\n\ndef get_text_with_text(text, text_with_codes):\n        \"\"\" Get text with text from text. \"\"\"\n        return text.replace('\\n', ' ') + ' '.join(text_with_codes)\n\n",
        "\n\ndef get_codes(text):\n    \"\"\" Get the codes for a string. \"\"\"\n    codes = []\n    for c in text:\n        if c in '0123456789':\n            codes.append(c)\n        else:\n            codes.append('\\\\')\n    return codes\n\ndef get_line_breaks(text):\n    \"\"\" Get the line breaks for a string. \"\"\"\n    return text.splitlines()\n\ndef get_line_breaks_with_spaces(text):\n    \"\"\" Get the line breaks for a string with spaces. \"\"\"\n    return text.splitlines()\n\ndef get_line_breaks_with_newlines(text):\n    \"\"\" Get the line breaks for a string with newlines. \"\"\"\n    return text.splitlines()\n\ndef get_line_breaks_with_newlines_with_spaces(text):\n    \"\"\" Get the line breaks for a string with newlines and spaces. \"\"\"\n    return text.splitlines()\n\ndef get_line_breaks_with_newlines_with_newlines(text):\n    \"\"\" Get the line breaks for a string with newlines and newlines. \"\"\"\n    return text.splitlines()\n\ndef get_line_breaks_with_newlines_with_newlines_with_spaces(text):\n    \"\"\" Get the line breaks for a string with newlines and newlines and spaces. \"\"\"\n    return",
        "\n\ndef get_words(line, width=60):\n        \"\"\" Return a list of words from `line` with a given `width`.\n        \"\"\"\n        return [word for word in line.split() if len(word) > width]\n\ndef get_words_with_spaces(line, width=60):\n        \"\"\" Return a list of words from `line` with a given `width`.\n        \"\"\"\n        return [word for word in line.split() if len(word) > width and word != '']\n\ndef get_words_with_spaces_and_spaces(line, width=60):\n        \"\"\" Return a list of words from `line` with a given `width`.\n        \"\"\"\n        return [word for word in line.split() if len(word) > width and word != '' and word != ' ']\n\ndef get_words_with_spaces_and_spaces_and_spaces(line, width=60):\n        \"\"\" Return a list of words from `line` with a given `width`.\n        \"\"\"\n        return [word for word in line.split() if len(word) > width and word != '' and word != ' ' and word != ' ']\n\ndef get_words_with_spaces_and_spaces_and_spaces(line, width=60):\n        \"\"\" Return a list of words from",
        "\n\ndef is_valid_ipv4(self, ip):\n        \"\"\"\n        Check if the given ip is a valid ipv4 address\n\n        :param ip: ipv4 ip address\n        :return: True if valid, False if not\n        \"\"\"\n\n        try:\n            ip = int(ip)\n        except ValueError:\n            return False\n\n        return True\n\ndef _request_httpbl(self, ip):\n        \"\"\"\n        Request httpBL API\n\n        :param ip: ipv4 ip address\n        :return: httpBL results or None if any error is occurred\n        \"\"\"\n\n        try:\n            url = 'http://www.httpbl.com/api/v1/ip/check/' + ip\n            response = requests.get(url, timeout=self._api_timeout)\n            return response.status_code, response.headers['x-age'], response.headers['x-threat'], response.headers['x-type']\n        except requests.exceptions.RequestException as e:\n            return 127, 0, 0, 0\n\ndef _make_cache_key(self, ip):\n        \"\"\"\n        Make a cache key for the given ip\n\n        :param ip: ipv4 ip address\n        :return: cache key\n        \"\"\"\n\n        return 'httpbl:check:ip:' + ip",
        "\n\ndef is_threat_type(self, result=None, harmless_age=None, threat_score=None, threat_type=None):\n        \"\"\"\n        Check if IP is a threat type\n\n        :param result: httpBL results; if None, then results from last check_ip() used (optional)\n        :param harmless_age: harmless age for check if httpBL age is older (optional)\n        :param threat_score: threat score for check if httpBL threat is lower (optional)\n        :param threat_type:  threat type, if not equal httpBL score type, then return False (optional)\n        :return: True or False\n        \"\"\"\n\n        harmless_age = harmless_age if harmless_age is not None else settings.CACHED_HTTPBL_HARMLESS_AGE\n        threat_score = threat_score if threat_score is not None else settings.CACHED_HTTPBL_THREAT_SCORE\n        threat_type = threat_type if threat_type is not None else -1\n        result = result if result is not None else self._last_result\n        threat = False\n        if result is not None:\n            if result['type'] & threat_",
        "\n\ndef is_suspicious_ip(self, ip):\n        \"\"\"\n        Check if IP is suspicious\n\n        :param ip: IP address to check\n        :return: True or False\n        \"\"\"\n\n        return is_suspicious(self.check_ip(ip))\n\ndef is_suspicious_ip_range(self, ip_range):\n        \"\"\"\n        Check if IP is suspicious\n\n        :param ip_range: IP range to check\n        :return: True or False\n        \"\"\"\n\n        return is_suspicious(self.check_ip_range(ip_range))\n\ndef is_suspicious_ip_range_range(self, ip_range_range):\n        \"\"\"\n        Check if IP is suspicious\n\n        :param ip_range_range: IP range range to check\n        :return: True or False\n        \"\"\"\n\n        return is_suspicious(self.check_ip_range_range(ip_range_range))\n\ndef is_suspicious_ip_range_range_range(self, ip_range_range_range):\n        \"\"\"\n        Check if IP is suspicious\n\n        :param ip_range_range_range: IP range range range to check\n       ",
        "\n        else:\n            self._cache.delete(self._make_cache_key(ip), version=self._cache_version)\n\n        return True\n\n    def _make_cache_key(self, ip):\n        \"\"\"\n        Make a cache key for ip\n\n        :param ip: ipv4 IP address\n        :return: cache key\n        \"\"\"\n\n        return ip\n\n    def _make_cache_key_from_ip(self, ip):\n        \"\"\"\n        Make a cache key for ip\n\n        :param ip: ipv4 IP address\n        :return: cache key\n        \"\"\"\n\n        return ip\n\n    def _make_cache_key_from_ip_and_port(self, ip, port):\n        \"\"\"\n        Make a cache key for ip and port\n\n        :param ip: ipv4 IP address\n        :param port: port number\n        :return: cache key\n        \"\"\"\n\n        return ip, port\n\n    def _make_cache_key_from_ip_and_port_and_protocol(self, ip, port, protocol):\n        \"\"\"\n        Make a cache key for ip and port and protocol\n\n        :param ip: ipv4 IP address\n        :param port: port number\n        :param protocol: protocol\n        :return: cache key\n        \"\"\"",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef upload(self):\n        \"\"\"Uploads the data.\"\"\"\n        self.log.debug('uploading data...')\n\n        self.queue.put(self.data)\n        self.log.debug('upload complete.')\n\ndef main():\n        \"\"\"Main function.\"\"\"\n        consumer = Consumer()\n        consumer.run()\n\nif __name__ == '__main__':\n        main()\n",
        "\n\ndef download(self):\n        \"\"\"Download the next batch of items, return whether successful.\"\"\"\n        success = False\n        batch = self.next()\n        if len(batch) == 0:\n            return False\n\n        try:\n            self.request(batch)\n            success = True\n        except Exception as e:\n            self.log.error('error downloading: %s', e)\n            success = False\n            if self.on_error:\n                self.on_error(e, batch)\n        finally:\n            # cleanup\n            for item in batch:\n                self.queue.task_done()\n\n            return success\n\ndef get_queue(self):\n        \"\"\"Return the queue object.\"\"\"\n        return self.queue\n\ndef get_queue_name(self):\n        \"\"\"Return the queue name.\"\"\"\n        return self.queue_name\n\ndef get_queue_size(self):\n        \"\"\"Return the queue size.\"\"\"\n        return self.queue_size\n\ndef get_queue_capacity(self):\n        \"\"\"Return the queue capacity.\"\"\"\n        return self.queue_capacity\n\ndef get_queue_capacity_in_bytes(self):\n        \"\"\"Return the queue capacity in bytes.\"\"\"\n        return self.queue_capacity_in_bytes\n\ndef get_queue_capacity_in_mb(",
        "\n\ndef next_item(self):\n        \"\"\"Return the next item to upload.\"\"\"\n        item = self.queue.get()\n        if item is None:\n            return None\n\n        return item\n\ndef upload(self, queue, upload_size, max_size=None):\n        \"\"\"Upload a batch of items to the queue.\n\n        :param queue: The queue to upload items to.\n        :param upload_size: The maximum size of the items to upload.\n        :param max_size: The maximum size of the items to upload.\n        :return: The number of items uploaded.\n        \"\"\"\n        if max_size is None:\n            max_size = self.upload_size\n\n        items = []\n        while len(items) < upload_size and not queue.empty():\n            item = self.next_item()\n            if item:\n                items.append(item)\n\n        return len(items)\n\ndef upload_batch(self, queue, upload_size, max_size=None):\n        \"\"\"Upload a batch of items to the queue.\n\n        :param queue: The queue to upload items to.\n        :param upload_size: The maximum size of the items to upload.\n        :param max_size: The maximum size of the items to upload.\n        :return: The",
        "\n\nclass Queue(object):\n    \"\"\"A queue that can be used to store items in a list.\"\"\"\n\n    def __init__(self, size=10):\n        \"\"\"Initialize a queue with a given size.\"\"\"\n        self.size = size\n        self.queue = deque()\n\n    def put(self, item):\n        \"\"\"Add an item to the queue.\"\"\"\n        self.queue.append(item)\n\n    def get(self):\n        \"\"\"Get the next item from the queue.\"\"\"\n        return self.queue.popleft()\n\n    def clear(self):\n        \"\"\"Clear the queue.\"\"\"\n        self.queue = deque()\n\n    def __len__(self):\n        \"\"\"Return the number of items in the queue.\"\"\"\n        return len(self.queue)\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the items in the queue.\"\"\"\n        return iter(self.queue)\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the queue.\"\"\"\n        return str(self.queue)\n\n    def __str__(self):\n        \"\"\"Return a string representation of the queue.\"\"\"\n        return str(self.queue)\n\n    def __len__(self):\n        \"\"\"Return the number of items in the queue.\"\"\"\n        return len(self.queue)",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef _camelcase_to_underscore(p):\n    \"\"\"\n    Converts a string to an underscored string.\n\n    >>> _camelcase_to_underscore('boards/1/members/1')\n    'boards_1_members_1'\n\n    \"\"\"\n    return p.replace('_', '-')\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef log_file(self, url):\n        \"\"\"\n        Wrapper for the other log methods, decide which one based on the\n        URL parameter.\n        \"\"\"\n        if re.match(\"file://\", url):\n            self.log_file(url)\n        elif re.match(\"https://\", url) or re.match(\"http://\", url):\n            self.log_post(url, credentials=None, do_verify_certificate=True)\n        else:\n            self.log_stdout()\n\ndef log_post(self, url, credentials=None, do_verify_certificate=True):\n        \"\"\"\n        Wrapper for the other log methods, decide which one based on the\n        URL parameter.\n        \"\"\"\n        if credentials is None:\n            credentials = self.credentials\n        if do_verify_certificate:\n            self.log_post_verify_certificate(url, credentials)\n        else:\n            self.log_post_no_verify_certificate(url, credentials)\n\ndef log_post_verify_certificate(self, url, credentials):\n        \"\"\"\n        Wrapper for the other log methods, decide which one based on the\n        URL parameter.\n        \"\"\"\n        if credentials is None:\n            credentials = self.credentials\n        if re.match(\"https://\", url):\n            self.log",
        "\n\ndef log_file_to_file(self, url=None):\n        \"\"\"\n        Write to a local log file\n        \"\"\"\n        if url is None:\n            url = self.url\n        f = re.sub(\"file://\", \"\", url)\n        try:\n            with open(f, \"a\") as of:\n                of.write(str(self.store.get_json_tuples(True)))\n        except IOError as e:\n            print(e)\n            print(\"Could not write the content to the file..\")\n\ndef log_file_to_file_with_format(self, url=None, format=None):\n        \"\"\"\n        Write to a local log file\n        \"\"\"\n        if url is None:\n            url = self.url\n        f = re.sub(\"file://\", \"\", url)\n        try:\n            with open(f, \"a\") as of:\n                of.write(str(self.store.get_json_tuples(True), format))\n        except IOError as e:\n            print(e)\n            print(\"Could not write the content to the file..\")\n\ndef log_file_to_file_with_format_and_file(self, url=None, format=None, file=None):\n        \"\"\"\n        Write to a local log",
        ".request\n        return request\n\ndef log_get(self, url=None, credentials=None, do_verify_certificate=True):\n        \"\"\"\n        Read from a remote host via HTTP GET\n        \"\"\"\n        if url is None:\n            url = self.url\n        if credentials is None:\n            credentials = self.credentials\n        if do_verify_certificate is None:\n            do_verify_certificate = self.do_verify_certificate\n        if credentials and \"base64\" in credentials:\n            headers = {\"Content-Type\": \"application/json\", \\\n                        'Authorization': 'Basic %s' % credentials[\"base64\"]}\n        else:\n            headers = {\"Content-Type\": \"application/json\"}\n        try:\n            request = requests.get(url, headers=headers, \\\n                    verify=do_verify_certificate)\n        except httplib.IncompleteRead as e:\n            request = e.partial.request\n        return request\n\ndef log_put(self, url=None, credentials=None, do_verify_certificate=True):\n        \"\"\"\n        Write to a remote host via HTTP PUT\n        \"\"\"\n        if url is None:\n            url = self.url\n        if credentials is None:\n            credentials = self.credentials\n        if do_verify_certificate is None:\n           ",
        "\n            #  2. encode to base 64 for basic auth\n            elif \"user\" in self.credentials:\n                self.credentials[\"base64\"] = b64encode(self.credentials[\"user\"] + \":\" + self.credentials[\"password\"]).decode(\"ascii\")\n\n            # if both user and password is set,\n            #  3. encode to base 64 for basic auth\n            elif \"password\" in self.credentials:\n                self.credentials[\"base64\"] = b64encode(self.credentials[\"password\"]).decode(\"ascii\")\n\n            # if both user and password is set,\n            #  4. encode to base 64 for basic auth\n            elif \"user\" in self.credentials:\n                self.credentials[\"base64\"] = b64encode(self.credentials[\"user\"]).decode(\"ascii\")\n\n            # if both user and password is set,\n            #  5. encode to base 64 for basic auth\n            elif \"password\" in self.credentials:\n                self.credentials[\"base64\"] = b64encode(self.credentials[\"password\"]).decode(\"ascii\")\n\n            # if both user and password is set,\n            #  6. encode to base 64 for basic auth\n            elif \"user\" in self.credentials:\n                self.credentials[\"base64\"] = b64encode(self.credentials[\"user\"]).decode",
        "\n    c.CONNECTION['PASSWORD'] = password\n\ndef get_connection():\n    \"\"\"Get connection parameters. Call set_connection with no arguments to clear.\"\"\"\n    return c.CONNECTION\n\ndef get_connection_dict():\n    \"\"\"Get connection parameters. Call set_connection with no arguments to clear.\"\"\"\n    return c.CONNECTION\n\ndef get_connection_host():\n    \"\"\"Get connection parameters. Call set_connection with no arguments to clear.\"\"\"\n    return c.CONNECTION['HOST']\n\ndef get_connection_database():\n    \"\"\"Get connection parameters. Call set_connection with no arguments to clear.\"\"\"\n    return c.CONNECTION['DATABASE']\n\ndef get_connection_user():\n    \"\"\"Get connection parameters. Call set_connection with no arguments to clear.\"\"\"\n    return c.CONNECTION['USER']\n\ndef get_connection_password():\n    \"\"\"Get connection parameters. Call set_connection with no arguments to clear.\"\"\"\n    return c.CONNECTION['PASSWORD']\n\ndef get_connection_user_dict():\n    \"\"\"Get connection parameters. Call set_connection with no arguments to clear.\"\"\"\n    return c.CONNECTION['USER']\n\ndef get_connection_password_dict():\n    \"\"\"Get connection parameters. Call set_connection with no arguments to clear.\"\"\"\n    return c.CONNECTION['PASSWORD']\n\ndef get_connection_host_dict():\n   ",
        "\n    c.DELEGATE['SECRET'] = secret\n\ndef get_delegate():\n    \"\"\"Get delegate parameters. Call get_delegate with no arguments to clear.\"\"\"\n    return c.DELEGATE\n\ndef set_address(address):\n    \"\"\"Set address. Call set_address with no arguments to clear.\"\"\"\n    c.ADDRESS = address\n\ndef get_address():\n    \"\"\"Get address. Call get_address with no arguments to clear.\"\"\"\n    return c.ADDRESS\n\ndef set_pubkey(pubkey):\n    \"\"\"Set pubkey. Call set_pubkey with no arguments to clear.\"\"\"\n    c.PUBKEY = pubkey\n\ndef get_pubkey():\n    \"\"\"Get pubkey. Call get_pubkey with no arguments to clear.\"\"\"\n    return c.PUBKEY\n\ndef set_secret(secret):\n    \"\"\"Set secret. Call set_secret with no arguments to clear.\"\"\"\n    c.SECRET = secret\n\ndef get_secret():\n    \"\"\"Get secret. Call get_secret with no arguments to clear.\"\"\"\n    return c.SECRET\n\ndef set_fee(fee):\n    \"\"\"Set fee. Call set_fee with no arguments to clear.\"\"\"\n    c.FEE = fee\n\ndef get_fee():\n    \"\"\"Get fee. Call get_fee with no arguments to clear.\"\"\"\n    return c.FEE\n\ndef set_fee_",
        "\n\ndef balance_for_address(address):\n        \"\"\"\n        Takes a single address and returns the current balance for that address.\n        \"\"\"\n        txhistory = Address.transactions(address)\n        balance = 0\n        for i in txhistory:\n            if i.recipientId == address:\n                balance += i.amount\n            if i.senderId == address:\n                balance -= (i.amount + i.fee)\n\n        delegates = Delegate.delegates()\n        for i in delegates:\n            if address == i.address:\n                forged_blocks = Delegate.blocks(i.pubkey)\n                for block in forged_blocks:\n                    balance += (block.reward + block.totalFee)\n\n        if balance < 0:\n            height = Node.height()\n            logger.fatal('Negative balance for address {0}, Nodeheight: {1)'.format(address, height))\n            raise NegativeBalanceError('Negative balance for address {0}, Nodeheight: {1)'.format(address, height))\n        return balance\n\ndef balance_for_addresses(addresses):\n        \"\"\"\n        Takes a list of addresses and returns the current balance for that addresses.\n        \"\"\"\n        txhistory = Address.transactions(addresses)\n        balance = 0\n        for i in txhistory:\n            if i.recipient",
        "\n\ndef balance_over_time_for_delegate(address, delegate):\n        \"\"\"returns a list of named tuples,  x.timestamp, x.amount including block rewards\"\"\"\n        forged_blocks = None\n        txhistory = Address.transactions(address)\n        delegates = Delegate.delegates()\n        for i in delegates:\n            if address == i.address:\n                forged_blocks = Delegate.blocks(i.pubkey)\n\n        balance_over_time = []\n        balance = 0\n        block = 0\n\n        Balance = namedtuple(\n            'balance',\n            'timestamp amount')\n\n        for tx in txhistory:\n            if forged_blocks:\n                while forged_blocks[block].timestamp <= tx.timestamp:\n                    balance += (forged_blocks[block].reward + forged_blocks[block].totalFee)\n                    balance_over_time.append(Balance(timestamp=forged_blocks[block].timestamp, amount=balance))\n                    block += 1\n\n            if tx.senderId == delegate:\n                balance -= (tx.amount + tx.fee)\n                res = Balance(timestamp=tx.timestamp, amount=balance)\n                balance_over_time.append(res)\n            if tx.recipientId == delegate:\n                balance += tx.amount\n               ",
        "\n\ndef value_to_int(config_val, evar):\n    \"\"\"\n    Massages the 'int' and 'float' strings to int equivalents.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :rtype: int\n    :return: The int value, or None if the value is not a valid int.\n    \"\"\"\n    if not config_val:\n        return None\n    if config_val.strip().lower() == 'int':\n        return int(config_val)\n    elif config_val.strip().lower() == 'float':\n        return float(config_val)\n    else:\n        return None\n\ndef value_to_float(config_val, evar):\n    \"\"\"\n    Massages the 'float' and 'int' strings to float equivalents.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :rtype: float\n    :return: The float value, or None if the value is not a valid float.\n    \"\"\"\n    if not config_val:\n        return None\n    if config_val.",
        "\n\n\ndef validate_is_not_empty(config_val, evar):\n    \"\"\"\n    If the value is ``None``, fail validation.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :raises: ValueError if the config value is empty.\n    \"\"\"\n    if config_val is None:\n        raise ValueError(\n            \"Value for environment variable '{evar_name}' can't \"\n            \"be empty.\".format(evar_name=evar.name))\n    return config_val\n\n\ndef validate_is_not_empty_list(config_val, evar):\n    \"\"\"\n    If the value is ``None``, fail validation.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :raises: ValueError if the config value is empty.\n    \"\"\"\n    if config_val is None:\n        raise ValueError(\n            \"Value for environment variable '{evar_name}' can't \"\n            \"be empty.\".format(evar_name=evar.name))\n    return config_val\n\n\ndef validate_is_not",
        "\n\n\ndef validate_is_boolean_false(config_val, evar):\n    \"\"\"\n    Make sure the value evaluates to boolean False.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :raises: ValueError if the config value evaluates to boolean True.\n    \"\"\"\n    if config_val is None:\n        raise ValueError(\n            \"Value for environment variable '{evar_name}' can't \"\n            \"be empty.\".format(evar_name=evar.name))\n    return config_val\n\n\ndef validate_is_integer_true(config_val, evar):\n    \"\"\"\n    Make sure the value evaluates to integer True.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :raises: ValueError if the config value evaluates to integer False.\n    \"\"\"\n    if config_val is None:\n        raise ValueError(\n            \"Value for environment variable '{evar_name}' can't \"\n            \"be empty.\".format(evar_name=evar.name))\n    return config_val\n\n\ndef validate_is_integer_false",
        "\n\ndef value_to_python_log_level_from_env_var(config_val, evar):\n    \"\"\"\n    Convert an env var value into a Python logging level constant.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :return: A validated string.\n    :raises: ValueError if the log level is invalid.\n    \"\"\"\n    if not config_val:\n        config_val = evar.default_val\n    config_val = config_val.upper()\n    # noinspection PyProtectedMember\n    return logging._checkLevel(config_val)\n\n\ndef value_to_python_log_level_from_env_var_with_default(config_val, evar):\n    \"\"\"\n    Convert an env var value into a Python logging level constant.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :return: A validated string.\n    :raises: ValueError if the log level is invalid.\n    \"\"\"\n    if not config_val:\n        config_val = evar.default_val\n    config_val = config_val.upper",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".get_error()\n\n\ndef _status_code_to_class(status_code, error_class):\n  \"\"\"Converts a status code to a class.\n\n  :param int status_code: HTTP status code\n  :param class error_class: the class to convert to\n  :returns: the appropriate class for a given status code\n  :rtype: class\n\n  \"\"\"\n  if status_code in _status_code_to_class:\n    return _status_code_to_class[status_code]\n  else:\n    raise error_class(status_code)\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\n\ndef get_param_values(request, model=None):\n    \"\"\"\n    Extracts ORB context information from the request.\n\n    :param request: <pyramid.request.Request>\n    :param model: <orb.Model> || None\n\n    :return: {<str> key: <variant> value} values, <orb.Context>\n    \"\"\"\n    # convert request parameters to python\n    param_values = {}\n    for key, value in request.matchdict.items():\n        if model:\n            schema_object = model.schema().column(key, raise_=False) or model.schema().collector(key)\n            if schema_object:\n                value = param_values.pop(key)\n                if isinstance(schema_object, orb.Collector) and type(value) not in (tuple, list):\n                    value = [value]\n                param_values[key] = value\n        else:\n            param_values[key] = value\n\n    # otherwise, extract the limit information\n    has_limit = 'limit' in param_values\n\n    # generate the base context information\n    query_context = {}\n    for key in orb.Context.Defaults:\n        if key in param_values:\n            used.add(key)\n            query_context[key] =",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\nclass WebSocket(object):\n  \"\"\"A WebSocket is a WebSocket object which is used to communicate with a\n  server.\n\n  This class is used to communicate with a server. It is used to\n  communicate with a client.\n  \"\"\"\n\n  def __init__(self, host, port, path, ws_handler):\n    \"\"\"Initializes a WebSocket object.\n\n    Args:\n      host: The host name of the server.\n      port: The port number of the server.\n      path: The path of the server.\n      ws_handler: The WebSocket handler.\n    \"\"\"\n    self._host = host\n    self._port = port\n    self._path = path\n    self._ws = None\n    self._thread = None\n    self._ws_handler = ws_handler\n\n  def connect(self):\n    \"\"\"Connect to the server.\n\n    Returns:\n      A WebSocket object which is used to communicate with the server.\n    \"\"\"\n    self._ws = WebSocket(self._host, self._port, self._path, self._ws_handler)\n    self._thread = threading.Thread(target=_keep_alive_thread, args=(self,))\n    self._thread.start()\n    return self._ws\n\n  def disconnect(self):\n    \"\"\"Disconnect from the server.\n\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".get_connection()\n\n\nclass CounterPool(object):\n    '''\n    A CounterPool is a class that manages a set of counters.\n    '''\n    def __init__(self, conn, max_count=None, max_age=None, max_age_unit=None,\n                 max_value=None, max_value_unit=None,\n                 max_value_unit_multiplier=None,\n                 max_value_unit_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=None,\n                 max_value_unit_multiplier_multiplier_multiplier=",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef drop_table(self):\n        '''\n        Hook point for overriding how the CounterPool drops a table in DynamooDB\n        '''\n        table = self.conn.drop_table(self.get_table_name())\n\n        if table.status != 'ACTIVE':\n            table.refresh(wait_for_active=True, retry_seconds=1)\n\n        return table\n\ndef get_table_name(self):\n        '''\n        Hook point for overriding how the CounterPool returns the name of the\n        table in DynamooDB\n        '''\n        return self.conn.get_table_name(self.get_schema())\n\ndef get_schema(self):\n        '''\n        Hook point for overriding how the CounterPool returns the schema of the\n        table in DynamooDB\n        '''\n        return self.conn.get_schema(self.get_table_name())\n\ndef get_read_units(self):\n        '''\n        Hook point for overriding how the CounterPool returns the read units of the\n        table in DynamooDB\n        '''\n        return self.conn.get_read_units(self.get_table_name())\n\ndef get_write_units(self):\n        '''\n        Hook point for overriding how the CounterPool returns the write units of the\n       ",
        "\n\ndef create_table(self):\n        '''\n        Hook point for overriding how the CounterPool creates a table.\n        '''\n        return self.conn.create_table(self.get_table_name())\n\ndef get_counter(self, counter_name):\n        '''\n        Hook point for overriding how the CounterPool gets a counter.\n        '''\n        return self.conn.get_counter(self.get_table_name(), counter_name)\n\ndef get_counter_value(self, counter_name, counter_value):\n        '''\n        Hook point for overriding how the CounterPool gets a counter value.\n        '''\n        return self.conn.get_counter_value(self.get_table_name(), counter_name, counter_value)\n\ndef get_counter_values(self, counter_name):\n        '''\n        Hook point for overriding how the CounterPool gets a counter values.\n        '''\n        return self.conn.get_counter_values(self.get_table_name(), counter_name)\n\ndef get_counter_count(self, counter_name):\n        '''\n        Hook point for overriding how the CounterPool gets a counter count.\n        '''\n        return self.conn.get_counter_count(self.get_table_name(), counter_name)\n\ndef get",
        "\n\ndef delete_item(self, hash_key, start=0, extra_attrs=None):\n        '''\n        Hook point for overriding how the CouterPool deletes a DynamoDB item\n        for a given counter when an existing item can't be found.\n        '''\n        table = self.get_table()\n        now = datetime.utcnow().replace(microsecond=0).isoformat()\n        attrs = {\n            'created_on': now,\n            'modified_on': now,\n            'count': start,\n        }\n\n        if extra_attrs:\n            attrs.update(extra_attrs)\n\n        table.delete_item(\n            hash_key=hash_key,\n            attrs=attrs,\n        )\n\n        return\n\ndef get_item(self, hash_key, start=0, extra_attrs=None):\n        '''\n        Hook point for overriding how the CouterPool gets a DynamoDB item\n        for a given counter when an existing item can't be found.\n        '''\n        table = self.get_table()\n        now = datetime.utcnow().replace(microsecond=0).isoformat()\n        attrs = {\n            'created_on': now,\n            'modified_on': now,\n            'count': start,\n        }\n\n        if extra_attrs",
        "\n\ndef create_item(self, hash_key, start=0, extra_attrs=None):\n        '''\n        Hook point for overriding how the CouterPool creates a DynamoDB item\n        for a given counter.\n        '''\n        table = self.get_table()\n\n        if extra_attrs is None:\n            extra_attrs = {}\n\n        item = table.create_item(\n            hash_key=hash_key,\n            start=start,\n            extra_attrs=extra_attrs,\n        )\n\n        return item\n\ndef get_table(self):\n        '''\n        Hook point for overriding how the CouterPool fetches a DynamoDB table\n        for a given counter.\n        '''\n        return self.get_counter_pool().get_table()\n\ndef get_counter_pool(self):\n        '''\n        Hook point for overriding how the CouterPool fetches a DynamoDB counter\n        pool for a given counter.\n        '''\n        return self.get_pool().get_counter_pool()\n\ndef get_pool(self):\n        '''\n        Hook point for overriding how the CouterPool fetches a DynamoDB pool\n        for a given counter.\n        '''\n        return self.get_pool().get_pool()\n\ndef get_pool_name(self):\n        '''\n        Hook point for",
        ", pool=self):\n        '''\n        Gets the DynamoDB item behind a counter and ties it to a Counter\n        instace.\n        '''\n        item = self.get_item(hash_key=name, start=start)\n        counter = Counter(dynamo_item=item, pool=self)\n\n        return counter\n\ndef get_counter_by_name(self, name, start=0):\n        '''\n        Gets the DynamoDB item behind a counter and ties it to a Counter\n        instace.\n        '''\n        item = self.get_item(hash_key=name, start=start)\n        counter = Counter(dynamo_item=item, pool=self)\n\n        return counter\n\ndef get_counter_by_name_and_start(self, name, start=0):\n        '''\n        Gets the DynamoDB item behind a counter and ties it to a Counter\n        instace.\n        '''\n        item = self.get_item(hash_key=name, start=start)\n        counter = Counter(dynamo_item=item, pool=self)\n\n        return counter\n\ndef get_counter_by_name_and_start_and_end(self, name, start=0, end=0):\n        '''\n        Gets the DynamoDB item behind a counter and t",
        "\n\ndef many_to_many(clsname, **kw):\n    \"\"\"Use an event to build a many-to-many relationship on a class.\n\n    This makes use of the :meth:`.References._reference_table` method\n    to generate a full foreign key relationship to the remote table.\n\n    \"\"\"\n    @declared_attr\n    def m2m(cls):\n        cls._references((cls.__name__, clsname))\n        return relationship(clsname, **kw)\n    return m2m\n\ndef many_to_many_with_related(clsname, **kw):\n    \"\"\"Use an event to build a many-to-many relationship on a class.\n\n    This makes use of the :meth:`.References._reference_table` method\n    to generate a full foreign key relationship to the remote table.\n\n    \"\"\"\n    @declared_attr\n    def m2m_with_related(cls):\n        cls._references((cls.__name__, clsname))\n        return relationship(clsname, **kw)\n    return m2m_with_related\n\ndef many_to_one_with_related(clsname, **kw):\n    \"\"\"Use an event to build a many-to-one relationship on a class.\n\n    This makes use of the :meth:`.References._reference",
        ".bind(clsname=clsname, **kw)\n\ndef many_to_one(clsname, **kw):\n    \"\"\"Use an event to build a many-to-one relationship on a class.\n\n    This makes use of the :meth:`.References._reference_table` method\n    to generate a full foreign key relationship from the remote table.\n\n    \"\"\"\n    @declared_attr\n    def o2m(cls):\n        cls._references((clsname, cls.name__))\n        return relationship(clsname, **kw)\n    return o2m.bind(clsname=clsname, **kw)\n\ndef many_to_many(clsname, **kw):\n    \"\"\"Use an event to build a many-to-many relationship on a class.\n\n    This makes use of the :meth:`.References._reference_table` method\n    to generate a full foreign key relationship from the remote table.\n\n    \"\"\"\n    @declared_attr\n    def o2m(cls):\n        cls._references((clsname, cls.name__))\n        return relationship(clsname, **kw)\n    return o2m.bind(clsname=clsname, **kw)\n\ndef many_to_one_and_many(clsname, **kw):\n    \"\"\"Use an event to build a many",
        "\n        if data.strip():\n            data = djeffify_string(data)\n        self.djhtml += data\n\ndef djeffify_string(data):\n        \"\"\"\n        Djeffify string\n        \"\"\"\n        if data.strip():\n            data = data.replace('\\n', ' ')\n            data = data.replace('\\r', ' ')\n            data = data.replace('\\t', ' ')\n            data = data.replace('\\n\\r', ' ')\n            data = data.replace('\\n\\t', ' ')\n            data = data.replace('\\n\\t\\t', ' ')\n            data = data.replace('\\n\\t\\t\\t', ' ')\n            data = data.replace('\\n\\t\\t\\t\\t', ' ')\n            data = data.replace('\\n\\t\\t\\t\\t\\t', ' ')\n            data = data.replace('\\n\\t\\t\\t\\t\\t', ' ')\n            data = data.replace('\\n\\t\\t\\t\\t\\t', ' ')\n            data = data.replace('\\n\\t\\t\\t\\t\\t', ' ')\n            data = data.replace('\\n\\t\\t\\t\\t\\t', ' ')",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n    return os.path.join(os.getcwd(), path)\n\n\ndef get_path_from_args(args):\n    \"\"\"\n    Get path from args\n\n    :type args: list\n    :rtype: str|unicode\n    \"\"\"\n    if len(args) == 1:\n        return args[0]\n    return args[0]\n\n\ndef get_path_from_kwargs(kwargs):\n    \"\"\"\n    Get path from kwargs\n\n    :type kwargs: dict\n    :rtype: str|unicode\n    \"\"\"\n    if len(kwargs) == 1:\n        return kwargs[0]\n    return kwargs[0]\n\n\ndef get_path_from_request(request):\n    \"\"\"\n    Get path from request\n\n    :type request: Request\n    :rtype: str|unicode\n    \"\"\"\n    if request.path:\n        return request.path\n    return request.path_info\n\n\ndef get_path_from_session(session):\n    \"\"\"\n    Get path from session\n\n    :type session: Session\n    :rtype: str|unicode\n    \"\"\"\n    if session.path:\n        return session.path\n    return session.path_info\n\n\ndef get_path_from_request_context(request_context):\n    \"\"\"",
        "\n\ndef write_to_file(file_path, data, encoding=\"utf-8\"):\n    \"\"\"\n    Write helper method\n\n    :type file_path: str|unicode\n    :type data: str|unicode\n    :type encoding: str|unicode\n    :rtype: str|unicode\n    \"\"\"\n    with codecs.open(file_path, \"w\", encoding) as f:\n        f.write(data)\n\n\ndef read_from_file_with_encoding(file_path, encoding=\"utf-8\"):\n    \"\"\"\n    Read helper method\n\n    :type file_path: str|unicode\n    :type encoding: str|unicode\n    :rtype: str|unicode\n    \"\"\"\n    with codecs.open(file_path, \"r\", encoding) as f:\n        return f.read()\n\n\ndef write_to_file_with_encoding(file_path, data, encoding=\"utf-8\"):\n    \"\"\"\n    Write helper method\n\n    :type file_path: str|unicode\n    :type data: str|unicode\n    :type encoding: str|unicode\n    :rtype: str|unicode\n    \"\"\"\n    with codecs.open(file_path, \"w\", encoding) as f:\n        f.write(data)\n\n\ndef",
        "\n\ndef write_to_file_with_encoding(file_path, contents, encoding=\"utf-8\"):\n    \"\"\"\n    Write helper method\n\n    :type file_path: str|unicode\n    :type contents: str|unicode\n    :type encoding: str|unicode\n    \"\"\"\n    with codecs.open(file_path, \"w\", encoding) as f:\n        f.write(contents)\n\n\ndef write_to_file_with_encoding_and_newline(file_path, contents, encoding=\"utf-8\", newline=\"\\n\"):\n    \"\"\"\n    Write helper method\n\n    :type file_path: str|unicode\n    :type contents: str|unicode\n    :type encoding: str|unicode\n    :type newline: str|unicode\n    \"\"\"\n    with codecs.open(file_path, \"w\", encoding) as f:\n        f.write(contents + newline)\n\n\ndef write_to_file_with_encoding_and_newline_and_newline(file_path, contents, encoding=\"utf-8\", newline=\"\\n\", newline=\"\\n\"):\n    \"\"\"\n    Write helper method\n\n    :type file_path: str|unicode\n    :type contents: str|unicode\n    :type encoding: str|unicode\n    :type newline: str",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef get_path_parts(path):\n        \"\"\"\n        Helper method for absolute and relative paths resolution\n        Split passed path and return each directory parts\n\n        example: \"/usr/share/dir\"\n        return: [\"usr\", \"share\", \"dir\"]\n\n        @type path: one of (unicode, str)\n        @rtype: list\n        \"\"\"\n        result_parts = []\n        #todo: check loops\n        while path != \"/\":\n            parts = os.path.split(path)\n            if parts[1] == path:\n                result_parts.insert(0, parts[0])\n                break\n            elif parts[0] == path:\n                result_parts.insert(0, parts[1])\n                break\n            else:\n                path = parts[0]\n                result_parts.insert(0, parts[1])\n        return result_parts\n\ndef get_path_parts_with_trailing_slash(path):\n        \"\"\"\n        Helper method for absolute and relative paths resolution\n        Split passed path and return each directory parts\n\n        example: \"/usr/share/dir\"\n        return: [\"usr\", \"share\", \"dir\"]\n\n        @type path: one of (unicode, str)\n        @rtype: list\n        \"\"\"\n        result_parts = []\n",
        "(parts)))\n\n\ndef _create_api_uri_with_query(self, *parts):\n    \"\"\"Creates fully qualified endpoint URIs.\n\n    :param parts: the string parts that form the request URI\n\n    \"\"\"\n    return urljoin(self.API_URI, '/'.join(map(quote, parts)))\n\n\ndef _create_api_uri_with_query_and_fragment(self, *parts):\n    \"\"\"Creates fully qualified endpoint URIs.\n\n    :param parts: the string parts that form the request URI\n\n    \"\"\"\n    return urljoin(self.API_URI, '/'.join(map(quote, parts)))\n\n\ndef _create_api_uri_with_query_and_fragment_and_query(self, *parts):\n    \"\"\"Creates fully qualified endpoint URIs.\n\n    :param parts: the string parts that form the request URI\n\n    \"\"\"\n    return urljoin(self.API_URI, '/'.join(map(quote, parts)))\n\n\ndef _create_api_uri_with_query_and_fragment_and_query_and_fragment(self, *parts):\n    \"\"\"Creates fully qualified endpoint URIs.\n\n    :param parts: the string parts that form the request URI\n\n    \"\"\"\n    return urljoin(self.API_URI, '/'.join(map(",
        "\n\ndef _format_iso_date(self, date):\n    \"\"\"Makes sure we have proper ISO 8601 date.\n\n    :param date: either already ISO 8601 a string or datetime.datetime\n    :returns: ISO 8601 date\n    :rtype: str\n\n    \"\"\"\n    if isinstance(date, str):\n        return date\n    elif isinstance(date, datetime):\n        return date.strftime('%Y-%m-%dT%H:%M:%S.%fZ')\n    else:\n        return None\n\ndef _format_iso_time_with_tz(self, time):\n    \"\"\"Makes sure we have proper ISO 8601 time with a timezone.\n\n    :param time: either already ISO 8601 a string or datetime.datetime\n    :returns: ISO 8601 time with a timezone\n    :rtype: str\n\n    \"\"\"\n    if isinstance(time, str):\n        return time\n    elif isinstance(time, datetime):\n        return time.strftime('%Y-%m-%dT%H:%M:%S.%fZ') + 'Z'\n    else:\n        return None\n\ndef _format_iso_date_with_tz(self, date):\n    \"\"\"Makes sure we have proper ISO 8601 date with a timezone.\n\n    :param date: either already ISO 8601 a string or datetime.datetime\n    :returns:",
        "\n\ndef get_api_error(response):\n    \"\"\"Returns an APIError for the given response.\n\n    :param requests.Response response: HTTP response\n    :returns: APIError\n    :rtype: APIError\n    :raises APIError: for non-2xx responses\n\n    \"\"\"\n    if not str(response.status_code).startswith('2'):\n      raise get_api_error(response)\n    return APIError(response.text)\n\ndef get_api_error_from_json(json_response):\n    \"\"\"Returns an APIError for the given json response.\n\n    :param json_response: JSON response\n    :returns: APIError\n    :rtype: APIError\n    :raises APIError: for non-2xx responses\n\n    \"\"\"\n    if not json_response.get('error'):\n      raise get_api_error(json_response)\n    return APIError(json_response['error'])\n\ndef get_api_error_from_file(file_path):\n    \"\"\"Returns an APIError for the given file path.\n\n    :param file_path: file path\n    :returns: APIError\n    :rtype: APIError\n    :raises APIError: for non-2xx responses\n\n    \"\"\"\n    if not os.",
        "\n\ndef _check_next_cursor(self):\n    \"\"\"Checks if a next cursor is possible.\n\n    :returns: True if a next cursor is possible, otherwise False\n    :rtype: bool\n\n    \"\"\"\n    if self.is_initial:\n      return True\n    if self.before:\n      if self.before_cursor:\n        return True\n      else:\n        return False\n    else:\n      if self.after_cursor:\n        return True\n      else:\n        return False\n\ndef _check_next_message(self):\n    \"\"\"Checks if a next message is possible.\n\n    :returns: True if a next message is possible, otherwise False\n    :rtype: bool\n\n    \"\"\"\n    if self.is_initial:\n      return True\n    if self.before:\n      if self.before_message:\n        return True\n      else:\n        return False\n    else:\n      if self.after_message:\n        return True\n      else:\n        return False\n\ndef _check_next_message_cursor(self):\n    \"\"\"Checks if a next message is possible.\n\n    :returns: True if a next message is possible, otherwise False\n    :rtype: bool\n\n    \"\"\"\n    if self.is_initial:\n      return True\n   ",
        "\n\ndef _wrap_text(self, text, format=None, style=None):\n        \"\"\" Wrap text with given format \"\"\"\n        if self.has_colors and self.colors_enabled:\n            return self.st.COLORS.get(style, text)\n        else:\n            return text\n\ndef _wrap_text_color(self, text, format=None, style=None):\n        \"\"\" Wrap text with given format \"\"\"\n        if self.has_colors and self.colors_enabled:\n            return self.st.COLORS.get(style, text)\n        else:\n            return text\n\ndef _wrap_text_bold(self, text, format=None, style=None):\n        \"\"\" Wrap text with given format \"\"\"\n        if self.has_colors and self.colors_enabled:\n            return self.st.COLORS.get(style, text)\n        else:\n            return text\n\ndef _wrap_text_underline(self, text, format=None, style=None):\n        \"\"\" Wrap text with given format \"\"\"\n        if self.has_colors and self.colors_enabled:\n            return self.st.COLORS.get(style, text)\n        else:\n            return text\n\ndef _wrap_text_reset_all(self, text, format=None,",
        "\n\ndef UnregisterMessage(self, message):\n    \"\"\"Unregisters the given message type from the local database.\n\n    Args:\n      message: a message.Message, to be unregistered.\n\n    Returns:\n      The provided message.\n    \"\"\"\n\n    desc = message.DESCRIPTOR\n    self.pool.RemoveDescriptor(desc)\n    del self._symbols[desc.full_name]\n    del self._symbols_by_file[desc.file.name][desc.full_name]\n    return message\n\ndef GetMessage(self, name):\n    \"\"\"Returns the message with the given name.\n\n    Args:\n      name: the name of the message.\n\n    Returns:\n      The message with the given name.\n    \"\"\"\n\n    return self._symbols[name]\n\ndef GetMessageByName(self, name):\n    \"\"\"Returns the message with the given name.\n\n    Args:\n      name: the name of the message.\n\n    Returns:\n      The message with the given name.\n    \"\"\"\n\n    return self._symbols_by_file[name]\n\ndef GetMessageByFile(self, file_name):\n    \"\"\"Returns the message with the given name.\n\n    Args:\n      file_name: the name of the message.\n\n    Returns:\n      The message",
        "\n\ndef remove(self, index):\n        \"\"\"\n        Remove object at index.\n\n        :param int index: index to remove from\n        \"\"\"\n        self._list.remove(index)\n        self._sync()\n\ndef remove_at(self, index):\n        \"\"\"\n        Remove object at index.\n\n        :param int index: index to remove from\n        \"\"\"\n        self._list.remove_at(index)\n        self._sync()\n\ndef remove_last(self):\n        \"\"\"\n        Remove last object.\n        \"\"\"\n        self._list.remove_last()\n        self._sync()\n\ndef remove_first(self):\n        \"\"\"\n        Remove first object.\n        \"\"\"\n        self._list.remove_first()\n        self._sync()\n\ndef remove_last_at(self):\n        \"\"\"\n        Remove last object at index.\n        \"\"\"\n        self._list.remove_last_at()\n        self._sync()\n\ndef remove_first_at(self):\n        \"\"\"\n        Remove first object at index.\n        \"\"\"\n        self._list.remove_first_at()\n        self._sync()\n\ndef remove_last_at(self):\n        \"\"\"\n        Remove last object at index.\n        \"\"\"\n        self._list.remove_last_",
        "\n\n    def __init__(self, runtimepath):\n        \"\"\"\n        Initialize runtime path parser.\n\n        :param string runtimepath: runtime path string\n        \"\"\"\n        self.runtimepath = runtimepath\n\n    def __str__(self):\n        \"\"\"\n        Return runtime path string.\n\n        :return: runtime path string\n        :rtype: string\n        \"\"\"\n        return self.runtimepath\n\n    def __repr__(self):\n        \"\"\"\n        Return runtime path string.\n\n        :return: runtime path string\n        :rtype: string\n        \"\"\"\n        return self.runtimepath\n\n    def __eq__(self, other):\n        \"\"\"\n        Return runtime path string.\n\n        :param other: runtime path string\n        :return: runtime path string\n        :rtype: string\n        \"\"\"\n        return self.runtimepath == other\n\n    def __ne__(self, other):\n        \"\"\"\n        Return runtime path string.\n\n        :param other: runtime path string\n        :return: runtime path string\n        :rtype: string\n        \"\"\"\n        return self.runtimepath != other\n\n    def __lt__(self, other):\n        \"\"\"\n        Return runtime path string.\n\n        :param other: runtime path string\n        :return: runtime path string\n       ",
        "\n\ndef add_bundle_from_file(self, path):\n        \"\"\"\n        Add some bundle from file\n\n        :type path: str\n        @rtype: BuildGroup\n        \"\"\"\n        with open(path, 'r') as f:\n            return add_bundle(self, *f.read().splitlines())\n\ndef add_bundle_from_file_with_type(self, path, type):\n        \"\"\"\n        Add some bundle from file with type\n\n        :type path: str\n        :type type: str\n        @rtype: BuildGroup\n        \"\"\"\n        with open(path, 'r') as f:\n            return add_bundle(self, *f.read().splitlines(), type=type)\n\ndef add_bundle_from_file_with_type_and_name(self, path, type, name):\n        \"\"\"\n        Add some bundle from file with type and name\n\n        :type path: str\n        :type type: str\n        :type name: str\n        @rtype: BuildGroup\n        \"\"\"\n        with open(path, 'r') as f:\n            return add_bundle(self, *f.read().splitlines(), type=type, name=name)\n\ndef add_bundle_from_file_with_type_and_name_and",
        "\n\ndef collect_files_from_bundle(self, bundle):\n        \"\"\"\n        Return collected files links\n\n        :rtype: list[static_bundle.files.StaticFileResult]\n        \"\"\"\n        self.files = []\n        for file in bundle.files:\n            self.files.append(file)\n        return self.files\n\ndef collect_files_from_bundle_files(self, bundle_files):\n        \"\"\"\n        Return collected files links\n\n        :rtype: list[static_bundle.files.StaticFileResult]\n        \"\"\"\n        self.files = []\n        for file in bundle_files:\n            self.files.append(file)\n        return self.files\n\ndef collect_files_from_bundle_files_from_bundle(self, bundle_files, bundle):\n        \"\"\"\n        Return collected files links\n\n        :rtype: list[static_bundle.files.StaticFileResult]\n        \"\"\"\n        self.files = []\n        for file in bundle_files:\n            self.files.append(file)\n        for file in bundle.files:\n            self.files.append(file)\n        return self.files\n\ndef collect_files_from_bundle_files_from_bundle_files(self, bundle_files, bundle_files_from_bundle",
        "\n\ndef get_minifier_for_asset(self, asset):\n        \"\"\"\n        Asset minifier\n        Uses default minifier in bundle if it's not defined\n\n        :rtype: static_bundle.minifiers.DefaultMinifier|None\n        \"\"\"\n        if self.minifier is None:\n            if not self.has_bundles():\n                raise Exception(\"Unable to get default minifier, no bundles in build group\")\n            minifier = self.get_first_bundle().get_default_minifier()\n        else:\n            minifier = self.minifier\n        if minifier:\n            minifier.init_asset(asset)\n        return minifier\n\ndef get_minifier_for_asset_with_bundle(self, asset, bundle):\n        \"\"\"\n        Asset minifier\n        Uses default minifier in bundle if it's not defined\n\n        :rtype: static_bundle.minifiers.DefaultMinifier|None\n        \"\"\"\n        if self.minifier is None:\n            if not self.has_bundles():\n                raise Exception(\"Unable to get default minifier, no bundles in build group\")\n            minifier = self.get_first_bundle().get_default_minifier()\n        else:\n            minifier = self.minifier\n        if minifier:\n            minifier.",
        "\ndef render_include(self, name):\n        \"\"\"\n        Render all includes in asset by name\n\n        :type name: str|unicode\n        :rtype: str|unicode\n        \"\"\"\n        result = \"\"\n        if self.has_asset(name):\n            asset = self.get_asset(name)\n            if asset.files:\n                for f in asset.files:\n                    result += f.render_include() + \"\\r\\n\"\n        return result\n\ndef render_include_list(self, name):\n        \"\"\"\n        Render all includes in asset by name\n\n        :type name: str|unicode\n        :rtype: str|unicode\n        \"\"\"\n        result = \"\"\n        if self.has_asset(name):\n            asset = self.get_asset(name)\n            if asset.files:\n                for f in asset.files:\n                    result += f.render_include_list() + \"\\r\\n\"\n        return result\n\ndef render_include_list_by_name(self, name):\n        \"\"\"\n        Render all includes in asset by name\n\n        :type name: str|unicode\n        :rtype: str|unicode\n        \"\"\"\n        result = \"\"\n        if self.has_asset(name):\n            asset = self.get_asset(name",
        "\n        return self.links\n\ndef _minify(emulate=False):\n        \"\"\"\n        Minify the static bundle\n        \"\"\"\n        if self.config.env == static_bundle.ENV_PRODUCTION:\n            self._minify_bundle(emulate=emulate)\n        self._add_url_prefix()\n        return self.links\n\ndef _minify_bundle(emulate=False):\n        \"\"\"\n        Minify the static bundle\n        \"\"\"\n        if self.config.env == static_bundle.ENV_PRODUCTION:\n            self._minify_bundle_with_assets(emulate=emulate)\n        self._add_url_prefix()\n        return self.links\n\ndef _minify_bundle_with_assets(emulate=False):\n        \"\"\"\n        Minify the static bundle\n        \"\"\"\n        for asset in self.assets.values():\n            if asset.has_bundles():\n                asset._minify_bundle(emulate=emulate)\n        self._add_url_prefix()\n        return self.links\n\ndef _add_url_prefix(self):\n        \"\"\"\n        Add the url prefix to the static bundle\n        \"\"\"\n        self.config.url_prefix = self.config.url_prefix + '/'\n        self.config.url_",
        "\n\ndef _default_json_default_date(obj):\n    \"\"\" Coerce everything to strings.\n    All objects representing date get output according to default_date_fmt.\n    \"\"\"\n    if isinstance(obj, (datetime.datetime, datetime.date, datetime.time)):\n        return obj.strftime(default_date_fmt)\n    else:\n        return str(obj)\n\ndef _default_json_default_datetime(obj):\n    \"\"\" Coerce everything to strings.\n    All objects representing datetime get output according to default_date_fmt.\n    \"\"\"\n    if isinstance(obj, (datetime.datetime, datetime.date, datetime.time)):\n        return obj.strftime(default_date_fmt)\n    else:\n        return str(obj)\n\ndef _default_json_default_datetime_date(obj):\n    \"\"\" Coerce everything to strings.\n    All objects representing datetime get output according to default_date_fmt.\n    \"\"\"\n    if isinstance(obj, (datetime.datetime, datetime.date, datetime.time)):\n        return obj.strftime(default_date_fmt)\n    else:\n        return str(obj)\n\ndef _default_json_default_datetime_time(obj):\n    \"\"\" Coerce everything to strings.\n    All objects representing datetime get output",
        "\n    if path is not None:\n        logger.info('Logging to %s', path)\n\n    if target is not None:\n        logger.info('Logging to %s', target)\n\n    if logger_name == 'root':\n        logger.info('Logging to root')\n\n    if server_hostname is not None:\n        logger.info('Logging to %s', server_hostname)\n\n    if fields is not None:\n        logger.info('Logging to %s', fields)\n\n\ndef init_logger(logger_name='root'):\n    \"\"\"Initialize the zlogger.\n\n    Sets up a default logger with the given name.\n\n    :param logger_name: name of the logger (defaults to root)\n    :type logger_name: string\n    \"\"\"\n    logger = logging.getLogger(logger_name)\n    logger.setLevel(logging.DEBUG)\n\n\ndef init_server_logger(logger_name='root'):\n    \"\"\"Initialize the zlogger.\n\n    Sets up a default logger with the given name.\n\n    :param logger_name: name of the logger (defaults to root)\n    :type logger_name: string\n    \"\"\"\n    logger = logging.getLogger(logger_name)\n    logger.setLevel(logging.DEBUG)\n\n\ndef init",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_abs_and_rel_paths_from_file(self, root_path, file_name, input_dir):\n        \"\"\"\n        Return absolute and relative path for file\n\n        :type root_path: str|unicode\n        :type file_name: str|unicode\n        :type input_dir: str|unicode\n        :rtype: tuple\n\n        \"\"\"\n        return get_abs_and_rel_paths(self, root_path, file_name, input_dir)\n\ndef get_abs_and_rel_paths_from_dir(self, root_path, input_dir):\n        \"\"\"\n        Return absolute and relative path for file\n\n        :type root_path: str|unicode\n        :type input_dir: str|unicode\n        :rtype: tuple\n\n        \"\"\"\n        return get_abs_and_rel_paths(self, root_path, input_dir, input_dir)\n\ndef get_abs_and_rel_paths_from_file_and_dir(self, root_path, file_name, input_dir):\n        \"\"\"\n        Return absolute and relative path for file\n\n        :type root_path: str|unicode\n        :type file_name: str|unicode\n        :type input_dir: str|unicode\n        :",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef FindFileContainingSymbolOrEnum(self, symbol):\n    \"\"\"Gets the FileDescriptor for the file containing the specified symbol.\n\n    Args:\n      symbol: The name of the symbol to search for.\n\n    Returns:\n      A FileDescriptor that contains the specified symbol.\n\n    Raises:\n      KeyError: if the file can not be found in the pool.\n    \"\"\"\n\n    symbol = _NormalizeFullyQualifiedName(symbol)\n    try:\n      return self._descriptors[symbol].file\n    except KeyError:\n      pass\n\n    try:\n      return self._enum_descriptors[symbol].file\n    except KeyError:\n      pass\n\n    try:\n      file_proto = self._internal_db.FindFileContainingSymbolOrEnum(symbol)\n    except KeyError as error:\n      if self._descriptor_db:\n        file_proto = self._descriptor_db.FindFileContainingSymbolOrEnum(symbol)\n      else:\n        raise error\n    if not file_proto:\n      raise KeyError('Cannot find a file containing %s' % symbol)\n    return self._ConvertFileProtoToFileDescriptor(file_proto)\n\ndef FindFileContainingSymbolOrEnumOrFile(self, symbol):\n    \"\"\"Gets the FileDescriptor for the file containing the specified symbol.\n\n    Args:\n      symbol: The name",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef _ConvertEnumValueDescriptor(self, value, index):\n    \"\"\"Make a protobuf EnumValueDescriptor given an EnumValueDescriptorProto protobuf.\n\n    Args:\n      value: The EnumValueDescriptorProto protobuf message.\n      index: The index of the EnumValueDescriptorProto in the EnumDescriptor.\n\n    Returns:\n      The added EnumValueDescriptor\n    \"\"\"\n\n    if value.name:\n      value_name = value.name\n    else:\n      value_name = value.name_with_type\n\n    desc = descriptor.EnumValueDescriptor(name=value_name,\n                                        full_name=value_name,\n                                        filename=None,\n                                        file=None,\n                                        index=index)\n    scope['.%s' % value_name] = desc\n    self._enum_values[value_name] = desc\n    return desc\n\ndef _ConvertEnumDescriptor(self, enum_proto, package=None, file_desc=None,\n                             containing_type=None, scope=None):\n    \"\"\"Make a protobuf EnumDescriptor given an EnumDescriptorProto protobuf.\n\n    Args:\n      enum_proto: The descriptor_pb2.EnumDescriptorProto protobuf message.\n      package: Optional package name for the new message EnumDescriptor.\n      file_desc: The file containing the enum descriptor.\n      containing_type: The",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        ", field\n\n\ndef require_list(name, field, data_type):\n    \"\"\"Require that the named `field` has the right `data_type`\"\"\"\n    if not isinstance(field, list):\n        msg = '{0} must have {1}, got: {2}'.format(name, data_type, field)\n        raise AssertionError(msg)\n\n\ndef require_dict(name, field, data_type):\n    \"\"\"Require that the named `field` has the right `data_type`\"\"\"\n    if not isinstance(field, dict):\n        msg = '{0} must have {1}, got: {2}'.format(name, data_type, field)\n        raise AssertionError(msg)\n\n\ndef require_tuple(name, field, data_type):\n    \"\"\"Require that the named `field` has the right `data_type`\"\"\"\n    if not isinstance(field, tuple):\n        msg = '{0} must have {1}, got: {2}'.format(name, data_type, field)\n        raise AssertionError(msg)\n\n\ndef require_tuple_of_lists(name, field, data_type):\n    \"\"\"Require that the named `field` has the right `data_type`\"\"\"\n    if not isinstance(field, tuple):\n        msg = '{0} must",
        "\n\ndef get_queue_size(self):\n        \"\"\"Returns the number of items in the internal queue\"\"\"\n        return self.queue.qsize()\n\ndef get_queue_size_with_timeout(self, timeout):\n        \"\"\"Returns the number of items in the internal queue with a timeout\"\"\"\n        return self.queue.qsize(timeout=timeout)\n\ndef get_queue_size_with_timeout_with_timeout(self, timeout, timeout_unit):\n        \"\"\"Returns the number of items in the internal queue with a timeout and timeout unit\"\"\"\n        return self.queue.qsize(timeout=timeout, timeout_unit=timeout_unit)\n\ndef get_queue_size_with_timeout_with_timeout_unit(self, timeout, timeout_unit, timeout_unit):\n        \"\"\"Returns the number of items in the internal queue with a timeout and timeout unit and timeout unit\"\"\"\n        return self.queue.qsize(timeout=timeout, timeout_unit=timeout_unit, timeout_unit=timeout_unit)\n\ndef get_queue_size_with_timeout_with_timeout_unit_with_timeout(self, timeout, timeout_unit, timeout_unit, timeout_unit_with_timeout):\n        \"\"\"Returns the number of items in the internal queue with a timeout and timeout unit and timeout unit and timeout unit with timeout",
        ", closefd=closefd)\n\ndef guess(name=None, fileobj=None, closefd=True):\n    \"\"\"\n    Use all decompressor possible to make the stream\n    \"\"\"\n    return Guesser().guess(name, fileobj, closefd)\n\nclass Guesser(object):\n    \"\"\"\n    Use all decompressor possible to make the stream\n    \"\"\"\n    def __init__(self):\n        self.decompressors = {}\n\n    def open(self, name=None, fileobj=None, closefd=True):\n        \"\"\"\n        Use all decompressor possible to make the stream\n        \"\"\"\n        if name is None:\n            name = self.__class__.__name__\n        if fileobj is None:\n            fileobj = self.__class__.__file__\n        if closefd:\n            self.decompressors[name] = self.decompressor(fileobj)\n        else:\n            self.decompressors[name] = self.decompressor(name)\n        return self.decompressors[name]\n\n    def guess(self, name=None, fileobj=None, closefd=True):\n        \"\"\"\n        Use all decompressor possible to make the stream\n        \"\"\"\n        if name is None:\n            name = self.__class__.__name__\n        if fileobj is None:\n           ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "(\n      buffer,\n      0,\n      len(buffer),\n      message_set_item_message,\n      message_set_item_field_dict)\n\n\ndef MessageSetItemMessage(extensions_by_number):\n  \"\"\"Returns a message class for a MessageSet item.\n\n  The parameter is the _extensions_by_number map for the message class.\n\n  The message set message looks like this:\n    message MessageSet {\n      repeated group Item = 1 {\n        required int32 type_id = 2;\n        required string message = 3;\n      }\n    }\n  \"\"\"\n\n  type_id_tag_bytes = encoder.TagBytes(2, wire_format.WIRETYPE_VARINT)\n  message_tag_bytes = encoder.TagBytes(3, wire_format.WIRETYPE_LENGTH_DELIMITED)\n  item_end_tag_bytes = encoder.TagBytes(1, wire_format.WIRETYPE_END_GROUP)\n\n  local_ReadTag = ReadTag\n  local_DecodeVarint = _DecodeVarint\n  local_SkipField = SkipField\n\n  def DecodeItem(buffer, pos, end, message, field_dict):\n    message_set_item_start = pos\n    type_id = -1\n    message_start = -1",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef get_function_name(function):\n    \"\"\"\n    Given a function, return the name of the function.\n    \"\"\"\n    return function.__name__\n\ndef get_function_module(function):\n    \"\"\"\n    Given a function, return the module name of the function.\n    \"\"\"\n    return function.__module__\n\ndef get_function_class(function):\n    \"\"\"\n    Given a function, return the class name of the function.\n    \"\"\"\n    return function.__class__.__name__\n\ndef get_function_function(function):\n    \"\"\"\n    Given a function, return the function name of the function.\n    \"\"\"\n    return function.__name__\n\ndef get_function_function_name(function):\n    \"\"\"\n    Given a function, return the name of the function.\n    \"\"\"\n    return function.__name__\n\ndef get_function_function_module(function):\n    \"\"\"\n    Given a function, return the module name of the function.\n    \"\"\"\n    return function.__module__\n\ndef get_function_function_class(function):\n    \"\"\"\n    Given a function, return the class name of the function.\n    \"\"\"\n    return function.__class__.__name__\n\ndef get_function_function_function_name(function):\n    \"\"\"\n    Given a function",
        "\n\ndef handle_del_fun(self, function_name):\n        \"\"\"Remove a function from the function list, in order.\"\"\"\n        function_name = function_name.strip()\n        try:\n            function = get_function(function_name)\n        except Exception, exc:\n            self.wfile.write(js_error(exc) + NEWLINE)\n            return\n        # This tests to see if the function has been decorated with the view\n        # server synchronisation decorator (``decorate_view``).\n        if not getattr(function, 'view_decorated', None):\n            del self.functions[function_name]\n        else:\n            function(self.log)\n        self.function_counter -= 1\n        return True\n\ndef handle_get_fun(self, function_name):\n        \"\"\"Get a function from the function list, in order.\"\"\"\n        function_name = function_name.strip()\n        try:\n            function = get_function(function_name)\n        except Exception, exc:\n            self.wfile.write(js_error(exc) + NEWLINE)\n            return\n        # This tests to see if the function has been decorated with the view\n        # server synchronisation decorator (``decorate_view``).\n        if not getattr(function, 'view_decorated', None",
        ".\n\ndef handle_map_doc_list(self, documents):\n        \"\"\"Return the mapping of a list of documents according to the function list.\"\"\"\n        # This uses the stored set of functions, sorted by order of addition.\n        for function in sorted(self.functions.values(), key=lambda x: x[0]):\n            try:\n                # It has to be run through ``list``, because it may be a\n                #\u00a0generator function.\n                yield [list(function(documents))]\n            except Exception, exc:\n                # Otherwise, return an empty list and log the event.\n                yield []\n                self.log(repr(exc))\n\ndef handle_map_doc_dict(self, documents):\n        \"\"\"Return the mapping of a dictionary according to the function list.\"\"\"\n        # This uses the stored set of functions, sorted by order of addition.\n        for function in sorted(self.functions.values(), key=lambda x: x[0]):\n            try:\n                # It has to be run through ``dict``, because it may be a\n                #\u00a0generator function.\n                yield {list(function(documents)): documents}\n            except Exception, exc:\n                # Otherwise, return an empty list and log the event.\n                yield {}\n                self.log(repr(exc))\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        ".encode('utf-8')\n\ndef handle_validate_all(self, function_name, new_doc, old_doc, user_ctx):\n        \"\"\"Validate...this function is undocumented, but still in CouchDB.\"\"\"\n        try:\n            function = get_function(function_name)\n        except Exception, exc:\n            self.log(repr(exc))\n            return False\n        try:\n            return function(new_doc, old_doc, user_ctx)\n        except Exception, exc:\n            self.log(repr(exc))\n            return repr(exc)\n\ndef handle_validate_all_all(self, function_name, new_doc, old_doc, user_ctx):\n        \"\"\"Validate...this function is undocumented, but still in CouchDB.\"\"\"\n        try:\n            function = get_function(function_name)\n        except Exception, exc:\n            self.log(repr(exc))\n            return False\n        try:\n            return function(new_doc, old_doc, user_ctx)\n        except Exception, exc:\n            self.log(repr(exc))\n            return repr(exc)\n\ndef handle_validate_all_all_all(self, function_name, new_doc, old_doc, user_ctx):\n        \"\"\"Validate...",
        "\n\ndef handle_command(self, cmd):\n        \"\"\"The main function called to handle a command.\"\"\"\n        if cmd == 'help':\n                self.wfile.write(\n                    one_lineify(\n                        \"Usage: %s [options] <command>\" % self.prog) + NEWLINE)\n                self.wfile.write(\n                    one_lineify(\n                        \"Options:\") + NEWLINE)\n                self.wfile.write(\n                    one_lineify(\n                        \"  -h, --help     Show this help message.\") + NEWLINE)\n                self.wfile.write(\n                    one_lineify(\n                        \"  -v, --version  Show version information.\") + NEWLINE)\n                self.wfile.write(\n                    one_lineify(\n                        \"  -c, --command <command>\" + NEWLINE) + NEWLINE)\n                self.wfile.write(\n                    one_lineify(\n                        \"  -d, --debug    Show debug information.\") + NEWLINE)\n                self.wfile.write(\n                    one_lineify(\n                        \"  -v, --version  Show version information.\") + NEWLINE)\n                self.wfile.write(\n                    one_lineify(\n                        \"  -c, --command <command>\" + NEWLINE) + NEWLINE)\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef guid_random(*args):\n    \"\"\"\n    Generates a universally unique ID.\n    Any arguments only create more randomness.\n    \"\"\"\n    t = float(time.time() * 1000)\n    r = float(random.random()*10000000000000)\n\n    a = random.random() * 10000000000000\n    data = str(t) + ' ' + str(r) + ' ' + str(a) + ' ' + str(args)\n    data = hashlib.md5(data.encode()).hexdigest()[:10]\n\n    return data\n\ndef guid_random_string(*args):\n    \"\"\"\n    Generates a universally unique ID.\n    Any arguments only create more randomness.\n    \"\"\"\n    t = float(time.time() * 1000)\n    r = float(random.random()*10000000000000)\n\n    a = random.random() * 10000000000000\n    data = str(t) + ' ' + str(r) + ' ' + str(a) + ' ' + str(args)\n    data = hashlib.md5(data.encode()).hexdigest()[:10]\n\n    return data\n\ndef guid_random_string_random(*args):\n    \"\"\"\n    Generates a universally unique ID.\n    Any arguments only",
        "\n\ndef get_token(self, callback):\n        '''\n        get_token returns the access token from the data_store\n        '''\n        yield Task(self.data_store.get, 'tokens', callback=callback)\n\ndef get_token_by_id(self, id, callback):\n        '''\n        get_token_by_id returns the access token from the data_store\n        '''\n        yield Task(self.data_store.get, 'tokens', id=id, callback=callback)\n\ndef get_token_by_name(self, name, callback):\n        '''\n        get_token_by_name returns the access token from the data_store\n        '''\n        yield Task(self.data_store.get, 'tokens', name=name, callback=callback)\n\ndef get_token_by_email(self, email, callback):\n        '''\n        get_token_by_email returns the access token from the data_store\n        '''\n        yield Task(self.data_store.get, 'tokens', email=email, callback=callback)\n\ndef get_token_by_expires_at(self, expires_at, callback):\n        '''\n        get_token_by_expires_at returns the access token from the data_store\n        '''\n        yield Task(self",
        "\n\ndef _auth_with_nonce(self, client_id, key, nonce, method, callback):\n        '''\n        _auth_with_nonce - internal method to ensure the client_id and client_secret passed\n        with the nonce match\n        '''\n        available = auth_methods.keys()\n        if method not in available:\n            raise Proauth2Error('invalid_request',\n                                'unsupported authentication method: %s' % \\\n                                (method, '\\n'.join(available)))\n        client = yield Task(self.data_store.fetch, 'applications',\n                            client_id=client_id)\n        if not client: raise Proauth2Error('access_denied')\n        if not auth_methods[method](key, client['client_secret'], nonce):\n            raise Proauth2Error('access_denied')\n        callback()\n\ndef _auth_with_nonce_and_client_secret(self, client_id, key, nonce, client_secret, method, callback):\n        '''\n        _auth_with_nonce_and_client_secret - internal method to ensure the client_id and client_secret passed\n        with the nonce match\n        '''\n        available = auth_methods.keys()\n        if method not in available:\n            raise Proauth2Error('invalid_request',",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ")\n\ndef _generate_random_string(self, length=32):\n        '''\n        _generate_random_string - internal function for generating randomized alphanumberic\n        strings of a given length\n        '''\n        return ''.join(choice(ascii_letters + digits) for x in range(length))\n\ndef _generate_random_int(self, min=0, max=2**32-1):\n        '''\n        _generate_random_int - internal function for generating randomized alphanumberic\n        integers of a given length\n        '''\n        return min + random.randint(min, max)\n\ndef _generate_random_float(self, min=0, max=2**32-1):\n        '''\n        _generate_random_float - internal function for generating randomized alphanumberic\n        floats of a given length\n        '''\n        return min + random.randfloat(min, max)\n\ndef _generate_random_bool(self, min=False, max=True):\n        '''\n        _generate_random_bool - internal function for generating randomized alphanumberic\n        booleans of a given length\n        '''\n        return min + random.randbool(min, max)\n\ndef _generate_random_datetime(self, min=datetime.datetime.now(), max=",
        "\n\ndef merge_unordered(ordereds: typing.Iterable[typing.Any]) -> typing.Iterable[typing.Any]:\n    \"\"\"Merge multiple unordered so that within-unordered order is preserved\n    \"\"\"\n    seen_set = set()\n    add_seen = seen_set.add\n    return reversed(tuple(map(\n        lambda obj: add_seen(obj) or obj,\n        filterfalse(\n            seen_set.__contains__,\n            chain.from_iterable(map(reversed, reversed(ordereds))),\n        ),\n    )))\n\n\ndef filterfalse(\n    predicate: typing.Callable[[typing.Any], bool],\n    iterable: typing.Iterable[typing.Any],\n) -> typing.Iterable[typing.Any]:\n    \"\"\"Filter iterable to only include elements that satisfy predicate\n    \"\"\"\n    return filter(predicate, iterable)\n\n\ndef filtertrue(predicate: typing.Callable[[typing.Any], bool], iterable: typing.Iterable[typing.Any]) -> typing.Iterable[typing.Any]:\n    \"\"\"Filter iterable to only include elements that satisfy predicate\n    \"\"\"\n    return filter(predicate, iterable)\n\n\ndef filterfalse(predicate: typing.Callable[[typing.Any], bool], iterable: typing.Iterable[typing.Any]) ->",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef __get_current_date(self):\n        \"\"\"Get current date for every file.\"\"\"\n        self.wql_date = \"SELECT Date FROM Win32_OperatingSystem\"\n        self.current_date = self.query(self.wql_date)\n        # [{'Date': '20160824161431.977000+480'}]'\n        self.current_date_string = str(\n            self.current_date[0].get('Date').split('.')[0])\n        # '20160824161431'\n        self.current_date_format = datetime.datetime.strptime(\n            self.current_date_string, '%Y%m%d%H%M%S')\n        # param: datetime.datetime(2016, 8, 24, 16, 14, 31) -> type:\n        # datetime.datetime\n        return self.current_date_format\n\ndef __get_current_time(self):\n        \"\"\"Get current time for every file.\"\"\"\n        self.wql_time = \"SELECT LocalTime FROM Win32_OperatingSystem\"\n        self.current_time = self.query(self.wql_time)\n        # [{'LocalTime': '20160824161431.977000+480'}]'\n        self.",
        "\n\n\ndef config_creator():\n        \"\"\"create a config object\n\n        :return: config object\n        \"\"\"\n        config = {}\n        config['debug'] = False\n        config['branch_queue'] = Queue()\n        config['branch_spider'] = BranchSpider()\n        return config\n\n\ndef branch_spider(url):\n        \"\"\"create a branch spider\n\n        :param url: url of the spider\n        :return: branch spider\n        \"\"\"\n        branch_spider = BranchSpider()\n        branch_spider.set_url(url)\n        return branch_spider\n\n\ndef sleep(self, *sleep_times):\n        \"\"\"sleep for a number of times\n\n        :param sleep_times: number of times to sleep\n        :return: None\n        \"\"\"\n        for i in range(*sleep_times):\n                time.sleep(random.randrange(*sleep_times))\n\n\ndef main():\n        \"\"\"run your main spider here\n\n        :return: None\n        \"\"\"\n        run()\n\n\nif __name__ == '__main__':\n        main()\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef MakeDescriptorFromProto(desc_proto, package='', build_file_if_cpp=True,\n                           syntax=None):\n  \"\"\"Make a protobuf Descriptor given a DescriptorProto protobuf.\n\n  Handles nested descriptors. Note that this is limited to the scope of defining\n  a message inside of another message. Composite fields can currently only be\n  resolved if the message is defined in the same scope as the field.\n\n  Args:\n    desc_proto: The descriptor_pb2.DescriptorProto protobuf message.\n    package: Optional package name for the new message Descriptor (string).\n    build_file_if_cpp: Update the C++ descriptor pool if api matches.\n                       Set to False on recursion, so no duplicates are created.\n    syntax: The syntax/semantics that should be used.  Set to \"proto3\" to get\n            proto3 field presence semantics.\n  Returns:\n    A Descriptor for protobuf messages.\n  \"\"\"\n  if api_implementation.Type() == 'cpp' and build_file_if_cpp:\n    # The C++ implementation requires all descriptors to be backed by the same\n    # definition in the C++ descriptor pool. To do this, we build a\n    # FileDescriptorProto with the same definition as this descriptor and build\n    # it into the pool.\n    from typy.google.protobuf",
        "\n    return desc\n\ndef GetTopLevelContainingTypeOrSelf(self):\n    \"\"\"Returns the top-level containing type, or itself if its the top-level.\"\"\"\n    return GetTopLevelContainingType()\n\ndef GetTopLevelContainingTypeOrSelfOrSelf(self):\n    \"\"\"Returns the top-level containing type, or itself if its the top-level.\"\"\"\n    return GetTopLevelContainingTypeOrSelf()\n\ndef GetTopLevelContainingTypeOrSelfOrSelfOrSelf(self):\n    \"\"\"Returns the top-level containing type, or itself if its the top-level.\"\"\"\n    return GetTopLevelContainingTypeOrSelf()\n\ndef GetTopLevelContainingTypeOrSelfOrSelfOrSelf(self):\n    \"\"\"Returns the top-level containing type, or itself if its the top-level.\"\"\"\n    return GetTopLevelContainingTypeOrSelf()\n\ndef GetTopLevelContainingTypeOrSelfOrSelfOrSelf(self):\n    \"\"\"Returns the top-level containing type, or itself if its the top-level.\"\"\"\n    return GetTopLevelContainingTypeOrSelf()\n\ndef GetTopLevelContainingTypeOrSelfOrSelfOrSelf(self):\n    \"\"\"Returns the top-level containing type, or itself if its the top-level.\"\"\"\n    return GetTopLevelContainingTypeOrSelf()\n\ndef GetTopLevelContainingTypeOrSelfOrSelfOrSelf(self):\n    \"\"\"Returns the top-level containing type,",
        "\ndef FindMethodBySignature(self, signature):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if method.signature == signature:\n        return method\n    return None\n\ndef FindMethodBySignatureAndName(self, signature, name):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if method.signature == signature and method.name == name:\n        return method\n    return None\n\ndef FindMethodBySignatureAndNameAndParameters(self, signature, name, parameters):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if method.signature == signature and method.name == name and method.parameters == parameters:\n        return method\n    return None\n\ndef FindMethodBySignatureAndNameAndParametersAndReturnType(self, signature, name, parameters, returnType):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if method.signature == signature and method.name == name and method.parameters == parameters and method.returnType == returnType:\n        return method\n    return None\n\ndef FindMethodBySignatureAndNameAndParametersAndReturnTypeAndParameters(self, signature, name, parameters, returnType, parameters):\n    \"\"\"",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.",
        ".get(key, unused_including_default)\n  return ret\n\ndef _ValueMessageToJsonObject(message):\n  \"\"\"Converts Value message according to Proto3 JSON Specification.\"\"\"\n  return {\n      'type': message.type,\n      'name': message.name,\n      'value': message.value,\n      'description': message.description,\n      'required': message.required,\n      'optional': message.optional,\n      'default': message.default,\n      'enum': message.enum,\n      'enum_values': message.enum_values,\n      'enum_values_as_strings': message.enum_values_as_strings,\n      'enum_values_as_ints': message.enum_values_as_ints,\n      'enum_values_as_floats': message.enum_values_as_floats,\n      'enum_values_as_doubles': message.enum_values_as_doubles,\n      'enum_values_as_booleans': message.enum_values_as_booleans,\n      'enum_values_as_bytes': message.enum_values_as_bytes,\n      'enum_values_as_integers': message.enum_values_as_integers,\n      'enum_values_as_strings': message.enum_values",
        "\n\ndef _DuplicateChecker(obj1, obj2):\n  \"\"\"Checks if two objects are identical.\n\n  Args:\n    obj1: First object to check.\n    obj2: Second object to check.\n\n  Returns:\n    True if the objects are identical.\n  \"\"\"\n  if obj1 is None and obj2 is None:\n    return True\n  if obj1 is None or obj2 is None:\n    return False\n  return obj1.__dict__ == obj2.__dict__\n\ndef _ConvertMessage(js, message):\n  \"\"\"Converts a JSON representation of a protocol message into a protocol beffer\n  message.\n\n  Args:\n    js: A JSON representation of a protocol message.\n    message: A protocol beffer message to merge into.\n  \"\"\"\n  if not isinstance(js, dict):\n    raise ValueError('Invalid JSON: {0}.'.format(str(js)))\n  for key, value in js.items():\n    if isinstance(value, dict):\n      _ConvertMessage(value, message[key])\n    else:\n      message[key] = value\n\ndef _ConvertMessage(js, message):\n  \"\"\"Converts a JSON representation of a protocol message into a protocol beffer\n  message.\n\n  Args:\n    js: A JSON representation of a protocol message",
        "\n    except KeyError as e:\n      raise ParseError('Failed to parse {0} field: {1}.'.format(name, e))\n\n\ndef _IsMapEntry(field):\n  \"\"\"Checks if a field is a map entry.\n\n  Args:\n    field: A field descriptor.FieldDescriptor.\n\n  Returns:\n    True if the field is a map entry.\n  \"\"\"\n  return field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MAP\n\n\ndef _ConvertMapFieldValue(value, message, field):\n  \"\"\"Convert a map field value into a regular protocol message.\n\n  Args:\n    value: A map field value.\n    message: A regular protocol message to record the data.\n    field: A field descriptor.FieldDescriptor.\n\n  Raises:\n    ParseError: In case of problems converting.\n  \"\"\"\n  if not isinstance(value, dict):\n    raise ParseError('map field value must be a dictionary.')\n  if field.label == descriptor.FieldDescriptor.LABEL_REPEATED:\n    raise ParseError('repeated field {0} must be in [] which is '\n                       '{1}.'.format(field.name, value))\n  if field.cpp_type == descriptor.FieldDescriptor.CPPTYPE_MESSAGE:\n    # Repeated message field.\n    for",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.GetOperation;\nimport com.hazelcast.",
        "\n\ndef _ConvertValueMessage(value, message):\n  \"\"\"Convert a JSON representation into Value message.\"\"\"\n  if not isinstance(value, dict):\n    raise ParseError(\n        'Value must be in a dictionary which is {0}.'.format(value))\n  message.ClearField('type')\n  if value.get('type'):\n    message.type = value['type']\n  message.ClearField('value')\n  if value.get('value'):\n    message.value = value['value']\n  message.ClearField('timestamp')\n  if value.get('timestamp'):\n    message.timestamp = value['timestamp']\n  message.ClearField('timestamp_ns')\n  if value.get('timestamp_ns'):\n    message.timestamp_ns = value['timestamp_ns']\n  message.ClearField('timestamp_ns_micros')\n  if value.get('timestamp_ns_micros'):\n    message.timestamp_ns_micros = value['timestamp_ns_micros']\n  message.ClearField('timestamp_ns_seconds')\n  if value.get('timestamp_ns_seconds'):\n    message.timestamp_ns_seconds = value['timestamp_ns_seconds']\n  message.ClearField('timestamp_ns_micros_seconds')\n  if value.get('timestamp",
        "\ndef _ConvertValueMessage(value, message):\n  \"\"\"Convert a JSON representation into Value message.\"\"\"\n  if not isinstance(value, dict):\n    raise ParseError(\n        'Value must be in a dict which is {0}.'.format(value))\n  for key in value:\n    _ConvertValueMessage(value[key], message.fields[key])\n  return\n\ndef _ConvertValueMessage(value, message):\n  \"\"\"Convert a JSON representation into Value message.\"\"\"\n  if not isinstance(value, dict):\n    raise ParseError(\n        'Value must be in a dict which is {0}.'.format(value))\n  for key in value:\n    _ConvertValueMessage(value[key], message.fields[key])\n  return\n\ndef _ConvertValueMessage(value, message):\n  \"\"\"Convert a JSON representation into Value message.\"\"\"\n  if not isinstance(value, dict):\n    raise ParseError(\n        'Value must be in a dict which is {0}.'.format(value))\n  for key in value:\n    _ConvertValueMessage(value[key], message.fields[key])\n  return\n\ndef _ConvertValueMessage(value, message):\n  \"\"\"Convert a JSON representation into Value message.\"\"\"\n  if not isinstance(value, dict):\n    raise ParseError(\n        'Value must be in a dict which",
        "\n\n    # Check for changed notebook directory.\n    if new_config.has_key('notebook_directory'):\n        wd = os.path.abspath(new_config['notebook_directory'])\n        if nbmanager.notebook_dir != wd:\n            if not os.path.exists(wd):\n                raise IOError('Path not found: %s' % wd)\n            nbmanager.notebook_dir = wd\n\n    # Check for changed notebook directory.\n    if new_config.has_key('notebook_directory_prefix'):\n        wd = os.path.abspath(new_config['notebook_directory_prefix'])\n        if nbmanager.notebook_dir != wd:\n            if not os.path.exists(wd):\n                raise IOError('Path not found: %s' % wd)\n            nbmanager.notebook_dir = wd\n\n    # Check for changed notebook directory.\n    if new_config.has_key('notebook_directory_suffix'):\n        wd = os.path.abspath(new_config['notebook_directory_suffix'])\n        if nbmanager.notebook_dir != wd:\n            if not os.path.exists(wd):\n                raise IOError('Path not found: %s' % wd)\n            nbmanager.notebook_dir = wd\n\n    # Check for changed notebook directory",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef FromJsonString(self, json_string):\n    \"\"\"Converts string format to Duration.\n\n    Args:\n      json_string: A string representation of a Duration.\n\n    Returns:\n      A Duration object.\n    \"\"\"\n    if json_string == '':\n      return None\n    if json_string.startswith('-'):\n      return Duration(-json_string[1:])\n    if json_string.startswith('+'):\n      return Duration(json_string[1:])\n    if json_string.startswith('.'):\n      return Duration(json_string[1:])\n    if json_string.startswith('-'):\n      return Duration(-json_string[1:])\n    if json_string.startswith('+'):\n      return Duration(json_string[1:])\n    if json_string.startswith('.'):\n      return Duration(json_string[1:])\n    if json_string.startswith('-'):\n      return Duration(-json_string[1:])\n    if json_string.startswith('+'):\n      return Duration(json_string[1:])\n    if json_string.startswith('.'):\n      return Duration(json_string[1:])\n    if json_string.startswith('-'):\n      return Duration",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        ".append(path)\n\n  def Clear(self):\n    self.paths.clear()\n\n  def Add(self, path):\n    self.paths.append(path)\n\n  def GetPaths(self):\n    return self.paths\n\n  def ToJsonString(self):\n    return json.dumps(self.paths)\n\n  def __str__(self):\n    return self.ToJsonString()\n\n  def __repr__(self):\n    return '<FieldMask paths=%s>' % self.paths\n\n  def __eq__(self, other):\n    return self.paths == other.paths\n\n  def __ne__(self, other):\n    return self.paths != other.paths\n\n  def __lt__(self, other):\n    return self.paths < other.paths\n\n  def __le__(self, other):\n    return self.paths <= other.paths\n\n  def __gt__(self, other):\n    return self.paths > other.paths\n\n  def __ge__(self, other):\n    return self.paths >= other.paths\n\n  def __eq__(self, other):\n    return self.paths == other.paths\n\n  def __ne__(self, other):\n    return self.paths != other.paths\n\n",
        "\n\ndef get_server(server_url='http://127.0.0.1:5984/'):\n    \"\"\"Return a CouchDB server, given its URL.\"\"\"\n    return couchdb.client.Server(server_url)\n\ndef get_server_by_name(server_name):\n    \"\"\"Return a CouchDB server, given its name.\"\"\"\n    return couchdb.client.Server(server_name)\n\ndef get_server_by_id(server_id):\n    \"\"\"Return a CouchDB server, given its ID.\"\"\"\n    return couchdb.client.Server(server_id)\n\ndef get_server_by_name_and_id(server_name, server_id):\n    \"\"\"Return a CouchDB server, given its name and ID.\"\"\"\n    return couchdb.client.Server(server_name, server_id)\n\ndef get_server_by_name_and_id_and_rev(server_name, server_id, rev):\n    \"\"\"Return a CouchDB server, given its name and ID and revision.\"\"\"\n    return couchdb.client.Server(server_name, server_id, rev)\n\ndef get_server_by_name_and_id_and_rev_and_db_name(server_name, server_id, rev, db_name):\n   ",
        "\n    else:\n        raise ValueError('Unknown extension: %s' % extend)\n\ndef write(readme, readme_file):\n    \"\"\"Write README to README_FILE.\"\"\"\n    with open(readme_file, 'w') as f:\n        f.write(read(readme))\n\ndef main():\n    \"\"\"Main function.\"\"\"\n    readme = read('README.rst')\n    write(readme, 'README.md')\n\nif __name__ == '__main__':\n    main()\n",
        "(self)\n\ndef insert(self, collection, **kwargs):\n        '''\n        insert records into collection whose parameters match kwargs\n        '''\n        callback = kwargs.pop('callback')\n        yield Op(self.db[collection].insert, kwargs)\n        callback()(self)\n\ndef update(self, collection, **kwargs):\n        '''\n        update records in collection whose parameters match kwargs\n        '''\n        callback = kwargs.pop('callback')\n        yield Op(self.db[collection].update, kwargs)\n        callback()(self)\n\ndef find(self, collection, **kwargs):\n        '''\n        find records in collection whose parameters match kwargs\n        '''\n        callback = kwargs.pop('callback')\n        yield Op(self.db[collection].find, kwargs)\n        callback()(self)\n\ndef count(self, collection, **kwargs):\n        '''\n        count records in collection whose parameters match kwargs\n        '''\n        callback = kwargs.pop('callback')\n        yield Op(self.db[collection].count, kwargs)\n        callback()(self)\n\ndef count_all(self, collection, **kwargs):\n        '''\n        count records in collection whose parameters match kwargs\n        '''\n        callback = kwargs.pop('callback')\n        yield Op(self.db[collection].count_all, kwargs",
        "\n\ndef _parent(self):\n        \"\"\"\n        Return the parent of this object.\n\n        >>> trello = TrelloAPIV1('APIKEY')\n        >>> trello.boards(board_id='BOARD_ID')._parent\n        '1/boards'\n        >>> trello.boards(board_id='BOARD_ID')(field='FIELD')._parent\n        '1/boards/BOARD_ID/FIELD'\n        >>> trello.boards(board_id='BOARD_ID').cards(filter='FILTER')._parent\n        '1/boards/BOARD_ID/cards'\n        >>> trello.boards(board_id='BOARD_ID').cards(filter='FILTER')(field='FIELD')._parent\n        '1/boards/BOARD_ID/cards/FILTER/FIELD'\n\n        \"\"\"\n        if self._api_arg:\n            mypart = str(self._api_arg)\n        else:\n            mypart = self._name\n\n        if self._parent:\n            return '/'.join(filter(None, [self._parent._url, mypart]))\n        else:\n            return mypart\n\ndef _api_arg(self):\n        \"\"\"\n",
        "\n\ndef _api_call_with_token(self, method_name, *args, **kwargs):\n        \"\"\"\n        Makes the HTTP request with a token.\n\n        \"\"\"\n        params = kwargs.setdefault('params', {})\n        params.update({'key': self._apikey})\n        if self._token is not None:\n            params.update({'token': self._token})\n\n        http_method = getattr(requests, method_name)\n        return http_method(TRELLO_URL + self._url, *args, **kwargs)\n\ndef _api_call_with_apikey(self, method_name, *args, **kwargs):\n        \"\"\"\n        Makes the HTTP request with a key.\n\n        \"\"\"\n        params = kwargs.setdefault('params', {})\n        params.update({'key': self._apikey})\n\n        http_method = getattr(requests, method_name)\n        return http_method(TRELLO_URL + self._url, *args, **kwargs)\n\ndef _api_call_with_token_and_apikey(self, method_name, *args, **kwargs):\n        \"\"\"\n        Makes the HTTP request with a token and a key.\n\n        \"\"\"\n        params = kwargs.setdefault('params', {})\n       ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef ParseFloat(text, is_signed=False, is_long=False):\n  \"\"\"Parses a float.\n\n  Args:\n    text: The text to parse.\n    is_signed: True if a signed float must be parsed.\n    is_long: True if a long float must be parsed.\n\n  Returns:\n    The float value.\n\n  Raises:\n    ValueError: Thrown Iff the text is not a valid float.\n  \"\"\"\n  # Do the actual parsing. Exception handling is propagated to caller.\n  try:\n    result = float(text)\n  except ValueError:\n    raise ValueError('Couldn\\'t parse float: %s' % text)\n\n  # Check if the float is sane. Exceptions handled by callers.\n  checker = _FLOAT_CHECKERS[2 * int(is_long) + int(is_signed)]\n  checker.CheckValue(result)\n  return result\n\ndef ParseString(text, is_signed=False, is_long=False):\n  \"\"\"Parses a string.\n\n  Args:\n    text: The text to parse.\n    is_signed: True if a signed string must be parsed.\n    is_long: True if a long string must be parsed.\n\n  Returns:\n    The string value.\n\n  Raises:\n    ValueError",
        ".Print(self.indent)\n\n  def PrintField(self, field, value):\n    \"\"\"Print a field to the text format.\n\n    Args:\n      field: The field to print.\n      value: The value to print.\n    \"\"\"\n    if field.label == descriptor.FieldDescriptor.LABEL_REPEATED:\n      self.PrintField(field, value)\n    else:\n      self.PrintField(field, value.SerializeToString())\n\n  def PrintEnum(self, enum_value):\n    \"\"\"Print a enum value to the text format.\n\n    Args:\n      enum_value: The enum value to print.\n    \"\"\"\n    self.PrintField(descriptor.FieldDescriptor(\n        label=descriptor.FieldDescriptor.LABEL_REPEATED,\n        type=descriptor.FieldDescriptor.TYPE_ENUM,\n        value=enum_value), enum_value)\n\n  def PrintEnumValue(self, enum_value):\n    \"\"\"Print a enum value to the text format.\n\n    Args:\n      enum_value: The enum value to print.\n    \"\"\"\n    self.PrintField(descriptor.FieldDescriptor(\n        label=descriptor.FieldDescriptor.LABEL_REPEATED,\n        type=descriptor.FieldDescriptor.TYPE_ENUM,\n        value=enum_value), enum_value)",
        "(tokenizer, message)\n\ndef _MergeField(self, tokenizer, message):\n  \"\"\"Merges a field from a text representation into a message.\n\n  Args:\n    tokenizer: A tokenizer for a text representation of a message.\n    message: A protocol buffer message to merge into.\n\n  Raises:\n    ParseError: On text parsing problems.\n  \"\"\"\n  if tokenizer.AtEnd():\n    return\n\n  field_name = tokenizer.GetText()\n  field_type = tokenizer.GetText()\n  field_value = tokenizer.GetText()\n\n  if field_type == 'BOOL':\n    field_value = bool(field_value)\n\n  if field_type == 'INT32':\n    field_value = int(field_value)\n\n  if field_type == 'INT64':\n    field_value = long(field_value)\n\n  if field_type == 'FLOAT':\n    field_value = float(field_value)\n\n  if field_type == 'DOUBLE':\n    field_value = double(field_value)\n\n  if field_type == 'STRING':\n    field_value = field_value.encode('utf-8')\n\n  if field_type == 'BYTES':\n    field_value = field_value.encode('utf-8')\n\n",
        "\n\n\ndef _MergeField(self, tokenizer, message):\n  \"\"\"Merges a single scalar field into a message.\n\n  Args:\n    tokenizer: A tokenizer to parse the field value.\n    message: The message of which field is a member.\n\n  Raises:\n    ParseError: In case of text parsing problems.\n  \"\"\"\n  if tokenizer.TryConsume('<'):\n    end_token = '>'\n  else:\n    tokenizer.Consume('{')\n    end_token = '}'\n\n  if tokenizer.TryConsume('<'):\n    end_token = '>'\n  else:\n    tokenizer.Consume('{')\n    end_token = '}'\n\n  if tokenizer.TryConsume('<'):\n    end_token = '>'\n  else:\n    tokenizer.Consume('{')\n    end_token = '}'\n\n  if tokenizer.TryConsume('<'):\n    end_token = '>'\n  else:\n    tokenizer.Consume('{')\n    end_token = '}'\n\n  if tokenizer.TryConsume('<'):\n    end_token = '>'\n  else:\n    tokenizer.Consume('{')\n    end_token = '}'\n\n  if tokenizer.TryConsume('<'):\n    end_token = '>'\n  else:\n    tokenizer.Consume('{')\n    end_",
        ".token\n\ndef ConsumeMessage(self):\n    \"\"\"Consumes protocol message field.\n\n    Returns:\n      Protocol message field.\n\n    Raises:\n      ParseError: If a message couldn't be consumed.\n    \"\"\"\n    result = self.token\n    if not self._MESSAGE.match(result):\n      raise self._ParseError('Expected message.')\n    self.NextToken()\n    return self.ConsumeField()\n\ndef ConsumeField(self):\n    \"\"\"Consumes protocol message field.\n\n    Returns:\n      Protocol message field.\n\n    Raises:\n      ParseError: If a field couldn't be consumed.\n    \"\"\"\n    result = self.token\n    if not self._FIELD.match(result):\n      raise self._ParseError('Expected field.')\n    self.NextToken()\n    return self.ConsumeField()\n\ndef ConsumeField(self):\n    \"\"\"Consumes protocol message field.\n\n    Returns:\n      Protocol message field.\n\n    Raises:\n      ParseError: If a field couldn't be consumed.\n    \"\"\"\n    result = self.token\n    if not self._FIELD.match(result):\n      raise self._ParseError('Expected field.')\n    self.NextToken()\n    return self.ConsumeField()\n\ndef ConsumeField(self):\n    \"\"\"Consumes protocol message field.\n\n    Returns",
        "\n\ndef ConsumeInt64(self):\n    \"\"\"Consumes a signed 64bit integer number.\n\n    Returns:\n      The integer parsed.\n\n    Raises:\n      ParseError: If a signed 64bit integer couldn't be consumed.\n    \"\"\"\n    try:\n      result = ParseInteger(self.token, is_signed=True, is_long=True)\n    except ValueError as e:\n      raise self._ParseError(str(e))\n    self.NextToken()\n    return result\n\ndef ConsumeFloat32(self):\n    \"\"\"Consumes a float32 integer number.\n\n    Returns:\n      The float parsed.\n\n    Raises:\n      ParseError: If a float32 integer couldn't be consumed.\n    \"\"\"\n    try:\n      result = ParseFloat(self.token)\n    except ValueError as e:\n      raise self._ParseError(str(e))\n    self.NextToken()\n    return result\n\ndef ConsumeFloat64(self):\n    \"\"\"Consumes a float64 integer number.\n\n    Returns:\n      The float parsed.\n\n    Raises:\n      ParseError: If a float64 integer couldn't be consumed.\n    \"\"\"\n    try:\n      result = ParseFloat(self.token)\n    except ValueError as e:\n      raise self._ParseError(str(e))\n    self.NextToken()\n",
        "\n\ndef ConsumeInteger(self):\n    \"\"\"Consumes an integer.\n\n    Returns:\n      The number parsed.\n\n    Raises:\n      ParseError: If an integer couldn't be consumed.\n    \"\"\"\n    try:\n      result = ParseInt(self.token)\n    except ValueError as e:\n      raise self._ParseError(str(e))\n    self.NextToken()\n    return result\n\ndef ConsumeString(self):\n    \"\"\"Consumes a string.\n\n    Returns:\n      The string parsed.\n\n    Raises:\n      ParseError: If a string couldn't be consumed.\n    \"\"\"\n    try:\n      result = self.token.strip()\n    except ValueError as e:\n      raise self._ParseError(str(e))\n    self.NextToken()\n    return result\n\ndef ConsumeBool(self):\n    \"\"\"Consumes a boolean.\n\n    Returns:\n      The boolean parsed.\n\n    Raises:\n      ParseError: If a boolean couldn't be consumed.\n    \"\"\"\n    try:\n      result = self.token.lower() == 'true'\n    except ValueError as e:\n      raise self._ParseError(str(e))\n    self.NextToken()\n    return result\n\ndef ConsumeError(self):\n    \"\"\"Consumes an error.\n\n    Returns:\n      The error parsed.\n",
        "\n\ndef ConsumeInt(self):\n    \"\"\"Consumes an integer value.\n\n    Returns:\n      The int parsed.\n\n    Raises:\n      ParseError: If an integer value couldn't be consumed.\n    \"\"\"\n    try:\n      result = ParseInt(self.token)\n    except ValueError as e:\n      raise self._ParseError(str(e))\n    self.NextToken()\n    return result\n\ndef ConsumeFloat(self):\n    \"\"\"Consumes a float value.\n\n    Returns:\n      The float parsed.\n\n    Raises:\n      ParseError: If a float value couldn't be consumed.\n    \"\"\"\n    try:\n      result = ParseFloat(self.token)\n    except ValueError as e:\n      raise self._ParseError(str(e))\n    self.NextToken()\n    return result\n\ndef ConsumeString(self):\n    \"\"\"Consumes a string value.\n\n    Returns:\n      The string parsed.\n\n    Raises:\n      ParseError: If a string value couldn't be consumed.\n    \"\"\"\n    try:\n      result = ParseString(self.token)\n    except ValueError as e:\n      raise self._ParseError(str(e))\n    self.NextToken()\n    return result\n\ndef ConsumeList(self):\n    \"\"\"Consumes a list value.\n\n    Returns:\n",
        "\n\ndef _ConsumeSingleByteStringList(self):\n    \"\"\"Consume one token of a string literal.\n\n    String literals (whether bytes or text) can come in multiple adjacent\n    tokens which are automatically concatenated, like in C or Python.  This\n    method only consumes one token.\n\n    Returns:\n      The token parsed.\n    Raises:\n      ParseError: When the wrong format data is found.\n    \"\"\"\n    text = self.token\n    if len(text) < 1 or text[0] not in _QUOTES:\n      raise self._ParseError('Expected string but found: %r' % (text,))\n\n    if len(text) < 2 or text[-1] != text[0]:\n      raise self._ParseError('String missing ending quote: %r' % (text,))\n\n    try:\n      result = text_encoding.CUnescape(text[1:-1])\n    except ValueError as e:\n      raise self._ParseError(str(e))\n    self.NextToken()\n    return result\n\ndef _ConsumeSingleByteStringDict(self):\n    \"\"\"Consume one token of a string literal.\n\n    String literals (whether bytes or text) can come in multiple adjacent\n    tokens which are automatically concatenated, like in C or Python.  This\n    method only consumes one token.\n\n   ",
        "\n\ndef unixt_to_arkt(unixt):\n    \"\"\" convert unix timestamp to ark timestamp\"\"\"\n    res = datetime.datetime(2017, 3, 21, 15, 55, 44) + datetime.timedelta(seconds=unixt)\n    return res.timestamp()\n\ndef get_ark_timestamp(ark_timestamp):\n    \"\"\" get ark timestamp from unix timestamp\"\"\"\n    return arkt_to_unixt(ark_timestamp)\n\ndef get_unix_timestamp(unixt):\n    \"\"\" get unix timestamp from ark timestamp\"\"\"\n    return unixt\n\ndef get_ark_timestamp_from_unixt(unixt):\n    \"\"\" get ark timestamp from unix timestamp\"\"\"\n    return arkt_to_arkt(unixt)\n\ndef get_unix_timestamp_from_arkt(arkt):\n    \"\"\" get unix timestamp from ark timestamp\"\"\"\n    return unixt_to_arkt(arkt)\n\ndef get_ark_timestamp_from_unixt_and_arkt(unixt, arkt):\n    \"\"\" get ark timestamp from unix timestamp and ark timestamp\"\"\"\n    return arkt_to_arkt(unixt) + arkt\n\ndef get_unix_timestamp_from_arkt_and_arkt(arkt, unixt):\n    \"\"\" get",
        "\n\ndef connect(self, host, port, user, password, database):\n        \"\"\"Connect to the database.\"\"\"\n        self.logger.debug(\"Connect to %s:%s\" % (host, port))\n        self.conn = pymssql.connect(host, port, user, password, database)\n        self.logger.debug(\"Connect succeed.\")\n\ndef execute(self, sql, params=None):\n        \"\"\"Execute the sql.\"\"\"\n        self.logger.debug(\"Execute %s\" % sql)\n        self.conn.execute(sql, params)\n        self.logger.debug(\"Execute succeed.\")\n\ndef execute_batch(self, sql, params=None):\n        \"\"\"Execute the sql.\"\"\"\n        self.logger.debug(\"Execute batch %s\" % sql)\n        self.conn.execute_batch(sql, params)\n        self.logger.debug(\"Execute batch succeed.\")\n\ndef execute_scalar(self, sql, params=None):\n        \"\"\"Execute the sql.\"\"\"\n        self.logger.debug(\"Execute scalar %s\" % sql)\n        self.conn.execute_scalar(sql, params)\n        self.logger.debug(\"Execute scalar succeed.\")\n\ndef execute_scalar_batch(self, sql, params=None):\n        \"\"\"Execute the sql.\"\"\"\n        self.logger.",
        "\n\ndef process_options(self, content: str) -> str:\n        '''Replace options with content defined in the config.\n\n        :param content: Markdown content\n\n        :returns: Markdown content without options\n        '''\n\n        def _sub(macro):\n            name = macro.group('body')\n            params = self.get_options(macro.group('options'))\n\n            return self.options['options'].get(name, '').format_map(params)\n\n        return self.pattern.sub(_sub, content)\n\n\ndef get_options(self, options: str) -> Dict[str, str]:\n        '''Get options from the config.\n\n        :param options: Markdown options\n\n        :returns: Dictionary of options\n        '''\n\n        options = {}\n\n        for option in options.split(','):\n            option = option.strip()\n\n            if option:\n                key, value = option.split('=')\n                options[key] = value\n\n        return options\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "(filepath))\r\n\r\ndef splitext_files_only(filepath):\r\n\t\"\"\"Split a filename or folder name into its components.\"\"\"\r\n\tparts = filepath.split('.')\r\n\tif len(parts) == 1:\r\n\t\treturn parts\r\n\telse:\r\n\t\treturn parts[:-1]\r\n\r\ndef __get_numbered_paths_from_file(filepath):\r\n\t\"\"\"Split a filename or folder name into its components.\"\"\"\r\n\tparts = splitext_files_only(filepath)\r\n\treturn map(lambda n: '%s (%%d)%s' % (n, itertools.count(1), parts[-1]), itertools.count(1))\r\n\r\ndef __get_numbered_paths_from_folder(filepath):\r\n\t\"\"\"Split a filename or folder name into its components.\"\"\"\r\n\tparts = splitext_files_only(filepath)\r\n\treturn map(lambda n: '%s (%%d)%s' % (n, itertools.count(1), parts[-1]), itertools.count(1))\r\n\r\ndef __get_numbered_paths_from_file_and_folder(filepath, folder):\r\n\t\"\"\"Split a filename or folder name into its components.\"\"\"\r\n\tparts = splitext_files_only(filepath)\r\n\treturn",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\r\n\r\ndef get_date(filename):\r\n\t\"\"\"\r\n\tGet the date for a file as a datetime instance\r\n\t\"\"\"\r\n\tts = os.stat(filename).st_mtime\r\n\treturn datetime.datetime.utcfromtimestamp(ts)\r\n\r\ndef get_date_time(filename):\r\n\t\"\"\"\r\n\tGet the date and time for a file as a datetime instance\r\n\t\"\"\"\r\n\tts = os.stat(filename).st_mtime\r\n\treturn datetime.datetime.utcfromtimestamp(ts)\r\n\r\ndef get_date_time_diff(filename):\r\n\t\"\"\"\r\n\tGet the date and time difference for a file as a datetime instance\r\n\t\"\"\"\r\n\tts = os.stat(filename).st_mtime\r\n\treturn datetime.datetime.utcfromtimestamp(ts)\r\n\r\ndef get_date_time_diff_diff(filename):\r\n\t\"\"\"\r\n\tGet the date and time difference for a file as a datetime instance\r\n\t\"\"\"\r\n\tts = os.stat(filename).st_mtime\r\n\treturn datetime.datetime.utcfromtimestamp(ts)\r\n\r\ndef get_date_time_diff_diff_diff(filename):\r\n\t\"\"\"\r\n\tGet the date and time difference for a file as a datetime instance",
        "\r\n\r\ndef ensure_file_exists(func):\r\n\t\"wrap a function that returns a file, making sure it exists\"\r\n\t@functools.wraps(func)\r\n\tdef make_if_not_present():\r\n\t\tfile = func()\r\n\t\tif not os.path.isfile(file):\r\n\t\t\tos.makedirs(file)\r\n\t\treturn file\r\n\treturn make_if_not_present\r\n\r\ndef ensure_file_not_exists(func):\r\n\t\"wrap a function that returns a file, making sure it does not exist\"\r\n\t@functools.wraps(func)\r\n\tdef make_if_not_present():\r\n\t\tfile = func()\r\n\t\tif os.path.isfile(file):\r\n\t\t\tos.remove(file)\r\n\t\treturn file\r\n\treturn make_if_not_present\r\n\r\ndef ensure_file_not_empty(func):\r\n\t\"wrap a function that returns a file, making sure it does not exist\"\r\n\t@functools.wraps(func)\r\n\tdef make_if_not_present():\r\n\t\tfile = func()\r\n\t\tif os.path.isfile(file):\r\n\t\t",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n        if self.rounds == 0:\n            self.do_run = True\n\ndef run(self):\n        \"\"\"\n        Run the composer\n        \"\"\"\n        self.do_run = True\n        self.age()\n\ndef main():\n        \"\"\"\n        Main function\n        \"\"\"\n        composer = Composer()\n        composer.run()\n\nif __name__ == '__main__':\n        main()\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef main():\n        \"\"\"main function\n\n        :return: None\n        \"\"\"\n        self = Main()\n        self.append_main_thread()\n\nif __name__ == '__main__':\n        main()\n",
        "\n\ndef getTextFromNodes(nodes):\n    \"\"\"\n    Scans through all children of nodes and gathers the\n    text. If node has non-text child-nodes then\n    NotTextNodeError is raised.\n    \"\"\"\n    t = \"\"\n    for n in nodes:\n        if n.nodeType == n.TEXT_NODE:\n            t += n.nodeValue\n        else:\n            raise NotTextNodeError\n    return t\n\ndef getTextFromNodesWithText(nodes, text):\n    \"\"\"\n    Scans through all children of nodes and gathers the\n    text. If node has non-text child-nodes then\n    NotTextNodeError is raised.\n    \"\"\"\n    t = \"\"\n    for n in nodes:\n        if n.nodeType == n.TEXT_NODE:\n            t += n.nodeValue\n        elif n.nodeValue == text:\n            t += n.nodeValue\n        else:\n            raise NotTextNodeError\n    return t\n\ndef getTextFromNodesWithTextAndAttributes(nodes, text, attributes):\n    \"\"\"\n    Scans through all children of nodes and gathers the\n    text. If node has non-text child-nodes then\n    NotTextNodeError is raised.\n    \"\"\"\n    t = \"\"\n    for n in nodes:\n        if n.nodeType == n.TEXT",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef contents_with_newline(self, f, text):\n        \"\"\"\n        Called for each file\n        Must return file content\n        Can be wrapped\n\n        :type f: static_bundle.files.StaticFileResult\n        :type text: str|unicode\n        :rtype: str|unicode\n        \"\"\"\n        text += self._read(f.abs_path) + \"\\r\\n\"\n        return text\n\ndef contents_with_newline_and_newline(self, f, text):\n        \"\"\"\n        Called for each file\n        Must return file content\n        Can be wrapped\n\n        :type f: static_bundle.files.StaticFileResult\n        :type text: str|unicode\n        :rtype: str|unicode\n        \"\"\"\n        text += self._read(f.abs_path) + \"\\r\\n\\r\\n\"\n        return text\n\ndef contents_with_newline_and_newline_and_newline(self, f, text):\n        \"\"\"\n        Called for each file\n        Must return file content\n        Can be wrapped\n\n        :type f: static_bundle.files.StaticFileResult\n        :type text: str|unicode\n        :rtype: str|unicode\n        \"\"\"\n        text += self._read(f.abs_path) + \"\\r\\n",
        "\n\ndef is_datetime_type(cls):\n    \"\"\"Return True if the class is a datetime type.\"\"\"\n    if not isinstance(cls, type):\n        return False\n    return issubclass(cls, datetime)\n\ndef is_time_type(cls):\n    \"\"\"Return True if the class is a time type.\"\"\"\n    if not isinstance(cls, type):\n        return False\n    return issubclass(cls, time)\n\ndef is_datetime_with_tz(cls):\n    \"\"\"Return True if the class is a datetime with a timezone.\"\"\"\n    if not isinstance(cls, type):\n        return False\n    return issubclass(cls, datetime) and issubclass(cls, datetime.tzinfo)\n\ndef is_time_with_tz(cls):\n    \"\"\"Return True if the class is a time with a timezone.\"\"\"\n    if not isinstance(cls, type):\n        return False\n    return issubclass(cls, time) and issubclass(cls, time.tzinfo)\n\ndef is_datetime_with_tz_aware(cls):\n    \"\"\"Return True if the class is a datetime with a timezone aware.\"\"\"\n    if not isinstance(cls, type):\n        return False\n    return issubclass(cls, datetime) and issubclass(cls, datetime.tzinfo) and issubclass(cls, datetime.tzaware)\n\ndef is_time_with_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "\n\ndef totz(when, tz=None):\n    \"\"\"\n    Return a datetime with the same timezone as the provided datetime.\n    \"\"\"\n    if not when:\n        return when\n    return when.replace(tzinfo=tz)\n\ndef tz(when, tz=None):\n    \"\"\"\n    Return a datetime with the same timezone as the provided datetime.\n    \"\"\"\n    if not when:\n        return when\n    return when.replace(tzinfo=tz)\n\ndef tz_utc(when, tz=None):\n    \"\"\"\n    Return a datetime with the same timezone as the provided datetime.\n    \"\"\"\n    if not when:\n        return when\n    return when.replace(tzinfo=tzinfo.utc)\n\ndef tz_local(when, tz=None):\n    \"\"\"\n    Return a datetime with the same timezone as the provided datetime.\n    \"\"\"\n    if not when:\n        return when\n    return when.replace(tzinfo=tzinfo.local)\n\ndef tz_utc_local(when, tz=None):\n    \"\"\"\n    Return a datetime with the same timezone as the provided datetime.\n    \"\"\"\n    if not when:\n        return when\n    return when.replace(tzinfo=tzinfo.utc_local)\n\ndef tz_local_utc(when, tz=None",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef prevweekday(when, week_start=mon):\n    \"\"\"Return the previous weekday of the provided datetime.\"\"\"\n    if is_datetime(when):\n        return when.replace(weekday=weekday(when, week_start))\n    elif is_date(when):\n        return weekday(when, week_start)\n    elif is_time(when):\n        return weekday(when, mon)\n    return weekday(when, mon)\n\ndef weekday(when, week_start=mon):\n    \"\"\"Return the weekday of the provided datetime.\"\"\"\n    if is_datetime(when):\n        return when.replace(weekday=weekday(when, week_start))\n    elif is_date(when):\n        return weekday(when, week_start)\n    elif is_time(when):\n        return weekday(when, mon)\n    return weekday(when, mon)\n\ndef is_datetime(when):\n    \"\"\"Return True if the provided datetime is a datetime.\"\"\"\n    return isinstance(when, datetime)\n\ndef is_date(when):\n    \"\"\"Return True if the provided datetime is a date.\"\"\"\n    return isinstance(when, date)\n\ndef is_time(when):\n    \"\"\"Return True if the provided datetime is a time.\"\"\"\n    return isinstance(when, time)\n\ndef is_",
        "\n\ndef month(when, month, start=mon):\n    \"\"\"Return the date for the month of this week.\"\"\"\n    if isinstance(when, datetime):\n        when = when.date()\n\n    today = when.month()\n    delta = month - today\n    if month < start and today >= start:\n        delta += 7\n    elif month >= start and today < start:\n        delta -= 7\n    return when + timedelta(days=delta)\n\ndef year(when, year, start=year):\n    \"\"\"Return the date for the year of this week.\"\"\"\n    if isinstance(when, datetime):\n        when = when.date()\n\n    today = when.year()\n    delta = year - today\n    if year < start and today >= start:\n        delta += 7\n    elif year >= start and today < start:\n        delta -= 7\n    return when + timedelta(days=delta)\n\ndef weekday_of_year(when, year, weekday, start=mon):\n    \"\"\"Return the date for the day of this week for a given year.\"\"\"\n    if isinstance(when, datetime):\n        when = when.date()\n\n    today = when.year()\n    delta = weekday - today\n    if weekday < start and today >= start:\n        delta += 7\n    elif weekday >= start and today < start",
        "\n\ndef _GetNativeEolStyleForPlatform(platform=sys.platform):\n    '''\n    Internal function that determines EOL_STYLE_NATIVE constant with the proper value for the current platform.\n    '''\n    _NATIVE_EOL_STYLE_MAP = {\n        'win32' : EOL_STYLE_WINDOWS,\n        'linux2' : EOL_STYLE_UNIX,\n        'linux' : EOL_STYLE_UNIX,\n        'darwin' : EOL_STYLE_MAC,\n    }\n    result = _NATIVE_EOL_STYLE_MAP.get(platform)\n\n    if result is None:\n        from ._exceptions import UnknownPlatformError\n        raise UnknownPlatformError(platform)\n\n    return result\n\ndef _GetNativeEolStyleForPlatform(platform=sys.platform):\n    '''\n    Internal function that determines EOL_STYLE_NATIVE constant with the proper value for the current platform.\n    '''\n    _NATIVE_EOL_STYLE_MAP = {\n        'win32' : EOL_STYLE_WINDOWS,\n        'linux2' : EOL_STYLE_UNIX,\n        'linux' : EOL_STYLE_UNIX,\n        'darwin' : EOL_STYLE_MAC,\n    }\n    result = _NATIVE_EOL_STYLE_MAP.get(platform)\n\n   ",
        "\n\ndef GetEnvironmentVariable(name):\n    '''\n    Returns the value of an environment variable.\n\n    :param unicode name: The name of the environment variable.\n\n    :rtype unicode: The value of the environment variable.\n    '''\n    return os.environ.get(name)\n\ndef GetEnvironmentVariableAsBool(name):\n    '''\n    Returns the value of an environment variable as a boolean.\n\n    :param unicode name: The name of the environment variable.\n\n    :rtype bool: The value of the environment variable as a boolean.\n    '''\n    return bool(GetEnvironmentVariable(name))\n\ndef GetEnvironmentVariableAsInt(name):\n    '''\n    Returns the value of an environment variable as an integer.\n\n    :param unicode name: The name of the environment variable.\n\n    :rtype int: The value of the environment variable as an integer.\n    '''\n    return int(GetEnvironmentVariable(name))\n\ndef GetEnvironmentVariableAsString(name):\n    '''\n    Returns the value of an environment variable as a string.\n\n    :param unicode name: The name of the environment variable.\n\n    :rtype unicode: The value of the environment variable as a string.\n    '''\n    return GetEnvironmentVariable(name)\n\ndef GetEnvironmentVariableAsFloat(name):\n    '''",
        "\ndef GetAbsolutePath(path):\n    '''\n    Returns a version of a path that is absolute.\n\n    Given two paths path1 and path2:\n        GetAbsolutePath(path1) == GetAbsolutePath(path2) if and only if they represent the same file on the host OS.\n        Takes account of case, slashes and relative paths.\n\n    :param unicode path:\n        The original path.\n\n    :rtype: unicode\n    :returns:\n        The absolute path.\n    '''\n    path = os.path.normpath(path)\n    path = os.path.abspath(path)\n    path = os.path.normcase(path)\n\n    return path\n\ndef GetRelativePath(path):\n    '''\n    Returns a version of a path that is relative.\n\n    Given two paths path1 and path2:\n        GetRelativePath(path1) == GetRelativePath(path2) if and only if they represent the same file on the host OS.\n        Takes account of case, slashes and relative paths.\n\n    :param unicode path:\n        The original path.\n\n    :rtype: unicode\n    :returns:\n        The relative path.\n    '''\n    path = os.path.normpath(path)\n    path = os.path.abspath(path)\n    path",
        "\n\ndef NormalizePath(path):\n    '''\n    Normalizes the path to be a valid path\n\n    :param str path:\n        The path to normalize\n    '''\n    path = path.replace(SEPARATOR_UNIX, SEPARATOR_WINDOWS)\n    return path\n\ndef NormalizePath(path, strip=False):\n    '''\n    Normalizes the path to be a valid path\n\n    :param str path:\n        The path to normalize\n    :param bool strip:\n        If True, removes additional slashes from the end of the path.\n    '''\n    path = NormalizePath(path)\n    if strip:\n        path = path.rstrip(SEPARATOR_UNIX)\n    return path\n\ndef NormalizePath(path, strip=False):\n    '''\n    Normalizes the path to be a valid path\n\n    :param str path:\n        The path to normalize\n    :param bool strip:\n        If True, removes additional slashes from the end of the path.\n    '''\n    path = NormalizePath(path)\n    if strip:\n        path = path.rstrip(SEPARATOR_WINDOWS)\n    return path\n\ndef NormalizePath(path, strip=False):\n    '''\n    Normalizes the path to be a valid path\n\n    :param str path:\n        The path to normalize\n    :param bool strip",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef CopyFiles(file_mapping):\n    '''\n    Copies files into directories, according to a file mapping\n\n    :param list(tuple(unicode,unicode)) file_mapping:\n        A list of mappings between the directory in the target and the source.\n        For syntax, @see: ExtendedPathMask\n\n    :rtype: list(tuple(unicode,unicode))\n    :returns:\n        List of files copied. (source_filename, target_filename)\n\n    .. seealso:: FTP LIMITATIONS at this module's doc for performance issues information\n    '''\n    return CopyFilesX(file_mapping)\n\ndef CopyDirectory(source_dir, target_dir):\n    '''\n    Copies a directory into a target directory\n\n    :param unicode source_dir:\n        The directory to copy\n    :param unicode target_dir:\n        The directory to copy to\n    :returns:\n        The directory that was copied\n    '''\n    # Create target dir if necessary\n    target_dir = os.path.dirname(target_dir)\n    CreateDirectory(target_dir)\n\n    # Copy files\n    CopyDirectory(source_dir, target_dir)\n\n    return target_dir\n\ndef CopyDirectoryX(source_dir, target_dir):\n    '''\n    Copies a directory into a target",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\n    if binary:\n        # If we're appending to a binary file, we need to ensure that the file is always\n        # written in binary mode.\n        oss.flush()\n\n\ndef _AssertIsLocal(filename):\n    '''\n    Asserts that the given filename is a local file.\n\n    :param unicode filename:\n\n    :raises NotImplementedForRemotePathError:\n        If trying to modify a non-local path\n\n    :raises ValueError:\n        If trying to mix unicode `filename` without `encoding`, or `encoding` without\n        unicode `filename`\n    '''\n    if not os.path.isfile(filename):\n        raise NotImplementedForRemotePathError(filename)\n\n\ndef _HandleContentsEol(contents, eol_style):\n    '''\n    Replaces the EOL by the appropriate EOL depending on the eol_style value.\n\n    :param unicode contents:\n\n    :type eol_style: EOL_STYLE_XXX constant\n    :param eol_style:\n        Replaces the EOL by the appropriate EOL depending on the eol_style value.\n        Considers that all content is using only \"\\n\" as EOL.\n\n    :returns:\n        The contents with the EOL replaced by the appropriate EOL.\n    '''\n    if eol_style == EOL_STYLE_NATIVE:",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef OpenFile(filename, binary=False, encoding=None, newline=None):\n    '''\n    Opens a file.\n\n    :param unicode filename:\n\n    :param bool binary:\n        If True returns the file as is, ignore any EOL conversion.\n\n    :param unicode encoding:\n        File's encoding. If not None, contents obtained from file will be decoded using this\n        `encoding`.\n\n    :param None|''|'\\n'|'\\r'|'\\r\\n' newline:\n        Controls universal newlines.\n        See 'io.open' newline parameter documentation for more details.\n\n    :returns file:\n        The file object.\n\n    .. seealso:: FTP LIMITATIONS at this module's doc for performance issues information\n    '''\n    if newline is None:\n        newline = '\\n'\n\n    if binary:\n        return open(filename, 'rb', newline=newline)\n    else:\n        return open(filename, 'rb', newline=newline, encoding=encoding)\n\ndef GetFileContentsAsText(filename, binary=False, encoding=None, newline=None):\n    '''\n    Reads a file and returns its contents as a string. Works for both local and remote files.\n\n    :param unicode filename:\n\n    :param bool binary:\n        If True returns the",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef CreateDirectory(dirname, create_dir=True, encoding=None, binary=False):\n    '''\n    Create a directory with the given contents.\n\n    :param unicode dirname:\n        Directory name.\n\n    :param unicode contents:\n        The directory contents as a string.\n\n    :type eol_style: EOL_STYLE_XXX constant\n    :param eol_style:\n        Replaces the EOL by the appropriate EOL depending on the eol_style value.\n        Considers that all content is using only \"\\n\" as EOL.\n\n    :param bool create_dir:\n        If True, also creates directories needed in dirname's path\n\n    :param unicode encoding:\n        Target file's content encoding. Defaults to sys.getfilesystemencoding()\n        Ignored if `binary` = True\n\n    :param bool binary:\n        If True, file is created in binary mode. In this case, `contents` must be `bytes` and not\n        `unicode`\n\n    :return unicode:\n        Returns the name of the directory created.\n\n    :raises NotImplementedProtocol:\n        If file protocol is not local or FTP\n\n    :raises ValueError:\n        If trying to mix unicode `contents` without `encoding`, or `encoding` without\n        unicode `contents`\n\n    .. seealso:: FTP LIMITATIONS at",
        "\n\ndef ReplaceInFileWithNew(filename, old, new, encoding=None):\n    '''\n    Replaces all occurrences of \"old\" by \"new\" in the given file.\n\n    :param unicode filename:\n        The name of the file.\n\n    :param unicode old:\n        The string to search for.\n\n    :param unicode new:\n        Replacement string.\n\n    :return unicode:\n        The new contents of the file.\n    '''\n    contents = GetFileContents(filename, encoding=encoding)\n    contents = contents.replace(old, new)\n    CreateFile(filename, contents, encoding=encoding)\n    return contents\n\ndef ReplaceInFileWithNewAndReplace(filename, old, new, encoding=None):\n    '''\n    Replaces all occurrences of \"old\" by \"new\" in the given file.\n\n    :param unicode filename:\n        The name of the file.\n\n    :param unicode old:\n        The string to search for.\n\n    :param unicode new:\n        Replacement string.\n\n    :return unicode:\n        The new contents of the file.\n    '''\n    contents = GetFileContents(filename, encoding=encoding)\n    contents = contents.replace(old, new)\n    CreateFile(filename, contents, encoding=encoding)\n    return",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        " Exception(\"Unable to delete directory: %s\" % directory)\n        raise\n\n\ndef DeleteFile(filename, skip_on_error=False):\n    '''\n    Deletes a file.\n\n    :param unicode filename:\n\n    :param bool skip_on_error:\n        If True, ignore any errors when trying to delete file (for example, file not found)\n\n    :raises NotImplementedForRemotePathError:\n        If trying to delete a remote file.\n    '''\n    _AssertIsLocal(filename)\n\n    import shutil\n    def OnError(fn, path, excinfo):\n        '''\n        Remove the read-only flag and try to remove again.\n        On Windows, rmtree fails when trying to remove a read-only file. This fix it!\n        Another case: Read-only files return True in os.access test. It seems that read-only\n        files has it own flag (looking at the property windows on Explorer).\n        '''\n        if IsLink(path):\n            return\n\n        if fn is os.remove and os.access(path, os.W_OK):\n            raise\n\n        # Make the file WRITEABLE and executes the original delete function (osfunc)\n        import stat\n        os.chmod(path, stat.S_IWRITE)\n        fn(path)",
        "\n\ndef GetMappedNetworkDrive(local_drive, remote_path):\n    '''\n    On Windows, returns the mapped network drive\n\n    :param local_drive: the local drive\n    :param remote_path: the remote path\n    :return: the mapped network drive\n    '''\n    if sys.platform != 'win32':\n        raise NotImplementedError\n    netuse = _CallWindowsNetCommand(['use', local_drive])\n    match = re.match(\"(\\w*)\\s+(\\w:)\\s+(.+)\", netuse.rstrip())\n    if match:\n        return match.group(2)\n    return None\n\ndef GetMappedNetworkDriveByRemotePath(remote_path):\n    '''\n    On Windows, returns the mapped network drive\n\n    :param remote_path: the remote path\n    :return: the mapped network drive\n    '''\n    if sys.platform != 'win32':\n        raise NotImplementedError\n    netuse = _CallWindowsNetCommand(['use', remote_path])\n    match = re.match(\"(\\w*)\\s+(\\w:)\\s+(.+)\", netuse.rstrip())\n    if match:\n        return match.group(2)\n    return None\n\ndef GetMappedNetworkDriveByLocalDrive(local_drive):\n    '''\n    On Windows, returns the",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetOperationCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.",
        "\n\ndef IsLink(path):\n    '''\n    Check if `path` is a symbolic link.\n\n    :param unicode path:\n        Path to a symbolic link\n\n    :returns bool:\n        True if `path` is a symbolic link\n    '''\n    _AssertIsLocal(path)\n\n    if sys.platform != 'win32':\n        return os.path.islink(path)  # @UndefinedVariable\n\n    if not os.path.islink(path):\n        from ._exceptions import FileNotFoundError\n        raise FileNotFoundError(path)\n\n    import jaraco.windows.filesystem\n    return jaraco.windows.filesystem.islink(path)\n\ndef IsDirectory(path):\n    '''\n    Check if `path` is a directory.\n\n    :param unicode path:\n        Path to a directory\n\n    :returns bool:\n        True if `path` is a directory\n    '''\n    _AssertIsLocal(path)\n\n    if sys.platform != 'win32':\n        return os.path.isdir(path)  # @UndefinedVariable\n\n    if not os.path.isdir(path):\n        from ._exceptions import FileNotFoundError\n        raise FileNotFoundError(path)\n\n    import jaraco.windows.filesystem\n    return jaraco.windows.filesystem.isdir(path)",
        "\n\ndef _UrlIsLocal(url):\n    '''\n    Checks if a given url is local, raise an exception if not.\n\n    This is used in filesystem functions that do not support remote operations yet.\n\n    :param urlparse url:\n\n    :raises NotImplementedForRemotePathError:\n        If the given url is not local\n    '''\n    from six.moves.urllib.parse import urlparse\n    if not urlparse(url).scheme == 'file':\n        from ._exceptions import NotImplementedForRemotePathError\n        raise NotImplementedForRemotePathError\n\ndef _GetLocalPath(url):\n    '''\n    Returns the local path of a given url, or None if the url is not local.\n\n    This is used in filesystem functions that do not support remote operations yet.\n\n    :param urlparse url:\n\n    :returns unicode:\n        The local path of the given url\n    '''\n    from six.moves.urllib.parse import urlparse\n    if not urlparse(url).scheme == 'file':\n        from ._exceptions import NotImplementedForRemotePathError\n        raise NotImplementedForRemotePathError\n    return urlparse(url).path\n\ndef _GetRemotePath(url):\n    '''\n    Returns the remote path of a given url, or None if the url is not local.\n\n    This is used in filesystem functions",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n\ndef GetFilename(filename):\n    '''\n    Returns the filename without extension.\n\n    :param str filename: The filename to get.\n    :return str: The filename without extension.\n    '''\n    return filename.split('.')[-1]\n\ndef GetFilenameWithoutExtension(filename):\n    '''\n    Returns the filename without extension.\n\n    :param str filename: The filename to get.\n    :return str: The filename without extension.\n    '''\n    return filename.split('.')[-1]\n\ndef GetFilenameWithoutExtensionAndExtension(filename):\n    '''\n    Returns the filename without extension and extension.\n\n    :param str filename: The filename to get.\n    :return str: The filename without extension and extension.\n    '''\n    return filename.split('.')[-1] + '.' + filename.split('.')[-1]\n\ndef GetFilenameWithoutExtensionAndExtensionAndExtension(filename):\n    '''\n    Returns the filename without extension and extension and extension.\n\n    :param str filename: The filename to get.\n    :return str: The filename without extension and extension and extension.\n    '''\n    return filename.split('.')[-1] + '.' + filename.split('.')[-1] + '.' + filename.split('.')[-1]\n\ndef GetFilenameWithoutExtension",
        "\n\ndef StandardizePath(path):\n    '''\n    Standardizes a path to be used in a file system path.\n\n    :param str path: the path to be standardized.\n    :return str: the standardized path.\n    '''\n    return path.replace('\\\\', '/')\n\ndef MatchMasks(path, in_filters):\n    '''\n    Checks if a path matches a given pattern.\n\n    :param str path: the path to be checked.\n    :param list(str): a list with patterns to match (default = all). E.g.: ['*.py']\n    :return bool: if the path matches the pattern, otherwise, False.\n    '''\n    for pattern in in_filters:\n        if pattern in path:\n            return True\n    return False\n",
        "\n\ndef GetUser(path):\n    '''\n    os.path.getuser wrapper, necessary because it cannot handle unicode strings properly.\n\n    This is not necessary in Python 3.\n\n    :param path:\n        .. seealso:: os.path.getuser\n    '''\n    if six.PY2:\n        encoding = sys.getfilesystemencoding()\n        path = path.encode(encoding)\n    result = os.path.getuser(path)\n    if six.PY2:\n        result = result.decode(encoding)\n    return result\n\ndef GetGroup(path):\n    '''\n    os.path.getgroup wrapper, necessary because it cannot handle unicode strings properly.\n\n    This is not necessary in Python 3.\n\n    :param path:\n        .. seealso:: os.path.getgroup\n    '''\n    if six.PY2:\n        encoding = sys.getfilesystemencoding()\n        path = path.encode(encoding)\n    result = os.path.getgroup(path)\n    if six.PY2:\n        result = result.decode(encoding)\n    return result\n\ndef GetWorkingDirectory(path):\n    '''\n    os.path.getcwd wrapper, necessary because it cannot handle unicode strings properly.\n\n    This is not necessary in Python 3.\n\n    :param",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "<?php\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef ensure_specifier_exists_with_port(db_spec):\n    \"\"\"Make sure a DB specifier exists, creating it if necessary, and\n    using a port number.\"\"\"\n    local_match = LOCAL_RE.match(db_spec)\n    remote_match = REMOTE_RE.match(db_spec)\n    plain_match = PLAIN_RE.match(db_spec)\n    if local_match:\n        hostname, portnum, database = map(remote_match.groupdict().get,\n            ('hostname', 'portnum', 'database'))\n        server = shortcuts.get_server(\n            server_url=('http://%s:%s' % (hostname, portnum)))\n        if database not in server:\n            server.create(database)\n        return True\n    elif remote_match:\n        hostname, portnum, database = map(remote_match.groupdict().get,\n            ('hostname', 'portnum', 'database'))\n        server = shortcuts.get_server(\n            server_url=('http://%s:%s' % (hostname, portnum)))\n        if database not in server:\n            server.create(database)\n        return True\n    elif plain_match:\n        db_name = plain_match.groupdict().get('database')\n        server = shortcuts.get",
        "(value1, value2)\n\n\ndef coerce_list(value1, value2, default=None):\n    \"\"\"Exclude NoSet objec\n\n    .. code-block::\n\n        >>> coerce_list(NoSet, 'value')\n        ['value']\n\n    \"\"\"\n    if value1 is not NoSet:\n        return value1\n    elif value2 is not NoSet:\n        return value2\n    else:\n        return default\n\n\ndef coerce_dict(value1, value2, default=None):\n    \"\"\"Exclude NoSet objec\n\n    .. code-block::\n\n        >>> coerce_dict(NoSet, 'value')\n        {'value': 'value'}\n\n    \"\"\"\n    if value1 is not NoSet:\n        return value1\n    elif value2 is not NoSet:\n        return value2\n    else:\n        return default\n\n\ndef coerce_dict_list(value1, value2, default=None):\n    \"\"\"Exclude NoSet objec\n\n    .. code-block::\n\n        >>> coerce_dict_list(NoSet, 'value')\n        [{'value': 'value'}]\n\n    \"\"\"\n    if value1 is not NoSet:\n        return value1\n    elif value2 is not NoSet:\n        return value2\n   ",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n    if not isinstance(string, str):\n        raise TypeError('{} should be a string'.format(part))\n\n\ndef parse_string(string):\n    \"\"\"Parse a string into a list of strings\n\n    :param string: str\n    :returns: list of strings\n    \"\"\"\n    return [x.strip() for x in string.split(',')]\n\n\ndef parse_list(string):\n    \"\"\"Parse a string into a list of strings\n\n    :param string: str\n    :returns: list of strings\n    \"\"\"\n    return [x.strip() for x in string.split(',')]\n\n\ndef parse_dict(string):\n    \"\"\"Parse a string into a dict of strings\n\n    :param string: str\n    :returns: dict of strings\n    \"\"\"\n    return {x.strip(): y.strip() for x, y in string.items()}\n\n\ndef parse_list_of_strings(string):\n    \"\"\"Parse a string into a list of strings\n\n    :param string: str\n    :returns: list of strings\n    \"\"\"\n    return [x.strip() for x in string.split(',')]\n\n\ndef parse_dict_of_strings(string):\n    \"\"\"Parse a string into a dict of strings\n\n    :param string: str\n   ",
        "\n                if 'default' not in command:\n                    command['default'] = False\n            if command['keys'][0].startswith('-'):\n                if 'default' not in command:\n                    command['default'] = False\n                if 'default' not in command['default']:\n                    command['default'] = False\n            if command['keys'][0].startswith('-'):\n                if 'default' not in command:\n                    command['default'] = False\n                if 'default' not in command['default']:\n                    command['default'] = False\n            if command['keys'][0].startswith('-'):\n                if 'default' not in command:\n                    command['default'] = False\n                if 'default' not in command['default']:\n                    command['default'] = False\n            if command['keys'][0].startswith('-'):\n                if 'default' not in command:\n                    command['default'] = False\n                if 'default' not in command['default']:\n                    command['default'] = False\n            if command['keys'][0].startswith('-'):\n                if 'default' not in command:\n                    command['default'] = False\n                if 'default' not in command['default']:\n                    command['default'] = False\n            if command['keys'][0].starts",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n\ndef main():\n    \"\"\" main function \"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"\"\"\n        A simple command line tool to generate a list of all the\n        available commands.\n        \"\"\")\n    parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"%(prog)s \" + __version__)\n    parser.add_argument(\"-h\", \"--help\", action=\"help\", help=\"show this help message\")\n    parser.add_argument(\"-c\", \"--config\", action=\"append\", default=[],\n                        help=\"add a config file to the parser\")\n    parser.add_argument(\"-p\", \"--path\", action=\"append\", default=[],\n                        help=\"add a path to the parser\")\n    parser.add_argument(\"-r\", \"--recursive\", action=\"store_true\",\n                        help=\"recursive mode\")\n    parser.add_argument(\"-f\", \"--force\", action=\"store_true\",\n                        help=\"force mode\")\n    parser.add_argument(\"-d\", \"--debug\", action=\"store_true\",\n                        help=\"debug mode\")\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\",\n                        help=\"verbose mode\")\n    parser.add_argument(\"-q\", \"--quiet\", action=\"store_true\",\n                        help",
        "\n\ndef get_template_name(self):\n        \"\"\" get template name from args \"\"\"\n        if self.template_name is None:\n            self.template_name = self.args.template_name\n        return self.template_name\n\ndef get_template_path(self):\n        \"\"\" get template path from args \"\"\"\n        if self.template_path is None:\n            self.template_path = self.args.template_path\n        return self.template_path\n\ndef get_template_path_from_args(self):\n        \"\"\" get template path from args \"\"\"\n        if self.template_path is None:\n            self.template_path = self.args.template_path\n        return self.template_path\n\ndef get_template_path_from_env(self):\n        \"\"\" get template path from env \"\"\"\n        if self.template_path is None:\n            self.template_path = os.environ.get('TEMPLATE_PATH', None)\n        return self.template_path\n\ndef get_template_path_from_env_from_args(self):\n        \"\"\" get template path from env \"\"\"\n        if self.template_path is None:\n            self.template_path = os.environ.get('TEMPLATE_PATH', None)\n        return self.template_path\n\ndef",
        "\n\ndef get_user_info(user_id):\n    '''\n    Return the user's information from the Shirts.io API.\n    '''\n\n    print 'Retrieve user info from Shirts.io API.'\n\n    user_info = {\n        'user_id': user_id,\n    }\n\n    response = requests.get('https://www.shirts.io/api/v1/users/' + user_id + '/info')\n    user_info = json.loads(response.text)\n\n    return user_info\n\ndef get_user_info_by_id(user_id):\n    '''\n    Return the user's information from the Shirts.io API.\n    '''\n\n    print 'Retrieve user info from Shirts.io API.'\n\n    user_info = {\n        'user_id': user_id,\n    }\n\n    response = requests.get('https://www.shirts.io/api/v1/users/' + user_id + '/info')\n    user_info = json.loads(response.text)\n\n    return user_info\n\ndef get_user_info_by_name(user_name):\n    '''\n    Return the user's information from the Shirts.io API.\n    '''",
        ".number)\n\ndef _AddPropertiesForMessageTypes(descriptor, cls):\n  \"\"\"Adds properties for all fields in this protocol message type.\"\"\"\n  for field in descriptor.fields:\n    _AddPropertiesForExtensions(field, cls)\n\ndef _AddPropertiesForEnums(descriptor, cls):\n  \"\"\"Adds properties for all fields in this protocol message type.\"\"\"\n  for enum_name, enum_value in descriptor.enum_values.items():\n    constant_name = enum_name.upper() + \"_FIELD_NUMBER\"\n    setattr(cls, constant_name, enum_value.number)\n\ndef _AddPropertiesForEnumValues(descriptor, cls):\n  \"\"\"Adds properties for all fields in this protocol message type.\"\"\"\n  for enum_value in descriptor.enum_values.values():\n    _AddPropertiesForExtensions(enum_value, cls)\n\ndef _AddPropertiesForExtensions(descriptor, cls):\n  \"\"\"Adds properties for all fields in this protocol message type.\"\"\"\n  for extension_name, extension_field in descriptor.extensions_by_name.items():\n    _AddPropertiesForExtensions(extension_field, cls)\n\ndef _AddPropertiesForMessageTypes(descriptor, cls):\n  \"\"\"Adds properties for all fields in this protocol message type.\"\"\"\n  for field in descriptor.fields:\n    _AddPropertiesForExtensions(field,",
        "\n\ndef _InternalUnpackAnyList(msg):\n  \"\"\"Unpacks AnyList message and returns the unpacked message.\n\n  This internal method is differnt from public Any Unpack method which takes\n  the target message as argument. _InternalUnpackAnyList method does not have\n  target message type and need to find the message type in descriptor pool.\n\n  Args:\n    msg: An AnyList message to be unpacked.\n\n  Returns:\n    The unpacked message.\n  \"\"\"\n  type_url = msg.type_url\n  db = symbol_database.Default()\n\n  if not type_url:\n    return None\n\n  # TODO(haberman): For now we just strip the hostname.  Better logic will be\n  # required.\n  type_name = type_url.split(\"/\")[-1]\n  descriptor = db.pool.FindMessageTypeByName(type_name)\n\n  if descriptor is None:\n    return None\n\n  message_class = db.GetPrototype(descriptor)\n  message = message_class()\n\n  message.ParseFromString(msg.value)\n  return message\n\ndef _InternalUnpackAnyMap(msg):\n  \"\"\"Unpacks AnyMap message and returns the unpacked message.\n\n  This internal method is differnt from public Any Unpack method which takes\n  the target message as argument"
    ],
    "references": [
        [
            "Stops monitoring the predefined directory."
        ],
        [
            "Called when a file in the monitored directory has been moved.\n\n        Breaks move down into a delete and a create (which it is sometimes detected as!).\n        :param event: the file system event"
        ],
        [
            "Tears down all temp files and directories."
        ],
        [
            "Test whether a file target is not exists or it exists but allow\n        overwrite."
        ],
        [
            "Copy this file to other place."
        ],
        [
            "Clients a Docker client.\n\n    Will raise a `ConnectionError` if the Docker daemon is not accessible.\n    :return: the Docker client"
        ],
        [
            "Decorate methods when repository path is required."
        ],
        [
            "clean repository given before and after states"
        ],
        [
            "Get repository descriptive stats\n\n        :Returns:\n            #. numberOfDirectories (integer): Number of diretories in repository\n            #. numberOfFiles (integer): Number of files in repository"
        ],
        [
            "Reset repository instance."
        ],
        [
            "Load repository from a directory path and update the current instance.\n        First, new repository still will be loaded. If failed, then old\n        style repository load will be tried.\n\n        :Parameters:\n            #. path (string): The path of the directory from where to load\n               the repository from. If '.' or an empty string is passed,\n               the current working directory will be used.\n            #. verbose (boolean): Whether to be verbose about abnormalities\n            #. ntrials (int): After aquiring all locks, ntrials is the maximum\n               number of trials allowed before failing.\n               In rare cases, when multiple processes\n               are accessing the same repository components, different processes\n               can alter repository components between successive lock releases\n               of some other process. Bigger number of trials lowers the\n               likelyhood of failure due to multiple processes same time\n               alteration.\n\n        :Returns:\n             #. repository (pyrep.Repository): returns self repository with loaded data."
        ],
        [
            "Remove all repository from path along with all repository tracked files.\n\n        :Parameters:\n            #. path (None, string): The path the repository to remove.\n            #. removeEmptyDirs (boolean): Whether to remove remaining empty\n               directories."
        ],
        [
            "Get whether creating a file or a directory from the basenane of the given\n        path is allowed\n\n        :Parameters:\n            #. path (str): The absolute or relative path or simply the file\n               or directory name.\n\n        :Returns:\n            #. allowed (bool): Whether name is allowed.\n            #. message (None, str): Reason for the name to be forbidden."
        ],
        [
            "Given a path, return relative path to diretory\n\n        :Parameters:\n            #. path (str): Path as a string\n            #. split (boolean): Whether to split path to its components\n\n        :Returns:\n            #. relativePath (str, list): Relative path as a string or as a list\n               of components if split is True"
        ],
        [
            "Get a list representation of repository state along with useful\n        information. List state is ordered relativeley to directories level\n\n        :Parameters:\n            #. relaPath (None, str): relative directory path from where to\n               start. If None all repository representation is returned.\n\n        :Returns:\n            #. state (list): List representation of the repository.\n               List items are all dictionaries. Every dictionary has a single\n               key which is the file or the directory name and the value is a\n               dictionary of information including:\n\n                   * 'type': the type of the tracked whether it's file, dir, or objectdir\n                   * 'exists': whether file or directory actually exists on disk\n                   * 'pyrepfileinfo': In case of a file or an objectdir whether .%s_pyrepfileinfo exists\n                   * 'pyrepdirinfo': In case of a directory whether .pyrepdirinfo exists"
        ],
        [
            "Get file information dict from the repository given its relative path.\n\n        :Parameters:\n            #. relativePath (string): The relative to the repository path of\n               the file.\n\n        :Returns:\n            #. info (None, dictionary): The file information dictionary.\n               If None, it means an error has occurred.\n            #. errorMessage (string): The error message if any error occurred."
        ],
        [
            "Check whether a given relative path is a repository file path\n\n        :Parameters:\n            #. relativePath (string): File relative path\n\n        :Returns:\n            #. isRepoFile (boolean): Whether file is a repository file.\n            #. isFileOnDisk (boolean): Whether file is found on disk.\n            #. isFileInfoOnDisk (boolean): Whether file info is found on disk.\n            #. isFileClassOnDisk (boolean): Whether file class is found on disk."
        ],
        [
            "Create a tar file package of all the repository files and directories.\n        Only files and directories that are tracked in the repository\n        are stored in the package tar file.\n\n        **N.B. On some systems packaging requires root permissions.**\n\n        :Parameters:\n            #. path (None, string): The real absolute path where to create the\n               package. If None, it will be created in the same directory as\n               the repository. If '.' or an empty string is passed, the current\n               working directory will be used.\n            #. name (None, string): The name to give to the package file\n               If None, the package directory name will be used with the\n               appropriate extension added.\n            #. mode (None, string): The writing mode of the tarfile.\n               If None, automatically the best compression mode will be chose.\n               Available modes are ('w', 'w:', 'w:gz', 'w:bz2')"
        ],
        [
            "Renames an item in this collection as a transaction.\n\n        Will override if new key name already exists.\n        :param key: the current name of the item\n        :param new_key: the new name that the item should have"
        ],
        [
            "Use default hash method to return hash value of a piece of string\n    default setting use 'utf-8' encoding."
        ],
        [
            "Return md5 hash value of a piece of a file\n\n    Estimate processing time on:\n\n    :param abspath: the absolute path to the file\n    :param nbytes: only has first N bytes of the file. if 0 or None,\n      hash all file\n\n    CPU = i7-4600U 2.10GHz - 2.70GHz, RAM = 8.00 GB\n    1 second can process 0.25GB data\n\n    - 0.59G - 2.43 sec\n    - 1.3G - 5.68 sec\n    - 1.9G - 7.72 sec\n    - 2.5G - 10.32 sec\n    - 3.9G - 16.0 sec"
        ],
        [
            "Return sha256 hash value of a piece of a file\n\n    Estimate processing time on:\n\n    :param abspath: the absolute path to the file\n    :param nbytes: only has first N bytes of the file. if 0 or None,\n      hash all file"
        ],
        [
            "Return sha512 hash value of a piece of a file\n\n    Estimate processing time on:\n\n    :param abspath: the absolute path to the file\n    :param nbytes: only has first N bytes of the file. if 0 or None,\n      hash all file"
        ],
        [
            "A command line auto complete similar behavior. Find all item with same\n        prefix of this one.\n\n        :param case_sensitive: toggle if it is case sensitive.\n        :return: list of :class:`pathlib_mate.pathlib2.Path`."
        ],
        [
            "Print ``top_n`` big dir in this dir."
        ],
        [
            "Print ``top_n`` big file in this dir."
        ],
        [
            "Print ``top_n`` big dir and ``top_n`` big file in each dir."
        ],
        [
            "Create a new folder having exactly same structure with this directory.\n        However, all files are just empty file with same file name.\n\n        :param dst: destination directory. The directory can't exists before\n        you execute this.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u521b\u5efa\u4e00\u4e2a\u76ee\u5f55\u7684\u955c\u50cf\u62f7\u8d1d, \u4e0e\u62f7\u8d1d\u64cd\u4f5c\u4e0d\u540c\u7684\u662f, \u6587\u4ef6\u7684\u526f\u672c\u53ea\u662f\u5728\u6587\u4ef6\u540d\u4e0a\n        \u4e0e\u539f\u4ef6\u4e00\u81f4, \u4f46\u662f\u662f\u7a7a\u6587\u4ef6, \u5b8c\u5168\u6ca1\u6709\u5185\u5bb9, \u6587\u4ef6\u5927\u5c0f\u4e3a0\u3002"
        ],
        [
            "Execute every ``.py`` file as main script.\n\n        :param py_exe: str, python command or python executable path.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u5c06\u76ee\u5f55\u4e0b\u7684\u6240\u6709Python\u6587\u4ef6\u4f5c\u4e3a\u4e3b\u811a\u672c\u7528\u5f53\u524d\u89e3\u91ca\u5668\u8fd0\u884c\u3002"
        ],
        [
            "Trail white space at end of each line for every ``.py`` file.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u5c06\u76ee\u5f55\u4e0b\u7684\u6240\u6709\u88ab\u9009\u62e9\u7684\u6587\u4ef6\u4e2d\u884c\u672b\u7684\u7a7a\u683c\u5220\u9664\u3002"
        ],
        [
            "Auto convert your python code in a directory to pep8 styled code.\n\n        :param kwargs: arguments for ``autopep8.fix_code`` method.\n\n        **\u4e2d\u6587\u6587\u6863**\n\n        \u5c06\u76ee\u5f55\u4e0b\u7684\u6240\u6709Python\u6587\u4ef6\u7528pep8\u98ce\u683c\u683c\u5f0f\u5316\u3002\u589e\u52a0\u5176\u53ef\u8bfb\u6027\u548c\u89c4\u8303\u6027\u3002"
        ],
        [
            "File size in bytes."
        ],
        [
            "Get most recent modify time in timestamp."
        ],
        [
            "Get most recent access time in timestamp."
        ],
        [
            "Get most recent create time in timestamp."
        ],
        [
            "Lists options that have not been used to format other values in \n        their sections. \n        \n        Good for finding out if the user has misspelled any of the options."
        ],
        [
            "List names of options and positional arguments."
        ],
        [
            "Add an Option object to the user interface."
        ],
        [
            "Append a positional argument to the user interface.\n\n        Optional positional arguments must be added after the required ones. \n        The user interface can have at most one recurring positional argument, \n        and if present, that argument must be the last one."
        ],
        [
            "Read program documentation from a DocParser compatible file.\n\n        docsfiles is a list of paths to potential docsfiles: parse if present.\n        A string is taken as a list of one item."
        ],
        [
            "Return user friendly help on program options."
        ],
        [
            "Return user friendly help on positional arguments in the program."
        ],
        [
            "Return user friendly help on positional arguments.        \n\n        indent is the number of spaces preceeding the text on each line. \n        \n        The indent of the documentation is dependent on the length of the \n        longest label that is shorter than maxindent. A label longer than \n        maxindent will be printed on its own line.\n        \n        width is maximum allowed page width, use self.width if 0."
        ],
        [
            "Return a summary of program options, their values and origins.\n        \n        width is maximum allowed page width, use self.width if 0."
        ],
        [
            "Parse text blocks from a file."
        ],
        [
            "Pop, parse and return the first self.nargs items from args.\n\n        if self.nargs > 1 a list of parsed values will be returned.\n        \n        Raise BadNumberOfArguments or BadArgument on errors.\n         \n        NOTE: argv may be modified in place by this method."
        ],
        [
            "Parse arguments found in settings files.\n        \n        Use the values in self.true for True in settings files, or those in \n        self.false for False, case insensitive."
        ],
        [
            "Return the separator that preceding format i, or '' for i == 0."
        ],
        [
            "Return a URL to redirect the user to for OAuth authentication."
        ],
        [
            "Exchange the authorization code for an access token."
        ],
        [
            "Wraps Lock.acquire"
        ],
        [
            "Wraps Lock.release"
        ],
        [
            "Handle a dict that might contain a wrapped state for a custom type."
        ],
        [
            "Wrap the marshalled state in a dictionary.\n\n        The returned dictionary has two keys, corresponding to the ``type_key`` and ``state_key``\n        options. The former holds the type name and the latter holds the marshalled state.\n\n        :param typename: registered name of the custom type\n        :param state: the marshalled state of the object\n        :return: an object serializable by the serializer"
        ],
        [
            "Enable HTTP access to a dataset.\n\n    This only works on datasets in some systems. For example, datasets stored\n    in AWS S3 object storage and Microsoft Azure Storage can be published as\n    datasets accessible over HTTP. A published dataset is world readable."
        ],
        [
            "Update the descriptive metadata interactively.\n\n    Uses values entered by the user. Note that the function keeps recursing\n    whenever a value is another ``CommentedMap`` or a ``list``. The\n    function works as passing dictionaries and lists into a function edits\n    the values in place."
        ],
        [
            "Create a proto dataset."
        ],
        [
            "Interactive prompting to populate the readme."
        ],
        [
            "Default editor updating of readme content."
        ],
        [
            "Show the descriptive metadata in the readme."
        ],
        [
            "Use YAML from a file or stdin to populate the readme.\n\n    To stream content from stdin use \"-\", e.g.\n\n    echo \"desc: my data\" | dtool readme write <DS_URI> -"
        ],
        [
            "Add a file to the proto dataset."
        ],
        [
            "Add metadata to a file in the proto dataset."
        ],
        [
            "Convert a proto dataset into a dataset.\n\n    This step is carried out after all files have been added to the dataset.\n    Freezing a dataset finalizes it with a stamp marking it as frozen."
        ],
        [
            "Copy a dataset to a different location."
        ],
        [
            "Compress anything to bytes or string.\n\n    :params obj: \n    :params level: \n    :params return_type: if bytes, then return bytes; if str, then return\n      base64.b64encode bytes in utf-8 string."
        ],
        [
            "attempt to deduce if a pre 100 year was lost\n         due to padded zeros being taken off"
        ],
        [
            "Change unicode output into bytestrings in Python 2\n\n    tzname() API changed in Python 3. It used to return bytes, but was changed\n    to unicode strings"
        ],
        [
            "The CPython version of ``fromutc`` checks that the input is a ``datetime``\n    object and that ``self`` is attached as its ``tzinfo``."
        ],
        [
            "Given a datetime in UTC, return local time"
        ],
        [
            "Strip comments from line string."
        ],
        [
            "Strip comments from json string.\n\n    :param string: A string containing json with comments started by comment_symbols.\n    :param comment_symbols: Iterable of symbols that start a line comment (default # or //).\n    :return: The string with the comments removed."
        ],
        [
            "dayofweek == 0 means Sunday, whichweek 5 means last instance"
        ],
        [
            "Convert a registry key's values to a dictionary."
        ],
        [
            "Parse strings as returned from the Windows registry into the time zone\n        name as defined in the registry.\n\n        >>> from dateutil.tzwin import tzres\n        >>> tzr = tzres()\n        >>> print(tzr.name_from_string('@tzres.dll,-251'))\n        'Dateline Daylight Time'\n        >>> print(tzr.name_from_string('Eastern Standard Time'))\n        'Eastern Standard Time'\n\n        :param tzname_str:\n            A timezone name string as returned from a Windows registry key.\n\n        :return:\n            Returns the localized timezone string from tzres.dll if the string\n            is of the form `@tzres.dll,-offset`, else returns the input string."
        ],
        [
            "This retrieves a time zone from the local zoneinfo tarball that is packaged\n    with dateutil.\n\n    :param name:\n        An IANA-style time zone name, as found in the zoneinfo file.\n\n    :return:\n        Returns a :class:`dateutil.tz.tzfile` time zone object.\n\n    .. warning::\n        It is generally inadvisable to use this function, and it is only\n        provided for API compatibility with earlier versions. This is *not*\n        equivalent to ``dateutil.tz.gettz()``, which selects an appropriate\n        time zone based on the inputs, favoring system zoneinfo. This is ONLY\n        for accessing the dateutil-specific zoneinfo (which may be out of\n        date compared to the system zoneinfo).\n\n    .. deprecated:: 2.6\n        If you need to use a specific zoneinfofile over the system zoneinfo,\n        instantiate a :class:`dateutil.zoneinfo.ZoneInfoFile` object and call\n        :func:`dateutil.zoneinfo.ZoneInfoFile.get(name)` instead.\n\n        Use :func:`get_zonefile_instance` to retrieve an instance of the\n        dateutil-provided zoneinfo."
        ],
        [
            "Get the zonefile metadata\n\n    See `zonefile_metadata`_\n\n    :returns:\n        A dictionary with the database metadata\n\n    .. deprecated:: 2.6\n        See deprecation warning in :func:`zoneinfo.gettz`. To get metadata,\n        query the attribute ``zoneinfo.ZoneInfoFile.metadata``."
        ],
        [
            "Get the configuration for the given JID based on XMPP_HTTP_UPLOAD_ACCESS.\n\n    If the JID does not match any rule, ``False`` is returned."
        ],
        [
            "Given a datetime and a time zone, determine whether or not a given datetime\n    would fall in a gap.\n\n    :param dt:\n        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``\n        is provided.)\n\n    :param tz:\n        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If\n        ``None`` or not provided, the datetime's own time zone will be used.\n\n    :return:\n        Returns a boolean value whether or not the \"wall time\" exists in ``tz``."
        ],
        [
            "Set the time zone data of this object from a _tzfile object"
        ],
        [
            "Return a version of this object represented entirely using integer\n        values for the relative attributes.\n\n        >>> relativedelta(days=1.5, hours=2).normalized()\n        relativedelta(days=1, hours=14)\n\n        :return:\n            Returns a :class:`dateutil.relativedelta.relativedelta` object."
        ],
        [
            "Create a new HMAC hash.\n\n    :param secret: The secret used when hashing data.\n    :type secret: bytes\n    :param data: The data to hash.\n    :type data: bytes\n    :param alg: The algorithm to use when hashing `data`.\n    :type alg: str\n    :return: New HMAC hash.\n    :rtype: bytes"
        ],
        [
            "Decodes the given token's header and payload and validates the signature.\n\n    :param secret: The secret used to decode the token. Must match the\n        secret used when creating the token.\n    :type secret: Union[str, bytes]\n    :param token: The token to decode.\n    :type token: Union[str, bytes]\n    :param alg: The algorithm used to decode the token. Must match the\n        algorithm used when creating the token.\n    :type alg: str\n    :return: The decoded header and payload.\n    :rtype: Tuple[dict, dict]"
        ],
        [
            "Compares the given signatures.\n\n    :param expected: The expected signature.\n    :type expected: Union[str, bytes]\n    :param actual: The actual signature.\n    :type actual: Union[str, bytes]\n    :return: Do the signatures match?\n    :rtype: bool"
        ],
        [
            "Compares the given tokens.\n\n    :param expected: The expected token.\n    :type expected: Union[str, bytes]\n    :param actual: The actual token.\n    :type actual: Union[str, bytes]\n    :return: Do the tokens match?\n    :rtype: bool"
        ],
        [
            "Is the token valid? This method only checks the timestamps within the\n        token and compares them against the current time if none is provided.\n\n        :param time: The timestamp to validate against\n        :type time: Union[int, None]\n        :return: The validity of the token.\n        :rtype: bool"
        ],
        [
            "Check for registered claims in the payload and move them to the\n        registered_claims property, overwriting any extant claims."
        ],
        [
            "Create a token based on the data held in the class.\n\n        :return: A new token\n        :rtype: str"
        ],
        [
            "Decodes the given token into an instance of `Jwt`.\n\n        :param secret: The secret used to decode the token. Must match the\n            secret used when creating the token.\n        :type secret: Union[str, bytes]\n        :param token: The token to decode.\n        :type token: Union[str, bytes]\n        :param alg: The algorithm used to decode the token. Must match the\n            algorithm used when creating the token.\n        :type alg: str\n        :return: The decoded token.\n        :rtype: `Jwt`"
        ],
        [
            "Compare against another `Jwt`.\n\n        :param jwt: The token to compare against.\n        :type jwt: Jwt\n        :param compare_dates: Should the comparision take dates into account?\n        :type compare_dates: bool\n        :return: Are the two Jwt's the same?\n        :rtype: bool"
        ],
        [
            "Download a file."
        ],
        [
            "Test a file is a valid json file.\n\n    - *.json: uncompressed, utf-8 encode json file\n    - *.js: uncompressed, utf-8 encode json file\n    - *.gz: compressed, utf-8 encode json file"
        ],
        [
            "``set`` dumper."
        ],
        [
            "``collections.deque`` dumper."
        ],
        [
            "``collections.OrderedDict`` dumper."
        ],
        [
            "``numpy.ndarray`` dumper."
        ],
        [
            "Decorator for rruleset methods which may invalidate the\n    cached length."
        ],
        [
            "Returns the last recurrence before the given datetime instance. The\n            inc keyword defines what happens if dt is an occurrence. With\n            inc=True, if dt itself is an occurrence, it will be returned."
        ],
        [
            "Returns the first recurrence after the given datetime instance. The\n            inc keyword defines what happens if dt is an occurrence. With\n            inc=True, if dt itself is an occurrence, it will be returned."
        ],
        [
            "Generator which yields up to `count` recurrences after the given\n        datetime instance, equivalent to `after`.\n\n        :param dt:\n            The datetime at which to start generating recurrences.\n\n        :param count:\n            The maximum number of recurrences to generate. If `None` (default),\n            dates are generated until the recurrence rule is exhausted.\n\n        :param inc:\n            If `dt` is an instance of the rule and `inc` is `True`, it is\n            included in the output.\n\n        :yields: Yields a sequence of `datetime` objects."
        ],
        [
            "Return new rrule with same attributes except for those attributes given new\n           values by whichever keyword arguments are specified."
        ],
        [
            "Run the excel_to_html function from the\n    command-line.\n\n    Args:\n        -p path to file\n        -s name of the sheet to convert\n        -css classes to apply\n        -m attempt to combine merged cells\n        -c caption for accessibility\n        -su summary for accessibility\n        -d details for accessibility\n\n    Example use:\n\n        excel_to_html -p myfile.xlsx -s SheetName -css diablo-python -m true"
        ],
        [
            "Gets the requested template for the given language.\n\n        Args:\n            language: string, the language of the template to look for.\n\n            template_type: string, 'iterable' or 'singular'. \n            An iterable template is needed when the value is an iterable\n            and needs more unpacking, e.g. list, tuple. A singular template \n            is needed when unpacking is complete and the value is singular, \n            e.g. string, int, float.\n\n            indentation: int, the indentation level.\n    \n            key: multiple types, the array key.\n\n            val: multiple types, the array values\n\n        Returns:\n            string, template formatting for arrays by language."
        ],
        [
            "Unserializes a serialized php array and prints it to\n        the console as a data structure in the specified language.\n        Used to translate or convert a php array into a data structure \n        in another language. Currently supports, PHP, Python, Javascript,\n        and JSON. \n\n        Args:\n            string: a string of serialized php\n        \n            language: a string representing the desired output \n            format for the array.\n\n            level: integer, indentation level in spaces. \n            Defaults to 3.\n\n            retdata: boolean, the method will return the string\n            in addition to printing it if set to True. Defaults \n            to false.\n\n        Returns:\n            None but prints a string to the console if retdata is \n            False, otherwise returns a string."
        ],
        [
            "Only API function for the config module.\n\n    :return: {dict}     loaded validated configuration."
        ],
        [
            "Create a reusable class from a generator function\n\n    Parameters\n    ----------\n    func: GeneratorCallable[T_yield, T_send, T_return]\n        the function to wrap\n\n    Note\n    ----\n    * the callable must have an inspectable signature\n    * If bound to a class, the new reusable generator is callable as a method.\n      To opt out of this, add a :func:`staticmethod` decorator above\n      this decorator."
        ],
        [
            "Send an item into a generator expecting a final return value\n\n    Parameters\n    ----------\n    gen: ~typing.Generator[T_yield, T_send, T_return]\n        the generator to send the value to\n    value: T_send\n        the value to send\n\n    Raises\n    ------\n    RuntimeError\n        if the generator did not return as expected\n\n    Returns\n    -------\n    T_return\n        the generator's return value"
        ],
        [
            "Apply a function to all ``send`` values of a generator\n\n    Parameters\n    ----------\n    func: ~typing.Callable[[T_send], T_mapped]\n        the function to apply\n    gen: Generable[T_yield, T_mapped, T_return]\n        the generator iterable.\n\n    Returns\n    -------\n    ~typing.Generator[T_yield, T_send, T_return]\n        the mapped generator"
        ],
        [
            "Prints the traceback and invokes the ipython debugger on any exception\n\n    Only invokes ipydb if you are outside ipython or python interactive session.\n    So scripts must be called from OS shell in order for exceptions to ipy-shell-out.\n\n    Dependencies:\n      Needs `pip install ipdb`\n\n    Arguments:\n      exc_type (type): The exception type/class (e.g. RuntimeError)\n      exc_value (Exception): The exception instance (e.g. the error message passed to the Exception constructor)\n      exc_trace (Traceback): The traceback instance\n    \n    References:\n      http://stackoverflow.com/a/242531/623735\n\n    Example Usage:\n      $  python -c 'from pug import debug;x=[];x[0]'\n      Traceback (most recent call last):\n        File \"<string>\", line 1, in <module>\n      IndexError: list index out of range\n\n      > <string>(1)<module>()\n\n      ipdb> x\n      []\n      ipdb> locals()\n      {'__builtins__': <module '__builtin__' (built-in)>, '__package__': None, 'x': [], 'debug': <module 'pug.debug' from 'pug/debug.py'>, '__name__': '__main__', '__doc__': None}\n      ipdb>"
        ],
        [
            "Copies a file from its location on the web to a designated \n    place on the local machine.\n\n    Args:\n        file_path: Complete url of the file to copy, string (e.g. http://fool.com/input.css).\n\n        target_path: Path and name of file on the local machine, string. (e.g. /directory/output.css)\n\n    Returns:\n        None."
        ],
        [
            "Counts the number of lines in a file.\n\n    Args:\n        fname: string, name of the file.\n\n    Returns:\n        integer, the number of lines in the file."
        ],
        [
            "Indentes css that has not been indented and saves it to a new file.\n    A new file is created if the output destination does not already exist.\n\n    Args:\n        f: string, path to file.\n\n        output: string, path/name of the output file (e.g. /directory/output.css).\n    print type(response.read())\n\n    Returns:\n        None."
        ],
        [
            "Adds line breaks after every occurance of a given character in a file.\n\n    Args:\n        f: string, path to input file.\n\n        output: string, path to output file.\n\n    Returns:\n        None."
        ],
        [
            "Reformats poorly written css. This function does not validate or fix errors in the code.\n    It only gives code the proper indentation. \n\n    Args:\n        input_file: string, path to the input file.\n\n        output_file: string, path to where the reformatted css should be saved. If the target file\n        doesn't exist, a new file is created.\n\n    Returns:\n        None."
        ],
        [
            "Take a list of strings and clear whitespace \n    on each one. If a value in the list is not a \n    string pass it through untouched.\n\n    Args:\n        iterable: mixed list\n\n    Returns: \n        mixed list"
        ],
        [
            "Calculates the future value of money invested at an anual interest rate,\n    x times per year, for a given number of years.\n\n    Args:\n        present_value: int or float, the current value of the money (principal).\n\n        annual_rate: float 0 to 1 e.g., .5 = 50%), the interest rate paid out.\n\n        periods_per_year: int, the number of times money is invested per year.\n\n        years: int, the number of years invested.\n\n    Returns:\n        Float, the future value of the money invested with compound interest."
        ],
        [
            "Uses Heron's formula to find the area of a triangle\n    based on the coordinates of three points.\n\n    Args:\n        point1: list or tuple, the x y coordinate of point one.\n\n        point2: list or tuple, the x y coordinate of point two.\n\n        point3: list or tuple, the x y coordinate of point three.\n\n    Returns:\n        The area of a triangle as a floating point number.\n\n    Requires:\n        The math module, point_distance()."
        ],
        [
            "Calculates  the median of a list of integers or floating point numbers.\n\n    Args:\n        data: A list of integers or floating point numbers\n\n    Returns:\n        Sorts the list numerically and returns the middle number if the list has an odd number\n        of items. If the list contains an even number of items the mean of the two middle numbers\n        is returned."
        ],
        [
            "Calculates the average or mean of a list of numbers\n\n    Args:\n        numbers: a list of integers or floating point numbers.\n\n        numtype: string, 'decimal' or 'float'; the type of number to return.\n\n    Returns:\n        The average (mean) of the numbers as a floating point number\n        or a Decimal object.\n\n    Requires:\n        The math module"
        ],
        [
            "Calculates the population or sample variance of a list of numbers.\n    A large number means the results are all over the place, while a\n    small number means the results are comparatively close to the average.\n\n    Args:\n        numbers: a list  of integers or floating point numbers to compare.\n\n        type: string, 'population' or 'sample', the kind of variance to be computed.\n\n    Returns:\n        The computed population or sample variance.\n        Defaults to population variance.\n\n    Requires:\n        The math module, average()"
        ],
        [
            "Finds the percentage of one number over another.\n\n    Args:\n        a: The number that is a percent, int or float.\n\n        b: The base number that a is a percent of, int or float.\n\n        i: Optional boolean integer. True if the user wants the result returned as\n        a whole number. Assumes False.\n\n        r: Optional boolean round. True if the user wants the result rounded.\n        Rounds to the second decimal point on floating point numbers. Assumes False.\n\n    Returns:\n        The argument a as a percentage of b. Throws a warning if integer is set to True\n        and round is set to False."
        ],
        [
            "Get datetime string from datetime object\n\n        :param datetime datetime_obj: datetime object\n        :return: datetime string\n        :rtype: str"
        ],
        [
            "attr pipe can extract attribute value of object.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param attr_name: The name of attribute\n    :type attr_name: str\n    :returns: generator"
        ],
        [
            "attrs pipe can extract attribute values of object.\n\n    If attr_names is a list and its item is not a valid attribute of\n    prev's object. It will be excluded from yielded dict.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param attr_names: The list of attribute names\n    :type attr_names: str of list\n    :returns: generator"
        ],
        [
            "attrdict pipe can extract attribute values of object into a dict.\n\n    The argument attr_names can be a list or a dict.\n\n    If attr_names is a list and its item is not a valid attribute of\n    prev's object. It will be excluded from yielded dict.\n\n    If attr_names is dict and the key doesn't exist in prev's object.\n    the value of corresponding attr_names key will be copy to yielded dict.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param attr_names: The list or dict of attribute names\n    :type attr_names: str of list or dict\n    :returns: generator"
        ],
        [
            "flatten pipe extracts nested item from previous pipe.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param depth: The deepest nested level to be extracted. 0 means no extraction.\n    :type depth: integer\n    :returns: generator"
        ],
        [
            "values pipe extract value from previous pipe.\n\n    If previous pipe send a dictionary to values pipe, keys should contains\n    the key of dictionary which you want to get. If previous pipe send list or\n    tuple,\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :returns: generator"
        ],
        [
            "pack pipe takes n elements from previous generator and yield one\n    list to next.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param rest: Set True to allow to output the rest part of last elements.\n    :type prev: boolean\n    :param padding: Specify the padding element for the rest part of last elements.\n    :type prev: boolean\n    :returns: generator\n\n    :Example:\n    >>> result([1,2,3,4,5,6,7] | pack(3))\n    [[1, 2, 3], [4, 5, 6]]\n\n    >>> result([1,2,3,4,5,6,7] | pack(3, rest=True))\n    [[1, 2, 3], [4, 5, 6], [7,]]\n\n    >>> result([1,2,3,4,5,6,7] | pack(3, padding=None))\n    [[1, 2, 3], [4, 5, 6], [7, None, None]]"
        ],
        [
            "The pipe greps the data passed from previous generator according to\n    given regular expression.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param pattern: The pattern which used to filter out data.\n    :type pattern: str|unicode|re pattern object\n    :param inv: If true, invert the match condition.\n    :type inv: boolean\n    :param kw:\n    :type kw: dict\n    :returns: generator"
        ],
        [
            "The pipe greps the data passed from previous generator according to\n    given regular expression. The data passed to next pipe is MatchObject\n    , dict or tuple which determined by 'to' in keyword argument.\n\n    By default, match pipe yields MatchObject. Use 'to' in keyword argument\n    to change the type of match result.\n\n    If 'to' is dict, yield MatchObject.groupdict().\n    If 'to' is tuple, yield MatchObject.groups().\n    If 'to' is list, yield list(MatchObject.groups()).\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param pattern: The pattern which used to filter data.\n    :type pattern: str|unicode\n    :param to: What data type the result should be stored. dict|tuple|list\n    :type to: type\n    :returns: generator"
        ],
        [
            "The resplit pipe split previous pipe input by regular expression.\n\n    Use 'maxsplit' keyword argument to limit the number of split.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param pattern: The pattern which used to split string.\n    :type pattern: str|unicode"
        ],
        [
            "sub pipe is a wrapper of re.sub method.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param pattern: The pattern string.\n    :type pattern: str|unicode\n    :param repl: Check repl argument in re.sub method.\n    :type repl: str|unicode|callable"
        ],
        [
            "wildcard pipe greps data passed from previous generator\n    according to given regular expression.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param pattern: The wildcard string which used to filter data.\n    :type pattern: str|unicode|re pattern object\n    :param inv: If true, invert the match condition.\n    :type inv: boolean\n    :returns: generator"
        ],
        [
            "This pipe read data from previous iterator and write it to stdout.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param endl: The end-of-line symbol for each output.\n    :type endl: str\n    :param thru: If true, data will passed to next generator. If false, data\n                 will be dropped.\n    :type thru: bool\n    :returns: generator"
        ],
        [
            "This pipe get filenames or file object from previous pipe and read the\n    content of file. Then, send the content of file line by line to next pipe.\n\n    The start and end parameters are used to limit the range of reading from file.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param filename: The files to be read. If None, use previous pipe input as filenames.\n    :type filename: None|str|unicode|list|tuple\n    :param mode: The mode to open file. default is 'r'\n    :type mode: str\n    :param trim: The function to trim the line before send to next pipe.\n    :type trim: function object.\n    :param start: if star is specified, only line number larger or equal to start will be sent.\n    :type start: integer\n    :param end: The last line number to read.\n    :type end: integer\n    :returns: generator"
        ],
        [
            "sh pipe execute shell command specified by args. If previous pipe exists,\n    read data from it and write it to stdin of shell process. The stdout of\n    shell process will be passed to next pipe object line by line.\n\n    A optional keyword argument 'trim' can pass a function into sh pipe. It is\n    used to trim the output from shell process. The default trim function is\n    str.rstrip. Therefore, any space characters in tail of\n    shell process output line will be removed.\n\n    For example:\n\n    py_files = result(sh('ls') | strip | wildcard('*.py'))\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param args: The command line arguments. It will be joined by space character.\n    :type args: list of string.\n    :param kw: arguments for subprocess.Popen.\n    :type kw: dictionary of options.\n    :returns: generator"
        ],
        [
            "This pipe wrap os.walk and yield absolute path one by one.\n\n    :param prev: The previous iterator of pipe.\n    :type prev: Pipe\n    :param args: The end-of-line symbol for each output.\n    :type args: list of string.\n    :param kw: The end-of-line symbol for each output.\n    :type kw: dictionary of options. Add 'endl' in kw to specify end-of-line symbol.\n    :returns: generator"
        ],
        [
            "alias of str.join"
        ],
        [
            "alias of string.Template.substitute"
        ],
        [
            "alias of string.Template.safe_substitute"
        ],
        [
            "Convert data from previous pipe with specified encoding."
        ],
        [
            "Regiser all default type-to-pipe convertors."
        ],
        [
            "Convert Paginator instance to dict\n\n        :return: Paging data\n        :rtype: dict"
        ],
        [
            "Check that a process is not running more than once, using PIDFILE"
        ],
        [
            "This function will check whether a PID is currently running"
        ],
        [
            "This function will disown, so the Ardexa service can be restarted"
        ],
        [
            "Run a  program and check program return code Note that some commands don't work\n    well with Popen.  So if this function is specifically called with 'shell=True',\n    then it will run the old 'os.system'. In which case, there is no program output"
        ],
        [
            "Yield each integer from a complex range string like \"1-9,12,15-20,23\"\n\n    >>> list(parse_address_list('1-9,12,15-20,23'))\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 15, 16, 17, 18, 19, 20, 23]\n\n    >>> list(parse_address_list('1-9,12,15-20,2-3-4'))\n    Traceback (most recent call last):\n        ...\n    ValueError: format error in 2-3-4"
        ],
        [
            "Do url-encode resource ids"
        ],
        [
            "Get item creator according registered item type.\n\n    :param item_type: The type of item to be checed.\n    :type item_type: types.TypeType.\n    :returns: Creator function. None if type not found."
        ],
        [
            "Self-cloning. All its next Pipe objects are cloned too.\n\n        :returns: cloned object"
        ],
        [
            "Append next object to pipe tail.\n\n        :param next: The Pipe object to be appended to tail.\n        :type next: Pipe object."
        ],
        [
            "Return an generator as iterator object.\n\n        :param prev: Previous Pipe object which used for data input.\n        :returns: A generator for iteration."
        ],
        [
            "Wrap a reduce function to Pipe object. Reduce function is a function\n        with at least two arguments. It works like built-in reduce function.\n        It takes first argument for accumulated result, second argument for\n        the new data to process. A keyword-based argument named 'init' is\n        optional. If init is provided, it is used for the initial value of\n        accumulated result. Or, the initial value is None.\n\n        The first argument is the data to be converted. The return data from\n        filter function should be a boolean value. If true, data can pass.\n        Otherwise, data is omitted.\n\n        :param func: The filter function to be wrapped.\n        :type func: function object\n        :param args: The default arguments to be used for filter function.\n        :param kw: The default keyword arguments to be used for filter function.\n        :returns: Pipe object"
        ],
        [
            "Return a dictionary of network name to active status bools.\n\n        Sample virsh net-list output::\n\n    Name                 State      Autostart\n    -----------------------------------------\n    default              active     yes\n    juju-test            inactive   no\n    foobar               inactive   no\n\n    Parsing the above would return::\n    {\"default\": True, \"juju-test\": False, \"foobar\": False}\n\n    See: http://goo.gl/kXwfC"
        ],
        [
            "flush the line to stdout"
        ],
        [
            "runs the passed in arguments and returns an iterator on the output of\n        running command"
        ],
        [
            "Build a basic 035 subfield with basic information from the OAI-PMH request.\n\n    :param root: ElementTree root node\n\n    :return: list of subfield tuples [(..),(..)]"
        ],
        [
            "Strip out namespace data from an ElementTree.\n\n    This function is recursive and will traverse all\n    subnodes to the root element\n\n    @param root: the root element\n\n    @return: the same root element, minus namespace"
        ],
        [
            "Load values from a dictionary structure. Nesting can be used to\n            represent namespaces.\n\n            >>> c = ConfigDict()\n            >>> c.load_dict({'some': {'namespace': {'key': 'value'} } })\n            {'some.namespace.key': 'value'}"
        ],
        [
            "The oembed endpoint, or the url to which requests for metadata are passed.\n    Third parties will want to access this view with URLs for your site's\n    content and be returned OEmbed metadata."
        ],
        [
            "Extract and return oembed content for given urls.\n\n    Required GET params:\n        urls - list of urls to consume\n\n    Optional GET params:\n        width - maxwidth attribute for oembed content\n        height - maxheight attribute for oembed content\n        template_dir - template_dir to use when rendering oembed\n\n    Returns:\n        list of dictionaries with oembed metadata and renderings, json encoded"
        ],
        [
            "A site profile detailing valid endpoints for a given domain.  Allows for\n    better auto-discovery of embeddable content.\n\n    OEmbed-able content lives at a URL that maps to a provider."
        ],
        [
            "scan path directory and any subdirectories for valid captain scripts"
        ],
        [
            "Make the request params given location data"
        ],
        [
            "Get the tax rate from the ZipTax response"
        ],
        [
            "Check if there are exceptions that should be raised"
        ],
        [
            "Recursively extract all text from node."
        ],
        [
            "Registers a provider with the site."
        ],
        [
            "Unregisters a provider from the site."
        ],
        [
            "Populate the internal registry's dictionary with the regexes for each\n        provider instance"
        ],
        [
            "Find the right provider for a URL"
        ],
        [
            "A hook for django-based oembed providers to delete any stored oembeds"
        ],
        [
            "The heart of the matter"
        ],
        [
            "Load up StoredProviders from url if it is an oembed scheme"
        ],
        [
            "Iterate over the returned json and try to sort out any new providers"
        ],
        [
            "A kind of cheesy method that allows for callables or attributes to\n        be used interchangably"
        ],
        [
            "Return an ImageFileField instance"
        ],
        [
            "Build a dictionary of metadata for the requested object."
        ],
        [
            "Parses the date from a url and uses it in the query.  For objects which\n        are unique for date."
        ],
        [
            "Override the base."
        ],
        [
            "Add the 909 OAI info to 035."
        ],
        [
            "Check if we shall add cnum in 035."
        ],
        [
            "Remove hidden notes and tag a CERN if detected."
        ],
        [
            "Remove INSPIRE specific notes."
        ],
        [
            "Move title info from 245 to 111 proceeding style."
        ],
        [
            "Update reportnumbers."
        ],
        [
            "Remove dashes from ISBN."
        ],
        [
            "Remove duplicate BibMatch DOIs."
        ],
        [
            "260 Date normalization."
        ],
        [
            "041 Language."
        ],
        [
            "Generate directory listing HTML\n\n    Arguments:\n        FS (FS): filesystem object to read files from\n        filepath (str): path to generate directory listings for\n\n    Keyword Arguments:\n        list_dir (callable: list[str]): list file names in a directory\n        isdir (callable: bool): os.path.isdir\n\n    Yields:\n        str: lines of an HTML table"
        ],
        [
            "Checks if files are not being uploaded to server.\n    @timeout - time after which the script will register an error."
        ],
        [
            "Converts capital letters to lower keeps first letter capital."
        ],
        [
            "Scans a block of text and extracts oembed data on any urls,\n        returning it in a list of dictionaries"
        ],
        [
            "Try to maintain parity with what is extracted by extract since strip\n        will most likely be used in conjunction with extract"
        ],
        [
            "Automatically build the provider index."
        ],
        [
            "pass in a list of options, promt the user to select one, and return the selected option or None"
        ],
        [
            "Transforms the argparse arguments from Namespace to dict and then to Bunch\n    Therefore it is not necessary to access the arguments using the dict syntax\n    The settings can be called like regular vars on the settings object"
        ],
        [
            "Reads a dom xml element in oaidc format and\n            returns the bibrecord object"
        ],
        [
            "display a progress that can update in place\n\n    example -- \n        total_length = 1000\n        with echo.progress(total_length) as p:\n            for x in range(total_length):\n                # do something crazy\n                p.update(x)\n\n    length -- int -- the total size of what you will be updating progress on"
        ],
        [
            "print format_msg to stderr"
        ],
        [
            "prints a banner\n\n    sep -- string -- the character that will be on the line on the top and bottom\n        and before any of the lines, defaults to *\n    count -- integer -- the line width, defaults to 80"
        ],
        [
            "format columned data so we can easily print it out on a console, this just takes\n    columns of data and it will format it into properly aligned columns, it's not\n    fancy, but it works for most type of strings that I need it for, like server name\n    lists.\n\n    other formatting options:\n        http://stackoverflow.com/a/8234511/5006\n\n    other packages that probably do this way better:\n        https://stackoverflow.com/a/26937531/5006\n\n    :Example:\n        >>> echo.table([(1, 2), (3, 4), (5, 6), (7, 8), (9, 0)])\n        1  2\n        3  4\n        5  6\n        7  8\n        9  0\n        >>> echo.table([1, 3, 5, 7, 9], [2, 4, 6, 8, 0])\n        1  2\n        3  4\n        5  6\n        7  8\n        9  0\n\n    :param *columns: can either be a list of rows or multiple lists representing each\n        column in the table\n    :param **kwargs: dict\n        prefix -- string -- what you want before each row (eg, a tab)\n        buf_count -- integer -- how many spaces between longest col value and its neighbor\n        headers -- list -- the headers you want, must match column count\n        widths -- list -- the widths of each column you want to use, this doesn't have\n            to match column count, so you can do something like [0, 5] to set the\n            width of the second column\n        width -- int -- similar to widths except it will set this value for all columns"
        ],
        [
            "echo a prompt to the user and wait for an answer\n\n    question -- string -- the prompt for the user\n    choices -- list -- if given, only exit when prompt matches one of the choices\n    return -- string -- the answer that was given by the user"
        ],
        [
            "Returns the records listed in the webpage given as\n        parameter as a xml String.\n\n        @param url: the url of the Journal, Book, Protocol or Reference work"
        ],
        [
            "Logs into the specified ftp server and returns connector."
        ],
        [
            "Set the thermostat mode\n\n        :param mode: The desired mode integer value.\n                     Auto = 1\n                     Temporary hold = 2\n                     Permanent hold = 3"
        ],
        [
            "Set the target temperature to the desired fahrenheit, with more granular control of the\n        hold mode\n\n        :param fahrenheit: The desired temperature in F\n        :param mode: The desired mode to operate in"
        ],
        [
            "Set the target temperature to the desired celsius, with more granular control of the hold\n        mode\n\n        :param celsius: The desired temperature in C\n        :param mode: The desired mode to operate in"
        ],
        [
            "Updates the target temperature on the NuHeat API\n\n        :param temperature: The desired temperature in NuHeat format\n        :param permanent: Permanently hold the temperature. If set to False, the schedule will\n                          resume at the next programmed event"
        ],
        [
            "This function returns a Bunch object from the stated config file.\n\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    NOTE:\n        The values are not evaluated by default.\n    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n    filename:\n        The desired config file to read.\n        The config file must be written in a syntax readable to the\n        ConfigParser module -> INI syntax\n\n        [sectionA]\n        optionA1 = ...\n        optionA2 = ...\n\n    section_option_dict:\n        A dictionary that contains keys, which are associated to the sections\n        in the config file, and values, which are a list of the desired\n        options.\n        If empty, everything will be loaded.\n        If the lists are empty, everything from the sections will be loaded.\n\n    Example:\n        dict = {'sectionA': ['optionA1', 'optionA2', ...],\n                'sectionB': ['optionB1', 'optionB2', ...]}\n\n        config = get_config('config.cfg', dict)\n        config.sectionA.optionA1\n\n    Other:\n        Bunch can be found in configparser.py"
        ],
        [
            "Authenticate against the NuHeat API"
        ],
        [
            "Make a request to the NuHeat API\n\n        :param url: The URL to request\n        :param method: The type of request to make (GET, POST)\n        :param data: Data to be sent along with POST requests\n        :param params: Querystring parameters\n        :param retry: Attempt to re-authenticate and retry request if necessary"
        ],
        [
            "Return representation of html start tag and attributes."
        ],
        [
            "Return representation of html end tag."
        ],
        [
            "Return stripped HTML, keeping only MathML."
        ],
        [
            "return True if callback is an instance of a class"
        ],
        [
            "return True if callback is a vanilla plain jane function"
        ],
        [
            "these kwargs come from the @arg decorator, they are then merged into any\n        keyword arguments that were automatically generated from the main function\n        introspection"
        ],
        [
            "find any matching parser_args from list_args and merge them into this\n        instance\n\n        list_args -- list -- an array of (args, kwargs) tuples"
        ],
        [
            "Overridden to not get rid of newlines\n\n        https://github.com/python/cpython/blob/2.7/Lib/argparse.py#L620"
        ],
        [
            "create string suitable for HTTP User-Agent header"
        ],
        [
            "Add a MARCXML datafield as a new child to a XML document."
        ],
        [
            "Given a document, return XML prettified."
        ],
        [
            "Transform & and < to XML valid &amp; and &lt.\n\n    Pass a list of tags as string to enable replacement of\n    '<' globally but keep any XML tags in the list."
        ],
        [
            "Properly format arXiv IDs."
        ],
        [
            "Convert journal name to Inspire's short form."
        ],
        [
            "Add correct nations field according to mapping in NATIONS_DEFAULT_MAP."
        ],
        [
            "Fix bad Unicode special dashes in string."
        ],
        [
            "Try to capitalize properly a title string."
        ],
        [
            "Convert some HTML tags to latex equivalents."
        ],
        [
            "Download URL to a file."
        ],
        [
            "Run a shell command."
        ],
        [
            "Create a logger object."
        ],
        [
            "Perform the actual uncompression."
        ],
        [
            "Locate all files matching supplied filename pattern recursively."
        ],
        [
            "Punctuate author names properly.\n\n    Expects input in the form 'Bloggs, J K' and will return 'Bloggs, J. K.'."
        ],
        [
            "Convert a date-value to the ISO date standard."
        ],
        [
            "Convert a date-value to the ISO date standard for humans."
        ],
        [
            "Convert list of images to PNG format.\n\n    @param: image_list ([string, string, ...]): the list of image files\n        extracted from the tarball in step 1\n\n    @return: image_list ([str, str, ...]): The list of image files when all\n        have been converted to PNG format."
        ],
        [
            "Generate a safe and closed filepath."
        ],
        [
            "Get letters from string only."
        ],
        [
            "Return True if license is compatible with Open Access"
        ],
        [
            "Information about the current volume, issue, etc. is available\n        in a file called issue.xml that is available in a higher directory."
        ],
        [
            "issue.xml from Elsevier assume the existence of a local DTD.\n        This procedure install the DTDs next to the issue.xml file\n        and normalize it using xmllint in order to resolve all namespaces\n        and references."
        ],
        [
            "main.xml from Elsevier assume the existence of a local DTD.\n        This procedure install the DTDs next to the main.xml file\n        and normalize it using xmllint in order to resolve all namespaces\n        and references."
        ],
        [
            "Return the best effort start_date."
        ],
        [
            "Extract oembed resources from a block of text.  Returns a list\n    of dictionaries.\n\n    Max width & height can be specified:\n    {% for embed in block_of_text|extract_oembeds:\"400x300\" %}\n\n    Resource type can be specified:\n    {% for photo_embed in block_of_text|extract_oembeds:\"photo\" %}\n\n    Or both:\n    {% for embed in block_of_text|extract_oembeds:\"400x300xphoto\" %}"
        ],
        [
            "A node which parses everything between its two nodes, and replaces any links\n    with OEmbed-provided objects, if possible.\n\n    Supports two optional argument, which is the maximum width and height,\n    specified like so:\n\n    {% oembed 640x480 %}http://www.viddler.com/explore/SYSTM/videos/49/{% endoembed %}\n\n    and or the name of a sub tempalte directory to render templates from:\n\n    {% oembed 320x240 in \"comments\" %}http://www.viddler.com/explore/SYSTM/videos/49/{% endoembed %}\n\n    or:\n\n    {% oembed in \"comments\" %}http://www.viddler.com/explore/SYSTM/videos/49/{% endoembed %}\n\n    either of those will render templates in oembed/comments/oembedtype.html\n\n    Additionally, you can specify a context variable to drop the rendered text in:\n\n    {% oembed 600x400 in \"comments\" as var_name %}...{% endoembed %}\n    {% oembed as var_name %}...{% endoembed %}"
        ],
        [
            "Generates a &lt;link&gt; tag with oembed autodiscovery bits for an object.\n\n    {% oembed_autodiscover video %}"
        ],
        [
            "Generates a &lt;link&gt; tag with oembed autodiscovery bits.\n\n    {% oembed_url_scheme %}"
        ],
        [
            "return the parser for the current name"
        ],
        [
            "load the module so we can actually run the script's function"
        ],
        [
            "get the contents of the script"
        ],
        [
            "parse and import the script, and then run the script's main function"
        ],
        [
            "return that path to be able to call this script from the passed in\n        basename\n\n        example -- \n            basepath = /foo/bar\n            self.path = /foo/bar/che/baz.py\n            self.call_path(basepath) # che/baz.py\n\n        basepath -- string -- the directory you would be calling this script in\n        return -- string -- the minimum path that you could use to execute this script\n            in basepath"
        ],
        [
            "load the script and set the parser and argument info\n\n        I feel that this is way too brittle to be used long term, I think it just\n        might be best to import the stupid module, the thing I don't like about that\n        is then we import basically everything, which seems bad?"
        ],
        [
            "return True if this script can be run from the command line"
        ],
        [
            "Handles registering the fields with the FieldRegistry and creating a \n    post-save signal for the model."
        ],
        [
            "I need a way to ensure that this signal gets created for all child\n        models, and since model inheritance doesn't have a 'contrubite_to_class'\n        style hook, I am creating a fake virtual field which will be added to\n        all subclasses and handles creating the signal"
        ],
        [
            "Fetch response headers and data from a URL, raising a generic exception\n    for any kind of failure."
        ],
        [
            "Given a url which may or may not be a relative url, convert it to a full\n    url path given another full url as an example"
        ],
        [
            "Generate a fake request object to allow oEmbeds to use context processors."
        ],
        [
            "dynamically load a class given a string of the format\n    \n    package.Class"
        ],
        [
            "Override the base get_record."
        ],
        [
            "Special handling if record is a CMS NOTE."
        ],
        [
            "Handle reportnumbers."
        ],
        [
            "653 Free Keywords."
        ],
        [
            "710 Collaboration."
        ],
        [
            "Return a field created with the provided elements.\n\n    Global position is set arbitrary to -1."
        ],
        [
            "Create a list of records from the marcxml description.\n\n    :returns: a list of objects initiated by the function create_record().\n              Please see that function's docstring."
        ],
        [
            "Create a record object from the marcxml description.\n\n    Uses the lxml parser.\n\n    The returned object is a tuple (record, status_code, list_of_errors),\n    where status_code is 0 when there are errors, 1 when no errors.\n\n    The return record structure is as follows::\n\n        Record := {tag : [Field]}\n        Field := (Subfields, ind1, ind2, value)\n        Subfields := [(code, value)]\n\n    .. code-block:: none\n\n                                    .--------.\n                                    | record |\n                                    '---+----'\n                                        |\n               .------------------------+------------------------------------.\n               |record['001']           |record['909']        |record['520'] |\n               |                        |                     |              |\n        [list of fields]           [list of fields]     [list of fields]    ...\n               |                        |                     |\n               |               .--------+--+-----------.      |\n               |               |           |           |      |\n               |[0]            |[0]        |[1]       ...     |[0]\n          .----+------.  .-----+-----.  .--+--------.     .---+-------.\n          | Field 001 |  | Field 909 |  | Field 909 |     | Field 520 |\n          '-----------'  '-----+-----'  '--+--------'     '---+-------'\n               |               |           |                  |\n              ...              |          ...                ...\n                               |\n                    .----------+-+--------+------------.\n                    |            |        |            |\n                    |[0]         |[1]     |[2]         |\n          [list of subfields]   'C'      '4'          ...\n                    |\n               .----+---------------+------------------------+\n               |                    |                        |\n        ('a', 'value')              |            ('a', 'value for another a')\n                     ('b', 'value for subfield b')\n\n    :param marcxml: an XML string representation of the record to create\n    :param verbose: the level of verbosity: 0 (silent), 1-2 (warnings),\n                    3(strict:stop when errors)\n    :param correct: 1 to enable correction of marcxml syntax. Else 0.\n    :return: a tuple (record, status_code, list_of_errors), where status\n             code is 0 where there are errors, 1 when no errors"
        ],
        [
            "Filter the given field.\n\n    Filters given field and returns only that field instances that contain\n    filter_subcode with given filter_value. As an input for search function\n    accepts output from record_get_field_instances function. Function can be\n    run in three modes:\n\n    - 'e' - looking for exact match in subfield value\n    - 's' - looking for substring in subfield value\n    - 'r' - looking for regular expression in subfield value\n\n    Example:\n\n    record_filter_field(record_get_field_instances(rec, '999', '%', '%'),\n                        'y', '2001')\n\n    In this case filter_subcode is 'y' and filter_value is '2001'.\n\n    :param field_instances: output from record_get_field_instances\n    :param filter_subcode: name of the subfield\n    :type filter_subcode: string\n    :param filter_value: value of the subfield\n    :type filter_value: string\n    :param filter_mode: 'e','s' or 'r'"
        ],
        [
            "Return a record where all the duplicate fields have been removed.\n\n    Fields are considered identical considering also the order of their\n    subfields."
        ],
        [
            "Return True if rec1 is identical to rec2.\n\n    It does so regardless of a difference in the 005 tag (i.e. the timestamp)."
        ],
        [
            "Return the list of field instances for the specified tag and indications.\n\n    Return empty list if not found.\n    If tag is empty string, returns all fields\n\n    Parameters (tag, ind1, ind2) can contain wildcard %.\n\n    :param rec: a record structure as returned by create_record()\n    :param tag: a 3 characters long string\n    :param ind1: a 1 character long string\n    :param ind2: a 1 character long string\n    :param code: a 1 character long string\n    :return: a list of field tuples (Subfields, ind1, ind2, value,\n             field_position_global) where subfields is list of (code, value)"
        ],
        [
            "Delete the field with the given position.\n\n    If global field position is specified, deletes the field with the\n    corresponding global field position.\n    If field_position_local is specified, deletes the field with the\n    corresponding local field position and tag.\n    Else deletes all the fields matching tag and optionally ind1 and\n    ind2.\n\n    If both field_position_global and field_position_local are present,\n    then field_position_local takes precedence.\n\n    :param rec: the record data structure\n    :param tag: the tag of the field to be deleted\n    :param ind1: the first indicator of the field to be deleted\n    :param ind2: the second indicator of the field to be deleted\n    :param field_position_global: the global field position (record wise)\n    :param field_position_local: the local field position (tag wise)\n    :return: the list of deleted fields"
        ],
        [
            "Add the fields into the record at the required position.\n\n    The position is specified by the tag and the field_position_local in the\n    list of fields.\n\n    :param rec: a record structure\n    :param tag: the tag of the fields to be moved\n    :param field_position_local: the field_position_local to which the field\n                                 will be inserted. If not specified, appends\n                                 the fields to the tag.\n    :param a: list of fields to be added\n    :return: -1 if the operation failed, or the field_position_local if it was\n             successful"
        ],
        [
            "Move some fields to the position specified by 'field_position_local'.\n\n    :param rec: a record structure as returned by create_record()\n    :param tag: the tag of the fields to be moved\n    :param field_positions_local: the positions of the fields to move\n    :param field_position_local: insert the field before that\n                                 field_position_local. If unspecified, appends\n                                 the fields :return: the field_position_local\n                                 is the operation was successful"
        ],
        [
            "Delete all subfields with subfield_code in the record."
        ],
        [
            "Return the the matching field.\n\n    One has to enter either a global field position or a local field position.\n\n    :return: a list of subfield tuples (subfield code, value).\n    :rtype: list"
        ],
        [
            "Replace a field with a new field."
        ],
        [
            "Return the subfield of the matching field.\n\n    One has to enter either a global field position or a local field position.\n\n    :return: a list of subfield tuples (subfield code, value).\n    :rtype:  list"
        ],
        [
            "Delete subfield from position specified.\n\n    Specify the subfield by tag, field number and subfield position."
        ],
        [
            "Add subfield into specified position.\n\n    Specify the subfield by tag, field number and optionally by subfield\n    position."
        ],
        [
            "Modify controlfield at position specified by tag and field number."
        ],
        [
            "Modify subfield at specified position.\n\n    Specify the subfield by tag, field number and subfield position."
        ],
        [
            "Move subfield at specified position.\n\n    Sspecify the subfield by tag, field number and subfield position to new\n    subfield position."
        ],
        [
            "Generate the XML for record 'rec'.\n\n    :param rec: record\n    :param tags: list of tags to be printed\n    :return: string"
        ],
        [
            "Generate the XML for field 'field' and returns it as a string."
        ],
        [
            "Print a record.\n\n    :param format: 1 XML, 2 HTML (not implemented)\n    :param tags: list of tags to be printed"
        ],
        [
            "Print a list of records.\n\n    :param format: 1 XML, 2 HTML (not implemented)\n    :param tags: list of tags to be printed\n           if 'listofrec' is not a list it returns empty string"
        ],
        [
            "Return the global and local positions of the first occurrence of the field.\n\n    :param rec:    A record dictionary structure\n    :type  rec:    dictionary\n    :param tag:    The tag of the field to search for\n    :type  tag:    string\n    :param field:  A field tuple as returned by create_field()\n    :type  field:  tuple\n    :param strict: A boolean describing the search method. If strict\n                   is False, then the order of the subfields doesn't\n                   matter. Default search method is strict.\n    :type  strict: boolean\n    :return:       A tuple of (global_position, local_position) or a\n                   tuple (None, None) if the field is not present.\n    :rtype:        tuple\n    :raise InvenioBibRecordFieldError: If the provided field is invalid."
        ],
        [
            "Find subfield instances in a particular field.\n\n    It tests values in 1 of 3 possible ways:\n     - Does a subfield code exist? (ie does 773__a exist?)\n     - Does a subfield have a particular value? (ie 773__a == 'PhysX')\n     - Do a pair of subfields have particular values?\n        (ie 035__2 == 'CDS' and 035__a == '123456')\n\n    Parameters:\n     * rec - dictionary: a bibrecord structure\n     * tag - string: the tag of the field (ie '773')\n     * ind1, ind2 - char: a single characters for the MARC indicators\n     * sub_key - char: subfield key to find\n     * sub_value - string: subfield value of that key\n     * sub_key2 - char: key of subfield to compare against\n     * sub_value2 - string: expected value of second subfield\n     * case_sensitive - bool: be case sensitive when matching values\n\n    :return: false if no match found, else provides the field position (int)"
        ],
        [
            "Remove unchanged volatile subfields from the record."
        ],
        [
            "Turns all subfields to volatile"
        ],
        [
            "Remove empty subfields and fields from the record.\n\n    If 'tag' is not None, only a specific tag of the record will be stripped,\n    otherwise the whole record.\n\n    :param rec:  A record dictionary structure\n    :type  rec:  dictionary\n    :param tag:  The tag of the field to strip empty fields from\n    :type  tag:  string"
        ],
        [
            "Remove all non-empty controlfields from the record.\n\n    :param rec:  A record dictionary structure\n    :type  rec:  dictionary"
        ],
        [
            "Order subfields from a record alphabetically based on subfield code.\n\n    If 'tag' is not None, only a specific tag of the record will be reordered,\n    otherwise the whole record.\n\n    :param rec: bibrecord\n    :type rec: bibrec\n    :param tag: tag where the subfields will be ordered\n    :type tag: str"
        ],
        [
            "Compare 2 fields.\n\n    If strict is True, then the order of the subfield will be taken care of, if\n    not then the order of the subfields doesn't matter.\n\n    :return: True if the field are equivalent, False otherwise."
        ],
        [
            "Check if a field is well-formed.\n\n    :param field: A field tuple as returned by create_field()\n    :type field:  tuple\n    :raise InvenioBibRecordFieldError: If the field is invalid."
        ],
        [
            "Shift all global field positions.\n\n    Shift all global field positions with global field positions\n    higher or equal to 'start' from the value 'delta'."
        ],
        [
            "Return true if MARC 'tag' matches a 'pattern'.\n\n    'pattern' is plain text, with % as wildcard\n\n    Both parameters must be 3 characters long strings.\n\n    .. doctest::\n\n        >>> _tag_matches_pattern(\"909\", \"909\")\n        True\n        >>> _tag_matches_pattern(\"909\", \"9%9\")\n        True\n        >>> _tag_matches_pattern(\"909\", \"9%8\")\n        False\n\n    :param tag: a 3 characters long string\n    :param pattern: a 3 characters long string\n    :return: False or True"
        ],
        [
            "Check if the global field positions in the record are valid.\n\n    I.e., no duplicate global field positions and local field positions in the\n    list of fields are ascending.\n\n    :param record: the record data structure\n    :return: the first error found as a string or None if no error was found"
        ],
        [
            "Sort the fields inside the record by indicators."
        ],
        [
            "Sort a set of fields by their indicators.\n\n    Return a sorted list with correct global field positions."
        ],
        [
            "Create a record object using the LXML parser.\n\n    If correct == 1, then perform DTD validation\n    If correct == 0, then do not perform DTD validation\n\n    If verbose == 0, the parser will not give warnings.\n    If 1 <= verbose <= 3, the parser will not give errors, but will warn\n        the user about possible mistakes (implement me!)\n    If verbose > 3 then the parser will be strict and will stop in case of\n        well-formedness errors or DTD errors."
        ],
        [
            "Retrieve all children from node 'node' with name 'name'."
        ],
        [
            "Iterate through all the children of a node.\n\n    Returns one string containing the values from all the text-nodes\n    recursively."
        ],
        [
            "Check and correct the structure of the record.\n\n    :param record: the record data structure\n    :return: a list of errors found"
        ],
        [
            "Return a warning message of code 'code'.\n\n    If code = (cd, str) it returns the warning message of code 'cd' and appends\n    str at the end"
        ],
        [
            "Compare twolists using given comparing function.\n\n    :param list1: first list to compare\n    :param list2: second list to compare\n    :param custom_cmp: a function taking two arguments (element of\n        list 1, element of list 2) and\n    :return: True or False depending if the values are the same"
        ],
        [
            "Parse an XML document and clean any namespaces."
        ],
        [
            "Clean MARCXML harvested from OAI.\n\n        Allows the xml to be used with BibUpload or BibRecord.\n\n        :param xml: either XML as a string or path to an XML file\n\n        :return: ElementTree of clean data"
        ],
        [
            "Generate the record deletion if deleted form OAI-PMH."
        ],
        [
            "Return a session for yesss.at."
        ],
        [
            "Check for working login data."
        ],
        [
            "Send an SMS."
        ],
        [
            "Return the date of the article in file."
        ],
        [
            "Return this articles' collection."
        ],
        [
            "Attach fulltext FFT."
        ],
        [
            "Convert the list of bibrecs into one MARCXML.\n\n        >>> from harvestingkit.bibrecord import BibRecordPackage\n        >>> from harvestingkit.inspire_cds_package import Inspire2CDS\n        >>> bibrecs = BibRecordPackage(\"inspire.xml\")\n        >>> bibrecs.parse()\n        >>> xml = Inspire2CDS.convert_all(bibrecs.get_records())\n\n        :param records: list of BibRecord dicts\n        :type records: list\n\n        :returns: MARCXML as string"
        ],
        [
            "Yield single conversion objects from a MARCXML file or string.\n\n        >>> from harvestingkit.inspire_cds_package import Inspire2CDS\n        >>> for record in Inspire2CDS.from_source(\"inspire.xml\"):\n        >>>     xml = record.convert()"
        ],
        [
            "Return the opposite mapping by searching the imported KB."
        ],
        [
            "Load configuration from config.\n\n        Meant to run only once per system process as\n        class variable in subclasses."
        ],
        [
            "Try to match the current record to the database."
        ],
        [
            "Keep only fields listed in field_list."
        ],
        [
            "Clear any fields listed in field_list."
        ],
        [
            "Add 035 number from 001 recid with given source."
        ],
        [
            "Add a control-number 00x for given tag with value."
        ],
        [
            "650 Translate Categories."
        ],
        [
            "Connects and logins to the server."
        ],
        [
            "Downloads a file from the FTP server to target folder\n\n        :param source_file: the absolute path for the file on the server\n                   it can be the one of the files coming from\n                   FtpHandler.dir().\n        :type source_file: string\n        :param target_folder: relative or absolute path of the\n                              destination folder default is the\n                              working directory.\n        :type target_folder: string"
        ],
        [
            "Changes the working directory on the server.\n\n        :param folder: the desired directory.\n        :type folder: string"
        ],
        [
            "Lists the files and folders of a specific directory\n        default is the current working directory.\n\n        :param folder: the folder to be listed.\n        :type folder: string\n\n        :returns: a tuple with the list of files in the folder\n                  and the list of subfolders in the folder."
        ],
        [
            "Creates a folder in the server\n\n        :param folder: the folder to be created.\n        :type folder: string"
        ],
        [
            "Delete a file from the server.\n\n        :param filename: the file to be deleted.\n        :type filename: string"
        ],
        [
            "Delete a folder from the server.\n\n        :param foldername: the folder to be deleted.\n        :type foldername: string"
        ],
        [
            "Returns the filesize of a file\n\n        :param filename: the full path to the file on the server.\n        :type filename: string\n\n        :returns: string representation of the filesize."
        ],
        [
            "Uploads a file on the server to the desired location\n\n        :param filename: the name of the file to be uploaded.\n        :type filename: string\n        :param location: the directory in which the file will\n                         be stored.\n        :type location: string"
        ],
        [
            "Parses a block of text indiscriminately"
        ],
        [
            "Parses a block of text rendering links that occur on their own line\n        normally but rendering inline links using a special template dir"
        ],
        [
            "Do the legwork of logging into the Midas Server instance, storing the API\n    key and token.\n\n    :param email: (optional) Email address to login with. If not set, the\n        console will be prompted.\n    :type email: None | string\n    :param password: (optional) User password to login with. If not set and no\n        'api_key' is set, the console will be prompted.\n    :type password: None | string\n    :param api_key: (optional) API key to login with. If not set, password\n        login with be used.\n    :type api_key: None | string\n    :param application: (optional) Application name to be used with 'api_key'.\n    :type application: string\n    :param url: (optional) URL address of the Midas Server instance to login\n        to. If not set, the console will be prompted.\n    :type url: None | string\n    :param verify_ssl_certificate: (optional) If True, the SSL certificate will\n        be verified\n    :type verify_ssl_certificate: bool\n    :returns: API token.\n    :rtype: string"
        ],
        [
            "Renew or get a token to use for transactions with the Midas Server\n    instance.\n\n    :returns: API token.\n    :rtype: string"
        ],
        [
            "Create an item from the local file in the Midas Server folder corresponding\n    to the parent folder id.\n\n    :param local_file: full path to a file on the local file system\n    :type local_file: string\n    :param parent_folder_id: id of parent folder on the Midas Server instance,\n        where the item will be added\n    :type parent_folder_id: int | long\n    :param reuse_existing: (optional) whether to accept an existing item of the\n        same name in the same location, or create a new one instead\n    :type reuse_existing: bool"
        ],
        [
            "Create a folder from the local file in the midas folder corresponding to\n    the parent folder id.\n\n    :param local_folder: full path to a directory on the local file system\n    :type local_folder: string\n    :param parent_folder_id: id of parent folder on the Midas Server instance,\n        where the folder will be added\n    :type parent_folder_id: int | long\n    :param reuse_existing: (optional) whether to accept an existing folder of\n       the same name in the same location, or create a new one instead\n    :type reuse_existing: bool"
        ],
        [
            "Create and return a hex checksum using the MD5 sum of the passed in file.\n    This will stream the file, rather than load it all into memory.\n\n    :param file_path: full path to the file\n    :type file_path: string\n    :returns: a hex checksum\n    :rtype: string"
        ],
        [
            "Create a bitstream in the given item.\n\n    :param file_path: full path to the local file\n    :type file_path: string\n    :param local_file: name of the local file\n    :type local_file: string\n    :param log_ind: (optional) any additional message to log upon creation of\n        the bitstream\n    :type log_ind: None | string"
        ],
        [
            "Function for doing an upload of a file as an item. This should be a\n    building block for user-level functions.\n\n    :param local_file: name of local file to upload\n    :type local_file: string\n    :param parent_folder_id: id of parent folder on the Midas Server instance,\n        where the item will be added\n    :type parent_folder_id: int | long\n    :param file_path: full path to the file\n    :type file_path: string\n    :param reuse_existing: (optional) whether to accept an existing item of the\n        same name in the same location, or create a new one instead\n    :type reuse_existing: bool"
        ],
        [
            "Function for creating a remote folder and returning the id. This should be\n    a building block for user-level functions.\n\n    :param local_folder: full path to a local folder\n    :type local_folder: string\n    :param parent_folder_id: id of parent folder on the Midas Server instance,\n        where the new folder will be added\n    :type parent_folder_id: int | long\n    :returns: id of the remote folder that was created\n    :rtype: int | long"
        ],
        [
            "Function to recursively upload a folder and all of its descendants.\n\n    :param local_folder: full path to local folder to be uploaded\n    :type local_folder: string\n    :param parent_folder_id: id of parent folder on the Midas Server instance,\n        where the new folder will be added\n    :type parent_folder_id: int | long\n    :param leaf_folders_as_items: (optional) whether leaf folders should have\n        all files uploaded as single items\n    :type leaf_folders_as_items: bool\n    :param reuse_existing: (optional) whether to accept an existing item of the\n        same name in the same location, or create a new one instead\n    :type reuse_existing: bool"
        ],
        [
            "Return whether a folder contains only files. This will be False if the\n    folder contains any subdirectories.\n\n    :param local_folder: full path to the local folder\n    :type local_folder: string\n    :returns: True if the folder contains only files\n    :rtype: bool"
        ],
        [
            "Upload a folder as a new item. Take a folder and use its base name as the\n    name of a new item. Then, upload its containing files into the new item as\n    bitstreams.\n\n    :param local_folder: The path to the folder to be uploaded\n    :type local_folder: string\n    :param parent_folder_id: The id of the destination folder for the new item.\n    :type parent_folder_id: int | long\n    :param reuse_existing: (optional) whether to accept an existing item of the\n        same name in the same location, or create a new one instead\n    :type reuse_existing: bool"
        ],
        [
            "Upload a pattern of files. This will recursively walk down every tree in\n    the file pattern to create a hierarchy on the server. As of right now, this\n    places the file into the currently logged in user's home directory.\n\n    :param file_pattern: a glob type pattern for files\n    :type file_pattern: string\n    :param destination: (optional) name of the midas destination folder,\n        defaults to Private\n    :type destination: string\n    :param leaf_folders_as_items: (optional) whether leaf folders should have\n        all files uploaded as single items\n    :type leaf_folders_as_items: bool\n    :param reuse_existing: (optional) whether to accept an existing item of the\n        same name in the same location, or create a new one instead\n    :type reuse_existing: bool"
        ],
        [
            "Descend a path to return a folder id starting from the given folder id.\n\n    :param parsed_path: a list of folders from top to bottom of a hierarchy\n    :type parsed_path: list[string]\n    :param folder_id: The id of the folder from which to start the descent\n    :type folder_id: int | long\n    :returns: The id of the found folder or -1\n    :rtype: int | long"
        ],
        [
            "Find an item or folder matching the name. A folder will be found first if\n    both are present.\n\n    :param name: The name of the resource\n    :type name: string\n    :param folder_id: The folder to search within\n    :type folder_id: int | long\n    :returns: A tuple indicating whether the resource is an item an the id of\n        said resource. i.e. (True, item_id) or (False, folder_id). Note that in\n        the event that we do not find a result return (False, -1)\n    :rtype: (bool, int | long)"
        ],
        [
            "Get a folder id from a path on the server.\n\n    Warning: This is NOT efficient at all.\n\n    The schema for this path is:\n    path := \"/users/<name>/\" | \"/communities/<name>\" , {<subfolder>/}\n    name := <firstname> , \"_\" , <lastname>\n\n    :param path: The virtual path on the server.\n    :type path: string\n    :returns: a tuple indicating True or False about whether the resource is an\n        item and id of the resource i.e. (True, item_id) or (False, folder_id)\n    :rtype: (bool, int | long)"
        ],
        [
            "Download a folder to the specified path along with any children.\n\n    :param folder_id: The id of the target folder\n    :type folder_id: int | long\n    :param path: (optional) the location to download the folder\n    :type path: string"
        ],
        [
            "Download the requested item to the specified path.\n\n    :param item_id: The id of the item to be downloaded\n    :type item_id: int | long\n    :param path: (optional) the location to download the item\n    :type path: string\n    :param item: The dict of item info\n    :type item: dict | None"
        ],
        [
            "Recursively download a file or item from the Midas Server instance.\n\n    :param server_path: The location on the server to find the resource to\n        download\n    :type server_path: string\n    :param local_path: The location on the client to store the downloaded data\n    :type local_path: string"
        ],
        [
            "Login and get a token. If you do not specify a specific application,\n        'Default' will be used.\n\n        :param email: Email address of the user\n        :type email: string\n        :param api_key: API key assigned to the user\n        :type api_key: string\n        :param application: (optional) Application designated for this API key\n        :type application: string\n        :returns: Token to be used for interaction with the API until\n            expiration\n        :rtype: string"
        ],
        [
            "List the folders in the users home area.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :returns: List of dictionaries containing folder information.\n        :rtype: list[dict]"
        ],
        [
            "Get the default API key for a user.\n\n        :param email: The email of the user.\n        :type email: string\n        :param password: The user's password.\n        :type password: string\n        :returns: API key to confirm that it was fetched successfully.\n        :rtype: string"
        ],
        [
            "List the public users in the system.\n\n        :param limit: (optional) The number of users to fetch.\n        :type limit: int | long\n        :returns: The list of users.\n        :rtype: list[dict]"
        ],
        [
            "Get a user by the email of that user.\n\n        :param email: The email of the desired user.\n        :type email: string\n        :returns: The user requested.\n        :rtype: dict"
        ],
        [
            "Create a new community or update an existing one using the uuid.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param name: The community name.\n        :type name: string\n        :param description: (optional) The community description.\n        :type description: string\n        :param uuid: (optional) uuid of the community. If none is passed, will\n            generate one.\n        :type uuid: string\n        :param privacy: (optional) Default 'Public', possible values\n            [Public|Private].\n        :type privacy: string\n        :param can_join: (optional) Default 'Everyone', possible values\n            [Everyone|Invitation].\n        :type can_join: string\n        :returns: The community dao that was created.\n        :rtype: dict"
        ],
        [
            "Get a community based on its name.\n\n        :param name: The name of the target community.\n        :type name: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: The requested community.\n        :rtype: dict"
        ],
        [
            "Get a community based on its id.\n\n        :param community_id: The id of the target community.\n        :type community_id: int | long\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: The requested community.\n        :rtype: dict"
        ],
        [
            "Get the non-recursive children of the passed in community_id.\n\n        :param community_id: The id of the requested community.\n        :type community_id: int | long\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: List of the folders in the community.\n        :rtype: dict[string, list]"
        ],
        [
            "List all communities visible to a user.\n\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: The list of communities.\n        :rtype: list[dict]"
        ],
        [
            "Get the attributes of the specified folder.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the requested folder.\n        :type folder_id: int | long\n        :returns: Dictionary of the folder attributes.\n        :rtype: dict"
        ],
        [
            "Get the non-recursive children of the passed in folder_id.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the requested folder.\n        :type folder_id: int | long\n        :returns: Dictionary of two lists: 'folders' and 'items'.\n        :rtype: dict[string, list]"
        ],
        [
            "Delete the folder with the passed in folder_id.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the folder to be deleted.\n        :type folder_id: int | long\n        :returns: None.\n        :rtype: None"
        ],
        [
            "Move a folder to the destination folder.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the folder to be moved.\n        :type folder_id: int | long\n        :param dest_folder_id: The id of destination (new parent) folder.\n        :type dest_folder_id: int | long\n        :returns: Dictionary containing the details of the moved folder.\n        :rtype: dict"
        ],
        [
            "Create an item to the server.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param name: The name of the item to be created.\n        :type name: string\n        :param parent_id: The id of the destination folder.\n        :type parent_id: int | long\n        :param description: (optional) The description text of the item.\n        :type description: string\n        :param uuid: (optional) The UUID for the item. It will be generated if\n            not given.\n        :type uuid: string\n        :param privacy: (optional) The privacy state of the item\n            ('Public' or 'Private').\n        :type privacy: string\n        :returns: Dictionary containing the details of the created item.\n        :rtype: dict"
        ],
        [
            "Get the attributes of the specified item.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the requested item.\n        :type item_id: int | string\n        :returns: Dictionary of the item attributes.\n        :rtype: dict"
        ],
        [
            "Download an item to disk.\n\n        :param item_id: The id of the item to be downloaded.\n        :type item_id: int | long\n        :param token: (optional) The authentication token of the user\n            requesting the download.\n        :type token: None | string\n        :param revision: (optional) The revision of the item to download, this\n            defaults to HEAD.\n        :type revision: None | int | long\n        :returns: A tuple of the filename and the content iterator.\n        :rtype: (string, unknown)"
        ],
        [
            "Delete the item with the passed in item_id.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item to be deleted.\n        :type item_id: int | long\n        :returns: None.\n        :rtype: None"
        ],
        [
            "Get the metadata associated with an item.\n\n        :param item_id: The id of the item for which metadata will be returned\n        :type item_id: int | long\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :param revision: (optional) Revision of the item. Defaults to latest\n            revision.\n        :type revision: int | long\n        :returns: List of dictionaries containing item metadata.\n        :rtype: list[dict]"
        ],
        [
            "Set the metadata associated with an item.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item for which metadata will be set.\n        :type item_id: int | long\n        :param element: The metadata element name.\n        :type element: string\n        :param value: The metadata value for the field.\n        :type value: string\n        :param qualifier: (optional) The metadata qualifier. Defaults to empty\n            string.\n        :type qualifier: None | string\n        :returns: None.\n        :rtype: None"
        ],
        [
            "Share an item to the destination folder.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item to be shared.\n        :type item_id: int | long\n        :param dest_folder_id: The id of destination folder where the item is\n            shared to.\n        :type dest_folder_id: int | long\n        :returns: Dictionary containing the details of the shared item.\n        :rtype: dict"
        ],
        [
            "Move an item from the source folder to the destination folder.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item to be moved\n        :type item_id: int | long\n        :param src_folder_id: The id of source folder where the item is located\n        :type src_folder_id: int | long\n        :param dest_folder_id: The id of destination folder where the item is\n            moved to\n        :type dest_folder_id: int | long\n        :returns: Dictionary containing the details of the moved item\n        :rtype: dict"
        ],
        [
            "Return all items.\n\n        :param name: The name of the item to search by.\n        :type name: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: A list of all items with the given name.\n        :rtype: list[dict]"
        ],
        [
            "Return all items with a given name and parent folder id.\n\n        :param name: The name of the item to search by.\n        :type name: string\n        :param folder_id: The id of the parent folder to search by.\n        :type folder_id: int | long\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: A list of all items with the given name and parent folder id.\n        :rtype: list[dict]"
        ],
        [
            "Return all items with a given name and parent folder name.\n\n        :param name: The name of the item to search by.\n        :type name: string\n        :param folder_name: The name of the parent folder to search by.\n        :type folder_name: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :returns: A list of all items with the given name and parent folder\n            name.\n        :rtype: list[dict]"
        ],
        [
            "Create a link bitstream.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param folder_id: The id of the folder in which to create a new item\n            that will contain the link. The new item will have the same name as\n            the URL unless an item name is supplied.\n        :type folder_id: int | long\n        :param url: The URL of the link you will create, will be used as the\n            name of the bitstream and of the item unless an item name is\n            supplied.\n        :type url: string\n        :param item_name: (optional)  The name of the newly created item, if\n            not supplied, the item will have the same name as the URL.\n        :type item_name: string\n        :param length: (optional) The length in bytes of the file to which the\n            link points.\n        :type length: int | long\n        :param checksum: (optional) The MD5 checksum of the file to which the\n            link points.\n        :type checksum: string\n        :returns: The item information of the item created.\n        :rtype: dict"
        ],
        [
            "Generate a token to use for upload.\n\n        Midas Server uses a individual token for each upload. The token\n        corresponds to the file specified and that file only. Passing the MD5\n        checksum allows the server to determine if the file is already in the\n        asset store.\n\n        If :param:`checksum` is passed and the token returned is blank, the\n        server already has this file and there is no need to follow this\n        call with a call to `perform_upload`, as the passed in file will have\n        been added as a bitstream to the item's latest revision, creating a\n        new revision if one doesn't exist.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The id of the item in which to upload the file as a\n            bitstream.\n        :type item_id: int | long\n        :param filename: The name of the file to generate the upload token for.\n        :type filename: string\n        :param checksum: (optional) The checksum of the file to upload.\n        :type checksum: None | string\n        :returns: String of the upload token.\n        :rtype: string"
        ],
        [
            "Upload a file into a given item (or just to the public folder if the\n        item is not specified.\n\n        :param upload_token: The upload token (returned by\n            generate_upload_token)\n        :type upload_token: string\n        :param filename: The upload filename. Also used as the path to the\n            file, if 'filepath' is not set.\n        :type filename: string\n        :param mode: (optional) Stream or multipart. Default is stream.\n        :type mode: string\n        :param folder_id: (optional) The id of the folder to upload into.\n        :type folder_id: int | long\n        :param item_id: (optional) If set, will append item ``bitstreams`` to\n            the latest revision (or the one set using :param:`revision` ) of\n            the existing item.\n        :type item_id: int | long\n        :param revision: (optional) If set, will add a new file into an\n            existing revision. Set this to 'head' to add to the most recent\n            revision.\n        :type revision: string | int | long\n        :param filepath: (optional) The path to the file.\n        :type filepath: string\n        :param create_additional_revision: (optional) If set, will create a\n            new revision in the existing item.\n        :type create_additional_revision: bool\n        :returns: Dictionary containing the details of the item created or\n            changed.\n        :rtype: dict"
        ],
        [
            "Get the resources corresponding to a given query.\n\n        :param search: The search criterion.\n        :type search: string\n        :param token: (optional) The credentials to use when searching.\n        :type token: None | string\n        :returns: Dictionary containing the search result. Notable is the\n            dictionary item 'results', which is a list of item details.\n        :rtype: dict"
        ],
        [
            "Add a Condor DAG to the given Batchmake task.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param batchmaketaskid: id of the Batchmake task for this DAG\n        :type batchmaketaskid: int | long\n        :param dagfilename: Filename of the DAG file\n        :type dagfilename: string\n        :param dagmanoutfilename: Filename of the DAG processing output\n        :type dagmanoutfilename: string\n        :returns: The created Condor DAG DAO\n        :rtype: dict"
        ],
        [
            "Add a Condor DAG job to the Condor DAG associated with this\n        Batchmake task\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param batchmaketaskid: id of the Batchmake task for this DAG\n        :type batchmaketaskid: int | long\n        :param jobdefinitionfilename: Filename of the definition file for the\n            job\n        :type jobdefinitionfilename: string\n        :param outputfilename: Filename of the output file for the job\n        :type outputfilename: string\n        :param errorfilename: Filename of the error file for the job\n        :type errorfilename: string\n        :param logfilename: Filename of the log file for the job\n        :type logfilename: string\n        :param postfilename: Filename of the post script log file for the job\n        :type postfilename: string\n        :return: The created Condor job DAO.\n        :rtype: dict"
        ],
        [
            "Extract DICOM metadata from the given item\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: id of the item to be extracted\n        :type item_id: int | long\n        :return: the item revision DAO\n        :rtype: dict"
        ],
        [
            "Log in to get the real token using the temporary token and otp.\n\n        :param temp_token: The temporary token or id returned from normal login\n        :type temp_token: string\n        :param one_time_pass: The one-time pass to be sent to the underlying\n            multi-factor engine.\n        :type one_time_pass: string\n        :returns: A standard token for interacting with the web api.\n        :rtype: string"
        ],
        [
            "Create a big thumbnail for the given bitstream with the given width.\n        It is used as the main image of the given item and shown in the item\n        view page.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param bitstream_id: The bitstream from which to create the thumbnail.\n        :type bitstream_id: int | long\n        :param item_id: The item on which to set the thumbnail.\n        :type item_id: int | long\n        :param width: (optional) The width in pixels to which to resize (aspect\n            ratio will be preserved). Defaults to 575.\n        :type width: int | long\n        :returns: The ItemthumbnailDao object that was created.\n        :rtype: dict"
        ],
        [
            "Create a 100x100 small thumbnail for the given item. It is used for\n        preview purpose and displayed in the 'preview' and 'thumbnails'\n        sidebar sections.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param item_id: The item on which to set the thumbnail.\n        :type item_id: int | long\n        :returns: The item object (with the new thumbnail id) and the path\n            where the newly created thumbnail is stored.\n        :rtype: dict"
        ],
        [
            "Search item metadata using Apache Solr.\n\n        :param query: The Apache Lucene search query.\n        :type query: string\n        :param token: (optional) A valid token for the user in question.\n        :type token: None | string\n        :param limit: (optional) The limit of the search.\n        :type limit: int | long\n        :returns: The list of items that match the search query.\n        :rtype: list[dict]"
        ],
        [
            "Create a new scalar data point.\n\n        :param token: A valid token for the user in question.\n        :type token: string\n        :param community_id: The id of the community that owns the producer.\n        :type community_id: int | long\n        :param producer_display_name: The display name of the producer.\n        :type producer_display_name: string\n        :param metric_name: The metric name that identifies which trend this\n            point belongs to.\n        :type metric_name: string\n        :param producer_revision: The repository revision of the producer that\n            produced this value.\n        :type producer_revision: int | long | string\n        :param submit_time: The submit timestamp. Must be parsable with PHP\n            strtotime().\n        :type submit_time: string\n        :param value: The value of the scalar.\n        :type value: float\n        :param config_item_id: (optional) If this value pertains to a specific\n            configuration item, pass its id here.\n        :type config_item_id: int | long\n        :param test_dataset_id: (optional) If this value pertains to a\n            specific test dataset, pass its id here.\n        :type test_dataset_id: int | long\n        :param truth_dataset_id: (optional) If this value pertains to a\n            specific ground truth dataset, pass its id here.\n        :type truth_dataset_id: int | long\n        :param silent: (optional) If true, do not perform threshold-based email\n            notifications for this scalar.\n        :type silent: bool\n        :param unofficial: (optional) If true, creates an unofficial scalar\n            visible only to the user performing the submission.\n        :type unofficial: bool\n        :param build_results_url: (optional) A URL for linking to build results\n            for this submission.\n        :type build_results_url: string\n        :param branch: (optional) The branch name in the source repository for\n            this submission.\n        :type branch: string\n        :param submission_id: (optional) The id of the submission.\n        :type submission_id: int | long\n        :param submission_uuid: (optional) The uuid of the submission. If one\n            does not exist, it will be created.\n        :type submission_uuid: string\n        :type branch: string\n        :param params: (optional) Any key/value pairs that should be displayed\n            with this scalar result.\n        :type params: dict\n        :param extra_urls: (optional) Other URL's that should be displayed with\n            with this scalar result. Each element of the list should be a dict\n            with the following keys: label, text, href\n        :type extra_urls: list[dict]\n        :param unit: (optional) The unit of the scalar value.\n        :type unit: string\n        :param reproduction_command: (optional) The command to reproduce this\n            scalar.\n        :type reproduction_command: string\n        :returns: The scalar object that was created.\n        :rtype: dict"
        ],
        [
            "Upload a JSON file containing numeric scoring results to be added as\n        scalars. File is parsed and then deleted from the server.\n\n        :param token: A valid token for the user in question.\n        :param filepath: The path to the JSON file.\n        :param community_id: The id of the community that owns the producer.\n        :param producer_display_name: The display name of the producer.\n        :param producer_revision: The repository revision of the producer\n            that produced this value.\n        :param submit_time: The submit timestamp. Must be parsable with PHP\n            strtotime().\n        :param config_item_id: (optional) If this value pertains to a specific\n            configuration item, pass its id here.\n        :param test_dataset_id: (optional) If this value pertains to a\n            specific test dataset, pass its id here.\n        :param truth_dataset_id: (optional) If this value pertains to a\n            specific ground truth dataset, pass its id here.\n        :param parent_keys: (optional) Semicolon-separated list of parent keys\n            to look for numeric results under. Use '.' to denote nesting, like\n            in normal javascript syntax.\n        :param silent: (optional) If true, do not perform threshold-based email\n            notifications for this scalar.\n        :param unofficial: (optional) If true, creates an unofficial scalar\n            visible only to the user performing the submission.\n        :param build_results_url: (optional) A URL for linking to build results\n            for this submission.\n        :param branch: (optional) The branch name in the source repository for\n            this submission.\n        :param params: (optional) Any key/value pairs that should be displayed\n            with this scalar result.\n        :type params: dict\n        :param extra_urls: (optional) Other URL's that should be displayed with\n            with this scalar result. Each element of the list should be a dict\n            with the following keys: label, text, href\n        :type extra_urls: list of dicts\n        :returns: The list of scalars that were created."
        ],
        [
            "Obtain particular version of the doc at key."
        ],
        [
            "Find a hash value for the linear combination of invocation methods."
        ],
        [
            "Connects to a Siemens S7 PLC.\n\n        Connects to a Siemens S7 using the Snap7 library.\n        See [the snap7 documentation](http://snap7.sourceforge.net/) for\n        supported models and more details.\n\n        It's not currently possible to query the device for available pins,\n        so `available_pins()` returns an empty list. Instead, you should use\n        `map_pin()` to map to a Merker, Input or Output in the PLC. The\n        internal id you should use is a string following this format:\n        '[DMQI][XBWD][0-9]+.?[0-9]*' where:\n\n        * [DMQI]: D for DB, M for Merker, Q for Output, I for Input\n        * [XBWD]: X for bit, B for byte, W for word, D for dword\n        * [0-9]+: Address of the resource\n        * [0-9]*: Bit of the address (type X only, ignored in others)\n\n        For example: 'IB100' will read a byte from an input at address 100 and\n        'MX50.2' will read/write bit 2 of the Merker at address 50. It's not\n        allowed to write to inputs (I), but you can read/write Outpus, DBs and\n        Merkers. If it's disallowed by the PLC, an exception will be thrown by\n        python-snap7 library.\n\n        For this library to work, it might be needed to change some settings\n        in the PLC itself. See\n        [the snap7 documentation](http://snap7.sourceforge.net/) for more\n        information. You also need to put the PLC in RUN mode. Not however that\n        having a Ladder program downloaded, running and modifying variables\n        will probably interfere with inputs and outputs, so put it in RUN mode,\n        but preferably without a downloaded program.\n\n        @arg address IP address of the module.\n        @arg rack rack where the module is installed.\n        @arg slot slot in the rack where the module is installed.\n        @arg port port the PLC is listenning to.\n\n        @throw RuntimeError if something went wrong\n        @throw any exception thrown by `snap7`'s methods."
        ],
        [
            "Connects to an Arduino UNO on serial port `port`.\n\n        @throw RuntimeError can't connect to Arduino"
        ],
        [
            "Returns a map of nodename to average fitness value for this block.\n        Assumes that required resources have been checked on all nodes."
        ],
        [
            "Returns a list of available drivers names."
        ],
        [
            "Maps a pin number to a physical device pin.\n\n        To make it easy to change drivers without having to refactor a lot of\n        code, this library does not use the names set by the driver to identify\n        a pin. This function will map a number, that will be used by other\n        functions, to a physical pin represented by the drivers pin id. That\n        way, if you need to use another pin or change the underlying driver\n        completly, you only need to redo the mapping.\n\n        If you're developing a driver, keep in mind that your driver will not\n        know about this. The other functions will translate the mapped pin to\n        your id before calling your function.\n\n        @arg abstract_pin_id the id that will identify this pin in the\n        other function calls. You can choose what you want.\n\n        @arg physical_pin_id the id returned in the driver.\n            See `AbstractDriver.available_pins`. Setting it to None removes the\n            mapping."
        ],
        [
            "Sets pin `pin` to `direction`.\n\n        The pin should support the requested mode. Calling this function\n        on a unmapped pin does nothing. Calling it with a unsupported direction\n        throws RuntimeError.\n\n        If you're developing a driver, you should implement\n        _set_pin_direction(self, pin, direction) where `pin` will be one of\n        your internal IDs. If a pin is set to OUTPUT, put it on LOW state.\n\n        @arg pin pin id you've set using `AbstractDriver.map_pin`\n        @arg mode a value from `AbstractDriver.Direction`\n\n        @throw KeyError if pin isn't mapped.\n        @throw RuntimeError if direction is not supported by pin."
        ],
        [
            "Gets the `ahio.Direction` this pin was set to.\n\n        If you're developing a driver, implement _pin_direction(self, pin)\n\n        @arg pin the pin you want to see the mode\n        @returns the `ahio.Direction` the pin is set to\n\n        @throw KeyError if pin isn't mapped."
        ],
        [
            "Sets pin `pin` to `type`.\n\n        The pin should support the requested mode. Calling this function\n        on a unmapped pin does nothing. Calling it with a unsupported mode\n        throws RuntimeError.\n\n        If you're developing a driver, you should implement\n        _set_pin_type(self, pin, ptype) where `pin` will be one of your\n        internal IDs. If a pin is set to OUTPUT, put it on LOW state.\n\n        @arg pin pin id you've set using `AbstractDriver.map_pin`\n        @arg mode a value from `AbstractDriver.PortType`\n\n        @throw KeyError if pin isn't mapped.\n        @throw RuntimeError if type is not supported by pin."
        ],
        [
            "Gets the `ahio.PortType` this pin was set to.\n\n        If you're developing a driver, implement _pin_type(self, pin)\n\n        @arg pin the pin you want to see the mode\n        @returns the `ahio.PortType` the pin is set to\n\n        @throw KeyError if pin isn't mapped."
        ],
        [
            "Sets the output to the given value.\n\n        Sets `pin` output to given value. If the pin is in INPUT mode, do\n        nothing. If it's an analog pin, value should be in write_range.\n        If it's not in the allowed range, it will be clamped. If pin is in\n        digital mode, value can be `ahio.LogicValue` if `pwm` = False, or a\n        number between 0 and 1 if `pwm` = True. If PWM is False, the pin will\n        be set to HIGH or LOW, if `pwm` is True, a PWM wave with the given\n        cycle will be created. If the pin does not support PWM and `pwm` is\n        True, raise RuntimeError. The `pwm` argument should be ignored in case\n        the pin is analog. If value is not valid for the given\n        pwm/analog|digital combination, raise TypeError.\n\n        If you're developing a driver, implement _write(self, pin, value, pwm)\n\n        @arg pin the pin to write to\n        @arg value the value to write on the pin\n        @arg pwm wether the output should be a pwm wave\n\n        @throw RuntimeError if the pin does not support PWM and `pwm` is True.\n        @throw TypeError if value is not valid for this pin's mode and pwm\n               value.\n        @throw KeyError if pin isn't mapped."
        ],
        [
            "Reads value from pin `pin`.\n\n        Returns the value read from pin `pin`. If it's an analog pin, returns\n        a number in analog.input_range. If it's digital, returns\n        `ahio.LogicValue`.\n\n        If you're developing a driver, implement _read(self, pin)\n\n        @arg pin the pin to read from\n        @returns the value read from the pin\n\n        @throw KeyError if pin isn't mapped."
        ],
        [
            "Sets the analog reference to `reference`\n\n        If the driver supports per pin reference setting, set pin to the\n        desired reference. If not, passing None means set to all, which is the\n        default in most hardware. If only per pin reference is supported and\n        pin is None, raise RuntimeError.\n\n        If you're developing a driver, implement\n        _set_analog_reference(self, reference, pin). Raise RuntimeError if pin\n        was set but is not supported by the platform.\n\n        @arg reference the value that describes the analog reference. See\n            `AbstractDriver.analog_references`\n        @arg pin if the the driver supports it, the pin that will use\n            `reference` as reference. None for all.\n\n        @throw RuntimeError if pin is None on a per pin only hardware, or if\n            it's a valid pin on a global only analog reference hardware.\n        @throw KeyError if pin isn't mapped."
        ],
        [
            "Returns the analog reference.\n\n        If the driver supports per pin analog reference setting, returns the\n        reference for pin `pin`. If pin is None, returns the global analog\n        reference. If only per pin reference is supported and pin is None,\n        raise RuntimeError.\n\n        If you're developing a driver, implement _analog_reference(self, pin)\n\n        @arg pin if the the driver supports it, the pin that will use\n            `reference` as reference. None for all.\n\n        @returns the reference used for pin\n\n        @throw RuntimeError if pin is None on a per pin only hardware, or if\n            it's a valid pin on a global only analog reference hardware.\n        @throw KeyError if pin isn't mapped."
        ],
        [
            "Sets PWM frequency, if supported by hardware\n\n        If the driver supports per pin frequency setting, set pin to the\n        desired frequency. If not, passing None means set to all. If only per\n        pin frequency is supported and pin is None, raise RuntimeError.\n\n        If you're developing a driver, implement\n        _set_pwm_frequency(self, frequency, pin). Raise RuntimeError if pin\n        was set but is not supported by the platform.\n\n        @arg frequency pwm frequency to be set, in Hz\n        @arg pin if the the driver supports it, the pin that will use\n            `frequency` as pwm frequency. None for all/global.\n\n        @throw RuntimeError if pin is None on a per pin only hardware, or if\n            it's a valid pin on a global only hardware.\n        @throw KeyError if pin isn't mapped."
        ],
        [
            "Integrate SIR epidemic model\n\n    Simulate a very basic deterministic SIR system.\n\n    :param 2x1 numpy array y0: initial conditions\n    :param Ntimestep length numpy array time: Vector of time points that \\\n    solution is returned at\n    :param float beta: transmission rate\n    :param float gamma: recovery rate\n\n    :returns: (2)x(Ntimestep) numpy array Xsim: first row S(t), second row I(t)"
        ],
        [
            "Return the URL of the server.\n\n        :returns: URL of the server\n        :rtype: string"
        ],
        [
            "Returns an estimate for the maximum amount of memory to be consumed by numpy arrays."
        ],
        [
            "Create coverage reports and open them in the browser."
        ],
        [
            "Start a Modbus server.\n\n        The following classes are available with their respective named\n        parameters:\n        \n        ModbusTcpClient\n            host: The host to connect to (default 127.0.0.1)\n            port: The modbus port to connect to (default 502)\n            source_address: The source address tuple to bind to (default ('', 0))\n            timeout: The timeout to use for this socket (default Defaults.Timeout)\n\n        ModbusUdpClient\n            host: The host to connect to (default 127.0.0.1)\n            port: The modbus port to connect to (default 502)\n            timeout: The timeout to use for this socket (default None)\n\n        ModbusSerialClient\n            method: The method to use for connection (asii, rtu, binary)\n            port: The serial port to attach to\n            stopbits: The number of stop bits to use (default 1)\n            bytesize: The bytesize of the serial messages (default 8 bits)\n            parity: Which kind of parity to use (default None)\n            baudrate: The baud rate to use for the serial device\n            timeout: The timeout between serial requests (default 3s)\n\n        When configuring the ports, the following convention should be\n        respected:\n        \n        portname: C1:13 -> Coil on device 1, address 13\n\n        The letters can be:\n\n        C = Coil\n        I = Input\n        R = Register\n        H = Holding\n\n        @arg configuration a string that instantiates one of those classes.\n\n        @throw RuntimeError can't connect to Arduino"
        ],
        [
            "Return an exception given status and error codes.\n\n    :param status_code: HTTP status code.\n    :type status_code: None | int\n    :param error_code: Midas Server error code.\n    :type error_code: None | int\n    :param value: Message to display.\n    :type value: string\n    :returns: Exception.\n    :rtype : pydas.exceptions.ResponseError"
        ],
        [
            "Retrieve the last analog data value received for the specified pin.\n\n        :param pin: Selected pin\n\n        :return: The last value entered into the analog response table."
        ],
        [
            "Disables analog reporting for a single analog pin.\n\n        :param pin: Analog pin number. For example for A0, the number is 0.\n\n        :return: No return value"
        ],
        [
            "Disables digital reporting. By turning reporting off for this pin, reporting\n        is disabled for all 8 bits in the \"port\" -\n\n        :param pin: Pin and all pins for this port\n\n        :return: No return value"
        ],
        [
            "Enables analog reporting. By turning reporting on for a single pin.\n\n        :param pin: Analog pin number. For example for A0, the number is 0.\n\n        :return: No return value"
        ],
        [
            "Enables digital reporting. By turning reporting on for all 8 bits in the \"port\" -\n        this is part of Firmata's protocol specification.\n\n        :param pin: Pin and all pins for this port\n\n        :return: No return value"
        ],
        [
            "This method will send an extended data analog output command to the selected pin\n\n        :param pin: 0 - 127\n\n        :param data: 0 - 0xfffff"
        ],
        [
            "Get the stepper library version number.\n\n        :param timeout: specify a time to allow arduino to process and return a version\n\n        :return: the stepper version number if it was set."
        ],
        [
            "Write data to an i2c device.\n\n        :param address: i2c device address\n\n        :param args: A variable number of bytes to be sent to the device"
        ],
        [
            "This method stops an I2C_READ_CONTINUOUSLY operation for the i2c device address specified.\n\n        :param address: address of i2c device"
        ],
        [
            "This method will call the Tone library for the selected pin.\n        If the tone command is set to TONE_TONE, then the specified tone will be played.\n        Else, if the tone command is TONE_NO_TONE, then any currently playing tone will be disabled.\n        It is intended for a future release of Arduino Firmata\n\n        :param pin: Pin number\n\n        :param tone_command: Either TONE_TONE, or TONE_NO_TONE\n\n        :param frequency: Frequency of tone in hz\n\n        :param duration: Duration of tone in milliseconds\n\n        :return: No return value"
        ],
        [
            "This method \"arms\" an analog pin for its data to be latched and saved in the latching table\n        If a callback method is provided, when latching criteria is achieved, the callback function is called\n        with latching data notification. In that case, the latching table is not updated.\n\n        :param pin: Analog pin number (value following an 'A' designator, i.e. A5 = 5\n\n        :param threshold_type: ANALOG_LATCH_GT | ANALOG_LATCH_LT  | ANALOG_LATCH_GTE | ANALOG_LATCH_LTE\n\n        :param threshold_value: numerical value - between 0 and 1023\n\n        :param cb: callback method\n\n        :return: True if successful, False if parameter data is invalid"
        ],
        [
            "This method \"arms\" a digital pin for its data to be latched and saved in the latching table\n        If a callback method is provided, when latching criteria is achieved, the callback function is called\n        with latching data notification. In that case, the latching table is not updated.\n\n        :param pin: Digital pin number\n\n        :param threshold_type: DIGITAL_LATCH_HIGH | DIGITAL_LATCH_LOW\n\n        :param cb: callback function\n\n        :return: True if successful, False if parameter data is invalid"
        ],
        [
            "Configure a pin as a servo pin. Set pulse min, max in ms.\n\n        :param pin: Servo Pin.\n\n        :param min_pulse: Min pulse width in ms.\n\n        :param max_pulse: Max pulse width in ms.\n\n        :return: No return value"
        ],
        [
            "Configure stepper motor prior to operation.\n\n        :param steps_per_revolution: number of steps per motor revolution\n\n        :param stepper_pins: a list of control pin numbers - either 4 or 2"
        ],
        [
            "Move a stepper motor for the number of steps at the specified speed\n\n        :param motor_speed: 21 bits of data to set motor speed\n\n        :param number_of_steps: 14 bits for number of steps & direction\n                                positive is forward, negative is reverse"
        ],
        [
            "Request the stepper library version from the Arduino.\n        To retrieve the version after this command is called, call\n        get_stepper_version"
        ],
        [
            "open the serial port using the configuration data\n        returns a reference to this instance"
        ],
        [
            "This method continually runs. If an incoming character is available on the serial port\n        it is read and placed on the _command_deque\n        @return: Never Returns"
        ],
        [
            "Set the brightness level for the entire display\n        @param brightness: brightness level (0 -15)"
        ],
        [
            "Populate the bit map with the supplied \"shape\" and color\n        and then write the entire bitmap to the display\n        @param shape: pattern to display\n        @param color: color for the pattern"
        ],
        [
            "Write the entire buffer to the display"
        ],
        [
            "Set all led's to off."
        ],
        [
            "This method handles the incoming digital message.\n        It stores the data values in the digital response table.\n        Data is stored for all 8 bits of a  digital port\n\n        :param data: Message data from Firmata\n\n        :return: No return value."
        ],
        [
            "This method handles the incoming encoder data message and stores\n        the data in the digital response table.\n\n        :param data: Message data from Firmata\n\n        :return: No return value."
        ],
        [
            "This method handles the incoming sonar data message and stores\n        the data in the response table.\n\n        :param data: Message data from Firmata\n\n        :return: No return value."
        ],
        [
            "This method will send a Sysex command to Firmata with any accompanying data\n\n        :param sysex_command: sysex command\n\n        :param sysex_data: data for command\n\n        :return : No return value."
        ],
        [
            "This method is used to transmit a non-sysex command.\n\n        :param command: Command to send to firmata includes command + data formatted by caller\n\n        :return : No return value."
        ],
        [
            "Send the reset command to the Arduino.\n        It resets the response tables to their initial values\n\n        :return: No return value"
        ],
        [
            "This method handles the incoming string data message from Firmata.\n        The string is printed to the console\n\n        :param data: Message data from Firmata\n\n        :return: No return value.s"
        ],
        [
            "This method starts the thread that continuously runs to receive and interpret\n        messages coming from Firmata. This must be the last method in this file\n        It also checks the deque for messages to be sent to Firmata."
        ],
        [
            "Use requests to fetch remote content"
        ],
        [
            "Combine finder_image_urls and extender_image_urls,\n        remove duplicate but keep order"
        ],
        [
            "Find image URL in background-image\n\n    Example:\n    <div style=\"width: 100%; height: 100%; background-image: url(http://distilleryimage10.ak.instagram.com/bde04558a43b11e28e5d22000a1f979a_7.jpg);\" class=\"Image iLoaded iWithTransition Frame\" src=\"http://distilleryimage10.ak.instagram.com/bde04558a43b11e28e5d22000a1f979a_7.jpg\"></div>\n    to\n    http://distilleryimage10.ak.instagram.com/bde04558a43b11e28e5d22000a1f979a_7.jpg"
        ],
        [
            "Return the node name where the ``name`` would land to"
        ],
        [
            "Return the node where the ``name`` would land to"
        ],
        [
            "Return the encoding, idletime, or refcount about the key"
        ],
        [
            "Pop a value off the tail of ``src``, push it on the head of ``dst``\n        and then return it.\n\n        This command blocks until a value is in ``src`` or until ``timeout``\n        seconds elapse, whichever is first. A ``timeout`` value of 0 blocks\n        forever.\n        Not atomic"
        ],
        [
            "RPOP a value off of the ``src`` list and LPUSH it\n        on to the ``dst`` list.  Returns the value."
        ],
        [
            "Move ``value`` from set ``src`` to set ``dst``\n        not atomic"
        ],
        [
            "Returns the members of the set resulting from the union between\n        the first set and all the successive sets."
        ],
        [
            "Store the union of sets ``src``,  ``args`` into a new\n        set named ``dest``.  Returns the number of keys in the new set."
        ],
        [
            "Sets each key in the ``mapping`` dict to its corresponding value if\n        none of the keys are already set"
        ],
        [
            "Rename key ``src`` to ``dst``"
        ],
        [
            "Rename key ``src`` to ``dst`` if ``dst`` doesn't already exist"
        ],
        [
            "Returns a list of keys matching ``pattern``"
        ],
        [
            "Returns the number of keys in the current database"
        ],
        [
            "Prepare the date in the instance state for serialization."
        ],
        [
            "Verify the signaure of an XML document with the given certificate.\n    Returns `True` if the document is signed with a valid signature.\n    Returns `False` if the document is not signed or if the signature is\n    invalid.\n\n    :param lxml.etree._Element xml: The document to sign\n    :param file stream: The private key to sign the document with\n\n    :rtype: Boolean"
        ],
        [
            "Add number of photos to each gallery."
        ],
        [
            "Set currently authenticated user as the author of the gallery."
        ],
        [
            "For each photo set it's author to currently authenticated user."
        ],
        [
            "Outputs a list of tuples with ranges or the empty list\n        According to the rfc, start or end values can be omitted"
        ],
        [
            "Removes errored ranges"
        ],
        [
            "Converts to valid byte ranges"
        ],
        [
            "Sorts and removes overlaps"
        ],
        [
            "Renders the selected social widget. You can specify optional settings\n    that will be passed  to widget template.\n\n    Sample usage:\n    {% social_widget_render widget_template ke1=val1 key2=val2 %}\n\n    For example to render Twitter follow button you can use code like this:\n    {% social_widget_render 'twitter/follow_button.html' username=\"ev\" %}"
        ],
        [
            "In-place addition\n\n        :param addend_mat: A matrix to be added on the Sparse3DMatrix object\n        :param axis: The dimension along the addend_mat is added\n        :return: Nothing (as it performs in-place operations)"
        ],
        [
            "In-place multiplication\n\n        :param multiplier: A matrix or vector to be multiplied\n        :param axis: The dim along which 'multiplier' is multiplied\n        :return: Nothing (as it performs in-place operations)"
        ],
        [
            "Updates the probability of read origin at read level\n\n        :param model: Normalization model (1: Gene->Allele->Isoform, 2: Gene->Isoform->Allele, 3: Gene->Isoform*Allele, 4: Gene*Isoform*Allele)\n        :return: Nothing (as it performs in-place operations)"
        ],
        [
            "Runs EM iterations\n\n        :param model: Normalization model (1: Gene->Allele->Isoform, 2: Gene->Isoform->Allele, 3: Gene->Isoform*Allele, 4: Gene*Isoform*Allele)\n        :param tol: Tolerance for termination\n        :param max_iters: Maximum number of iterations until termination\n        :param verbose: Display information on how EM is running\n        :return: Nothing (as it performs in-place operations)"
        ],
        [
            "Exports expected read counts\n\n        :param filename: File name for output\n        :param grp_wise: whether the report is at isoform level or gene level\n        :param reorder: whether the report should be either 'decreasing' or 'increasing' order or just 'as-is'\n        :return: Nothing but the method writes a file"
        ],
        [
            "Exports expected depths\n\n        :param filename: File name for output\n        :param grp_wise: whether the report is at isoform level or gene level\n        :param reorder: whether the report should be either 'decreasing' or 'increasing' order or just 'as-is'\n        :return: Nothing but the method writes a file"
        ],
        [
            "Writes the posterior probability of read origin\n\n        :param filename: File name for output\n        :param title: The title of the posterior probability matrix\n        :return: Nothing but the method writes a file in EMASE format (PyTables)"
        ],
        [
            "Prints nonzero rows of the read wanted"
        ],
        [
            "Transliterate `data` with the given `scheme_map`. This function is used\n  when the source scheme is a Roman scheme.\n\n  :param data: the data to transliterate\n  :param scheme_map: a dict that maps between characters in the old scheme\n                     and characters in the new scheme"
        ],
        [
            "Transliterate `data` with the given `scheme_map`. This function is used\n  when the source scheme is a Brahmic scheme.\n\n  :param data: the data to transliterate\n  :param scheme_map: a dict that maps between characters in the old scheme\n                     and characters in the new scheme"
        ],
        [
            "Detect the input's transliteration scheme.\n\n    :param text: some text data, either a `unicode` or a `str` encoded\n                 in UTF-8."
        ],
        [
            "Add a variety of default schemes."
        ],
        [
            "converts an array of integers to utf8 string"
        ],
        [
            "set the value of delta to reflect the current codepage"
        ],
        [
            "Handle unrecognised characters."
        ],
        [
            "Transliterate a Latin character equivalent to Devanagari.\n        \n        Add VIRAMA for ligatures.\n        Convert standalone to dependent vowels."
        ],
        [
            "A convenience method"
        ],
        [
            "Load and generate ``num`` number of top-level rules from the specified grammar.\n\n    :param list grammar: The grammar file to load and generate data from\n    :param int num: The number of times to generate data\n    :param output: The output destination (an open, writable stream-type object. default=``sys.stdout``)\n    :param int max_recursion: The maximum reference-recursion when generating data (default=``10``)\n    :param int seed: The seed to initialize the PRNG with. If None, will not initialize it."
        ],
        [
            "Build the ``Quote`` instance\n\n        :param list pre: The prerequisites list\n        :param bool shortest: Whether or not the shortest reference-chain (most minimal) version of the field should be generated."
        ],
        [
            "Make the list of verbs into present participles\n\n    E.g.:\n\n        empower -> empowering\n        drive -> driving"
        ],
        [
            "Deletes sent MailerMessage records"
        ],
        [
            "Load the includes of an encoding Namelist files.\n\n  This is an implementation detail of readNamelist."
        ],
        [
            "Return a dict with the data of an encoding Namelist file.\n\n  This is an implementation detail of readNamelist."
        ],
        [
            "Detect infinite recursion and prevent it.\n\n  This is an implementation detail of readNamelist.\n\n  Raises NamelistRecursionError if namFilename is in the process of being included"
        ],
        [
            "Returns the set of codepoints contained in a given Namelist file.\n\n  This is a replacement CodepointsInSubset and implements the \"#$ include\"\n  header format.\n\n  Args:\n    namFilename: The path to the  Namelist file.\n    unique_glyphs: Optional, whether to only include glyphs unique to subset.\n  Returns:\n    A set containing the glyphs in the subset."
        ],
        [
            "Returns list of CharsetInfo about supported orthographies"
        ],
        [
            "Generates header for oauth2"
        ],
        [
            "Parse oauth2 access"
        ],
        [
            "Refresh access token"
        ],
        [
            "Calls right function according to file extension"
        ],
        [
            "Call right func to save data according to file extension"
        ],
        [
            "Write json data into a file"
        ],
        [
            "Get data from json file"
        ],
        [
            "Get data from .yml file"
        ],
        [
            "Write data into a .yml file"
        ],
        [
            "Turns distances into RBF values.\n\n        Parameters\n        ----------\n        X : array\n            The raw pairwise distances.\n\n        Returns\n        -------\n        X_rbf : array of same shape as X\n            The distances in X passed through the RBF kernel."
        ],
        [
            "Learn the linear transformation to clipped eigenvalues.\n\n        Note that if min_eig isn't zero and any of the original eigenvalues\n        were exactly zero, this will leave those eigenvalues as zero.\n\n        Parameters\n        ----------\n        X : array, shape [n, n]\n            The *symmetric* input similarities. If X is asymmetric, it will be\n            treated as if it were symmetric based on its lower-triangular part."
        ],
        [
            "Learn the linear transformation to flipped eigenvalues.\n\n        Parameters\n        ----------\n        X : array, shape [n, n]\n            The *symmetric* input similarities. If X is asymmetric, it will be\n            treated as if it were symmetric based on its lower-triangular part."
        ],
        [
            "Transforms X according to the linear transformation corresponding to\n        flipping the input eigenvalues.\n\n        Parameters\n        ----------\n        X : array, shape [n_test, n]\n            The test similarities to training points.\n\n        Returns\n        -------\n        Xt : array, shape [n_test, n]\n            The transformed test similarites to training points."
        ],
        [
            "Flips the negative eigenvalues of X.\n\n        Parameters\n        ----------\n        X : array, shape [n, n]\n            The *symmetric* input similarities. If X is asymmetric, it will be\n            treated as if it were symmetric based on its lower-triangular part.\n\n        Returns\n        -------\n        Xt : array, shape [n, n]\n            The transformed training similarities."
        ],
        [
            "Learn the transformation to shifted eigenvalues. Only depends\n        on the input dimension.\n\n        Parameters\n        ----------\n        X : array, shape [n, n]\n            The *symmetric* input similarities."
        ],
        [
            "Transforms X according to the linear transformation corresponding to\n        shifting the input eigenvalues to all be at least ``self.min_eig``.\n\n        Parameters\n        ----------\n        X : array, shape [n_test, n]\n            The test similarities to training points.\n\n        Returns\n        -------\n        Xt : array, shape [n_test, n]\n            The transformed test similarites to training points. Only different\n            from X if X is the training data."
        ],
        [
            "Picks the elements of the basis to use for the given data.\n\n        Only depends on the dimension of X. If it's more convenient, you can\n        pass a single integer for X, which is the dimension to use.\n\n        Parameters\n        ----------\n        X : an integer, a :class:`Features` instance, or a list of bag features\n            The input data, or just its dimension, since only the dimension is\n            needed here."
        ],
        [
            "Transform a list of bag features into its projection series\n        representation.\n\n        Parameters\n        ----------\n        X : :class:`skl_groups.features.Features` or list of bag feature arrays\n            New data to transform. The data should all lie in [0, 1];\n            use :class:`skl_groups.preprocessing.BagMinMaxScaler` if not.\n\n        Returns\n        -------\n        X_new : integer array, shape ``[len(X), dim_]``\n            X transformed into the new space."
        ],
        [
            "Get distribution version.\n\n        This method is enhanced compared to original distutils implementation.\n        If the version string is set to a special value then instead of using\n        the actual value the real version is obtained by querying versiontools.\n\n        If versiontools package is not installed then the version is obtained\n        from the standard section of the ``PKG-INFO`` file. This file is\n        automatically created by any source distribution. This method is less\n        useful as it cannot take advantage of version control information that\n        is automatically loaded by versiontools. It has the advantage of not\n        requiring versiontools installation and that it does not depend on\n        ``setup_requires`` feature of ``setuptools``."
        ],
        [
            "Get a live version string using versiontools"
        ],
        [
            "Fit the transformer on the stacked points.\n\n        Parameters\n        ----------\n        X : :class:`Features` or list of arrays of shape ``[n_samples[i], n_features]``\n            Training set. If a Features object, it will be stacked.\n\n        any other keyword argument :\n            Passed on as keyword arguments to the transformer's ``fit()``."
        ],
        [
            "Transform the stacked points.\n\n        Parameters\n        ----------\n        X : :class:`Features` or list of bag feature arrays\n            New data to transform.\n\n        any other keyword argument :\n            Passed on as keyword arguments to the transformer's ``transform()``.\n\n        Returns\n        -------\n        X_new : :class:`Features`\n            Transformed features."
        ],
        [
            "Fit and transform the stacked points.\n\n        Parameters\n        ----------\n        X : :class:`Features` or list of bag feature arrays\n            Data to train on and transform.\n\n        any other keyword argument :\n            Passed on as keyword arguments to the transformer's ``transform()``.\n\n        Returns\n        -------\n        X_new : :class:`Features`\n            Transformed features."
        ],
        [
            "Compute the minimum and maximum to be used for later scaling.\n\n        Parameters\n        ----------\n        X : array-like, shape [n_samples, n_features]\n            The data used to compute the per-feature minimum and maximum\n            used for later scaling along the features axis."
        ],
        [
            "Scaling features of X according to feature_range.\n\n        Parameters\n        ----------\n        X : array-like with shape [n_samples, n_features]\n            Input data that will be transformed."
        ],
        [
            "Undo the scaling of X according to feature_range.\n\n        Note that if truncate is true, any truncated points will not\n        be restored exactly.\n\n        Parameters\n        ----------\n        X : array-like with shape [n_samples, n_features]\n            Input data that will be transformed."
        ],
        [
            "Choose the codewords based on a training set.\n\n        Parameters\n        ----------\n        X : :class:`skl_groups.features.Features` or list of arrays of shape ``[n_samples[i], n_features]``\n            Training set. If a Features object, it will be stacked."
        ],
        [
            "Transform a list of bag features into its bag-of-words representation.\n\n        Parameters\n        ----------\n        X : :class:`skl_groups.features.Features` or list of bag feature arrays\n            New data to transform.\n\n        Returns\n        -------\n        X_new : integer array, shape [len(X), kmeans.n_clusters]\n            X transformed into the new space."
        ],
        [
            "Checks whether the array is either integral or boolean."
        ],
        [
            "Returns argument as an integer array, converting floats if convertable.\n    Raises ValueError if it's a float array with nonintegral values."
        ],
        [
            "Signal the start of the process.\n\n        Parameters\n        ----------\n        total : int\n            The total number of steps in the process, or None if unknown."
        ],
        [
            "Builds FLANN indices for each bag."
        ],
        [
            "Gets within-bag distances for each bag."
        ],
        [
            "r'''\n    Estimates the linear inner product \\int p q between two distributions,\n    based on kNN distances."
        ],
        [
            "r'''\n    Estimates \\int p^2 based on kNN distances.\n\n    In here because it's used in the l2 distance, above.\n\n    Returns array of shape (num_Ks,)."
        ],
        [
            "Topologically sort a DAG, represented by a dict of child => set of parents.\n    The dependency dict is destroyed during operation.\n\n    Uses the Kahn algorithm: http://en.wikipedia.org/wiki/Topological_sorting\n    Not a particularly good implementation, but we're just running it on tiny\n    graphs."
        ],
        [
            "Ks as an array and type-checked."
        ],
        [
            "The dictionary of arguments to give to FLANN."
        ],
        [
            "Sets up for divergence estimation \"from\" new data \"to\" X.\n        Builds FLANN indices for each bag, and maybe gets within-bag distances.\n\n        Parameters\n        ----------\n        X : list of arrays or :class:`skl_groups.features.Features`\n            The bags to search \"to\".\n\n        get_rhos : boolean, optional, default False\n            Compute within-bag distances :attr:`rhos_`. These are only needed\n            for some divergence functions or if do_sym is passed, and they'll\n            be computed (and saved) during :meth:`transform` if they're not\n            computed here.\n\n            If you're using Jensen-Shannon divergence, a higher max_K may\n            be needed once it sees the number of points in the transformed bags,\n            so the computation here might be wasted."
        ],
        [
            "If unstacked, convert to stacked. If stacked, do nothing."
        ],
        [
            "Copies the Feature object. Makes a copy of the features array.\n\n        Parameters\n        ----------\n        stack : boolean, optional, default False\n            Whether to stack the copy if this one is unstacked.\n\n        copy_meta : boolean, optional, default False\n            Also copy the metadata. If False, metadata in both points to the\n            same object."
        ],
        [
            "Make a Features object with no metadata; points to the same features."
        ],
        [
            "Specify the data to which kernel values should be computed.\n\n        Parameters\n        ----------\n        X : list of arrays or :class:`skl_groups.features.Features`\n            The bags to compute \"to\"."
        ],
        [
            "Transform a list of bag features into a matrix of its mean features.\n\n        Parameters\n        ----------\n        X : :class:`skl_groups.features.Features` or list of bag feature arrays\n            Data to transform.\n\n        Returns\n        -------\n        X_new : array, shape ``[len(X), X.dim]``\n            X transformed into its means."
        ],
        [
            "Start listening to the server"
        ],
        [
            "Connect to the server\n\n        :raise ConnectionError: If socket cannot establish a connection"
        ],
        [
            "Disconnect from the server"
        ],
        [
            "Send a command to the server\n\n        :param string command: command to send"
        ],
        [
            "Read a line from the server. Data is read from the socket until a character ``\\n`` is found\n\n        :return: the read line\n        :rtype: string"
        ],
        [
            "Read a block from the server. Lines are read until a character ``.`` is found\n\n        :return: the read block\n        :rtype: string"
        ],
        [
            "Read a block and return the result as XML\n\n        :return: block as xml\n        :rtype: xml.etree.ElementTree"
        ],
        [
            "Analyse an OpenStreetMap changeset."
        ],
        [
            "Get information about number of changesets, blocks and mapping days of a\n    user, using both the OSM API and the Mapbox comments APIself."
        ],
        [
            "Return a dictionary with id, user, user_id, bounds, date of creation\n    and all the tags of the changeset.\n\n    Args:\n        changeset: the XML string of the changeset."
        ],
        [
            "Get the changeset using the OSM API and return the content as a XML\n    ElementTree.\n\n    Args:\n        changeset: the id of the changeset."
        ],
        [
            "Get the metadata of a changeset using the OSM API and return it as a XML\n    ElementTree.\n\n    Args:\n        changeset: the id of the changeset."
        ],
        [
            "Read the first feature from the geojson and return it as a Polygon\n        object."
        ],
        [
            "Filter the changesets that intersects with the geojson geometry."
        ],
        [
            "Set the fields of this class with the metadata of the analysed\n        changeset."
        ],
        [
            "Add suspicion reason and set the suspicious flag."
        ],
        [
            "Execute the count and verify_words methods."
        ],
        [
            "Verify the fields source, imagery_used and comment of the changeset\n        for some suspect words."
        ],
        [
            "Verify if the software used in the changeset is a powerfull_editor."
        ],
        [
            "Count the number of elements created, modified and deleted by the\n        changeset and analyses if it is a possible import, mass modification or\n        a mass deletion."
        ],
        [
            "Get a stream URI from a playlist URI, ``uri``.\n    Unwraps nested playlists until something that's not a playlist is found or\n    the ``timeout`` is reached."
        ],
        [
            "Start asynchronous HTTP Server on an individual process.\n\n        :param request_handler: Sanic request handler with middleware\n        :param error_handler: Sanic error handler with middleware\n        :param debug: enables debug output (slows server)\n        :param request_timeout: time in seconds\n        :param ssl: SSLContext\n        :param sock: Socket for the server to accept connections from\n        :param request_max_size: size in bytes, `None` for no limit\n        :param reuse_port: `True` for multiple workers\n        :param loop: asyncio compatible event loop\n        :param protocol: subclass of asyncio protocol class\n        :return: Nothing"
        ],
        [
            "Grow this Pantheon by multiplying Gods."
        ],
        [
            "Get it on."
        ],
        [
            "Compare vectors. Borrowed from A. Parish."
        ],
        [
            "This model recognizes that sex chromosomes don't always line up with\n        gender. Assign M, F, or NB according to the probabilities in p_gender."
        ],
        [
            "Accept either strings or Gods as inputs."
        ],
        [
            "Produce two gametes, an egg and a sperm, from the input strings.\n        Combine them to produce a genome a la sexual reproduction."
        ],
        [
            "Produce two gametes, an egg and a sperm, from input Gods. Combine\n        them to produce a genome a la sexual reproduction. Assign divinity\n        according to probabilities in p_divinity. The more divine the parents,\n        the more divine their offspring."
        ],
        [
            "Extract 23 'chromosomes' aka words from 'gene pool' aka list of tokens\n        by searching the list of tokens for words that are related to the given\n        egg_or_sperm_word."
        ],
        [
            "Print parents' names and epithets."
        ],
        [
            "Returns all the information regarding a specific stage run\n\n        See the `Go stage instance documentation`__ for examples.\n\n        .. __: http://api.go.cd/current/#get-stage-instance\n\n        Args:\n          counter (int): The stage instance to fetch.\n            If falsey returns the latest stage instance from :meth:`history`.\n          pipeline_counter (int): The pipeline instance for which to fetch\n            the stage. If falsey returns the latest pipeline instance.\n\n        Returns:\n          Response: :class:`gocd.api.response.Response` object"
        ],
        [
            "Performs a HTTP request to the Go server\n\n        Args:\n          path (str): The full path on the Go server to request.\n            This includes any query string attributes.\n          data (str, dict, bool, optional): If any data is present this\n            request will become a POST request.\n          headers (dict, optional): Headers to set for this particular\n            request\n\n        Raises:\n          HTTPError: when the HTTP request fails.\n\n        Returns:\n          file like object: The response from a\n            :func:`urllib2.urlopen` call"
        ],
        [
            "Make the request appear to be coming from a browser\n\n        This is to interact with older parts of Go that doesn't have a\n        proper API call to be made. What will be done:\n\n        1. If no response passed in a call to `go/api/pipelines.xml` is\n           made to get a valid session\n        2. `JSESSIONID` will be populated from this request\n        3. A request to `go/pipelines` will be so the\n           `authenticity_token` (CSRF) can be extracted. It will then\n           silently be injected into `post_args` on any POST calls that\n           doesn't start with `go/api` from this point.\n\n        Args:\n          response: a :class:`Response` object from a previously successful\n            API call. So we won't have to query `go/api/pipelines.xml`\n            unnecessarily.\n\n        Raises:\n          HTTPError: when the HTTP request fails.\n          AuthenticationFailed: when failing to get the `session_id`\n            or the `authenticity_token`."
        ],
        [
            "Return a dict as a list of lists.\n\n    >>> flatten({\"a\": \"b\"})\n    [['a', 'b']]\n    >>> flatten({\"a\": [1, 2, 3]})\n    [['a', [1, 2, 3]]]\n    >>> flatten({\"a\": {\"b\": \"c\"}})\n    [['a', 'b', 'c']]\n    >>> flatten({\"a\": {\"b\": {\"c\": \"e\"}}})\n    [['a', 'b', 'c', 'e']]\n    >>> flatten({\"a\": {\"b\": \"c\", \"d\": \"e\"}})\n    [['a', 'b', 'c'], ['a', 'd', 'e']]\n    >>> flatten({\"a\": {\"b\": \"c\", \"d\": \"e\"}, \"b\": {\"c\": \"d\"}})\n    [['a', 'b', 'c'], ['a', 'd', 'e'], ['b', 'c', 'd']]"
        ],
        [
            "Returns all the information regarding a specific pipeline run\n\n        See the `Go pipeline instance documentation`__ for examples.\n\n        .. __: http://api.go.cd/current/#get-pipeline-instance\n\n        Args:\n          counter (int): The pipeline instance to fetch.\n            If falsey returns the latest pipeline instance from :meth:`history`.\n\n        Returns:\n          Response: :class:`gocd.api.response.Response` object"
        ],
        [
            "Schedule a pipeline run\n\n        Aliased as :meth:`run`, :meth:`schedule`, and :meth:`trigger`.\n\n        Args:\n          variables (dict, optional): Variables to set/override\n          secure_variables (dict, optional): Secure variables to set/override\n          materials (dict, optional): Material revisions to be used for\n            this pipeline run. The exact format for this is a bit iffy,\n            have a look at the official\n            `Go pipeline scheduling documentation`__ or inspect a call\n            from triggering manually in the UI.\n          return_new_instance (bool): Returns a :meth:`history` compatible\n            response for the newly scheduled instance. This is primarily so\n            users easily can get the new instance number. **Note:** This is done\n            in a very naive way, it just checks that the instance number is\n            higher than before the pipeline was triggered.\n          backoff_time (float): How long between each check for\n            :arg:`return_new_instance`.\n\n         .. __: http://api.go.cd/current/#scheduling-pipelines\n\n        Returns:\n          Response: :class:`gocd.api.response.Response` object"
        ],
        [
            "Yields the output and metadata from all jobs in the pipeline\n\n        Args:\n          instance: The result of a :meth:`instance` call, if not supplied\n            the latest of the pipeline will be used.\n\n        Yields:\n          tuple: (metadata (dict), output (str)).\n\n          metadata contains:\n            - pipeline\n            - pipeline_counter\n            - stage\n            - stage_counter\n            - job\n            - job_result"
        ],
        [
            "Update template config for specified template name.\n\n        .. __: https://api.go.cd/current/#edit-template-config\n\n        Returns:\n          Response: :class:`gocd.api.response.Response` object"
        ],
        [
            "Create template config for specified template name.\n\n        .. __: https://api.go.cd/current/#create-template-config\n\n        Returns:\n          Response: :class:`gocd.api.response.Response` object"
        ],
        [
            "Delete template config for specified template name.\n\n        .. __: https://api.go.cd/current/#delete-a-template\n\n        Returns:\n          Response: :class:`gocd.api.response.Response` object"
        ],
        [
            "Returns a set of all pipelines from the last response\n\n        Returns:\n          set: Response success: all the pipelines available in the response\n               Response failure: an empty set"
        ],
        [
            "Gets an artifact directory by its path.\n\n        See the `Go artifact directory documentation`__ for example responses.\n\n        .. __: http://api.go.cd/current/#get-artifact-directory\n\n        .. note::\n          Getting a directory relies on Go creating a zip file of the\n          directory in question. Because of this Go will zip the file in\n          the background and return a 202 Accepted response. It's then up\n          to the client to check again later and get the final file.\n\n          To work with normal assumptions this :meth:`get_directory` will\n          retry itself up to ``timeout`` seconds to get a 200 response to\n          return. At that point it will then return the response as is, no\n          matter whether it's still 202 or 200. The retry is done with an\n          exponential backoff with a max value between retries. See the\n          ``backoff`` and ``max_wait`` variables.\n\n          If you want to handle the retry logic yourself then use :meth:`get`\n          and add '.zip' as a suffix on the directory.\n\n        Args:\n          path_to_directory (str): The path to the directory to get.\n            It can be nested eg ``target/dist.zip``\n          timeout (int): How many seconds we will wait in total for a\n            successful response from Go when we're receiving 202\n          backoff (float): The initial value used for backoff, raises\n            exponentially until it reaches ``max_wait``\n          max_wait (int): The max time between retries\n\n        Returns:\n          Response: :class:`gocd.api.response.Response` object\n            A successful response is a zip-file."
        ],
        [
            "Configuration loader.\n\n    Adds support for loading templates from the Flask application's instance\n    folder (``<instance_folder>/templates``)."
        ],
        [
            "Create Flask application class.\n\n    Invenio-Files-REST needs to patch the Werkzeug form parsing in order to\n    support streaming large file uploads. This is done by subclassing the Flask\n    application class."
        ],
        [
            "Initialize application object.\n\n        :param app: An instance of :class:`~flask.Flask`."
        ],
        [
            "Initialize configuration.\n\n        :param app: An instance of :class:`~flask.Flask`."
        ],
        [
            "Covert name from CamelCase to \"Normal case\".\n\n    >>> camel2word('CamelCase')\n    'Camel case'\n    >>> camel2word('CaseWithSpec')\n    'Case with spec'"
        ],
        [
            "Format a time in seconds."
        ],
        [
            "Indent representation of a dict"
        ],
        [
            "Test for existence of ``needle`` regex within ``haystack``.\n\n    Say ``escape`` to escape the ``needle`` if you aren't really using the\n    regex feature & have special characters in it."
        ],
        [
            "Mutates any attributes on ``obj`` which are classes, with link to ``obj``.\n\n    Adds a convenience accessor which instantiates ``obj`` and then calls its\n    ``setup`` method.\n\n    Recurses on those objects as well."
        ],
        [
            "Procesa TCU, CP, FEU diario.\n\n    :param df:\n    :param verbose:\n    :param convert_kwh:\n    :return:"
        ],
        [
            "Compress the log message in order to send less bytes to the wire."
        ],
        [
            "Internal bookkeeping to handle nested classes"
        ],
        [
            "Needs to be its own method so it can be called from both wantClass and\n        registerGoodClass."
        ],
        [
            "Obtiene los dataframes de los datos de PVPC con resampling diario y mensual."
        ],
        [
            "Performs sanitation of the path after validating\n\n    :param path: path to sanitize\n    :return: path\n    :raises:\n        - InvalidPath if the path doesn't start with a slash"
        ],
        [
            "Ensures the passed schema instance is compatible\n\n    :param obj: object to validate\n    :return: obj\n    :raises:\n        - IncompatibleSchema if the passed schema is of an incompatible type"
        ],
        [
            "Journey route decorator\n\n    Enables simple serialization, deserialization and validation of Flask routes with the help of Marshmallow.\n\n    :param bp: :class:`flask.Blueprint` object\n    :param args: args to pass along to `Blueprint.route`\n    :param kwargs:\n        - :strict_slashes: Enable / disable strict slashes (default False)\n        - :validate: Enable / disable body/query validation (default True)\n        - :_query: Unmarshal Query string into this schema\n        - :_body: Unmarshal JSON body into this schema\n        - :marshal_with: Serialize the output with this schema\n    :raises:\n        - ValidationError if the query parameters or JSON body fails validation"
        ],
        [
            "Attaches a flask.Blueprint to the bundle\n\n        :param bp: :class:`flask.Blueprint` object\n        :param description: Optional description string\n        :raises:\n            - InvalidBlueprint if the Blueprint is not of type `flask.Blueprint`"
        ],
        [
            "Returns the DottedRule that results from moving the dot."
        ],
        [
            "Computes the intermediate FIRST set using symbols."
        ],
        [
            "Computes the FIRST set for every symbol in the grammar.\n\n        Tenatively based on _compute_first in PLY."
        ],
        [
            "Computes the FOLLOW set for every non-terminal in the grammar.\n\n        Tenatively based on _compute_follow in PLY."
        ],
        [
            "Computes the initial closure using the START_foo production."
        ],
        [
            "Computes the next closure for rules based on the symbol we got.\n\n        Args:\n            rules - an iterable of DottedRules\n            symbol - a string denoting the symbol we've just seen\n\n        Returns: frozenset of DottedRules"
        ],
        [
            "Fills out the entire closure based on some initial dotted rules.\n\n        Args:\n            rules - an iterable of DottedRules\n\n        Returns: frozenset of DottedRules"
        ],
        [
            "Initializes Journey extension\n\n        :param app: App passed from constructor or directly to init_app\n        :raises:\n            - NoBundlesAttached if no bundles has been attached attached"
        ],
        [
            "Returns simple info about registered blueprints\n\n        :return: Tuple containing endpoint, path and allowed methods for each route"
        ],
        [
            "Checks if a bundle exists at the provided path\n\n        :param path: Bundle path\n        :return: bool"
        ],
        [
            "Attaches a bundle object\n\n        :param bundle: :class:`flask_journey.BlueprintBundle` object\n        :raises:\n            - IncompatibleBundle if the bundle is not of type `BlueprintBundle`\n            - ConflictingPath if a bundle already exists at bundle.path\n            - MissingBlueprints if the bundle doesn't contain any blueprints"
        ],
        [
            "Register and return info about the registered blueprint\n\n        :param bp: :class:`flask.Blueprint` object\n        :param bundle_path: the URL prefix of the bundle\n        :param child_path: blueprint relative to the bundle path\n        :return: Dict with info about the blueprint"
        ],
        [
            "Returns detailed information about registered blueprint routes matching the `BlueprintBundle` path\n\n        :param app: App instance to obtain rules from\n        :param base_path: Base path to return detailed route info for\n        :return: List of route detail dicts"
        ],
        [
            "Computes the precedence of terminal and production.\n\n        The precedence of a terminal is it's level in the PRECEDENCE tuple. For\n        a production, the precedence is the right-most terminal (if it exists).\n        The default precedence is DEFAULT_PREC - (LEFT, 0).\n\n        Returns:\n            precedence - dict[terminal | production] = (assoc, level)"
        ],
        [
            "Generates the ACTION and GOTO tables for the grammar.\n\n        Returns:\n            action - dict[state][lookahead] = (action, ...)\n            goto - dict[state][just_reduced] = new_state"
        ],
        [
            "Return the antecedents and the consequent of a definite clause."
        ],
        [
            "Auxiliary routine to implement tt_entails."
        ],
        [
            "Return a list of all propositional symbols in x."
        ],
        [
            "Return True if the propositional logic expression is true in the model,\n    and False if it is false. If the model does not specify the value for\n    every proposition, this may return None to indicate 'not obvious';\n    this may happen even when the expression is tautological."
        ],
        [
            "See if the clauses are true in a partial model."
        ],
        [
            "A variable is an Expr with no args and a lowercase symbol as the op."
        ],
        [
            "Remove the sentence's clauses from the KB."
        ],
        [
            "Updates the cache with setting values from the database."
        ],
        [
            "Search game to determine best action; use alpha-beta pruning.\n    This version cuts off search and uses an evaluation function."
        ],
        [
            "Return the value to player; 1 for win, -1 for loss, 0 otherwise."
        ],
        [
            "If X wins with this move, return 1; if O return -1; else return 0."
        ],
        [
            "Return true if there is a line through move on board for player."
        ],
        [
            "Update a dict, or an object with slots, according to `entries` dict.\n\n    >>> update({'a': 1}, a=10, b=20)\n    {'a': 10, 'b': 20}\n    >>> update(Struct(a=1), a=10, b=20)\n    Struct(a=10, b=20)"
        ],
        [
            "Pick n samples from seq at random, with replacement, with the\n    probability of each element in proportion to its corresponding\n    weight."
        ],
        [
            "Return a random-sample function that picks from seq weighted by weights."
        ],
        [
            "Format args with the first argument as format string, and write.\n    Return the last arg, or format itself if there are no args."
        ],
        [
            "Try to find some reasonable name for the object."
        ],
        [
            "Open a file based at the AIMA root directory."
        ],
        [
            "Just count how many times each value of each input attribute\n    occurs, conditional on the target value. Count the different\n    target values too."
        ],
        [
            "Number of bits to represent the probability distribution in values."
        ],
        [
            "Layered feed-forward network."
        ],
        [
            "Given a list of learning algorithms, have them vote."
        ],
        [
            "Return a predictor that takes a weighted vote."
        ],
        [
            "Copy dataset, replicating each example in proportion to its weight."
        ],
        [
            "Leave one out cross-validation over the dataset."
        ],
        [
            "Generate a DataSet with n examples."
        ],
        [
            "2 inputs are chosen uniformly from (0.0 .. 2.0]; output is xor of ints."
        ],
        [
            "Compare various learners on various datasets using cross-validation.\n    Print results as a table."
        ],
        [
            "Check that my fields make sense."
        ],
        [
            "Add an example to the list of examples, checking it first."
        ],
        [
            "Raise ValueError if example has any invalid values."
        ],
        [
            "Returns the number used for attr, which can be a name, or -n .. n-1."
        ],
        [
            "Return a copy of example, with non-input attributes replaced by None."
        ],
        [
            "Add an observation o to the distribution."
        ],
        [
            "Include o among the possible observations, whether or not\n        it's been observed yet."
        ],
        [
            "Return a random sample from the distribution."
        ],
        [
            "Return true if we remove a value."
        ],
        [
            "Minimum-remaining-values heuristic."
        ],
        [
            "Least-constraining-values heuristic."
        ],
        [
            "Prune neighbor values inconsistent with var=value."
        ],
        [
            "Maintain arc consistency."
        ],
        [
            "Solve a CSP by stochastic hillclimbing on the number of conflicts."
        ],
        [
            "Return the value that will give var the least number of conflicts.\n    If there is a tie, choose at random."
        ],
        [
            "Return the number of conflicts var=val has with other variables."
        ],
        [
            "Start accumulating inferences from assuming var=value."
        ],
        [
            "Rule out var=value."
        ],
        [
            "Return the partial assignment implied by the current inferences."
        ],
        [
            "Undo a supposition and all inferences from it."
        ],
        [
            "Return a list of variables in current assignment that are in conflict"
        ],
        [
            "The number of conflicts, as recorded with each assignment.\n        Count conflicts in row and in up, down diagonals. If there\n        is a queen there, it can't conflict with itself, so subtract 3."
        ],
        [
            "Assign var, and keep track of conflicts."
        ],
        [
            "Record conflicts caused by addition or deletion of a Queen."
        ],
        [
            "Find the best segmentation of the string of characters, given the\n    UnigramTextModel P."
        ],
        [
            "Encodes text, using a code which is a permutation of the alphabet."
        ],
        [
            "Build up a random sample of text nwords words long, using\n        the conditional probability given the n-1 preceding words."
        ],
        [
            "Index a whole collection of files."
        ],
        [
            "Index the text of a document."
        ],
        [
            "Compute a score for this word on this docid."
        ],
        [
            "Present the results as a list."
        ],
        [
            "Get results for the query and present them."
        ],
        [
            "Return a score for text based on how common letters pairs are."
        ],
        [
            "Search for a decoding of the ciphertext."
        ],
        [
            "Score is product of word scores, unigram scores, and bigram scores.\n        This can get very small, so we use logs and exp."
        ],
        [
            "Returns a ``SettingDict`` object."
        ],
        [
            "The expected utility of doing a in state s, according to the MDP and U."
        ],
        [
            "Return the state that results from going in this direction."
        ],
        [
            "Returns a ``SettingDict`` object for this queryset."
        ],
        [
            "Creates and returns an object of the appropriate type for ``value``."
        ],
        [
            "Returns ``True`` if this model should be used to store ``value``.\n\n        Checks if ``value`` is an instance of ``value_type``. Override this\n        method if you need more advanced behaviour. For example, to distinguish\n        between single and multi-line text."
        ],
        [
            "One possible schedule function for simulated annealing"
        ],
        [
            "Call genetic_algorithm on the appropriate parts of a problem.\n    This requires the problem to have states that can mate and mutate,\n    plus a value method that scores states."
        ],
        [
            "Return a random Boggle board of size n x n.\n    We represent a board as a linear list of letters."
        ],
        [
            "Print the board in a 2-d array."
        ],
        [
            "Return a list of lists, where the i-th element is the list of indexes\n    for the neighbors of square i."
        ],
        [
            "If n2 is a perfect square, return its square root, else raise error."
        ],
        [
            "List the nodes reachable in one step from this node."
        ],
        [
            "Fig. 3.10"
        ],
        [
            "Return a list of nodes forming the path from the root to this node."
        ],
        [
            "Return a new individual crossing self and other."
        ],
        [
            "Make a digraph into an undirected graph by adding symmetric edges."
        ],
        [
            "Add a link from A and B of given distance, and also add the inverse\n        link if the graph is undirected."
        ],
        [
            "Add a link from A to B of given distance, in one direction only."
        ],
        [
            "h function is straight-line distance from a node's state to goal."
        ],
        [
            "In the leftmost empty column, try all non-conflicting rows."
        ],
        [
            "Place the next queen at the given row."
        ],
        [
            "Set the board, and find all the words in it."
        ],
        [
            "The total score for the words found, according to the rules."
        ],
        [
            "Wrap the agent's program to print its input and output. This will let\n    you see what the agent is doing in the environment."
        ],
        [
            "An agent that keeps track of what locations are clean or dirty."
        ],
        [
            "Run the environment for one time step. If the\n        actions and exogenous changes are independent, this method will\n        do.  If there are interactions between them, you'll need to\n        override this method."
        ],
        [
            "Run the Environment for given number of time steps."
        ],
        [
            "Return all things exactly at a given location."
        ],
        [
            "Add a thing to the environment, setting its location. For\n        convenience, if thing is an agent program we make a new agent\n        for it. (Shouldn't need to override this."
        ],
        [
            "Remove a thing from the environment."
        ],
        [
            "Return all things within radius of location."
        ],
        [
            "By default, agent perceives things within a default radius."
        ],
        [
            "Move a thing to a new location."
        ],
        [
            "Put walls around the entire perimeter of the grid."
        ],
        [
            "Parse a list of words; according to the grammar.\n        Leave results in the chart."
        ],
        [
            "Add edge to chart, and see if it extends or predicts another edge."
        ],
        [
            "For each edge expecting a word of this category here, extend the edge."
        ],
        [
            "Add to chart any rules for B that could help extend this edge."
        ],
        [
            "See what edges can be extended by this edge."
        ],
        [
            "Adds a ``SettingDict`` object for the ``Setting`` model to the context as\n    ``SETTINGS``. Automatically creates non-existent settings with an empty\n    string as the default value."
        ],
        [
            "Return the factor for var in bn's joint distribution given e.\n    That is, bn's full joint distribution, projected to accord with e,\n    is the pointwise product of these factors for bn's variables."
        ],
        [
            "Eliminate var from all factors by summing over its values."
        ],
        [
            "Yield every way of extending e with values for all vars."
        ],
        [
            "Is event consistent with the given evidence?"
        ],
        [
            "Sample an event from bn that's consistent with the evidence e;\n    return the event and its weight, the likelihood that the event\n    accords to the evidence."
        ],
        [
            "Show the probabilities rounded and sorted by key, for the\n        sake of portable doctests."
        ],
        [
            "Add a node to the net. Its parents must already be in the\n        net, and its variable must not."
        ],
        [
            "Multiply two factors, combining their variables."
        ],
        [
            "Make a factor eliminating var by summing over its values."
        ],
        [
            "Return my probabilities; must be down to one variable."
        ],
        [
            "Strips all whitespace from a minidom XML node and its children\n\n    This operation is made in-place."
        ],
        [
            "Takes a hls color and converts to proper hue \n        Bulbs use a BGR order instead of RGB"
        ],
        [
            "Takes your standard rgb color \n        and converts it to a proper hue value"
        ],
        [
            "Takes an HTML hex code\n        and converts it to a proper hue value"
        ],
        [
            "Wait for x seconds\n            each wait command is 100ms"
        ],
        [
            "Return json from querying Web Api\n\n\t\tArgs:\n\t\t\tview: django view function.\n\t\t\trequest: http request object got from django.\n\t\t\t\t\n\t\tReturns: json format dictionary"
        ],
        [
            "put text on on screen\n    a tuple as first argument tells absolute position for the text\n    does not change TermCursor position\n    args = list of optional position, formatting tokens and strings"
        ],
        [
            "get user input without echo"
        ],
        [
            "get character. waiting for key"
        ],
        [
            "tweaked from source of base"
        ],
        [
            "getProcessOwner - Get the process owner of a pid\n\n        @param pid <int> - process id\n\n        @return - None if process not found or can't be determined. Otherwise, a dict: \n            {\n                uid  - Owner UID\n                name - Owner name, or None if one cannot be determined\n            }"
        ],
        [
            "scanProcessForCwd - Searches a given pid's cwd for a given pattern\n\n            @param pid <int> - A running process ID on this system\n            @param searchPortion <str> - Any portion of directory to search\n            @param isExactMatch <bool> Default False - If match should be exact, otherwise a partial match is performed.\n\n            @return <dict> - If result is found, the following dict is returned. If no match found on the given pid, or pid is not found running, None is returned.\n                {\n                    'searchPortion' : The passed search pattern\n                    'pid'           : The passed pid (as an integer)\n                    'owner'         : String of process owner, or uid if no mapping can be found, or \"unknown\" if neither could be determined.\n                    'cmdline'       : Commandline string\n                    'cwd'           : The exact cwd of matched process\n                }"
        ],
        [
            "scanAllProcessesForCwd - Scans all processes on the system for a given search pattern.\n\n            @param searchPortion <str> - Any portion of directory to search\n            @param isExactMatch <bool> Default False - If match should be exact, otherwise a partial match is performed.\n\n        @return - <dict> - A dictionary of pid -> cwdResults for each pid that matched the search pattern. For format of \"cwdResults\", @see scanProcessForCwd"
        ],
        [
            "scanProcessForMapping - Searches a given pid's mappings for a certain pattern.\n\n            @param pid <int> - A running process ID on this system\n            @param searchPortion <str> - A mapping for which to search, example: libc or python or libz.so.1. Give empty string to return all mappings.\n            @param isExactMatch <bool> Default False - If match should be exact, otherwise a partial match is performed.\n            @param ignoreCase <bool> Default False - If True, search will be performed case-insensitively\n\n            @return <dict> - If result is found, the following dict is returned. If no match found on the given pid, or pid is not found running, None is returned.\n                {\n                    'searchPortion' : The passed search pattern\n                    'pid'           : The passed pid (as an integer)\n                    'owner'         : String of process owner, or uid if no mapping can be found, or \"unknown\" if neither could be determined.\n                    'cmdline'       : Commandline string\n                    'matchedMappings' : All mappings likes that matched the given search pattern\n                }"
        ],
        [
            "scanAllProcessesForMapping - Scans all processes on the system for a given search pattern.\n\n            @param searchPortion <str> - A mapping for which to search, example: libc or python or libz.so.1. Give empty string to return all mappings.\n            @param isExactMatch <bool> Default False - If match should be exact, otherwise a partial match is performed.\n            @param ignoreCase <bool> Default False - If True, search will be performed case-insensitively\n\n        @return - <dict> - A dictionary of pid -> mappingResults for each pid that matched the search pattern. For format of \"mappingResults\", @see scanProcessForMapping"
        ],
        [
            "scanProcessForOpenFile - Scans open FDs for a given pid to see if any are the provided searchPortion\n\n            @param searchPortion <str> - Filename to check\n            @param isExactMatch <bool> Default True - If match should be exact, otherwise a partial match is performed.\n            @param ignoreCase <bool> Default False - If True, search will be performed case-insensitively\n\n        @return -  If result is found, the following dict is returned. If no match found on the given pid, or the pid is not found running, None is returned.\n                {\n                    'searchPortion' : The search portion provided\n                    'pid'           : The passed pid (as an integer)\n                    'owner'         : String of process owner, or \"unknown\" if one could not be determined\n                    'cmdline'       : Commandline string\n                    'fds'           : List of file descriptors assigned to this file (could be mapped several times)\n                    'filenames'     : List of the filenames matched\n                }"
        ],
        [
            "scanAllProcessessForOpenFile - Scans all processes on the system for a given filename\n\n            @param searchPortion <str> - Filename to check\n            @param isExactMatch <bool> Default True - If match should be exact, otherwise a partial match is performed.\n            @param ignoreCase <bool> Default False - If True, search will be performed case-insensitively\n\n        @return - <dict> - A dictionary of pid -> mappingResults for each pid that matched the search pattern. For format of \"mappingResults\", @see scanProcessForOpenFile"
        ],
        [
            "Create and connect to socket for TCP communication with hub."
        ],
        [
            "Send TCP command to hub and return response."
        ],
        [
            "Receive TCP response, looping to get whole thing or timeout."
        ],
        [
            "Get current light data as dictionary with light zids as keys."
        ],
        [
            "Get current light data, set and return as list of Bulb objects."
        ],
        [
            "Set brightness of bulb."
        ],
        [
            "Set color and brightness of bulb."
        ],
        [
            "Update light objects to their current values."
        ],
        [
            "This function takes a file path beginning with edgar and stores the form in a directory.\n        The default directory is sec_filings but can be changed through a keyword argument."
        ],
        [
            "read file as is"
        ],
        [
            "Clean up after ourselves, removing created files.\n    @param {[String]} A list of file paths specifying the files we've created\n        during run. Will all be deleted.\n    @return {None}"
        ],
        [
            "Create an index file in the given location, supplying known lists of\n    present image files and subdirectories.\n    @param {String} root_dir - The root directory of the entire crawl. Used to\n        ascertain whether the given location is the top level.\n    @param {String} location - The current directory of the crawl. The index\n        file will be created here.\n    @param {[String]} image_files - A list of image file names in the location.\n        These will be displayed in the index file's gallery.\n    @param {[String]} dirs - The subdirectories of the location directory.\n        These will be displayed as links further down the file structure.\n    @param {Boolean=False} force_no_processing - If True, do not attempt to\n        actually process thumbnails, PIL images or anything. Simply index\n        <img> tags with original file src attributes.\n    @return {String} The full path (location plus filename) of the newly\n        created index file. Intended for usage cleaning up created files."
        ],
        [
            "Crawl the root directory downwards, generating an index HTML file in each\n    directory on the way down.\n    @param {String} root_dir - The top level directory to crawl down from. In\n        normal usage, this will be '.'.\n    @param {Boolean=False} force_no_processing - If True, do not attempt to\n        actually process thumbnails, PIL images or anything. Simply index\n        <img> tags with original file src attributes.\n    @return {[String]} Full file paths of all created files."
        ],
        [
            "Get an instance of PIL.Image from the given file.\n    @param {String} dir_path - The directory containing the image file\n    @param {String} image_file - The filename of the image file within dir_path\n    @return {PIL.Image} An instance of the image file as a PIL Image, or None\n        if the functionality is not available. This could be because PIL is not\n        present, or because it can't process the given file type."
        ],
        [
            "Get base-64 encoded data as a string for the given image. Fallback to return\n    fallback_image_file if cannot get the image data or img is None.\n    @param {Image} img - The PIL Image to get src data for\n    @param {String} fallback_image_file - The filename of the image file,\n        to be used when image data capture fails\n    @return {String} The base-64 encoded image data string, or path to the file\n        itself if not supported."
        ],
        [
            "Get a PIL.Image from the given image file which has been scaled down to\n    THUMBNAIL_WIDTH wide.\n    @param {String} dir_path - The directory containing the image file\n    @param {String} image_file - The filename of the image file within dir_path\n    @return {PIL.Image} An instance of the thumbnail as a PIL Image, or None\n        if the functionality is not available. See _get_image_from_file for\n        details."
        ],
        [
            "Run the image server. This is blocking. Will handle user KeyboardInterrupt\n    and other exceptions appropriately and return control once the server is\n    stopped.\n    @return {None}"
        ],
        [
            "Generate indexes and run server from the given directory downwards.\n    @param {String} dir_path - The directory path (absolute, or relative to CWD)\n    @return {None}"
        ],
        [
            "USE carefully ^^"
        ],
        [
            "random blending masks"
        ],
        [
            "z value as like a seed"
        ],
        [
            "Converts a permutation into a permutation matrix.\n\n    `matches` is a dictionary whose keys are vertices and whose values are\n    partners. For each vertex ``u`` and ``v``, entry (``u``, ``v``) in the\n    returned matrix will be a ``1`` if and only if ``matches[u] == v``.\n\n    Pre-condition: `matches` must be a permutation on an initial subset of the\n    natural numbers.\n\n    Returns a permutation matrix as a square NumPy array."
        ],
        [
            "Convenience function that creates a block matrix with the specified\n    blocks.\n\n    Each argument must be a NumPy matrix. The two top matrices must have the\n    same number of rows, as must the two bottom matrices. The two left matrices\n    must have the same number of columns, as must the two right matrices."
        ],
        [
            "Returns the adjacency matrix of a bipartite graph whose biadjacency\n    matrix is `A`.\n\n    `A` must be a NumPy array.\n\n    If `A` has **m** rows and **n** columns, then the returned matrix has **m +\n    n** rows and columns."
        ],
        [
            "Returns the Boolean matrix in the same shape as `D` with ones exactly\n    where there are nonzero entries in `D`.\n\n    `D` must be a NumPy array."
        ],
        [
            "Returns the result of incrementing `version`.\n\n    If `which` is not specified, the \"patch\" part of the version number will be\n    incremented.  If `which` is specified, it must be ``'major'``, ``'minor'``,\n    or ``'patch'``. If it is one of these three strings, the corresponding part\n    of the version number will be incremented instead of the patch number.\n\n    Returns a string representing the next version number.\n\n    Example::\n\n        >>> bump_version('2.7.1')\n        '2.7.2'\n        >>> bump_version('2.7.1', 'minor')\n        '2.8.0'\n        >>> bump_version('2.7.1', 'major')\n        '3.0.0'"
        ],
        [
            "Gets the current version from the specified file.\n\n    This function assumes the file includes a string of the form::\n\n        <pattern> = <version>"
        ],
        [
            "Prints the specified message and exits the program with the specified\n    exit status."
        ],
        [
            "Tags the current version."
        ],
        [
            "initialize with templates' path\n        parameters\n          templates_path    str    the position of templates directory\n          global_data       dict   globa data can be got in any templates"
        ],
        [
            "Render data with template, return html unicodes.\n        parameters\n          template   str  the template's filename\n          data       dict the data to render"
        ],
        [
            "Render data with template and then write to path"
        ],
        [
            "shortcut to render data with `template`. Just add exception\n    catch to `renderer.render`"
        ],
        [
            "Get the DataFrame for this view.\n        Defaults to using `self.dataframe`.\n\n        This method should always be used rather than accessing `self.dataframe`\n        directly, as `self.dataframe` gets evaluated only once, and those results\n        are cached for all subsequent requests.\n\n        You may want to override this if you need to provide different\n        dataframes depending on the incoming request."
        ],
        [
            "Indexes the row based on the request parameters."
        ],
        [
            "Returns the row the view is displaying.\n\n        You may want to override this if you need to provide non-standard\n        queryset lookups.  Eg if objects are referenced using multiple\n        keyword arguments in the url conf."
        ],
        [
            "The paginator instance associated with the view, or `None`."
        ],
        [
            "Return a single page of results, or `None` if pagination is disabled."
        ],
        [
            "parse config, return a dict"
        ],
        [
            "shortcut to render data with `template` and then write to `path`.\n    Just add exception catch to `renderer.render_to`"
        ],
        [
            "Parse ascii post source, return dict"
        ],
        [
            "parse post source files name to datetime object"
        ],
        [
            "run a server binding to port"
        ],
        [
            "get source files' update time"
        ],
        [
            "watch files for changes, if changed, rebuild blog. this thread\n        will quit if the main process ends"
        ],
        [
            "Deploy new blog to current directory"
        ],
        [
            "Temporarily update the context to use the BlockContext for the given alias."
        ],
        [
            "Find the first matching block in the current block_context"
        ],
        [
            "Load a series of widget libraries."
        ],
        [
            "Return a list of widget names for the provided field."
        ],
        [
            "Allow reuse of a block within a template.\n\n    {% reuse '_myblock' foo=bar %}\n\n    If passed a list of block names, will use the first that matches:\n\n    {% reuse list_of_block_names .... %}"
        ],
        [
            "When dealing with optgroups, ensure that the value is properly force_text'd."
        ],
        [
            "Message instances are namedtuples of type `Message`.\n        The date field is already serialized in datetime.isoformat ECMA-262 format"
        ],
        [
            "Send a message to a list of users without passing through `django.contrib.messages`\n\n    :param users: an iterable containing the recipients of the messages\n    :param level: message level\n    :param message_text: the string containing the message\n    :param extra_tags: like the Django api, a string containing extra tags for the message\n    :param date: a date, different than the default timezone.now\n    :param url: an optional url\n    :param fail_silently: not used at the moment"
        ],
        [
            "Send a message to all users aka broadcast.\n\n    :param level: message level\n    :param message_text: the string containing the message\n    :param extra_tags: like the Django api, a string containing extra tags for the message\n    :param date: a date, different than the default timezone.now\n    :param url: an optional url\n    :param fail_silently: not used at the moment"
        ],
        [
            "Mark message instance as read for user.\n    Returns True if the message was `unread` and thus actually marked as `read` or False in case\n    it is already `read` or it does not exist at all.\n\n    :param user: user instance for the recipient\n    :param message: a Message instance to mark as read"
        ],
        [
            "Mark all message instances for a user as read.\n\n    :param user: user instance for the recipient"
        ],
        [
            "Renders a list of archived messages for the current user"
        ],
        [
            "Retrieve unread messages for current user, both from the inbox and\n        from other storages"
        ],
        [
            "If the message level was configured for being stored and request.user\n        is not anonymous, save it to the database. Otherwise, let some other\n        class handle the message.\n\n        Notice: controls like checking the message is not empty and the level\n        is above the filter need to be performed here, but it could happen\n        they'll be performed again later if the message does not need to be\n        stored."
        ],
        [
            "persistent messages are already in the database inside the 'archive',\n        so we can say they're already \"stored\".\n        Here we put them in the inbox, or remove from the inbox in case the\n        messages were iterated.\n\n        messages contains only new msgs if self.used==True\n        else contains both new and unread messages"
        ],
        [
            "Like the base class method, prepares a list of messages for storage\n        but avoid to do this for `models.Message` instances."
        ],
        [
            "Main entry point for script."
        ],
        [
            "initializes a base logger\n\n    you can use this to init a logger in any of your files.\n    this will use config.py's LOGGER param and logging.dictConfig to configure\n    the logger for you.\n\n    :param int|logging.LEVEL base_level: desired base logging level\n    :param int|logging.LEVEL verbose_level: desired verbose logging level\n    :param dict logging_dict: dictConfig based configuration.\n     used to override the default configuration from config.py\n    :rtype: `python logger`"
        ],
        [
            "Configure an object with a user-supplied factory."
        ],
        [
            "sets the global verbosity level for console and the jocker_lgr logger.\n\n    :param bool is_verbose_output: should be output be verbose"
        ],
        [
            "returns a configuration object\n\n    :param string config_file: path to config file"
        ],
        [
            "generates a Dockerfile, builds an image and pushes it to DockerHub\n\n    A `Dockerfile` will be generated by Jinja2 according to the `varsfile`\n    imported. If build is true, an image will be generated from the\n    `outputfile` which is the generated Dockerfile and committed to the\n    image:tag string supplied to `build`.\n    If push is true, a build will be triggered and the produced image\n    will be pushed to DockerHub upon completion.\n\n    :param string varsfile: path to file with variables.\n    :param string templatefile: path to template file to use.\n    :param string outputfile: path to output Dockerfile.\n    :param string configfile: path to yaml file with docker-py config.\n    :param bool dryrun: mock run.\n    :param build: False or the image:tag to build to.\n    :param push: False or the image:tag to build to. (triggers build)\n    :param bool verbose: verbose output."
        ],
        [
            "since the push process outputs a single unicode string consisting of\n        multiple JSON formatted \"status\" lines, we need to parse it so that it\n        can be read as multiple strings.\n\n        This will receive the string as an input, count curly braces and ignore\n        any newlines. When the curly braces stack is 0, it will append the\n        entire string it has read up until then to a list and so forth.\n\n        :param string: the string to parse\n        :rtype: list of JSON's"
        ],
        [
            "Uploads an image file to Imgur"
        ],
        [
            "Return true if the IP address is in dotted decimal notation."
        ],
        [
            "Return true if the IP address is in binary notation."
        ],
        [
            "Return true if the IP address is in octal notation."
        ],
        [
            "Return true if the IP address is in decimal notation."
        ],
        [
            "Function internally used to check if the given netmask\n    is of the specified notation."
        ],
        [
            "Return true if the netmask is in bits notatation."
        ],
        [
            "Return true if the netmask is in wildcard bits notatation."
        ],
        [
            "Dotted decimal notation to decimal conversion."
        ],
        [
            "Decimal to dotted decimal notation conversion."
        ],
        [
            "Hexadecimal to decimal conversion."
        ],
        [
            "Octal to decimal conversion."
        ],
        [
            "Binary to decimal conversion."
        ],
        [
            "Generate a table to convert a whole byte to binary.\n    This code was taken from the Python Cookbook, 2nd edition - O'Reilly."
        ],
        [
            "Decimal to binary conversion."
        ],
        [
            "Bits to decimal conversion."
        ],
        [
            "Wildcard bits to decimal conversion."
        ],
        [
            "Function internally used to detect the notation of the\n    given IP or netmask."
        ],
        [
            "Internally used to convert IPs and netmasks to other notations."
        ],
        [
            "Convert among IP address notations.\n\n    Given an IP address, this function returns the address\n    in another notation.\n\n    @param ip: the IP address.\n    @type ip: integers, strings or object with an appropriate __str()__ method.\n\n    @param notation: the notation of the output (default: IP_DOT).\n    @type notation: one of the IP_* constants, or the equivalent strings.\n\n    @param inotation: force the input to be considered in the given notation\n                    (default the notation of the input is autodetected).\n    @type inotation: one of the IP_* constants, or the equivalent strings.\n\n    @param check: force the notation check on the input.\n    @type check: True force the check, False force not to check and None\n                do the check only if the inotation is unknown.\n\n    @return: a string representing the IP in the selected notation.\n\n    @raise ValueError: raised when the input is in unknown notation."
        ],
        [
            "Convert a netmask to another notation."
        ],
        [
            "Sum two IP addresses."
        ],
        [
            "Subtract two IP addresses."
        ],
        [
            "Return the bits notation of the netmask."
        ],
        [
            "Return the wildcard bits notation of the netmask."
        ],
        [
            "Set the IP address and the netmask."
        ],
        [
            "Change the current IP."
        ],
        [
            "Change the current netmask."
        ],
        [
            "Return true if the given address in amongst the usable addresses,\n        or if the given CIDR is contained in this one."
        ],
        [
            "Upload a file to S3 possibly using the multi-part uploader\n        Return the key uploaded"
        ],
        [
            "Copy a file from one bucket into another"
        ],
        [
            "Recursively upload a ``folder`` into a backet.\n\n        :param bucket: bucket where to upload the folder to\n        :param folder: the folder location in the local file system\n        :param key: Optional key where the folder is uploaded\n        :param skip: Optional list of files to skip\n        :param content_types: Optional dictionary mapping suffixes to\n            content types\n        :return: a coroutine"
        ],
        [
            "Coroutine for uploading a single file"
        ],
        [
            "Trigger an ``event`` on this channel"
        ],
        [
            "Connect to a Pusher websocket"
        ],
        [
            "Handle websocket incoming messages"
        ],
        [
            "Constant time string comparison"
        ],
        [
            "Decodes a limited set of HTML entities."
        ],
        [
            "Set signature passphrases"
        ],
        [
            "Set encryption passphrases"
        ],
        [
            "Set algorithms used for sealing. Defaults can not be overridden."
        ],
        [
            "Get algorithms used for sealing"
        ],
        [
            "Private function for setting options used for sealing"
        ],
        [
            "Verify sealed data signature"
        ],
        [
            "Encode data with specific algorithm"
        ],
        [
            "Decode data with specific algorithm"
        ],
        [
            "Add signature to data"
        ],
        [
            "Verify and remove signature"
        ],
        [
            "Verify and remove magic"
        ],
        [
            "Add header to data"
        ],
        [
            "Read header from data"
        ],
        [
            "Remove header from data"
        ],
        [
            "Read header version from data"
        ],
        [
            "Get algorithm info"
        ],
        [
            "Generate and return PBKDF2 key"
        ],
        [
            "Update algorithm definition type dictionaries"
        ],
        [
            "This function populates the internal tableOfContents list with the contents\n        of the zip file TOC. If the server does not support ranged requests, this will raise\n        and exception. It will also throw an exception if the TOC cannot be found."
        ],
        [
            "This function will extract a single file from the remote zip without downloading\n        the entire zip file. The filename argument should match whatever is in the 'filename'\n        key of the tableOfContents."
        ],
        [
            "Does photometry and estimates uncertainties by calculating the scatter around a linear fit to the data\n        in each orientation. This function is called by other functions and generally the user will not need\n        to interact with it directly."
        ],
        [
            "Creates the figure shown in ``adjust_aperture`` for visualization purposes. Called by other functions\n        and generally not called by the user directly.\n\n        Args: \n            img: The data frame to be passed through to be plotted. A cutout of the ``integrated_postcard``"
        ],
        [
            "Identify the centroid positions for the target star at all epochs. Useful for verifying that there is\n        no correlation between flux and position, as might be expected for high proper motion stars."
        ],
        [
            "Identify the \"expected\" flux value at the time of each observation based on the \n        Kepler long-cadence data, to ensure variations observed are not the effects of a single\n        large starspot. Only works if the target star was targeted for long or short cadence\n        observations during the primary mission."
        ],
        [
            "Estimate the photometric uncertainties on each data point following Equation A.2 of The Paper.\n        Based on the kepcal package of Dan Foreman-Mackey."
        ],
        [
            "Dump single field."
        ],
        [
            "Disassemble serialized protocol buffers file."
        ],
        [
            "Find all missing imports in list of Pbd instances."
        ],
        [
            "Write fasta_dict to fasta_file\n\n    :param fasta_dict: returned by fasta_file_to_dict\n    :param fasta_file: output file can be a string path or a file object\n    :param line_char_limit: None = no limit (default)\n    :return: None"
        ],
        [
            "Helper function to record and log an error message\n\n        :param line_data: dict\n        :param error_info: dict\n        :param logger:\n        :param log_level: int\n        :return:"
        ],
        [
            "checks whether child features are within the coordinate boundaries of parent features\n\n        :return:"
        ],
        [
            "1. get a list of CDS with the same parent\n        2. sort according to strand\n        3. calculate and validate phase"
        ],
        [
            "Transfer children from old_parent to new_parent\n\n        :param old_parent: feature_id(str) or line_index(int) or line_data(dict) or feature\n        :param new_parent: feature_id(str) or line_index(int) or line_data(dict)\n        :return: List of children transferred"
        ],
        [
            "Marks line_data and all of its associated feature's 'line_status' as 'removed', does not actually remove the line_data from the data structure.\n        The write function checks the 'line_status' when writing the gff file.\n        Find the root parent of line_data of type root_type, remove all of its descendants.\n        If the root parent has a parent with no children after the remove, remove the root parent's parent recursively.\n\n        :param line_data:\n        :param root_type:\n        :return:"
        ],
        [
            "given a filename, return the ABFs ID string."
        ],
        [
            "Determine the protocol used to record an ABF file"
        ],
        [
            "given the bytestring ABF header, make and launch HTML."
        ],
        [
            "iterate over every sweep"
        ],
        [
            "read the header and populate self with information about comments"
        ],
        [
            "given a sweep, return the protocol as condensed sequence.\n        This is better for comparing similarities and determining steps.\n        There should be no duplicate numbers."
        ],
        [
            "return the average of part of the current sweep."
        ],
        [
            "Return a sweep which is the average of multiple sweeps.\n        For now, standard deviation is lost."
        ],
        [
            "create kernel based on this ABF info."
        ],
        [
            "Get the filtered sweepY of the current sweep.\n        Only works if self.kernel has been generated."
        ],
        [
            "Given a list of list of dicts, return just the dicts."
        ],
        [
            "given a key, return a list of values from the matrix with that key."
        ],
        [
            "given a recarray, return it as a list of dicts."
        ],
        [
            "given text, make it a temporary HTML file and launch it."
        ],
        [
            "show everything we can about an object's projects and methods."
        ],
        [
            "Put 2d numpy data into a temporary HTML file."
        ],
        [
            "given a string or a path to an XML file, return an XML object."
        ],
        [
            "mono-exponential curve."
        ],
        [
            "return a list of Is where the data first crosses above threshold."
        ],
        [
            "Try to format anything as a 2D matrix with column names."
        ],
        [
            "save something to a pickle file"
        ],
        [
            "convert a dictionary to a pretty formatted string."
        ],
        [
            "determine the comment cooked in the protocol."
        ],
        [
            "scan an ABF directory and subdirectory. Try to do this just once.\n    Returns ABF files, SWHLab files, and groups."
        ],
        [
            "given an ABF file name, return the ABF of its parent."
        ],
        [
            "given an ABF and the groups dict, return the ID of its parent."
        ],
        [
            "given an ABF, find the parent, return that line of experiments.txt"
        ],
        [
            "given a path or list of files, return ABF IDs."
        ],
        [
            "May be given an ABF object or filename."
        ],
        [
            "return an \"FTP\" object after logging in."
        ],
        [
            "upload everything from localFolder into the current FTP folder."
        ],
        [
            "Only scott should do this. Upload new version to site."
        ],
        [
            "use the GUI to ask for a string."
        ],
        [
            "use the GUI to pop up a message."
        ],
        [
            "use the GUI to ask YES or NO."
        ],
        [
            "check out the arguments and figure out what to do."
        ],
        [
            "provide all stats on the first AP."
        ],
        [
            "return average of a feature divided by sweep."
        ],
        [
            "continuously monitor a folder for new abfs and try to analyze them.\n    This is intended to watch only one folder, but can run multiple copies."
        ],
        [
            "easy way to plot a gain function."
        ],
        [
            "draw vertical lines at comment points. Defaults to seconds."
        ],
        [
            "stamp the bottom with file info."
        ],
        [
            "makes a new matplotlib figure with default dims and DPI.\n    Also labels it with pA or mV depending on ABF."
        ],
        [
            "Save the pylab figure somewhere.\n    If fname==False, show it instead.\n    Height force > dpi force\n    if a tag is given instead of a filename, save it alongside the ABF"
        ],
        [
            "if the module is in this path, load it from the local folder."
        ],
        [
            "Called to update the state of the iterator.  This methods\n        receives the set of task ids from the previous set of tasks\n        together with the launch information to allow the output\n        values to be parsed using the output_extractor. This data is then\n        used to determine the next desired point in the parameter\n        space by calling the _update_state method."
        ],
        [
            "When dynamic, not all argument values may be available."
        ],
        [
            "Summarizes the trace of values used to update the DynamicArgs\n        and the arguments subsequently returned. May be used to\n        implement the summary method."
        ],
        [
            "Takes as input a list or tuple of two elements. First the\n        value returned by incrementing by 'stepsize' followed by the\n        value returned after a 'stepsize' decrement."
        ],
        [
            "given a filename or ABF object, try to analyze it."
        ],
        [
            "frame the current matplotlib plot with ABF info, and optionally save it.\n    Note that this is entirely independent of the ABFplot class object.\n    if saveImage is False, show it instead.\n\n    Datatype should be:\n        * plot\n        * experiment"
        ],
        [
            "make sure a figure is ready."
        ],
        [
            "save the existing figure. does not close it."
        ],
        [
            "plot every sweep of an ABF file."
        ],
        [
            "plot the current sweep protocol."
        ],
        [
            "plot the protocol of all sweeps."
        ],
        [
            "Given ABFs and TIFs formatted long style, rename each of them to prefix their number with a different number.\n\n    Example: 2017_10_11_0011.abf\n    Becomes: 2017_10_11_?011.abf\n    where ? can be any character."
        ],
        [
            "given a list of files, return a dict organized by extension."
        ],
        [
            "given files and cells, return a dict of files grouped by cell."
        ],
        [
            "populate class properties relating to files in the folder."
        ],
        [
            "generate list of cells with links. keep this simple.\n        automatically generates splash page and regnerates frames."
        ],
        [
            "generate a data view for every ABF in the project folder."
        ],
        [
            "hyperpolarization step. Use to calculate tau and stuff."
        ],
        [
            "IC steps. Use to determine gain function."
        ],
        [
            "IC steps. See how hyperpol. step affects things."
        ],
        [
            "repeated membrane tests."
        ],
        [
            "fast sweeps, 1 step per sweep, for clean IV without fast currents."
        ],
        [
            "repeated membrane tests, likely with drug added. Maybe IPSCs."
        ],
        [
            "combination of membrane test and IV steps."
        ],
        [
            "OBSOLETE WAY TO INDEX A FOLDER."
        ],
        [
            "A custom save method that handles figuring out when something is activated or deactivated."
        ],
        [
            "It is impossible to delete an activatable model unless force is True. This function instead sets it to inactive."
        ],
        [
            "Write to file_handle if supplied, othewise print output"
        ],
        [
            "A helper method that supplies the root directory name given a\n        timestamp."
        ],
        [
            "The log contains the tids and corresponding specifications\n        used during launch with the specifications in JSON format."
        ],
        [
            "All launchers should call this method to write the info file\n        at the end of the launch. The .info file is saved given\n        setup_info supplied by _setup_launch into the\n        root_directory. When called without setup_info, the existing\n        info file is updated with the end-time."
        ],
        [
            "Launches processes defined by process_commands, but only\n        executes max_concurrency processes at a time; if a process\n        completes and there are still outstanding processes to be\n        executed, the next processes are run until max_concurrency is\n        reached again."
        ],
        [
            "A succinct summary of the Launcher configuration.  Unlike the\n        repr, a summary does not have to be complete but must supply\n        key information relevant to the user."
        ],
        [
            "The method that actually runs qsub to invoke the python\n        process with the necessary commands to trigger the next\n        collation step and next block of jobs."
        ],
        [
            "This method handles static argument specifiers and cases where\n        the dynamic specifiers cannot be queued before the arguments\n        are known."
        ],
        [
            "Aggregates all process_commands and the designated output files into a\n        list, and outputs it as JSON, after which the wrapper script is called."
        ],
        [
            "Performs consistency checks across all the launchers."
        ],
        [
            "Launches all available launchers."
        ],
        [
            "Runs the review process for all the launchers."
        ],
        [
            "Helper to prompt the user for input on the commandline."
        ],
        [
            "The implementation in the base class simply checks there is no\n        clash between the metadata and data keys."
        ],
        [
            "Returns the full path for saving the file, adding an extension\n        and making the filename unique as necessary."
        ],
        [
            "Returns a boolean indicating whether the filename has an\n        appropriate extension for this class."
        ],
        [
            "Data may be either a PIL Image object or a Numpy array."
        ],
        [
            "return \"YYYY-MM-DD\" when the file was modified."
        ],
        [
            "returns a dict of active folders with days as keys."
        ],
        [
            "given some data and a list of X posistions, return the normal\n    distribution curve as a Y point at each of those Xs."
        ],
        [
            "show basic info about ABF class variables."
        ],
        [
            "read the ABF header and save it HTML formatted."
        ],
        [
            "use 1 colormap for the whole abf. You can change it!."
        ],
        [
            "return self.dataY around a time point. All units are seconds.\n        if thisSweep==False, the time point is considered to be experiment time\n            and an appropriate sweep may be selected. i.e., with 10 second\n            sweeps and timePint=35, will select the 5s mark of the third sweep"
        ],
        [
            "RETURNS filtered trace. Desn't filter it in place."
        ],
        [
            "Raises a ValidationError for any ActivatableModel that has ForeignKeys or OneToOneFields that will\n    cause cascading deletions to occur. This function also raises a ValidationError if the activatable\n    model has not defined a Boolean field with the field name defined by the ACTIVATABLE_FIELD_NAME variable\n    on the model."
        ],
        [
            "Helper function to convet an Args object to a HoloViews Table"
        ],
        [
            "Method to define the positional arguments and keyword order\n        for pretty printing."
        ],
        [
            "Formats the elements of an argument set appropriately"
        ],
        [
            "Returns a dictionary like object with the lists of values\n        collapsed by their respective key. Useful to find varying vs\n        constant keys and to find how fast keys vary."
        ],
        [
            "A succinct summary of the argument specifier. Unlike the repr,\n        a summary does not have to be complete but must supply the\n        most relevant information about the object to the user."
        ],
        [
            "Returns the specs, the remaining kwargs and whether or not the\n        constructor was called with kwarg or explicit specs."
        ],
        [
            "Convenience method to inspect the available argument values in\n        human-readable format. The ordering of keys is determined by\n        how quickly they vary.\n\n        The exclude list allows specific keys to be excluded for\n        readability (e.g. to hide long, absolute filenames)."
        ],
        [
            "The lexical sort order is specified by a list of string\n        arguments. Each string is a key name prefixed by '+' or '-'\n        for ascending and descending sort respectively. If the key is\n        not found in the operand's set of varying keys, it is ignored."
        ],
        [
            "Simple replacement for numpy linspace"
        ],
        [
            "Parses the log file generated by a launcher and returns\n        dictionary with tid keys and specification values.\n\n        Ordering can be maintained by setting dict_type to the\n        appropriate constructor (i.e. OrderedDict). Keys are converted\n        from unicode to strings for kwarg use."
        ],
        [
            "Writes the supplied specifications to the log path. The data\n        may be supplied as either as a an Args or as a list of\n        dictionaries.\n\n        By default, specifications will be appropriately appended to\n        an existing log file. This can be disabled by setting\n        allow_append to False."
        ],
        [
            "Load all the files in a given directory selecting only files\n        with the given extension if specified. The given kwargs are\n        passed through to the normal constructor."
        ],
        [
            "Return the fields specified in the pattern using Python's\n        formatting mini-language."
        ],
        [
            "Loads the files that match the given pattern."
        ],
        [
            "From the pattern decomposition, finds the absolute paths\n        matching the pattern."
        ],
        [
            "Convenience method to directly chain a pattern processed by\n        FilePattern into a FileInfo instance.\n\n        Note that if a default filetype has been set on FileInfo, the\n        filetype argument may be omitted."
        ],
        [
            "Load the file contents into the supplied Table using the\n        specified key and filetype. The input table should have the\n        filenames as values which will be replaced by the loaded\n        data. If data_key is specified, this key will be used to index\n        the loaded data to retrive the specified item."
        ],
        [
            "Load the file contents into the supplied dataframe using the\n        specified key and filetype."
        ],
        [
            "Generates the union of the source.specs and the metadata\n        dictionary loaded by the filetype object."
        ],
        [
            "Push new data into the buffer. Resume looping if paused."
        ],
        [
            "Create a plot of one area of interest of a single sweep."
        ],
        [
            "Inelegant for now, but lets you manually analyze every ABF in a folder."
        ],
        [
            "Reanalyze data for a single ABF. Also remakes child and parent html."
        ],
        [
            "scan folder1 and folder2 into files1 and files2.\n        since we are on windows, simplify things by making them all lowercase.\n        this WILL cause problems on 'nix operating systems.If this is the case,\n        just run a script to rename every file to all lowercase."
        ],
        [
            "run this to turn all folder1 TIFs and JPGs into folder2 data.\n        TIFs will be treated as micrographs and converted to JPG with enhanced\n        contrast. JPGs will simply be copied over."
        ],
        [
            "analyze every unanalyzed ABF in the folder."
        ],
        [
            "return appropriate HTML determined by file extension."
        ],
        [
            "generate a generic flat file html for an ABF parent. You could give\n        this a single ABF ID, its parent ID, or a list of ABF IDs.\n        If a child ABF is given, the parent will automatically be used."
        ],
        [
            "create ID_plot.html of just intrinsic properties."
        ],
        [
            "This applies a kernel to a signal through convolution and returns the result.\n\n    Some magic is done at the edges so the result doesn't apprach zero:\n        1. extend the signal's edges with len(kernel)/2 duplicated values\n        2. perform the convolution ('same' mode)\n        3. slice-off the ends we added\n        4. return the same number of points as the original"
        ],
        [
            "simple timer. returns a time object, or a string."
        ],
        [
            "if the value is in the list, move it to the front and return it."
        ],
        [
            "if the value is in the list, move it to the back and return it."
        ],
        [
            "given a list and a list of items to be first, return the list in the\n    same order except that it begins with each of the first items."
        ],
        [
            "given a list of goofy ABF names, return it sorted intelligently.\n    This places things like 16o01001 after 16901001."
        ],
        [
            "when given a dictionary where every key contains a list of IDs, replace\n    the keys with the list of files matching those IDs. This is how you get a\n    list of files belonging to each child for each parent."
        ],
        [
            "given a groups dictionary and an ID, return its actual parent ID."
        ],
        [
            "return the semi-temporary user folder"
        ],
        [
            "Coroutine wrapper to catch errors after async scheduling.\n\n    Args:\n        emitter (EventEmitter): The event emitter that is attempting to\n            call a listener.\n        event (str): The event that triggered the emitter.\n        listener (async def): The async def that was used to generate the coro.\n        coro (coroutine): The coroutine that should be tried.\n\n    If an exception is caught the function will use the emitter to emit the\n    failure event. If, however, the current event _is_ the failure event then\n    the method reraises. The reraised exception may show in debug mode for the\n    event loop but is otherwise silently dropped."
        ],
        [
            "Check if the listener limit is hit and warn if needed."
        ],
        [
            "Bind a listener to a particular event.\n\n        Args:\n            event (str): The name of the event to listen for. This may be any\n                string value.\n            listener (def or async def): The callback to execute when the event\n                fires. This may be a sync or async function."
        ],
        [
            "Add a listener that is only called once."
        ],
        [
            "Remove a listener from the emitter.\n\n        Args:\n            event (str): The event name on which the listener is bound.\n            listener: A reference to the same object given to add_listener.\n\n        Returns:\n            bool: True if a listener was removed else False.\n\n        This method only removes one listener at a time. If a listener is\n        attached multiple times then this method must be called repeatedly.\n        Additionally, this method removes listeners first from the those\n        registered with 'on' or 'add_listener'. If none are found it continue\n        to remove afterwards from those added with 'once'."
        ],
        [
            "Schedule a coroutine for execution.\n\n        Args:\n            event (str): The name of the event that triggered this call.\n            listener (async def): The async def that needs to be executed.\n            *args: Any number of positional arguments.\n            **kwargs: Any number of keyword arguments.\n\n        The values of *args and **kwargs are passed, unaltered, to the async\n        def when generating the coro. If there is an exception generating the\n        coro, such as the wrong number of arguments, the emitter's error event\n        is triggered. If the triggering event _is_ the emitter's error event\n        then the exception is reraised. The reraised exception may show in\n        debug mode for the event loop but is otherwise silently dropped."
        ],
        [
            "Execute a sync function.\n\n        Args:\n            event (str): The name of the event that triggered this call.\n            listener (def): The def that needs to be executed.\n            *args: Any number of positional arguments.\n            **kwargs: Any number of keyword arguments.\n\n        The values of *args and **kwargs are passed, unaltered, to the def\n        when exceuting. If there is an exception executing the def, such as the\n        wrong number of arguments, the emitter's error event is triggered. If\n        the triggering event _is_ the emitter's error event then the exception\n        is reraised. The reraised exception may show in debug mode for the\n        event loop but is otherwise silently dropped."
        ],
        [
            "Dispatch an event to a listener.\n\n        Args:\n            event (str): The name of the event that triggered this call.\n            listener (def or async def): The listener to trigger.\n            *args: Any number of positional arguments.\n            **kwargs: Any number of keyword arguments.\n\n        This method inspects the listener. If it is a def it dispatches the\n        listener to a method that will execute that def. If it is an async def\n        it dispatches it to a method that will schedule the resulting coro with\n        the event loop."
        ],
        [
            "Call each listener for the event with the given arguments.\n\n        Args:\n            event (str): The event to trigger listeners on.\n            *args: Any number of positional arguments.\n            **kwargs: Any number of keyword arguments.\n\n        This method passes all arguments other than the event name directly\n        to the listeners. If a listener raises an exception for any reason the\n        'listener-error', or current value of LISTENER_ERROR_EVENT, is emitted.\n        Listeners to this event are given the event name, listener object, and\n        the exception raised. If an error listener fails it does so silently.\n\n        All event listeners are fired in a deferred way so this method returns\n        immediately. The calling coro must yield at some point for the event\n        to propagate to the listeners."
        ],
        [
            "Get the number of listeners for the event.\n\n        Args:\n            event (str): The event for which to count all listeners.\n\n        The resulting count is a combination of listeners added using\n        'on'/'add_listener' and 'once'."
        ],
        [
            "Convert each TIF to PNG. Return filenames of new PNGs."
        ],
        [
            "given an ID and the dict of files, generate a static html for that abf."
        ],
        [
            "expects a folder of ABFs."
        ],
        [
            "simple example how to load an ABF file and plot every sweep."
        ],
        [
            "plot X and Y data, then shade its background by variance."
        ],
        [
            "create some fancy graphs to show color-coded variances."
        ],
        [
            "run this before analysis. Checks if event detection occured.\n        If not, runs AP detection on all sweeps."
        ],
        [
            "runs AP detection on every sweep."
        ],
        [
            "Return package author and version as listed in `init.py`."
        ],
        [
            "Create an API subclass with fewer methods than its base class.\n\n    Arguments:\n      name (:py:class:`str`): The name of the new class.\n      docstring (:py:class:`str`): The docstring for the new class.\n      remove_methods (:py:class:`dict`): The methods to remove from\n        the base class's :py:attr:`API_METHODS` for the subclass. The\n        key is the name of the root method (e.g. ``'auth'`` for\n        ``'auth.test'``, the value is either a tuple of child method\n        names (e.g. ``('test',)``) or, if all children should be\n        removed, the special value :py:const:`ALL`.\n      base (:py:class:`type`, optional): The base class (defaults to\n        :py:class:`SlackApi`).\n\n    Returns:\n      :py:class:`type`: The new subclass.\n\n    Raises:\n      :py:class:`KeyError`: If the method wasn't in the superclass."
        ],
        [
            "Execute a specified Slack Web API method.\n\n        Arguments:\n          method (:py:class:`str`): The name of the method.\n          **params (:py:class:`dict`): Any additional parameters\n            required.\n\n        Returns:\n          :py:class:`dict`: The JSON data from the response.\n\n        Raises:\n          :py:class:`aiohttp.web_exceptions.HTTPException`: If the HTTP\n            request returns a code other than 200 (OK).\n          SlackApiError: If the Slack API is reached but the response\n           contains an error message."
        ],
        [
            "Whether a given method exists in the known API.\n\n        Arguments:\n          method (:py:class:`str`): The name of the method.\n\n        Returns:\n          :py:class:`bool`: Whether the method is in the known API."
        ],
        [
            "Extend XPath evaluation with Parsley extensions' namespace"
        ],
        [
            "Try and convert matching Elements to unicode strings.\n\n        If this fails, the selector evaluation probably already\n        returned some string(s) of some sort, or boolean value,\n        or int/float, so return that instead."
        ],
        [
            "Join the real-time messaging service.\n\n        Arguments:\n          filters (:py:class:`dict`, optional): Dictionary mapping\n            message filters to the functions they should dispatch to.\n            Use a :py:class:`collections.OrderedDict` if precedence is\n            important; only one filter, the first match, will be\n            applied to each message."
        ],
        [
            "Handle an incoming message appropriately.\n\n        Arguments:\n          message (:py:class:`aiohttp.websocket.Message`): The incoming\n            message to handle.\n          filters (:py:class:`list`): The filters to apply to incoming\n            messages."
        ],
        [
            "If you send a message directly to me"
        ],
        [
            "Create a new instance from the API token.\n\n        Arguments:\n          token (:py:class:`str`, optional): The bot's API token\n            (defaults to ``None``, which means looking in the\n            environment).\n          api_cls (:py:class:`type`, optional): The class to create\n            as the ``api`` argument for API access (defaults to\n            :py:class:`aslack.slack_api.SlackBotApi`).\n\n        Returns:\n          :py:class:`SlackBot`: The new instance."
        ],
        [
            "Format an outgoing message for transmission.\n\n        Note:\n          Adds the message type (``'message'``) and incremental ID.\n\n        Arguments:\n          channel (:py:class:`str`): The channel to send to.\n          text (:py:class:`str`): The message text to send.\n\n        Returns:\n          :py:class:`str`: The JSON string of the message."
        ],
        [
            "Get the WebSocket URL for the RTM session.\n\n        Warning:\n          The URL expires if the session is not joined within 30\n          seconds of the API call to the start endpoint.\n\n        Returns:\n          :py:class:`str`: The socket URL."
        ],
        [
            "Generates the instructions for a bot and its filters.\n\n        Note:\n          The guidance for each filter is generated by combining the\n          docstrings of the predicate filter and resulting dispatch\n          function with a single space between. The class's\n          :py:attr:`INSTRUCTIONS` and the default help command are\n          added.\n\n        Arguments:\n          filters (:py:class:`list`): The filters to apply to incoming\n            messages.\n\n        Returns:\n          :py:class:`str`: The bot's instructions."
        ],
        [
            "Respond to a message on the current socket.\n\n        Args:\n          channel (:py:class:`str`): The channel to send to.\n          text (:py:class:`str`): The message text to send."
        ],
        [
            "Check the first message matches the expected handshake.\n\n        Note:\n          The handshake is provided as :py:attr:`RTM_HANDSHAKE`.\n\n        Arguments:\n          msg (:py:class:`aiohttp.Message`): The message to validate.\n\n        Raises:\n          :py:class:`SlackApiError`: If the data doesn't match the\n            expected handshake."
        ],
        [
            "Returns list of paths to tested apps"
        ],
        [
            "Get the imported task classes for each task that will be run"
        ],
        [
            "Get the options for each task that will be run"
        ],
        [
            "Write the data from the db to a CLDF dataset according to the metadata in `self.dataset`.\n\n        :param dest:\n        :param mdname:\n        :return: path of the metadata file"
        ],
        [
            "A user-friendly description of the handler.\n\n        Returns:\n          :py:class:`str`: The handler's description."
        ],
        [
            "Create a Parselet instance from a file containing\n        the Parsley script as a JSON object\n\n        >>> import parslepy\n        >>> with open('parselet.json') as fp:\n        ...     parslepy.Parselet.from_jsonfile(fp)\n        ...\n        <parslepy.base.Parselet object at 0x2014e50>\n\n        :param file fp: an open file-like pointer containing the Parsley script\n        :rtype: :class:`.Parselet`\n\n        Other arguments: same as for :class:`.Parselet` contructor"
        ],
        [
            "Create a Parselet instance from a file containing\n        the Parsley script as a YAML object\n\n        >>> import parslepy\n        >>> with open('parselet.yml') as fp:\n        ...     parslepy.Parselet.from_yamlfile(fp)\n        ...\n        <parslepy.base.Parselet object at 0x2014e50>\n\n        :param file fp: an open file-like pointer containing the Parsley script\n        :rtype: :class:`.Parselet`\n\n        Other arguments: same as for :class:`.Parselet` contructor"
        ],
        [
            "Interpret input lines as a JSON Parsley script.\n        Python-style comment lines are skipped."
        ],
        [
            "Build part of the abstract Parsley extraction tree\n\n        Arguments:\n        parselet_node (dict) -- part of the Parsley tree to compile\n                                (can be the root dict/node)\n        level (int)          -- current recursion depth (used for debug)"
        ],
        [
            "Use CLDF reference properties to implicitely create foreign key constraints.\n\n        :param component: A Table object or `None`."
        ],
        [
            "Create a URL for the specified endpoint.\n\n        Arguments:\n          endpoint (:py:class:`str`): The API endpoint to access.\n          root: (:py:class:`str`, optional): The root URL for the\n            service API.\n          params: (:py:class:`dict`, optional): The values for format\n            into the created URL (defaults to ``None``).\n          url_params: (:py:class:`dict`, optional): Parameters to add\n            to the end of the URL (defaults to ``None``).\n\n        Returns:\n          :py:class:`str`: The resulting URL."
        ],
        [
            "Raise an appropriate error for a given response.\n\n    Arguments:\n      response (:py:class:`aiohttp.ClientResponse`): The API response.\n\n    Raises:\n      :py:class:`aiohttp.web_exceptions.HTTPException`: The appropriate\n        error for the response's status."
        ],
        [
            "Truncate the supplied text for display.\n\n    Arguments:\n      text (:py:class:`str`): The text to truncate.\n      max_len (:py:class:`int`, optional): The maximum length of the\n        text before truncation (defaults to 350 characters).\n      end (:py:class:`str`, optional): The ending to use to show that\n        the text was truncated (defaults to ``'...'``).\n\n    Returns:\n      :py:class:`str`: The truncated text."
        ],
        [
            "Add a source, either specified by glottolog reference id, or as bibtex record."
        ],
        [
            "Returns a cache key consisten of a username and image size."
        ],
        [
            "Decorator to cache the result of functions that take a ``user`` and a\n    ``size`` value."
        ],
        [
            "Function to be called when saving or changing an user's avatars."
        ],
        [
            "Returns a field object instance for a given PrefProxy object.\n\n    :param PrefProxy pref_proxy:\n\n    :rtype: models.Field"
        ],
        [
            "Updates field object with data from a PrefProxy object.\n\n    :param models.Field field_obj:\n\n    :param PrefProxy pref_proxy:"
        ],
        [
            "Returns preferences model class dynamically crated for a given app or None on conflict."
        ],
        [
            "Returns locals dictionary from a given frame.\n\n    :param int stepback:\n\n    :rtype: dict"
        ],
        [
            "Generator to walk through variables considered as preferences\n    in locals dict of a given frame.\n\n    :param int stepback:\n\n    :rtype: tuple"
        ],
        [
            "Prints file details in the current directory"
        ],
        [
            "Attempt to bind the args to the type signature. First try to just bind\n        to the signature, then ensure that all arguments match the parameter\n        types."
        ],
        [
            "For every parameter, create a matcher if the parameter has an\n        annotation."
        ],
        [
            "Makes a wrapper function that executes a dispatch call for func. The\n        wrapper has the dispatch and dispatch_first attributes, so that\n        additional overloads can be added to the group."
        ],
        [
            "Adds the decorated function to this dispatch."
        ],
        [
            "Adds the decorated function to this dispatch, at the FRONT of the order.\n        Useful for allowing third parties to add overloaded functionality\n        to be executed before default functionality."
        ],
        [
            "Dispatch a call. Call the first function whose type signature matches\n        the arguemts."
        ],
        [
            "reprojette en WGS84 et recupere l'extend"
        ],
        [
            "Convert GRIB to Tif"
        ],
        [
            "Triggered on dynamic preferences model save.\n     Issues DB save and reread."
        ],
        [
            "Binds PrefProxy objects to module variables used by apps as preferences.\n\n    :param list|tuple values: Preference values.\n\n    :param str|unicode category: Category name the preference belongs to.\n\n    :param Field field: Django model field to represent this preference.\n\n    :param str|unicode verbose_name: Field verbose name.\n\n    :param str|unicode help_text: Field help text.\n\n    :param bool static: Leave this preference static (do not store in DB).\n\n    :param bool readonly: Make this field read only.\n\n    :rtype: list"
        ],
        [
            "Registers dynamically created preferences models for Admin interface.\n\n    :param admin.AdminSite admin_site: AdminSite object."
        ],
        [
            "Automatically discovers and registers all preferences available in all apps.\n\n    :param admin.AdminSite admin_site: Custom AdminSite object."
        ],
        [
            "Restores the original values of module variables\n    considered preferences if they are still PatchedLocal\n    and not PrefProxy."
        ],
        [
            "Replaces a settings module with a Module proxy to intercept\n    an access to settings.\n\n    :param int depth: Frame count to go backward."
        ],
        [
            "Registers preferences that should be handled by siteprefs.\n\n    Expects preferences as *args.\n\n    Use keyword arguments to batch apply params supported by\n    ``PrefProxy`` to all preferences not constructed by ``pref`` and ``pref_group``.\n\n    Batch kwargs:\n\n        :param str|unicode help_text: Field help text.\n\n        :param bool static: Leave this preference static (do not store in DB).\n\n        :param bool readonly: Make this field read only.\n\n    :param bool swap_settings_module: Whether to automatically replace settings module\n        with a special ``ProxyModule`` object to access dynamic values of settings\n        transparently (so not to bother with calling ``.value`` of ``PrefProxy`` object)."
        ],
        [
            "Marks preferences group.\n\n    :param str|unicode title: Group title\n\n    :param list|tuple prefs: Preferences to group.\n\n    :param str|unicode help_text: Field help text.\n\n    :param bool static: Leave this preference static (do not store in DB).\n\n    :param bool readonly: Make this field read only."
        ],
        [
            "Marks a preference.\n\n    :param preference: Preference variable.\n\n    :param Field field: Django model field to represent this preference.\n\n    :param str|unicode verbose_name: Field verbose name.\n\n    :param str|unicode help_text: Field help text.\n\n    :param bool static: Leave this preference static (do not store in DB).\n\n    :param bool readonly: Make this field read only.\n\n    :rtype: PrefProxy|None"
        ],
        [
            "Generate the ``versionwarning-data.json`` file.\n\n    This file is included in the output and read by the AJAX request when\n    accessing to the documentation and used to compare the live versions with\n    the curent one.\n\n    Besides, this file contains meta data about the project, the API to use and\n    the banner itself."
        ],
        [
            "Gives objective functions a number of dimensions and parameter range\n\n    Parameters\n    ----------\n    param_scales : (int, int)\n        Scale (std. dev.) for choosing each parameter\n\n    xstar : array_like\n        Optimal parameters"
        ],
        [
            "Pointwise minimum of two quadratic bowls"
        ],
        [
            "Objective and gradient for the rosenbrock function"
        ],
        [
            "Beale's function"
        ],
        [
            "Booth's function"
        ],
        [
            "Three-hump camel function"
        ],
        [
            "One of the Bohachevsky functions"
        ],
        [
            "Dixon-Price function"
        ],
        [
            "Styblinski-Tang function"
        ],
        [
            "Return a list of buckets in MimicDB.\n\n        :param boolean force: If true, API call is forced to S3"
        ],
        [
            "Return a bucket from MimicDB if it exists. Return a\n        S3ResponseError if the bucket does not exist and validate is passed.\n\n        :param boolean force: If true, API call is forced to S3"
        ],
        [
            "Add the bucket to MimicDB after successful creation."
        ],
        [
            "Sync either a list of buckets or the entire connection.\n\n        Force all API calls to S3 and populate the database with the current\n        state of S3.\n\n        :param \\*string \\*buckets: Buckets to sync"
        ],
        [
            "Return the key from MimicDB.\n\n        :param boolean force: If true, API call is forced to S3"
        ],
        [
            "Return None if key is not in the bucket set.\n\n        Pass 'force' in the headers to check S3 for the key, and after fetching\n        the key from S3, save the metadata and key to the bucket set."
        ],
        [
            "Return a list of keys from MimicDB.\n\n        :param boolean force: If true, API call is forced to S3"
        ],
        [
            "Remove each key or key name in an iterable from the bucket set."
        ],
        [
            "Remove key name from bucket set."
        ],
        [
            "Return an iterable of keys from MimicDB.\n\n        :param boolean force: If true, API call is forced to S3"
        ],
        [
            "Sync a bucket.\n\n        Force all API calls to S3 and populate the database with the current state of S3."
        ],
        [
            "Minimize the proximal operator of a given objective using L-BFGS\n\n    Parameters\n    ----------\n    f_df : function\n        Returns the objective and gradient of the function to minimize\n\n    maxiter : int\n        Maximum number of L-BFGS iterations"
        ],
        [
            "Applies a smoothing operator along one dimension\n\n    currently only accepts a matrix as input\n\n    Parameters\n    ----------\n    penalty : float\n\n    axis : int, optional\n        Axis along which to apply the smoothing (Default: 0)\n\n    newshape : tuple, optional\n        Desired shape of the parameters to apply the nuclear norm to. The given\n        parameters are reshaped to an array with this shape, or not reshaped if\n        the value of newshape is None. (Default: None)"
        ],
        [
            "Projection onto the semidefinite cone"
        ],
        [
            "Projection onto the probability simplex\n\n    http://arxiv.org/pdf/1309.1541v1.pdf"
        ],
        [
            "Applies a proximal operator to the columns of a matrix"
        ],
        [
            "Turns a coroutine into a gradient based optimizer."
        ],
        [
            "Adds a proximal operator to the list of operators"
        ],
        [
            "Set key attributes to retrived metadata. Might be extended in the\n        future to support more attributes."
        ],
        [
            "Called internally for any type of upload. After upload finishes,\n        make sure the key is in the bucket set and save the metadata."
        ],
        [
            "Memoizes an objective + gradient function, and splits it into\n    two functions that return just the objective and gradient, respectively.\n\n    Parameters\n    ----------\n    f_df : function\n        Must be unary (takes a single argument)\n\n    xref : list, dict, or array_like\n        The form of the parameters\n\n    size : int, optional\n        Size of the cache (Default=1)"
        ],
        [
            "Decorates a function with the given docstring\n\n    Parameters\n    ----------\n    docstr : string"
        ],
        [
            "Compares the numerical gradient to the analytic gradient\n\n    Parameters\n    ----------\n    f_df : function\n        The analytic objective and gradient function to check\n\n    x0 : array_like\n        Parameter values to check the gradient at\n\n    stepsize : float, optional\n        Stepsize for the numerical gradient. Too big and this will poorly estimate the gradient.\n        Too small and you will run into precision issues (default: 1e-6)\n\n    tol : float, optional\n        Tolerance to use when coloring correct/incorrect gradients (default: 1e-5)\n\n    width : int, optional\n        Width of the table columns (default: 15)\n\n    style : string, optional\n        Style of the printed table, see tableprint for a list of styles (default: 'round')"
        ],
        [
            "Evaluate the files identified for checksum."
        ],
        [
            "Check the integrity of the datapackage.json"
        ],
        [
            "Guess the filetype and read the file into row sets"
        ],
        [
            "Guess schema using messytables"
        ],
        [
            "Calculates a checksum for a Finnish national reference number"
        ],
        [
            "Helper to make sure the given character is valid for a reference number"
        ],
        [
            "Creates the huge number from ISO alphanumeric ISO reference"
        ],
        [
            "Validates ISO reference number"
        ],
        [
            "Calculates virtual barcode for IBAN account number and ISO reference\n\n    Arguments:\n        iban {string} -- IBAN formed account number\n        reference {string} -- ISO 11649 creditor reference\n        amount {decimal.Decimal} -- Amount in euros, 0.01 - 999999.99\n        due {datetime.date} -- due date"
        ],
        [
            "Add a normal file including its source"
        ],
        [
            "Run the executable and capture the input and output..."
        ],
        [
            "Add files to the repository by explicitly specifying them or by\n    specifying a pattern over files accessed during execution of an\n    executable.\n\n    Parameters\n    ----------\n\n    repo: Repository\n\n    args: files or command line\n         (a) If simply adding files, then the list of files that must\n         be added (including any additional arguments to be passed to\n         git\n         (b) If files to be added are an output of a command line, then\n         args is the command lined\n    targetdir: Target directory to store the files\n    execute: Args are not files to be added but scripts that must be run.\n    includes: patterns used to select files to\n    script: Is this a script?\n    generator: Is this a generator\n    source: Link to the original source of the data"
        ],
        [
            "For various actions we need files that match patterns"
        ],
        [
            "Run a specific command using the manager"
        ],
        [
            "Get metadata for a given file"
        ],
        [
            "Lookup all available repos"
        ],
        [
            "Working directory for the repo"
        ],
        [
            "Add repo to the internal lookup table..."
        ],
        [
            "Lookup a repo based on username reponame"
        ],
        [
            "Run a shell command within the repo's context\n\n    Parameters\n    ----------\n\n    repo: Repository object\n    args: Shell command"
        ],
        [
            "Check if the datapackage exists..."
        ],
        [
            "Create the datapackage file.."
        ],
        [
            "Initialize an empty repository with datapackage.json\n\n    Parameters\n    ----------\n\n    username: Name of the user\n    reponame: Name of the repo\n    setup: Specify the 'configuration' (git only, git+s3 backend etc)\n    force: Force creation of the files\n    options: Dictionary with content of dgit.json, if available.\n    noinput: Automatic operation with no human interaction"
        ],
        [
            "Update metadata with the content of the files"
        ],
        [
            "Update metadata with the commit information"
        ],
        [
            "Update metadata with the action history"
        ],
        [
            "Update metadata host information"
        ],
        [
            "Collect information from the dependent repo's"
        ],
        [
            "Post to metadata server\n\n    Parameters\n    ----------\n\n    repo: Repository object (result of lookup)"
        ],
        [
            "Show details of available plugins\n\n    Parameters\n    ----------\n    what: Class of plugins e.g., backend\n    name: Name of the plugin e.g., s3\n    version: Version of the plugin\n    details: Show details be shown?"
        ],
        [
            "Load all plugins from dgit extension"
        ],
        [
            "Registering a plugin\n\n        Params\n        ------\n        what: Nature of the plugin (backend, instrumentation, repo)\n        obj: Instance of the plugin"
        ],
        [
            "Search for a plugin"
        ],
        [
            "Instantiate the validation specification"
        ],
        [
            "Validate the content of the files for consistency. Validators can\n    look as deeply as needed into the files. dgit treats them all as\n    black boxes.\n\n    Parameters\n    ----------\n\n    repo: Repository object\n    validator_name: Name of validator, if any. If none, then all validators specified in dgit.json will be included.\n    filename: Pattern that specifies files that must be processed by the validators selected. If none, then the default specification in dgit.json is used.\n    rules: Pattern specifying the files that have rules that validators will use\n    show: Print the validation results on the terminal\n\n    Returns\n    -------\n\n    status: A list of dictionaries, each with target file processed, rules file applied, status of the validation and any error  message."
        ],
        [
            "Check if a URL exists"
        ],
        [
            "Post to the metadata server\n\n        Parameters\n        ----------\n\n        repo"
        ],
        [
            "imports and returns module class from ``path.to.module.Class``\n    argument"
        ],
        [
            "Find max 5 executables that are responsible for this repo."
        ],
        [
            "Automatically get repo\n\n    Parameters\n    ----------\n\n    autooptions: dgit.json content"
        ],
        [
            "Look through the local directory to pick up files to check"
        ],
        [
            "Cleanup the paths and add"
        ],
        [
            "This will try to pull in a stream from an external source. Once a\n        stream has been successfully pulled it is assigned a 'local stream\n        name' which can be used to access the stream from the EMS.\n\n        :param uri: The URI of the external stream. Can be RTMP, RTSP or\n            unicast/multicast (d) mpegts\n        :type uri: str\n\n        :param keepAlive: If keepAlive is set to 1, the server will attempt to\n            reestablish connection with a stream source after a connection has\n            been lost. The reconnect will be attempted once every second\n            (default: 1 true)\n        :type keepAlive: int\n\n        :param localStreamName: If provided, the stream will be given this\n            name. Otherwise, a fallback techniques used to determine the stream\n            name (based on the URI)\n        :type localStreamName: str\n\n        :param forceTcp: If 1 and if the stream is RTSP, a TCP connection will\n            be forced. Otherwise the transport mechanism will be negotiated\n            (UDP or TCP) (default: 1 true)\n        :type forceTcp: int\n\n        :param tcUrl: When specified, this value will be used to set the TC URL\n            in the initial RTMP connect invoke\n        :type tcUrl: str\n\n        :param pageUrl: When specified, this value will be used to set the\n            originating web page address in the initial RTMP connect invoke\n        :type pageUrl: str\n\n        :param swfUrl: When specified, this value will be used to set the\n            originating swf URL in the initial RTMP connect invoke\n        :type swfUrl: str\n\n        :param rangeStart: For RTSP and RTMP connections. A value from which\n            the playback should start expressed in seconds. There are 2 special\n            values: -2 and -1. For more information, please read about\n            start/len parameters here:\n            http://livedocs.adobe.com/flashmediaserver/3.0/hpdocs/help.html?content=00000185.html\n        :type rangeStart: int\n\n        :param rangeEnd: The length in seconds for the playback. -1 is a\n            special value. For more information, please read about start/len\n            parameters here:\n            http://livedocs.adobe.com/flashmediaserver/3.0/hpdocs/help.html?content=00000185.html\n        :type rangeEnd: int\n\n        :param ttl: Sets the IP_TTL (time to live) option on the socket\n        :type ttl: int\n\n        :param tos: Sets the IP_TOS (Type of Service) option on the socket\n        :type tos: int\n\n        :param rtcpDetectionInterval: How much time (in seconds) should the\n            server wait for RTCP packets before declaring the RTSP stream as a\n            RTCP-less stream\n        :type rtcpDetectionInterval: int\n\n        :param emulateUserAgent: When specified, this value will be used as the\n            user agent string. It is meaningful only for RTMP\n        :type emulateUserAgent: str\n\n        :param isAudio: If 1 and if the stream is RTP, it indicates that the\n            currently pulled stream is an audio source. Otherwise the pulled\n            source is assumed as a video source\n        :type isAudio: int\n\n        :param audioCodecBytes: The audio codec setup of this RTP stream if it\n            is audio. Represented as hex format without '0x' or 'h'. For\n            example: audioCodecBytes=1190\n        :type audioCodecBytes: str\n\n        :param spsBytes: The video SPS bytes of this RTP stream if it is video.\n            It should be base 64 encoded.\n        :type spsBytes: str\n\n        :param ppsBytes: The video PPS bytes of this RTP stream if it is video.\n            It should be base 64 encoded\n        :type ppsBytes: str\n\n        :param ssmIp: The source IP from source-specific-multicast. Only usable\n            when doing UDP based pull\n        :type ssmIp: str\n\n        :param httpProxy: This parameter has two valid values: IP:Port - This\n            value combination specifies an RTSP HTTP Proxy from which the RTSP\n            stream should be pulled from Self - Specifying \"self\" as the value\n            implies pulling RTSP over HTTP\n        :type httpProxy: str\n\n        :link: http://docs.evostream.com/ems_api_definition/pullstream"
        ],
        [
            "Records any inbound stream. The record command allows users to record\n        a stream that may not yet exist. When a new stream is brought into\n        the server, it is checked against a list of streams to be recorded.\n\n        Streams can be recorded as FLV files, MPEG-TS files or as MP4 files.\n\n        :param localStreamName: The name of the stream to be used as input\n            for recording.\n        :type localStreamName: str\n\n        :param pathToFile: Specify path and file name to write to.\n        :type pathToFile: str\n\n        :param type: `ts`, `mp4` or `flv`\n        :type type: str\n\n        :param overwrite: If false, when a file already exists for the stream\n            name, a new file will be created with the next appropriate number\n            appended. If 1 (true), files with the same name will be\n            overwritten.\n        :type overwrite: int\n\n        :param keepAlive: If 1 (true), the server will restart recording every\n            time the stream becomes available again.\n        :type keepAlive: int\n\n        :param chunkLength: If non-zero the record command will start a new\n            recording file after ChunkLength seconds have elapsed.\n        :type chunkLength: int\n\n        :param waitForIDR: This is used if the recording is being chunked.\n            When true, new files will only be created on IDR boundaries.\n        :type waitForIDR: int\n\n        :param winQtCompat: Mandates 32bit header fields to ensure\n            compatibility with Windows QuickTime.\n        :type winQtCompat: int\n\n        :param dateFolderStructure: If set to 1 (true), folders will be\n            created with names in `YYYYMMDD` format. Recorded files will be\n            placed inside these folders based on the date they were created.\n        :type dateFolderStructure: int\n\n        :link: http://docs.evostream.com/ems_api_definition/record"
        ],
        [
            "Creates an RTMP ingest point, which mandates that streams pushed into\n        the EMS have a target stream name which matches one Ingest Point\n        privateStreamName.\n\n        :param privateStreamName: The name that RTMP Target Stream Names must\n            match.\n        :type privateStreamName: str\n\n        :param publicStreamName: The name that is used to access the stream\n            pushed to the privateStreamName. The publicStreamName becomes the\n            streams localStreamName.\n        :type publicStreamName: str\n\n        :link: http://docs.evostream.com/ems_api_definition/createingestpoint"
        ],
        [
            "Instantiate the generator and filename specification"
        ],
        [
            "Helper function to run commands\n\n        Parameters\n        ----------\n        cmd : list\n              Arguments to git command"
        ],
        [
            "Run a generic command within the repo. Assumes that you are\n        in the repo's root directory"
        ],
        [
            "Initialize a Git repo\n\n        Parameters\n        ----------\n\n        username, reponame : Repo name is tuple (name, reponame)\n        force: force initialization of the repo even if exists\n        backend: backend that must be used for this (e.g. s3)"
        ],
        [
            "Delete files from the repo"
        ],
        [
            "Cleanup the repo"
        ],
        [
            "Get the permalink to command that generated the dataset"
        ],
        [
            "Add files to the repo"
        ],
        [
            "Marks the invoice as sent in Holvi\n\n        If send_email is False then the invoice is *not* automatically emailed to the recipient\n        and your must take care of sending the invoice yourself."
        ],
        [
            "Convert our Python object to JSON acceptable to Holvi API"
        ],
        [
            "API wrapper documentation"
        ],
        [
            "Saves this order to Holvi, returns a tuple with the order itself and checkout_uri"
        ],
        [
            "Return source code based on tokens.\n\n    This is like tokenize.untokenize(), but it preserves spacing between\n    tokens. So if the original soure code had multiple spaces between\n    some tokens or if escaped newlines were used, those things will be\n    reflected by untokenize()."
        ],
        [
            "Load profile INI"
        ],
        [
            "Update the profile"
        ],
        [
            "Insert hook into the repo"
        ],
        [
            "Try the library. If it doesnt work, use the command line.."
        ],
        [
            "Run a shell command"
        ],
        [
            "Get the commit history for a given dataset"
        ],
        [
            "Look at files and compute the diffs intelligently"
        ],
        [
            "Execute command and wait for it to finish. Proceed with caution because\n        if you run a command that causes a prompt this will hang"
        ],
        [
            "Enter sudo mode"
        ],
        [
            "Install specified packages using apt-get. -y options are\n        automatically used. Waits for command to finish.\n\n        Parameters\n        ----------\n        package_names: list-like of str\n        raise_on_error: bool, default False\n            If True then raise ValueError if stderr is not empty\n            debconf often gives tty error"
        ],
        [
            "Install specified python packages using pip. -U option added\n        Waits for command to finish.\n\n        Parameters\n        ----------\n        package_names: list-like of str\n        raise_on_error: bool, default True\n            If True then raise ValueError if stderr is not empty"
        ],
        [
            "Install all requirements contained in the given file path\n        Waits for command to finish.\n\n        Parameters\n        ----------\n        requirements: str\n            Path to requirements.txt\n        raise_on_error: bool, default True\n            If True then raise ValueError if stderr is not empty"
        ],
        [
            "Create fiji-macros for stitching all channels and z-stacks for a well.\n\n    Parameters\n    ----------\n    path : string\n        Well path.\n    output_folder : string\n        Folder to store images. If not given well path is used.\n\n    Returns\n    -------\n    output_files, macros : tuple\n        Tuple with filenames and macros for stitched well."
        ],
        [
            "Lossless compression. Save images as PNG and TIFF tags to json. Can be\n    reversed with `decompress`. Will run in multiprocessing, where\n    number of workers is decided by ``leicaexperiment.experiment._pools``.\n\n    Parameters\n    ----------\n    images : list of filenames\n        Images to lossless compress.\n    delete_tif : bool\n        Wheter to delete original images.\n    folder : string\n        Where to store images. Basename will be kept.\n\n    Returns\n    -------\n    list of filenames\n        List of compressed files."
        ],
        [
            "Lossless compression. Save image as PNG and TIFF tags to json. Process\n    can be reversed with `decompress`.\n\n    Parameters\n    ----------\n    image : string\n        TIF-image which should be compressed lossless.\n    delete_tif : bool\n        Wheter to delete original images.\n    force : bool\n        Wheter to compress even if .png already exists.\n\n    Returns\n    -------\n    string\n        Filename of compressed image, or empty string if compress failed."
        ],
        [
            "Set self.path, self.dirname and self.basename."
        ],
        [
            "List of paths to images."
        ],
        [
            "Get path of specified image.\n\n        Parameters\n        ----------\n        well_row : int\n            Starts at 0. Same as --U in files.\n        well_column : int\n            Starts at 0. Same as --V in files.\n        field_row : int\n            Starts at 0. Same as --Y in files.\n        field_column : int\n            Starts at 0. Same as --X in files.\n\n        Returns\n        -------\n        string\n            Path to image or empty string if image is not found."
        ],
        [
            "Get list of paths to images in specified well.\n\n\n        Parameters\n        ----------\n        well_row : int\n            Starts at 0. Same as --V in files.\n        well_column : int\n            Starts at 0. Save as --U in files.\n\n        Returns\n        -------\n        list of strings\n            Paths to images or empty list if no images are found."
        ],
        [
            "Stitches all wells in experiment with ImageJ. Stitched images are\n        saved in experiment root.\n\n        Images which already exists are omitted stitching.\n\n        Parameters\n        ----------\n        folder : string\n            Where to store stitched images. Defaults to experiment path.\n\n        Returns\n        -------\n        list\n            Filenames of stitched images. Files which already exists before\n            stitching are also returned."
        ],
        [
            "Lossless compress all images in experiment to PNG. If folder is\n        omitted, images will not be moved.\n\n        Images which already exists in PNG are omitted.\n\n        Parameters\n        ----------\n        folder : string\n            Where to store PNGs. Defaults to the folder they are in.\n        delete_tif : bool\n            If set to truthy value, ome.tifs will be deleted after compression.\n\n        Returns\n        -------\n        list\n            Filenames of PNG images. Files which already exists before\n            compression are also returned."
        ],
        [
            "Get OME-XML metadata of given field.\n\n        Parameters\n        ----------\n        well_row : int\n            Y well coordinate. Same as --V in files.\n        well_column : int\n            X well coordinate. Same as --U in files.\n        field_row : int\n            Y field coordinate. Same as --Y in files.\n        field_column : int\n            X field coordinate. Same as --X in files.\n\n        Returns\n        -------\n        lxml.objectify.ObjectifiedElement\n            lxml object of OME-XML found in slide/chamber/field/metadata."
        ],
        [
            "Get a list of stitch coordinates for the given well.\n\n        Parameters\n        ----------\n        well_row : int\n            Y well coordinate. Same as --V in files.\n        well_column : int\n            X well coordinate. Same as --U in files.\n\n        Returns\n        -------\n        (xs, ys, attr) : tuples with float and collections.OrderedDict\n            Tuple of x's, y's and attributes."
        ],
        [
            "Create a new droplet\n\n        Parameters\n        ----------\n        name: str\n            Name of new droplet\n        region: str\n            slug for region (e.g., sfo1, nyc1)\n        size: str\n            slug for droplet size (e.g., 512mb, 1024mb)\n        image: int or str\n            image id (e.g., 12352) or slug (e.g., 'ubuntu-14-04-x64')\n        ssh_keys: list, optional\n            default SSH keys to be added on creation\n            this is highly recommended for ssh access\n        backups: bool, optional\n            whether automated backups should be enabled for the Droplet.\n            Automated backups can only be enabled when the Droplet is created.\n        ipv6: bool, optional\n            whether IPv6 is enabled on the Droplet\n        private_networking: bool, optional\n            whether private networking is enabled for the Droplet. Private\n            networking is currently only available in certain regions\n        wait: bool, default True\n            if True then block until creation is complete"
        ],
        [
            "Retrieve a droplet by id\n\n        Parameters\n        ----------\n        id: int\n            droplet id\n\n        Returns\n        -------\n        droplet: DropletActions"
        ],
        [
            "Restore this droplet with given image id\n\n        A Droplet restoration will rebuild an image using a backup image.\n        The image ID that is passed in must be a backup of the current Droplet\n        instance. The operation will leave any embedded SSH keys intact.\n\n        Parameters\n        ----------\n        image: int or str\n            int for image id and str for image slug\n        wait: bool, default True\n            Whether to block until the pending action is completed"
        ],
        [
            "Rebuild this droplet with given image id\n\n        Parameters\n        ----------\n        image: int or str\n            int for image id and str for image slug\n        wait: bool, default True\n            Whether to block until the pending action is completed"
        ],
        [
            "Change the name of this droplet\n\n        Parameters\n        ----------\n        name: str\n            New name for the droplet\n        wait: bool, default True\n            Whether to block until the pending action is completed\n\n        Raises\n        ------\n        APIError if region does not support private networking"
        ],
        [
            "Change the kernel of this droplet\n\n        Parameters\n        ----------\n        kernel_id: int\n            Can be retrieved from output of self.kernels()\n        wait: bool, default True\n            Whether to block until the pending action is completed\n\n        Raises\n        ------\n        APIError if region does not support private networking"
        ],
        [
            "Delete this droplet\n\n        Parameters\n        ----------\n        wait: bool, default True\n            Whether to block until the pending action is completed"
        ],
        [
            "wait for all actions to complete on a droplet"
        ],
        [
            "Open SSH connection to droplet\n\n        Parameters\n        ----------\n        interactive: bool, default False\n            If True then SSH client will prompt for password when necessary\n            and also print output to console"
        ],
        [
            "Send a request to the REST API\n\n        Parameters\n        ----------\n        kind: str, {get, delete, put, post, head}\n        resource: str\n        url_components: list or tuple to be appended to the request URL\n\n        Notes\n        -----\n        kwargs contain request parameters to be sent as request data"
        ],
        [
            "Properly formats array types"
        ],
        [
            "create request url for resource"
        ],
        [
            "Send a request for this resource to the API\n\n        Parameters\n        ----------\n        kind: str, {'get', 'delete', 'put', 'post', 'head'}"
        ],
        [
            "Send list request for all members of a collection"
        ],
        [
            "Get single unit of collection"
        ],
        [
            "Transfer this image to given region\n\n        Parameters\n        ----------\n        region: str\n            region slug to transfer to (e.g., sfo1, nyc1)"
        ],
        [
            "id or slug"
        ],
        [
            "id or fingerprint"
        ],
        [
            "Creates a new domain\n\n        Parameters\n        ----------\n        name: str\n            new domain name\n        ip_address: str\n            IP address for the new domain"
        ],
        [
            "Get a list of all domain records for the given domain name\n\n        Parameters\n        ----------\n        name: str\n            domain name"
        ],
        [
            "Change the name of this domain record\n\n        Parameters\n        ----------\n        id: int\n            domain record id\n        name: str\n            new name of record"
        ],
        [
            "Retrieve a single domain record given the id"
        ],
        [
            "Logs the user on to FogBugz.\n\n        Returns None for a successful login."
        ],
        [
            "Chop list_ into n chunks. Returns a list."
        ],
        [
            "return first droplet"
        ],
        [
            "Take a snapshot of a droplet\n\n    Parameters\n    ----------\n    name: str\n        name for snapshot"
        ],
        [
            "Retrieves the allowed operations for this request."
        ],
        [
            "Assets if the requested operations are allowed in this context."
        ],
        [
            "Fills the response object from the passed data."
        ],
        [
            "Processes a `GET` request."
        ],
        [
            "Processes a `POST` request."
        ],
        [
            "Processes a `PUT` request."
        ],
        [
            "Processes a `DELETE` request."
        ],
        [
            "Processes a `LINK` request.\n\n        A `LINK` request is asking to create a relation from the currently\n        represented URI to all of the `Link` request headers."
        ],
        [
            "Creates a base Django project"
        ],
        [
            "Helper function that performs an `ilike` query if a string value\n    is passed, otherwise the normal default operation."
        ],
        [
            "Parse the querystring into a normalized form."
        ],
        [
            "Return objects representing segments."
        ],
        [
            "we expect foo=bar"
        ],
        [
            "Set the value of this attribute for the passed object."
        ],
        [
            "Consumes set specifiers as text and forms a generator to retrieve\n    the requested ranges.\n\n    @param[in] specifiers\n        Expected syntax is from the byte-range-specifier ABNF found in the\n        [RFC 2616]; eg. 15-17,151,-16,26-278,15\n\n    @returns\n        Consecutive tuples that describe the requested range; eg. (1, 72) or\n        (1, 1) [read as 1 to 72 or 1 to 1]."
        ],
        [
            "Paginate an iterable during a request.\n\n    Magically splicling an iterable in our supported ORMs allows LIMIT and\n    OFFSET queries. We should probably delegate this to the ORM or something\n    in the future."
        ],
        [
            "Decorate test methods with this if you don't require strict index checking"
        ],
        [
            "Read and return the request data.\n\n        @param[in] deserialize\n            True to deserialize the resultant text using a determiend format\n            or the passed format.\n\n        @param[in] format\n            A specific format to deserialize in; if provided, no detection is\n            done. If not provided, the content-type header is looked at to\n            determine an appropriate deserializer."
        ],
        [
            "Updates the active resource configuration to the passed\n    keyword arguments.\n\n    Invoking this method without passing arguments will just return the\n    active resource configuration.\n\n    @returns\n        The previous configuration."
        ],
        [
            "This decorator wraps descriptor methods with a new method that tries\n    to delegate to a function of the same name defined on the owner instance\n    for convenience for dispatcher clients."
        ],
        [
            "Given a single decorated handler function,\n        prepare, append desired data to self.registry."
        ],
        [
            "Find the first method this input dispatches to."
        ],
        [
            "Given a node, return the string to use in computing the\n        matching visitor methodname. Can also be a generator of strings."
        ],
        [
            "Find all method names this input dispatches to."
        ],
        [
            "Parse string to create an instance\n\n          :param str s: String with requirement to parse\n          :param bool required: Is this requirement required to be fulfilled? If not, then it is a filter."
        ],
        [
            "Add requirements to be managed\n\n        :param list/Requirement requirements: List of :class:`BumpRequirement` or :class:`pkg_resources.Requirement`\n        :param bool required: Set required flag for each requirement if provided."
        ],
        [
            "Check if requirement is already satisfied by what was previously checked\n\n        :param Requirement req: Requirement to check"
        ],
        [
            "Add new requirements that must be fulfilled for this bump to occur"
        ],
        [
            "Parse changes for requirements\n\n        :param list changes:"
        ],
        [
            "Bump dependencies using given requirements.\n\n          :param RequirementsManager bump_reqs: Bump requirements manager\n          :param dict kwargs: Additional args from argparse. Some bumpers accept user options, and some not.\n          :return: List of :class:`Bump` changes made."
        ],
        [
            "Restore content in target file to be before any changes"
        ],
        [
            "Transforms the object into an acceptable format for transmission.\n\n        @throws ValueError\n            To indicate this serializer does not support the encoding of the\n            specified object."
        ],
        [
            "Extends a collection with a value."
        ],
        [
            "Merges a named option collection."
        ],
        [
            "All package info for given package"
        ],
        [
            "All versions for package"
        ],
        [
            "Flush and close the stream.\n\n        This is called automatically by the base resource on resources\n        unless the resource is operating asynchronously; in that case,\n        this method MUST be called in order to signal the end of the request.\n        If not the request will simply hang as it is waiting for some\n        thread to tell it to return to the client."
        ],
        [
            "Writes the given chunk to the output buffer.\n\n        @param[in] chunk\n            Either a byte array, a unicode string, or a generator. If `chunk`\n            is a generator then calling `self.write(<generator>)` is\n            equivalent to:\n\n            @code\n                for x in <generator>:\n                    self.write(x)\n                    self.flush()\n            @endcode\n\n        @param[in] serialize\n            True to serialize the lines in a determined serializer.\n\n        @param[in] format\n            A specific format to serialize in; if provided, no detection is\n            done. If not provided, the accept header (as well as the URL\n            extension) is looked at to determine an appropriate serializer."
        ],
        [
            "Serializes the data into this response using a serializer.\n\n        @param[in] data\n            The data to be serialized.\n\n        @param[in] format\n            A specific format to serialize in; if provided, no detection is\n            done. If not provided, the accept header (as well as the URL\n            extension) is looked at to determine an appropriate serializer.\n\n        @returns\n            A tuple of the serialized text and an instance of the\n            serializer used."
        ],
        [
            "Flush the write buffers of the stream.\n\n        This results in writing the current contents of the write buffer to\n        the transport layer, initiating the HTTP/1.1 response. This initiates\n        a streaming response. If the `Content-Length` header is not given\n        then the chunked `Transfer-Encoding` is applied."
        ],
        [
            "Writes the passed chunk and flushes it to the client."
        ],
        [
            "Writes the passed chunk, flushes it to the client,\n        and terminates the connection."
        ],
        [
            "This ``Context Manager`` is used to move the contents of a directory\n    elsewhere temporarily and put them back upon exit.  This allows testing\n    code to use the same file directories as normal code without fear of\n    damage.\n\n    The name of the temporary directory which contains your files is yielded.\n\n    :param dirname:\n        Path name of the directory to be replaced.\n\n\n    Example:\n\n    .. code-block:: python\n\n        with replaced_directory('/foo/bar/') as rd:\n            # \"/foo/bar/\" has been moved & renamed\n            with open('/foo/bar/thing.txt', 'w') as f:\n                f.write('stuff')\n                f.close()\n\n\n        # got here? => \"/foo/bar/ is now restored and temp has been wiped, \n        # \"thing.txt\" is gone"
        ],
        [
            "This ``Context Manager`` redirects STDOUT to a ``StringIO`` objects\n    which is returned from the ``Context``.  On exit STDOUT is restored.\n\n    Example:\n\n    .. code-block:: python\n\n        with capture_stdout() as capture:\n            print('foo')\n\n        # got here? => capture.getvalue() will now have \"foo\\\\n\""
        ],
        [
            "This ``Context Manager`` redirects STDERR to a ``StringIO`` objects\n    which is returned from the ``Context``.  On exit STDERR is restored.\n\n    Example:\n\n    .. code-block:: python\n\n        with capture_stderr() as capture:\n            print('foo')\n\n        # got here? => capture.getvalue() will now have \"foo\\\\n\""
        ],
        [
            "Builds the URL configuration for this resource."
        ],
        [
            "Dump an object in req format to the fp given.\n\n    :param Mapping obj: The object to serialize.  Must have a keys method.\n    :param fp: A writable that can accept all the types given.\n    :param separator: The separator between key and value.  Defaults to u'|' or b'|', depending on the types.\n    :param index_separator: The separator between key and index.  Defaults to u'_' or b'_', depending on the types."
        ],
        [
            "Dump an object in req format to a string.\n\n    :param Mapping obj: The object to serialize.  Must have a keys method.\n    :param separator: The separator between key and value.  Defaults to u'|' or b'|', depending on the types.\n    :param index_separator: The separator between key and index.  Defaults to u'_' or b'_', depending on the types."
        ],
        [
            "Load an object from the file pointer.\n\n    :param fp: A readable filehandle.\n    :param separator: The separator between key and value.  Defaults to u'|' or b'|', depending on the types.\n    :param index_separator: The separator between key and index.  Defaults to u'_' or b'_', depending on the types.\n    :param cls: A callable that returns a Mapping that is filled with pairs.  The most common alternate option would be OrderedDict.\n    :param list_cls: A callable that takes an iterable and returns a sequence."
        ],
        [
            "Loads an object from a string.\n\n    :param s: An object to parse\n    :type s: bytes or str\n    :param separator: The separator between key and value.  Defaults to u'|' or b'|', depending on the types.\n    :param index_separator: The separator between key and index.  Defaults to u'_' or b'_', depending on the types.\n    :param cls: A callable that returns a Mapping that is filled with pairs.  The most common alternate option would be OrderedDict.\n    :param list_cls: A callable that takes an iterable and returns a sequence."
        ],
        [
            "Reverse all bumpers"
        ],
        [
            "Expand targets by looking for '-r' in targets."
        ],
        [
            "Gets the Nginx config for the project"
        ],
        [
            "Creates base directories for app, virtualenv, and nginx"
        ],
        [
            "Creates the virtualenv for the project"
        ],
        [
            "Creates the Nginx configuration for the project"
        ],
        [
            "Creates scripts to start and stop the application"
        ],
        [
            "Creates the full project"
        ],
        [
            "Dasherizes the passed value."
        ],
        [
            "Redirect to the canonical URI for this resource."
        ],
        [
            "Parses out parameters and separates them out of the path.\n\n        This uses one of the many defined patterns on the options class. But,\n        it defaults to a no-op if there are no defined patterns."
        ],
        [
            "Traverses down the path and determines the accessed resource.\n\n        This makes use of the patterns array to implement simple traversal.\n        This defaults to a no-op if there are no defined patterns."
        ],
        [
            "Helper method used in conjunction with the view handler to\n        stream responses to the client."
        ],
        [
            "Deserializes the text using a determined deserializer.\n\n        @param[in] request\n            The request object to pull information from; normally used to\n            determine the deserialization format (when `format` is\n            not provided).\n\n        @param[in] text\n            The text to be deserialized. Can be left blank and the\n            request will be read.\n\n        @param[in] format\n            A specific format to deserialize in; if provided, no detection is\n            done. If not provided, the content-type header is looked at to\n            determine an appropriate deserializer.\n\n        @returns\n            A tuple of the deserialized data and an instance of the\n            deserializer used."
        ],
        [
            "Serializes the data using a determined serializer.\n\n        @param[in] data\n            The data to be serialized.\n\n        @param[in] response\n            The response object to serialize the data to.\n            If this method is invoked as an instance method, the response\n            object can be omitted and it will be taken from the instance.\n\n        @param[in] request\n            The request object to pull information from; normally used to\n            determine the serialization format (when `format` is not provided).\n            May be used by some serializers as well to pull additional headers.\n            If this method is invoked as an instance method, the request\n            object can be omitted and it will be taken from the instance.\n\n        @param[in] format\n            A specific format to serialize in; if provided, no detection is\n            done. If not provided, the accept header (as well as the URL\n            extension) is looked at to determine an appropriate serializer.\n\n        @returns\n            A tuple of the serialized text and an instance of the\n            serializer used."
        ],
        [
            "Entry-point of the dispatch cycle for this resource.\n\n        Performs common work such as authentication, decoding, etc. before\n        handing complete control of the result to a function with the\n        same name as the request method."
        ],
        [
            "Ensure we are authenticated."
        ],
        [
            "Ensure we are allowed to access this resource."
        ],
        [
            "Ensure that we're allowed to use this HTTP method."
        ],
        [
            "Processes every request.\n\n        Directs control flow to the appropriate HTTP/1.1 method."
        ],
        [
            "Process an `OPTIONS` request.\n\n        Used to initiate a cross-origin request. All handling specific to\n        CORS requests is done on every request however this method also\n        returns a list of available methods."
        ],
        [
            "Wraps the decorated function in a lightweight resource."
        ],
        [
            "Render to cookie strings."
        ],
        [
            "update self with cookie_string."
        ],
        [
            "Adds a method to the internal lists of allowed or denied methods.\n        Each object in the internal list contains a resource ARN and a\n        condition statement. The condition statement can be null."
        ],
        [
            "This function loops over an array of objects containing\n        a resourceArn and conditions statement and generates\n        the array of statements for the policy."
        ],
        [
            "AWS doesn't quite have Swagger 2.0 validation right and will fail\n        on some refs. So, we need to convert to deref before\n        upload."
        ],
        [
            "Check all necessary system requirements to exist.\n\n    :param pre_requirements:\n        Sequence of pre-requirements to check by running\n        ``where <pre_requirement>`` on Windows and ``which ...`` elsewhere."
        ],
        [
            "Convert config dict to arguments list.\n\n    :param config: Configuration dict."
        ],
        [
            "Create virtual environment.\n\n    :param env: Virtual environment name.\n    :param args: Pass given arguments to ``virtualenv`` script.\n    :param recerate: Recreate virtual environment? By default: False\n    :param ignore_activated:\n        Ignore already activated virtual environment and create new one. By\n        default: False\n    :param quiet: Do not output messages into terminal. By default: False"
        ],
        [
            "Decorator to error handling."
        ],
        [
            "Install library or project into virtual environment.\n\n    :param env: Use given virtual environment name.\n    :param requirements: Use given requirements file for pip.\n    :param args: Pass given arguments to pip script.\n    :param ignore_activated:\n        Do not run pip inside already activated virtual environment. By\n        default: False\n    :param install_dev_requirements:\n        When enabled install prefixed or suffixed dev requirements after\n        original installation process completed. By default: False\n    :param quiet: Do not output message to terminal. By default: False"
        ],
        [
            "Iterate over dict items."
        ],
        [
            "Iterate over dict keys."
        ],
        [
            "r\"\"\"Bootstrap Python projects and libraries with virtualenv and pip.\n\n    Also check system requirements before bootstrap and run post bootstrap\n    hook if any.\n\n    :param \\*args: Command line arguments list."
        ],
        [
            "Parse args from command line by creating argument parser instance and\n    process it.\n\n    :param args: Command line arguments list."
        ],
        [
            "r\"\"\"Run pip command in given or activated virtual environment.\n\n    :param env: Virtual environment name.\n    :param cmd: Pip subcommand to run.\n    :param ignore_activated:\n        Ignore activated virtual environment and use given venv instead. By\n        default: False\n    :param \\*\\*kwargs:\n        Additional keyword arguments to be passed to :func:`~run_cmd`"
        ],
        [
            "Convert config dict to command line args line.\n\n    :param config: Configuration dict.\n    :param bootstrap: Bootstrapper configuration dict."
        ],
        [
            "Print error message to stderr, using ANSI-colors.\n\n    :param message: Message to print\n    :param wrap:\n        Wrap message into ``ERROR: <message>. Exit...`` template. By default:\n        True"
        ],
        [
            "Print message via ``subprocess.call`` function.\n\n    This helps to ensure consistent output and avoid situations where print\n    messages actually shown after messages from all inner threads.\n\n    :param message: Text message to print."
        ],
        [
            "Read and parse configuration file. By default, ``filename`` is relative\n    path to current work directory.\n\n    If no config file found, default ``CONFIG`` would be used.\n\n    :param filename: Read config from given filename.\n    :param args: Parsed command line arguments."
        ],
        [
            "r\"\"\"Call given command with ``subprocess.call`` function.\n\n    :param cmd: Command to run.\n    :type cmd: tuple or str\n    :param echo:\n        If enabled show command to call and its output in STDOUT, otherwise\n        hide all output. By default: False\n    :param fail_silently: Do not raise exception on error. By default: False\n    :param \\*\\*kwargs:\n        Additional keyword arguments to be passed to ``subprocess.call``\n        function. STDOUT and STDERR streams would be setup inside of function\n        to ensure hiding command output in case of disabling ``echo``."
        ],
        [
            "Run post-bootstrap hook if any.\n\n    :param hook: Hook to run.\n    :param config: Configuration dict.\n    :param quiet: Do not output messages to STDOUT/STDERR. By default: False"
        ],
        [
            "Save error traceback to bootstrapper log file.\n\n    :param err: Catched exception."
        ],
        [
            "Convert Python object to string.\n\n    :param value: Python object to convert.\n    :param encoding: Encoding to use if in Python 2 given object is unicode.\n    :param errors: Errors mode to use if in Python 2 given object is unicode."
        ],
        [
            "Copy file from `src` path to `dst` path. If `dst` already exists, will add '+' characters\n    to the end of the basename without extension.\n\n    Parameters\n    ----------\n    src: str\n\n    dst: str\n\n    Returns\n    -------\n    dstpath: str"
        ],
        [
            "Returns the absolute path of folderpath.\n    If the path does not exist, will raise IOError."
        ],
        [
            "Return the extension of fpath.\n\n    Parameters\n    ----------\n    fpath: string\n    File name or path\n\n    check_if_exists: bool\n\n    allowed_exts: dict\n    Dictionary of strings, where the key if the last part of a complex ('.' separated) extension\n    and the value is the previous part.\n    For example: for the '.nii.gz' extension I would have a dict as {'.gz': ['.nii',]}\n\n    Returns\n    -------\n    str\n    The extension of the file name or path"
        ],
        [
            "Add the extension ext to fpath if it doesn't have it.\n\n    Parameters\n    ----------\n    filepath: str\n    File name or path\n\n    ext: str\n    File extension\n\n    check_if_exists: bool\n\n    Returns\n    -------\n    File name or path with extension added, if needed."
        ],
        [
            "Joins path to each line in filelist\n\n    Parameters\n    ----------\n    path: str\n\n    filelist: list of str\n\n    Returns\n    -------\n    list of filepaths"
        ],
        [
            "Deletes all files in filelist\n\n    Parameters\n    ----------\n    filelist: list of str\n        List of the file paths to be removed\n\n    folder: str\n        Path to be used as common directory for all file paths in filelist"
        ],
        [
            "Returns the length of the file using the 'wc' GNU command\n\n    Parameters\n    ----------\n    filepath: str\n\n    Returns\n    -------\n    float"
        ],
        [
            "Merge two dictionaries.\n\n    Values that evaluate to true take priority over falsy values.\n    `dict_1` takes priority over `dict_2`."
        ],
        [
            "Return a folder path if it exists.\n\n    First will check if it is an existing system path, if it is, will return it\n    expanded and absoluted.\n\n    If this fails will look for the rcpath variable in the app_name rcfiles or\n    exclusively within the given section_name, if given.\n\n    Parameters\n    ----------\n    rcpath: str\n        Existing folder path or variable name in app_name rcfile with an\n        existing one.\n\n    section_name: str\n        Name of a section in the app_name rcfile to look exclusively there for\n        variable names.\n\n    app_name: str\n        Name of the application to look for rcfile configuration files.\n\n    Returns\n    -------\n    sys_path: str\n        A expanded absolute file or folder path if the path exists.\n\n    Raises\n    ------\n    IOError if the proposed sys_path does not exist."
        ],
        [
            "Read environment variables and config files and return them merged with\n    predefined list of arguments.\n\n    Parameters\n    ----------\n    appname: str\n        Application name, used for config files and environment variable\n        names.\n\n    section: str\n        Name of the section to be read. If this is not set: appname.\n\n    args:\n        arguments from command line (optparse, docopt, etc).\n\n    strip_dashes: bool\n        Strip dashes prefixing key names from args dict.\n\n    Returns\n    --------\n    dict\n        containing the merged variables of environment variables, config\n        files and args.\n\n    Raises\n    ------\n    IOError\n        In case the return value is empty.\n\n    Notes\n    -----\n    Environment variables are read if they start with appname in uppercase\n    with underscore, for example:\n\n        TEST_VAR=1\n\n    Config files compatible with ConfigParser are read and the section name\n    appname is read, example:\n\n        [appname]\n        var=1\n\n    We can also have host-dependent configuration values, which have\n    priority over the default appname values.\n\n        [appname]\n        var=1\n\n        [appname:mylinux]\n        var=3\n\n\n    For boolean flags do not try to use: 'True' or 'False',\n                                         'on' or 'off',\n                                         '1' or '0'.\n    Unless you are willing to parse this values by yourself.\n    We recommend commenting the variables out with '#' if you want to set a\n    flag to False and check if it is in the rcfile cfg dict, i.e.:\n\n        flag_value = 'flag_variable' in cfg\n\n\n    Files are read from: /etc/appname/config,\n                         /etc/appfilerc,\n                         ~/.config/appname/config,\n                         ~/.config/appname,\n                         ~/.appname/config,\n                         ~/.appnamerc,\n                         appnamerc,\n                         .appnamerc,\n                         appnamerc file found in 'path' folder variable in args,\n                         .appnamerc file found in 'path' folder variable in args,\n                         file provided by 'config' variable in args.\n\n    Example\n    -------\n        args = rcfile(__name__, docopt(__doc__, version=__version__))"
        ],
        [
            "Return the dictionary containing the rcfile section configuration\n    variables.\n\n    Parameters\n    ----------\n    section_name: str\n        Name of the section in the rcfiles.\n\n    app_name: str\n        Name of the application to look for its rcfiles.\n\n    Returns\n    -------\n    settings: dict\n        Dict with variable values"
        ],
        [
            "Return the value of the variable in the section_name section of the\n    app_name rc file.\n\n    Parameters\n    ----------\n    var_name: str\n        Name of the variable to be searched for.\n\n    section_name: str\n        Name of the section in the rcfiles.\n\n    app_name: str\n        Name of the application to look for its rcfiles.\n\n    Returns\n    -------\n    var_value: str\n        The value of the variable with given var_name."
        ],
        [
            "Return the section and the value of the variable where the first\n    var_name is found in the app_name rcfiles.\n\n    Parameters\n    ----------\n    var_name: str\n        Name of the variable to be searched for.\n\n    app_name: str\n        Name of the application to look for its rcfiles.\n\n    Returns\n    -------\n    section_name: str\n        Name of the section in the rcfiles where var_name was first found.\n\n    var_value: str\n        The value of the first variable with given var_name."
        ],
        [
            "Filters the lst using pattern.\n    If pattern starts with '(' it will be considered a re regular expression,\n    otherwise it will use fnmatch filter.\n\n    :param lst: list of strings\n\n    :param pattern: string\n\n    :return: list of strings\n    Filtered list of strings"
        ],
        [
            "Given a nested dictionary adict.\n    This returns its childen just below the path.\n    The path is a string composed of adict keys separated by sep.\n\n    :param adict: nested dict\n\n    :param path: str\n\n    :param sep: str\n\n    :return: dict or list or leaf of treemap"
        ],
        [
            "Given a nested dictionary, this returns all its leave elements in a list.\n\n    :param adict:\n\n    :return: list"
        ],
        [
            "Looks for path_regex within base_path. Each match is append\n    in the returned list.\n    path_regex may contain subfolder structure.\n    If any part of the folder structure is a\n\n    :param base_path: str\n\n    :param path_regex: str\n\n    :return list of strings"
        ],
        [
            "Will create dirpath folder. If dirpath already exists and overwrite is False,\n        will append a '+' suffix to dirpath until dirpath does not exist."
        ],
        [
            "Imports filetree and root_path variable values from the filepath.\n\n        :param filepath:\n        :return: root_path and filetree"
        ],
        [
            "Remove the nodes that match the pattern."
        ],
        [
            "Return the number of nodes that match the pattern.\n\n        :param pattern:\n\n        :param adict:\n        :return: int"
        ],
        [
            "Converts an array-like to an array of floats\n\n    The new dtype will be np.float32 or np.float64, depending on the original\n    type. The function can create a copy or modify the argument depending\n    on the argument copy.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix}\n\n    copy : bool, optional\n        If True, a copy of X will be created. If False, a copy may still be\n        returned if X's dtype is not a floating point type.\n\n    Returns\n    -------\n    XT : {array, sparse matrix}\n        An array of type np.float"
        ],
        [
            "Make arrays indexable for cross-validation.\n\n    Checks consistent length, passes through None, and ensures that everything\n    can be indexed by converting sparse matrices to csr and converting\n    non-interable objects to arrays.\n\n    Parameters\n    ----------\n    iterables : lists, dataframes, arrays, sparse matrices\n        List of objects to ensure sliceability."
        ],
        [
            "Input validation on an array, list, sparse matrix or similar.\n\n    By default, the input is converted to an at least 2nd numpy array.\n\n    Parameters\n    ----------\n    array : object\n        Input object to check / convert.\n\n    accept_sparse : string, list of string or None (default=None)\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc.  None means that sparse matrix input will raise an error.\n        If the input is sparse but not in the allowed format, it will be\n        converted to the first listed format.\n\n    order : 'F', 'C' or None (default=None)\n        Whether an array will be forced to be fortran or c-style.\n\n    copy : boolean (default=False)\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n\n    force_all_finite : boolean (default=True)\n        Whether to raise an error on np.inf and np.nan in X.\n\n    ensure_2d : boolean (default=True)\n        Whether to make X at least 2d.\n\n    allow_nd : boolean (default=False)\n        Whether to allow X.ndim > 2.\n\n    Returns\n    -------\n    X_converted : object\n        The converted and validated X."
        ],
        [
            "Input validation for standard estimators.\n\n    Checks X and y for consistent length, enforces X 2d and y 1d.\n    Standard input checks are only applied to y. For multi-label y,\n    set multi_ouput=True to allow 2d and sparse y.\n\n    Parameters\n    ----------\n    X : nd-array, list or sparse matrix\n        Input data.\n\n    y : nd-array, list or sparse matrix\n        Labels.\n\n    accept_sparse : string, list of string or None (default=None)\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc.  None means that sparse matrix input will raise an error.\n        If the input is sparse but not in the allowed format, it will be\n        converted to the first listed format.\n\n    order : 'F', 'C' or None (default=None)\n        Whether an array will be forced to be fortran or c-style.\n\n    copy : boolean (default=False)\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n\n    force_all_finite : boolean (default=True)\n        Whether to raise an error on np.inf and np.nan in X.\n\n    ensure_2d : boolean (default=True)\n        Whether to make X at least 2d.\n\n    allow_nd : boolean (default=False)\n        Whether to allow X.ndim > 2.\n\n    Returns\n    -------\n    X_converted : object\n        The converted and validated X."
        ],
        [
            "Ravel column or 1d numpy array, else raises an error\n\n    Parameters\n    ----------\n    y : array-like\n\n    Returns\n    -------\n    y : array"
        ],
        [
            "Warning utility function to check that data type is floating point.\n\n    Returns True if a warning was raised (i.e. the input is not float) and\n    False otherwise, for easier input validation."
        ],
        [
            "Convert an arbitrary array to numpy.ndarray.\n\n    In the case of a memmap array, a copy is automatically made to break the\n    link with the underlying file (whatever the value of the \"copy\" keyword).\n\n    The purpose of this function is mainly to get rid of memmap objects, but\n    it can be used for other purposes. In particular, combining copying and\n    casting can lead to performance improvements in some cases, by avoiding\n    unnecessary copies.\n\n    If not specified, input array order is preserved, in all cases, even when\n    a copy is requested.\n\n    Caveat: this function does not copy during bool to/from 1-byte dtype\n    conversions. This can lead to some surprising results in some rare cases.\n    Example:\n\n        a = numpy.asarray([0, 1, 2], dtype=numpy.int8)\n        b = as_ndarray(a, dtype=bool)  # array([False, True, True], dtype=bool)\n        c = as_ndarray(b, dtype=numpy.int8)  # array([0, 1, 2], dtype=numpy.int8)\n\n    The usually expected result for the last line would be array([0, 1, 1])\n    because True evaluates to 1. Since there is no copy made here, the original\n    array is recovered.\n\n    Parameters\n    ----------\n    arr: array-like\n        input array. Any value accepted by numpy.asarray is valid.\n\n    copy: bool\n        if True, force a copy of the array. Always True when arr is a memmap.\n\n    dtype: any numpy dtype\n        dtype of the returned array. Performing copy and type conversion at the\n        same time can in some cases avoid an additional copy.\n\n    order: string\n        gives the order of the returned array.\n        Valid values are: \"C\", \"F\", \"A\", \"K\", None.\n        default is \"K\". See ndarray.copy() for more information.\n\n    Returns\n    -------\n    ret: np.ndarray\n        Numpy array containing the same data as arr, always of class\n        numpy.ndarray, and with no link to any underlying file."
        ],
        [
            "Call FSL tools to apply transformations to a given atlas to a functional image.\n    Given the transformation matrices.\n\n    Parameters\n    ----------\n    atlas_filepath: str\n        Path to the 3D atlas volume file.\n\n    anatbrain_filepath: str\n        Path to the anatomical brain volume file (skull-stripped and registered to the same space as the atlas,\n        e.g., MNI).\n\n    meanfunc_filepath: str\n        Path to the average functional image to be used as reference in the last applywarp step.\n\n    atlas2anat_nonlin_xfm_filepath: str\n        Path to the atlas to anatomical brain linear transformation .mat file.\n        If you have the inverse transformation, i.e., anatomical brain to atlas, set is_atlas2anat_inverted to True.\n\n    is_atlas2anat_inverted: bool\n        If False will have to calculate the inverse atlas2anat transformation to apply the transformations.\n        This step will be performed with FSL invwarp.\n\n    anat2func_lin_xfm_filepath: str\n        Path to the anatomical to functional .mat linear transformation file.\n\n    atlasinanat_out_filepath: str\n        Path to output file which will contain the 3D atlas in the subject anatomical space.\n\n    atlasinfunc_out_filepath: str\n        Path to output file which will contain the 3D atlas in the subject functional space.\n\n    verbose: bool\n        If verbose will show DEBUG log info.\n\n    rewrite: bool\n        If True will re-run all the commands overwriting any existing file. Otherwise will check if\n        each file exists and if it does won't run the command.\n\n    parallel: bool\n        If True will launch the commands using ${FSLDIR}/fsl_sub to use the cluster infrastructure you have setup\n        with FSL (SGE or HTCondor)."
        ],
        [
            "Convert a FWHM value to sigma in a Gaussian kernel.\n\n    Parameters\n    ----------\n    fwhm: float or numpy.array\n       fwhm value or values\n\n    Returns\n    -------\n    fwhm: float or numpy.array\n       sigma values"
        ],
        [
            "Convert a sigma in a Gaussian kernel to a FWHM value.\n\n    Parameters\n    ----------\n    sigma: float or numpy.array\n       sigma value or values\n\n    Returns\n    -------\n    fwhm: float or numpy.array\n       fwhm values corresponding to `sigma` values"
        ],
        [
            "Smooth images with a a Gaussian filter.\n\n    Apply a Gaussian filter along the three first dimensions of arr.\n\n    Parameters\n    ----------\n    arr: numpy.ndarray\n        3D or 4D array, with image number as last dimension.\n\n    affine: numpy.ndarray\n        Image affine transformation matrix for image.\n\n    fwhm: scalar, numpy.ndarray\n        Smoothing kernel size, as Full-Width at Half Maximum (FWHM) in millimeters.\n        If a scalar is given, kernel width is identical on all three directions.\n        A numpy.ndarray must have 3 elements, giving the FWHM along each axis.\n\n    copy: bool\n        if True, will make a copy of the input array. Otherwise will directly smooth the input array.\n\n    Returns\n    -------\n    smooth_arr: numpy.ndarray"
        ],
        [
            "Smooth images using a Gaussian filter.\n\n    Apply a Gaussian filter along the three first dimensions of each image in images.\n    In all cases, non-finite values in input are zeroed.\n\n    Parameters\n    ----------\n    imgs: str or img-like object or iterable of img-like objects\n        See boyle.nifti.read.read_img\n        Image(s) to smooth.\n\n    fwhm: scalar or numpy.ndarray\n        Smoothing kernel size, as Full-Width at Half Maximum (FWHM) in millimeters.\n        If a scalar is given, kernel width is identical on all three directions.\n        A numpy.ndarray must have 3 elements, giving the FWHM along each axis.\n\n    Returns\n    -------\n    smooth_imgs: nibabel.Nifti1Image or list of.\n        Smooth input image/s."
        ],
        [
            "Smooth images by applying a Gaussian filter.\n    Apply a Gaussian filter along the three first dimensions of arr.\n\n    This is copied and slightly modified from nilearn:\n    https://github.com/nilearn/nilearn/blob/master/nilearn/image/image.py\n    Added the **kwargs argument.\n\n    Parameters\n    ==========\n    arr: numpy.ndarray\n        4D array, with image number as last dimension. 3D arrays are also\n        accepted.\n    affine: numpy.ndarray\n        (4, 4) matrix, giving affine transformation for image. (3, 3) matrices\n        are also accepted (only these coefficients are used).\n        If fwhm='fast', the affine is not used and can be None\n    fwhm: scalar, numpy.ndarray, 'fast' or None\n        Smoothing strength, as a full-width at half maximum, in millimeters.\n        If a scalar is given, width is identical on all three directions.\n        A numpy.ndarray must have 3 elements, giving the FWHM along each axis.\n        If fwhm == 'fast', a fast smoothing will be performed with\n        a filter [0.2, 1, 0.2] in each direction and a normalisation\n        to preserve the local average value.\n        If fwhm is None, no filtering is performed (useful when just removal\n        of non-finite values is needed).\n    ensure_finite: bool\n        if True, replace every non-finite values (like NaNs) by zero before\n        filtering.\n    copy: bool\n        if True, input array is not modified. False by default: the filtering\n        is performed in-place.\n    kwargs: keyword-arguments\n        Arguments for the ndimage.gaussian_filter1d function.\n\n    Returns\n    =======\n    filtered_arr: numpy.ndarray\n        arr, filtered.\n    Notes\n    =====\n    This function is most efficient with arr in C order."
        ],
        [
            "Smooth images by applying a Gaussian filter.\n    Apply a Gaussian filter along the three first dimensions of arr.\n    In all cases, non-finite values in input image are replaced by zeros.\n\n    This is copied and slightly modified from nilearn:\n    https://github.com/nilearn/nilearn/blob/master/nilearn/image/image.py\n    Added the **kwargs argument.\n\n    Parameters\n    ==========\n    imgs: Niimg-like object or iterable of Niimg-like objects\n        See http://nilearn.github.io/manipulating_images/manipulating_images.html#niimg.\n        Image(s) to smooth.\n    fwhm: scalar, numpy.ndarray, 'fast' or None\n        Smoothing strength, as a Full-Width at Half Maximum, in millimeters.\n        If a scalar is given, width is identical on all three directions.\n        A numpy.ndarray must have 3 elements, giving the FWHM along each axis.\n        If fwhm == 'fast', a fast smoothing will be performed with\n        a filter [0.2, 1, 0.2] in each direction and a normalisation\n        to preserve the scale.\n        If fwhm is None, no filtering is performed (useful when just removal\n        of non-finite values is needed)\n    Returns\n    =======\n    filtered_img: nibabel.Nifti1Image or list of.\n        Input image, filtered. If imgs is an iterable, then filtered_img is a\n        list."
        ],
        [
            "Create requests session with any required auth headers\n        applied.\n\n        :rtype: requests.Session."
        ],
        [
            "Create requests session with AAD auth headers\n\n        :rtype: requests.Session."
        ],
        [
            "Return a grid with coordinates in 3D physical space for `img`."
        ],
        [
            "Gets a 3D CoordinateMap from img.\n\n    Parameters\n    ----------\n    img: nib.Nifti1Image or nipy Image\n\n    Returns\n    -------\n    nipy.core.reference.coordinate_map.CoordinateMap"
        ],
        [
            "Return the header and affine matrix from a Nifti file.\n\n    Parameters\n    ----------\n    image: img-like object or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    Returns\n    -------\n    hdr, aff"
        ],
        [
            "Return the voxel matrix of the Nifti file.\n    If safe_mode will make a copy of the img before returning the data, so the input image is not modified.\n\n    Parameters\n    ----------\n    image: img-like object or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    copy: bool\n    If safe_mode will make a copy of the img before returning the data, so the input image is not modified.\n\n    Returns\n    -------\n    array_like"
        ],
        [
            "Read a Nifti file and return as nipy.Image\n\n    Parameters\n    ----------\n    param nii_file: str\n        Nifti file path\n\n    Returns\n    -------\n    nipy.Image"
        ],
        [
            "From the list of absolute paths to nifti files, creates a Numpy array\n    with the data.\n\n    Parameters\n    ----------\n    img_filelist:  list of str\n        List of absolute file paths to nifti files. All nifti files must have\n        the same shape.\n\n    outdtype: dtype\n        Type of the elements of the array, if not set will obtain the dtype from\n        the first nifti file.\n\n    Returns\n    -------\n    outmat: Numpy array with shape N x prod(vol.shape)\n            containing the N files as flat vectors.\n\n    vol_shape: Tuple with shape of the volumes, for reshaping."
        ],
        [
            "Crops image to a smaller size\n\n    Crop img to size indicated by slices and modify the affine accordingly.\n\n    Parameters\n    ----------\n    image: img-like object or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n        Image to be cropped.\n\n    slices: list of slices\n        Defines the range of the crop.\n        E.g. [slice(20, 200), slice(40, 150), slice(0, 100)]\n        defines a 3D cube\n\n        If slices has less entries than image has dimensions,\n        the slices will be applied to the first len(slices) dimensions.\n\n    copy: boolean\n        Specifies whether cropped data is to be copied or not.\n        Default: True\n\n    Returns\n    -------\n    cropped_img: img-like object\n        Cropped version of the input image"
        ],
        [
            "Crops img as much as possible\n\n    Will crop img, removing as many zero entries as possible\n    without touching non-zero entries. Will leave one voxel of\n    zero padding around the obtained non-zero area in order to\n    avoid sampling issues later on.\n\n    Parameters\n    ----------\n    image: img-like object or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n        Image to be cropped.\n\n    rtol: float\n        relative tolerance (with respect to maximal absolute\n        value of the image), under which values are considered\n        negligeable and thus croppable.\n\n    copy: boolean\n        Specifies whether cropped data is copied or not.\n\n    Returns\n    -------\n    cropped_img: image\n        Cropped version of the input image"
        ],
        [
            "Create a new image of the same class as the reference image\n\n    Parameters\n    ----------\n    ref_niimg: image\n        Reference image. The new image will be of the same type.\n\n    data: numpy array\n        Data to be stored in the image\n\n    affine: 4x4 numpy array, optional\n        Transformation matrix\n\n    copy_header: boolean, optional\n        Indicated if the header of the reference image should be used to\n        create the new image\n\n    Returns\n    -------\n    new_img: image\n        A loaded image with the same type (and header) as the reference image."
        ],
        [
            "Return the h5py.File given its file path.\n\n    Parameters\n    ----------\n    file_path: string\n        HDF5 file path\n\n    mode: string\n        r   Readonly, file must exist\n        r+  Read/write, file must exist\n        w   Create file, truncate if exists\n        w-  Create file, fail if exists\n        a   Read/write if exists, create otherwise (default)\n\n    Returns\n    -------\n    h5file: h5py.File"
        ],
        [
            "Return all dataset contents from h5path group in h5file in an OrderedDict.\n\n    Parameters\n    ----------\n    h5file: h5py.File\n        HDF5 file object\n\n    h5path: str\n        HDF5 group path to read datasets from\n\n    Returns\n    -------\n    datasets: OrderedDict\n        Dict with variables contained in file_path/h5path"
        ],
        [
            "Return the node of type node_type names within h5path of h5file.\n\n    Parameters\n    ----------\n    h5file: h5py.File\n        HDF5 file object\n\n    h5path: str\n        HDF5 group path to get the group names from\n\n    node_type: h5py object type\n        HDF5 object type\n\n    Returns\n    -------\n    names: list of str\n        List of names"
        ],
        [
            "self.mask setter\n\n        Parameters\n        ----------\n        image: str or img-like object.\n            See NeuroImage constructor docstring."
        ],
        [
            "Read the images, load them into self.items and set the labels."
        ],
        [
            "Save the Numpy array created from to_matrix function to the output_file.\n\n        Will save into the file: outmat, mask_indices, vol_shape and self.others (put here whatever you want)\n\n            data: Numpy array with shape N x prod(vol.shape)\n                  containing the N files as flat vectors.\n\n            mask_indices: matrix with indices of the voxels in the mask\n\n            vol_shape: Tuple with shape of the volumes, for reshaping.\n\n        Parameters\n        ----------\n        output_file: str\n            Path to the output file. The extension of the file will be taken into account for the file format.\n            Choices of extensions: '.pyshelf' or '.shelf' (Python shelve)\n                                   '.mat' (Matlab archive),\n                                   '.hdf5' or '.h5' (HDF5 file)\n\n        smooth_fwhm: int\n            Integer indicating the size of the FWHM Gaussian smoothing kernel\n            to smooth the subject volumes before creating the data matrix\n\n        outdtype: dtype\n            Type of the elements of the array, if None will obtain the dtype from\n            the first nifti file."
        ],
        [
            "Writes msg to stderr and exits with return code"
        ],
        [
            "Calls the command\n\n    Parameters\n    ----------\n    cmd_args: list of str\n        Command name to call and its arguments in a list.\n\n    Returns\n    -------\n    Command output"
        ],
        [
            "Call CLI command with arguments and returns its return value.\n\n    Parameters\n    ----------\n    cmd_name: str\n        Command name or full path to the binary file.\n\n    arg_strings: list of str\n        Argument strings list.\n\n    Returns\n    -------\n    return_value\n        Command return value."
        ],
        [
            "Tries to submit cmd to HTCondor, if it does not succeed, it will\n    be called with subprocess.call.\n\n    Parameters\n    ----------\n    cmd: string\n        Command to be submitted\n\n    Returns\n    -------"
        ],
        [
            "Submits cmd to HTCondor queue\n\n    Parameters\n    ----------\n    cmd: string\n        Command to be submitted\n\n    Returns\n    -------\n    int\n        returncode value from calling the submission command."
        ],
        [
            "Clean previously built package artifacts."
        ],
        [
            "Upload the package to an index server.\n\n    This implies cleaning and re-building the package.\n\n    :param repo: Required. Name of the index server to upload to, as specifies\n        in your .pypirc configuration file."
        ],
        [
            "Load all Service Fabric commands"
        ],
        [
            "Open a volumetric file using the tools following the file extension.\n\n    Parameters\n    ----------\n    filepath: str\n        Path to a volume file\n\n    Returns\n    -------\n    volume_data: np.ndarray\n        Volume data\n\n    pixdim: 1xN np.ndarray\n        Vector with the description of the voxels physical size (usually in mm) for each volume dimension.\n\n    Raises\n    ------\n    IOError\n        In case the file is not found."
        ],
        [
            "Will rename all files in file_lst to a padded serial\n    number plus its extension\n\n    :param file_lst: list of path.py paths"
        ],
        [
            "Search for dicoms in folders and save file paths into\n        self.dicom_paths set.\n\n        :param folders: str or list of str"
        ],
        [
            "Overwrites self.items with the given set of files.\n        Will filter the fileset and keep only Dicom files.\n\n        Parameters\n        ----------\n        fileset: iterable of str\n        Paths to files\n\n        check_if_dicoms: bool\n        Whether to check if the items in fileset are dicom file paths"
        ],
        [
            "Update this set with the union of itself and dicomset.\n\n        Parameters\n        ----------\n        dicomset: DicomFileSet"
        ],
        [
            "Copies all files within this set to the output_folder\n\n        Parameters\n        ----------\n        output_folder: str\n        Path of the destination folder of the files\n\n        rename_files: bool\n        Whether or not rename the files to a sequential format\n\n        mkdir: bool\n        Whether to make the folder if it does not exist\n\n        verbose: bool\n        Whether to print to stdout the files that are beind copied"
        ],
        [
            "Creates a lambda function to read DICOM files.\n        If store_store_metadata is False, will only return the file path.\n        Else if you give header_fields, will return only the set of of\n        header_fields within a DicomFile object or the whole DICOM file if\n        None.\n\n        :return: function\n        This function has only one parameter: file_path"
        ],
        [
            "Generator that yields one by one the return value for self.read_dcm\n        for each file within this set"
        ],
        [
            "Return a set of unique field values from a list of DICOM files\n\n    Parameters\n    ----------\n    dcm_file_list: iterable of DICOM file paths\n\n    field_name: str\n     Name of the field from where to get each value\n\n    Returns\n    -------\n    Set of field values"
        ],
        [
            "Returns a list of the dicom files within root_path\n\n    Parameters\n    ----------\n    root_path: str\n    Path to the directory to be recursively searched for DICOM files.\n\n    Returns\n    -------\n    dicoms: set\n    Set of DICOM absolute file paths"
        ],
        [
            "Tries to read the file using dicom.read_file,\n    if the file exists and dicom.read_file does not raise\n    and Exception returns True. False otherwise.\n\n    :param filepath: str\n     Path to DICOM file\n\n    :return: bool"
        ],
        [
            "Group in a dictionary all the DICOM files in dicom_paths\n    separated by the given `hdr_field` tag value.\n\n    Parameters\n    ----------\n    dicom_paths: str\n        Iterable of DICOM file paths.\n\n    hdr_field: str\n        Name of the DICOM tag whose values will be used as key for the group.\n\n    Returns\n    -------\n    dicom_groups: dict of dicom_paths"
        ],
        [
            "Return the attributes values from this DicomFile\n\n        Parameters\n        ----------\n        attributes: str or list of str\n         DICOM field names\n\n        default: str\n         Default value if the attribute does not exist.\n\n        Returns\n        -------\n        Value of the field or list of values."
        ],
        [
            "Concatenate `images` in the direction determined in `axis`.\n\n    Parameters\n    ----------\n    images: list of str or img-like object.\n        See NeuroImage constructor docstring.\n\n    axis: str\n      't' : concatenate images in time\n      'x' : concatenate images in the x direction\n      'y' : concatenate images in the y direction\n      'z' : concatenate images in the z direction\n\n    Returns\n    -------\n    merged: img-like object"
        ],
        [
            "Picks a function whose first argument is an `img`, processes its\n    data and returns a numpy array. This decorator wraps this numpy array\n    into a nibabel.Nifti1Image."
        ],
        [
            "Pixelwise division or divide by a number"
        ],
        [
            "Return the image with the given `mask` applied."
        ],
        [
            "Return an image with the binarised version of the data of `img`."
        ],
        [
            "Return a z-scored version of `icc`.\n    This function is based on GIFT `icatb_convertImageToZScores` function."
        ],
        [
            "Return the thresholded z-scored `icc`."
        ],
        [
            "Write the content of the `meta_dict` into `filename`.\n\n    Parameters\n    ----------\n    filename: str\n        Path to the output file\n\n    meta_dict: dict\n        Dictionary with the fields of the metadata .mhd file"
        ],
        [
            "Write the data into a raw format file. Big endian is always used.\n\n    Parameters\n    ----------\n    filename: str\n        Path to the output file\n\n    data: numpy.ndarray\n        n-dimensional image data array."
        ],
        [
            "Write the `data` and `meta_dict` in two files with names\n    that use `filename` as a prefix.\n\n    Parameters\n    ----------\n    filename: str\n        Path to the output file.\n        This is going to be used as a preffix.\n        Two files will be created, one with a '.mhd' extension\n        and another with '.raw'. If `filename` has any of these already\n        they will be taken into account to build the filenames.\n\n    data: numpy.ndarray\n        n-dimensional image data array.\n\n    shape: tuple\n        Tuple describing the shape of `data`\n        Default: data.shape\n\n    meta_dict: dict\n        Dictionary with the fields of the metadata .mhd file\n        Default: {}\n\n    Returns\n    -------\n    mhd_filename: str\n        Path to the .mhd file\n\n    raw_filename: str\n        Path to the .raw file"
        ],
        [
            "Copy .mhd and .raw files to dst.\n\n    If dst is a folder, won't change the file, but if dst is another filepath,\n    will modify the ElementDataFile field in the .mhd to point to the\n    new renamed .raw file.\n\n    Parameters\n    ----------\n    src: str\n        Path to the .mhd file to be copied\n\n    dst: str\n        Path to the destination of the .mhd and .raw files.\n        If a new file name is given, the extension will be ignored.\n\n    Returns\n    -------\n    dst: str"
        ],
        [
            "SPSS .sav files to Pandas DataFrame through Rpy2\n\n    :param input_file: string\n\n    :return:"
        ],
        [
            "SPSS .sav files to Pandas DataFrame through savreader module\n\n    :param input_file: string\n\n    :return:"
        ],
        [
            "Valid extensions '.pyshelf', '.mat', '.hdf5' or '.h5'\n\n        @param filename: string\n\n        @param varnames: list of strings\n        Names of the variables\n\n        @param varlist: list of objects\n        The objects to be saved"
        ],
        [
            "Create CLI environment"
        ],
        [
            "Find all the ROIs in img and returns a similar volume with the ROIs\n    emptied, keeping only their border voxels.\n\n    This is useful for DTI tractography.\n\n    Parameters\n    ----------\n    img: img-like object or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    Returns\n    -------\n    np.ndarray\n        an array of same shape as img_data"
        ],
        [
            "Return the largest connected component of a 3D array.\n\n    Parameters\n    -----------\n    volume: numpy.array\n        3D boolean array.\n\n    Returns\n    --------\n    volume: numpy.array\n        3D boolean array with only one connected component."
        ],
        [
            "Return as mask for `volume` that includes only areas where\n    the connected components have a size bigger than `min_cluster_size`\n    in number of voxels.\n\n    Parameters\n    -----------\n    volume: numpy.array\n        3D boolean array.\n\n    min_cluster_size: int\n        Minimum size in voxels that the connected component must have.\n\n    Returns\n    --------\n    volume: numpy.array\n        3D int array with a mask excluding small connected components."
        ],
        [
            "Look for the files in filelist containing the names in roislist, these files will be opened, binarised\n    and merged in one mask.\n\n    Parameters\n    ----------\n    roislist: list of strings\n        Names of the ROIs, which will have to be in the names of the files in filelist.\n\n    filelist: list of strings\n        List of paths to the volume files containing the ROIs.\n\n    Returns\n    -------\n    numpy.ndarray\n        Mask volume"
        ],
        [
            "Return a sorted list of the non-zero unique values of arr.\n\n    Parameters\n    ----------\n    arr: numpy.ndarray\n        The data array\n\n    Returns\n    -------\n    list of items of arr."
        ],
        [
            "Get the center of mass for each ROI in the given volume.\n\n    Parameters\n    ----------\n    vol: numpy ndarray\n        Volume with different values for each ROI.\n\n    Returns\n    -------\n    OrderedDict\n        Each entry in the dict has the ROI value as key and the center_of_mass coordinate as value."
        ],
        [
            "Extracts the values in `datavol` that are in the ROI with value `roivalue` in `roivol`.\n    The ROI can be masked by `maskvol`.\n\n    Parameters\n    ----------\n    datavol: numpy.ndarray\n        4D timeseries volume or a 3D volume to be partitioned\n\n    roivol: numpy.ndarray\n        3D ROIs volume\n\n    roivalue: int or float\n        A value from roivol that represents the ROI to be used for extraction.\n\n    maskvol: numpy.ndarray\n        3D mask volume\n\n    zeroe: bool\n        If true will remove the null timeseries voxels.  Only applied to timeseries (4D) data.\n\n    Returns\n    -------\n    values: np.array\n        An array of the values in the indicated ROI.\n        A 2D matrix if `datavol` is 4D or a 1D vector if `datavol` is 3D."
        ],
        [
            "Pick one 3D volume from a 4D nifti image file\n\n    Parameters\n    ----------\n    image: img-like object or str\n        Volume defining different ROIs.\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    vol_idx: int\n        Index of the 3D volume to be extracted from the 4D volume.\n\n    Returns\n    -------\n    vol, hdr, aff\n        The data array, the image header and the affine transform matrix."
        ],
        [
            "Returns a h5py dataset given its registered name.\n\n        :param ds_name: string\n        Name of the dataset to be returned.\n\n        :return:"
        ],
        [
            "Creates a Dataset with unknown size.\n        Resize it before using.\n\n        :param ds_name: string\n\n        :param dtype: dtype\n        Datatype of the dataset\n\n        :return: h5py DataSet"
        ],
        [
            "Saves a Numpy array in a dataset in the HDF file, registers it as\n        ds_name and returns the h5py dataset.\n\n        :param ds_name: string\n        Registration name of the dataset to be registered.\n\n        :param data: Numpy ndarray\n\n        :param dtype: dtype\n        Datatype of the dataset\n\n        :return: h5py dataset"
        ],
        [
            "See create_dataset."
        ],
        [
            "Will get the names of the index colums of df, obtain their ranges from\n        range_values dict and return a reindexed version of df with the given\n        range values.\n\n        :param df: pandas DataFrame\n\n        :param range_values: dict or array-like\n        Must contain for each index column of df an entry with all the values\n        within the range of the column.\n\n        :param fill_value: scalar or 'nearest', default 0\n        Value to use for missing values. Defaults to 0, but can be any\n        \"compatible\" value, e.g., NaN.\n        The 'nearest' mode will fill the missing value with the nearest value in\n         the column.\n\n        :param fill_method:  {'backfill', 'bfill', 'pad', 'ffill', None}, default None\n        Method to use for filling holes in reindexed DataFrame\n        'pad' / 'ffill': propagate last valid observation forward to next valid\n        'backfill' / 'bfill': use NEXT valid observation to fill gap\n\n        :return: pandas Dataframe and used column ranges\n        reindexed DataFrame and dict with index column ranges"
        ],
        [
            "Retrieve pandas object or group of Numpy ndarrays\n        stored in file\n\n        Parameters\n        ----------\n        key : object\n\n        Returns\n        -------\n        obj : type of object stored in file"
        ],
        [
            "Store object in HDFStore\n\n        Parameters\n        ----------\n        key : str\n\n        value : {Series, DataFrame, Panel, Numpy ndarray}\n\n        format : 'fixed(f)|table(t)', default is 'fixed'\n            fixed(f) : Fixed format\n                Fast writing/reading. Not-appendable, nor searchable\n\n            table(t) : Table format\n                Write as a PyTables Table structure which may perform worse but allow more flexible operations\n                like searching/selecting subsets of the data\n\n        append : boolean, default False\n            This will force Table format, append the input data to the\n            existing.\n\n        encoding : default None, provide an encoding for strings"
        ],
        [
            "Returns a PyTables HDF Array from df in the shape given by its index columns range values.\n\n        :param key: string object\n\n        :param df: pandas DataFrame\n\n        :param range_values: dict or array-like\n        Must contain for each index column of df an entry with all the values\n        within the range of the column.\n\n        :param loop_multiindex: bool\n        Will loop through the first index in a multiindex dataframe, extract a\n        dataframe only for one value, complete and fill the missing values and\n        store in the HDF.\n        If this is True, it will not use unstack.\n        This is as fast as unstacking.\n\n        :param unstack: bool\n        Unstack means that this will use the first index name to\n        unfold the DataFrame, and will create a group with as many datasets\n        as valus has this first index.\n        Use this if you think the filled dataframe won't fit in your RAM memory.\n        If set to False, this will transform the dataframe in memory first\n        and only then save it.\n\n        :param fill_value: scalar or 'nearest', default 0\n        Value to use for missing values. Defaults to 0, but can be any\n        \"compatible\" value, e.g., NaN.\n        The 'nearest' mode will fill the missing value with the nearest value in\n         the column.\n\n        :param fill_method:  {'backfill', 'bfill', 'pad', 'ffill', None}, default None\n        Method to use for filling holes in reindexed DataFrame\n        'pad' / 'ffill': propagate last valid observation forward to next valid\n        'backfill' / 'bfill': use NEXT valid observation to fill gap\n\n        :return: PyTables data node"
        ],
        [
            "Set a smoothing Gaussian kernel given its FWHM in mm."
        ],
        [
            "First set_mask and the get_masked_data.\n\n        Parameters\n        ----------\n        mask_img:  nifti-like image, NeuroImage or str\n            3D mask array: True where a voxel should be used.\n            Can either be:\n            - a file path to a Nifti image\n            - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n            If niimg is a string, consider it as a path to Nifti image and\n            call nibabel.load on it. If it is an object, check if get_data()\n            and get_affine() methods are present, raise TypeError otherwise.\n\n        Returns\n        -------\n        The masked data deepcopied"
        ],
        [
            "Sets a mask img to this. So every operation to self, this mask will be taken into account.\n\n        Parameters\n        ----------\n        mask_img: nifti-like image, NeuroImage or str\n            3D mask array: True where a voxel should be used.\n            Can either be:\n            - a file path to a Nifti image\n            - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n            If niimg is a string, consider it as a path to Nifti image and\n            call nibabel.load on it. If it is an object, check if get_data()\n            and get_affine() methods are present, raise TypeError otherwise.\n\n        Note\n        ----\n        self.img and mask_file must have the same shape.\n\n        Raises\n        ------\n        FileNotFound, NiftiFilesNotCompatible"
        ],
        [
            "Return the data masked with self.mask\n\n        Parameters\n        ----------\n        data: np.ndarray\n\n        Returns\n        -------\n        masked np.ndarray\n\n        Raises\n        ------\n        ValueError if the data and mask dimensions are not compatible.\n        Other exceptions related to numpy computations."
        ],
        [
            "Set self._smooth_fwhm and then smooths the data.\n        See boyle.nifti.smooth.smooth_imgs.\n\n        Returns\n        -------\n        the smoothed data deepcopied."
        ],
        [
            "Return a vector of the masked data.\n\n        Returns\n        -------\n        np.ndarray, tuple of indices (np.ndarray), tuple of the mask shape"
        ],
        [
            "Save this object instance in outpath.\n\n        Parameters\n        ----------\n        outpath: str\n            Output file path"
        ],
        [
            "Setup logging configuration."
        ],
        [
            "Return a 3D volume from a 4D nifti image file\n\n    Parameters\n    ----------\n    filename: str\n        Path to the 4D .mhd file\n\n    vol_idx: int\n        Index of the 3D volume to be extracted from the 4D volume.\n\n    Returns\n    -------\n    vol, hdr\n        The data array and the new 3D image header."
        ],
        [
            "A wrapper for mem.cache that flushes the cache if the version\n        number of nibabel has changed."
        ],
        [
            "Saves a Nifti1Image into an HDF5 group.\n\n    Parameters\n    ----------\n    h5group: h5py Group\n        Output HDF5 file path\n\n    spatial_img: nibabel SpatialImage\n        Image to be saved\n\n    h5path: str\n        HDF5 group path where the image data will be saved.\n        Datasets will be created inside the given group path:\n        'data', 'extra', 'affine', the header information will\n        be set as attributes of the 'data' dataset."
        ],
        [
            "Saves a Nifti1Image into an HDF5 file.\n\n    Parameters\n    ----------\n    file_path: string\n        Output HDF5 file path\n\n    spatial_img: nibabel SpatialImage\n        Image to be saved\n\n    h5path: string\n        HDF5 group path where the image data will be saved.\n        Datasets will be created inside the given group path:\n        'data', 'extra', 'affine', the header information will\n        be set as attributes of the 'data' dataset.\n        Default: '/img'\n\n    append: bool\n        True if you don't want to erase the content of the file\n        if it already exists, False otherwise.\n\n    Note\n    ----\n    HDF5 open modes\n    >>> 'r' Readonly, file must exist\n    >>> 'r+' Read/write, file must exist\n    >>> 'w' Create file, truncate if exists\n    >>> 'w-' Create file, fail if exists\n    >>> 'a' Read/write if exists, create otherwise (default)"
        ],
        [
            "Transforms an H5py Attributes set to a dict.\n    Converts unicode string keys into standard strings\n    and each value into a numpy array.\n\n    Parameters\n    ----------\n    h5attrs: H5py Attributes\n\n    Returns\n    --------\n    dict"
        ],
        [
            "Returns in a list all images found under h5group.\n\n    Parameters\n    ----------\n    h5group: h5py.Group\n        HDF group\n\n    Returns\n    -------\n    list of nifti1Image"
        ],
        [
            "Inserts all given nifti files from file_list into one dataset in fname.\n    This will not check if the dimensionality of all files match.\n\n    Parameters\n    ----------\n    file_path: string\n        HDF5 file path\n\n    h5path: string\n\n    file_list: list of strings\n\n    newshape: tuple or lambda function\n        If None, it will not reshape the images.\n        If a lambda function, this lambda will receive only the shape array.\n        e.g., newshape = lambda x: (np.prod(x[0:3]), x[3])\n        If a tuple, it will try to reshape all the images with the same shape.\n        It must work for all the images in file_list.\n\n    concat_axis: int\n        Axis of concatenation after reshaping\n\n    dtype: data type\n    Dataset data type\n    If not set, will use the type of the first file.\n\n    append: bool\n\n    Raises\n    ------\n    ValueError if concat_axis is bigger than data dimensionality.\n\n    Note\n    ----\n    For now, this only works if the dataset ends up being a 2D matrix.\n    I haven't tested for multi-dimensionality concatenations."
        ],
        [
            "Generate all combinations of the elements of iterable and its subsets.\n\n    Parameters\n    ----------\n    iterable: list, set or dict or any iterable object\n\n    Returns\n    -------\n    A generator of all possible combinations of the iterable.\n\n    Example:\n    -------\n    >>> for i in treefall([1, 2, 3, 4, 5]): print(i)\n    >>> (1, 2, 3)\n    >>> (1, 2)\n    >>> (1, 3)\n    >>> (2, 3)\n    >>> (1,)\n    >>> (2,)\n    >>> (3,)\n    >>> ()"
        ],
        [
            "List existing reliable dictionaries.\n\n    List existing reliable dictionaries and respective schema for given application and service.\n\n    :param application_name: Name of the application.\n    :type application_name: str\n    :param service_name: Name of the service.\n    :type service_name: str"
        ],
        [
            "Query Schema information for existing reliable dictionaries.\n\n    Query Schema information existing reliable dictionaries for given application and service.\n\n    :param application_name: Name of the application.\n    :type application_name: str\n    :param service_name: Name of the service.\n    :type service_name: str\n    :param dictionary: Name of the reliable dictionary.\n    :type dictionary: str\n    :param output_file: Optional file to save the schema."
        ],
        [
            "Query existing reliable dictionary.\n\n    Query existing reliable dictionaries for given application and service.\n\n    :param application_name: Name of the application.\n    :type application_name: str\n    :param service_name: Name of the service.\n    :type service_name: str\n    :param dictionary_name: Name of the reliable dictionary.\n    :type dictionary_name: str\n    :param query_string: An OData query string. For example $top=10. Check https://www.odata.org/documentation/ for more information.\n    :type query_string: str\n    :param partition_key: Optional partition key of the desired partition, either a string if named schema or int if Int64 schema\n    :type partition_id: str\n    :param partition_id: Optional partition GUID of the owning reliable dictionary.\n    :type partition_id: str\n    :param output_file: Optional file to save the schema."
        ],
        [
            "Execute create, update, delete operations on existing reliable dictionaries.\n\n    carry out create, update and delete operations on existing reliable dictionaries for given application and service.\n\n    :param application_name: Name of the application.\n    :type application_name: str\n    :param service_name: Name of the service.\n    :type service_name: str\n    :param output_file: input file with list of json to provide the operation information for reliable dictionaries."
        ],
        [
            "Verify arguments for select command"
        ],
        [
            "Get AAD token"
        ],
        [
            "Use openpyxl to read an Excel file."
        ],
        [
            "Return the expanded absolute path of `xl_path` if\n    if exists and 'xlrd' or 'openpyxl' depending on\n    which module should be used for the Excel file in `xl_path`.\n\n    Parameters\n    ----------\n    xl_path: str\n        Path to an Excel file\n\n    Returns\n    -------\n    xl_path: str\n        User expanded and absolute path to `xl_path`\n\n    module: str\n        The name of the module you should use to process the\n        Excel file.\n        Choices: 'xlrd', 'pyopenxl'\n\n    Raises\n    ------\n    IOError\n        If the file does not exist\n\n    RuntimError\n        If a suitable reader for xl_path is not found"
        ],
        [
            "Return the workbook from the Excel file in `xl_path`."
        ],
        [
            "Return a list with the name of the sheets in\n    the Excel file in `xl_path`."
        ],
        [
            "Return a pandas DataFrame with the concat'ed\n    content of the `sheetnames` from the Excel file in\n    `xl_path`.\n\n    Parameters\n    ----------\n    xl_path: str\n        Path to the Excel file\n\n    sheetnames: list of str\n        List of existing sheet names of `xl_path`.\n        If None, will use all sheets from `xl_path`.\n\n    add_tab_names: bool\n        If True will add a 'Tab' column which says from which\n        tab the row comes from.\n\n    Returns\n    -------\n    df: pandas.DataFrame"
        ],
        [
            "Raise an AttributeError if `df` does not have a column named as an item of\n    the list of strings `col_names`."
        ],
        [
            "Return a list of not null values from the `col_name` column of `df`."
        ],
        [
            "Return a DataFrame with the duplicated values of the column `col_name`\n    in `df`."
        ],
        [
            "Return the duplicated items in `values`"
        ],
        [
            "Convert to string all values in `data`.\n\n    Parameters\n    ----------\n    data: dict[str]->object\n\n    Returns\n    -------\n    string_data: dict[str]->str"
        ],
        [
            "Search for items in `table` that have the same field sub-set values as in `sample`.\n    Expecting it to be unique, otherwise will raise an exception.\n\n    Parameters\n    ----------\n    table: tinydb.table\n    sample: dict\n        Sample data\n\n    Returns\n    -------\n    search_result: tinydb.database.Element\n        Unique item result of the search.\n\n    Raises\n    ------\n    KeyError:\n        If the search returns for more than one entry."
        ],
        [
            "Search in `table` an item with the value of the `unique_fields` in the `sample` sample.\n    Check if the the obtained result is unique. If nothing is found will return an empty list,\n    if there is more than one item found, will raise an IndexError.\n\n    Parameters\n    ----------\n    table: tinydb.table\n\n    sample: dict\n        Sample data\n\n    unique_fields: list of str\n        Name of fields (keys) from `data` which are going to be used to build\n        a sample to look for exactly the same values in the database.\n        If None, will use every key in `data`.\n\n    Returns\n    -------\n    eid: int\n        Id of the object found with same `unique_fields`.\n        None if none is found.\n\n    Raises\n    ------\n    MoreThanOneItemError\n        If more than one example is found."
        ],
        [
            "Create a TinyDB query that looks for items that have each field in `sample` with a value\n    compared with the correspondent operation in `operators`.\n\n    Parameters\n    ----------\n    sample: dict\n        The sample data\n\n    operators: str or list of str\n        A list of comparison operations for each field value in `sample`.\n        If this is a str, will use the same operator for all `sample` fields.\n        If you want different operators for each field, remember to use an OrderedDict for `sample`.\n        Check TinyDB.Query class for possible choices.\n\n    Returns\n    -------\n    query: tinydb.database.Query"
        ],
        [
            "Create a tinyDB Query object that looks for items that confirms the correspondent operator\n    from `operators` for each `field_names` field values from `data`.\n\n    Parameters\n    ----------\n    data: dict\n        The data sample\n\n    field_names: str or list of str\n        The name of the fields in `data` that will be used for the query.\n\n    operators: str or list of str\n        A list of comparison operations for each field value in `field_names`.\n        If this is a str, will use the same operator for all `field_names`.\n        If you want different operators for each field, remember to use an OrderedDict for `data`.\n        Check TinyDB.Query class for possible choices.\n\n    Returns\n    -------\n    query: tinydb.database.Query"
        ],
        [
            "Create a tinyDB Query object that is the concatenation of each query in `queries`.\n    The concatenation operator is taken from `operators`.\n\n    Parameters\n    ----------\n    queries: list of tinydb.Query\n        The list of tinydb.Query to be joined.\n\n    operators: str or list of str\n        List of binary operators to join `queries` into one query.\n        Check TinyDB.Query class for possible choices.\n\n    Returns\n    -------\n    query: tinydb.database.Query"
        ],
        [
            "Return the element in `table_name` with Object ID `eid`.\n        If None is found will raise a KeyError exception.\n\n        Parameters\n        ----------\n        table_name: str\n            The name of the table to look in.\n\n        eid: int\n            The Object ID of the element to look for.\n\n        Returns\n        -------\n        elem: tinydb.database.Element\n\n        Raises\n        ------\n        KeyError\n            If the element with ID `eid` is not found."
        ],
        [
            "Search in `table` an item with the value of the `unique_fields` in the `data` sample.\n        Check if the the obtained result is unique. If nothing is found will return an empty list,\n        if there is more than one item found, will raise an IndexError.\n\n        Parameters\n        ----------\n        table_name: str\n\n        sample: dict\n            Sample data\n\n        unique_fields: list of str\n            Name of fields (keys) from `data` which are going to be used to build\n            a sample to look for exactly the same values in the database.\n            If None, will use every key in `data`.\n\n        Returns\n        -------\n        eid: int\n            Id of the object found with same `unique_fields`.\n            None if none is found.\n\n        Raises\n        ------\n        MoreThanOneItemError\n            If more than one example is found."
        ],
        [
            "Return True if an item with the value of `unique_fields`\n        from `data` is unique in the table with `table_name`.\n        False if no sample is found or more than one is found.\n\n        See function `find_unique` for more details.\n\n        Parameters\n        ----------\n        table_name: str\n\n        sample: dict\n            Sample data for query\n\n        unique_fields: str or list of str\n\n        Returns\n        -------\n        is_unique: bool"
        ],
        [
            "Update the unique matching element to have a given set of fields.\n\n        Parameters\n        ----------\n        table_name: str\n\n        fields: dict or function[dict -> None]\n            new data/values to insert into the unique element\n            or a method that will update the elements.\n\n        data: dict\n            Sample data for query\n\n        cond: tinydb.Query\n            which elements to update\n\n        unique_fields: list of str\n\n        raise_if_not_found: bool\n            Will raise an exception if the element is not found for update.\n\n        Returns\n        -------\n        eid: int\n            The eid of the updated element if found, None otherwise."
        ],
        [
            "Return the number of items that match the `sample` field values\n        in table `table_name`.\n        Check function search_sample for more details."
        ],
        [
            "Check for get_data and get_affine method in an object\n\n    Parameters\n    ----------\n    obj: any object\n        Tested object\n\n    Returns\n    -------\n    is_img: boolean\n        True if get_data and get_affine methods are present and callable,\n        False otherwise."
        ],
        [
            "Get the data in the image without having a side effect on the Nifti1Image object\n\n    Parameters\n    ----------\n    img: Nifti1Image\n\n    Returns\n    -------\n    np.ndarray"
        ],
        [
            "Return the shape of img.\n\n    Paramerers\n    -----------\n    img:\n\n    Returns\n    -------\n    shape: tuple"
        ],
        [
            "Return true if one_img and another_img have the same shape.\n    False otherwise.\n    If both are nibabel.Nifti1Image will also check for affine matrices.\n\n    Parameters\n    ----------\n    one_img: nibabel.Nifti1Image or np.ndarray\n\n    another_img: nibabel.Nifti1Image  or np.ndarray\n\n    only_check_3d: bool\n        If True will check only the 3D part of the affine matrices when they have more dimensions.\n\n    Raises\n    ------\n    NiftiFilesNotCompatible"
        ],
        [
            "Return True if the affine matrix of one_img is close to the affine matrix of another_img.\n    False otherwise.\n\n    Parameters\n    ----------\n    one_img: nibabel.Nifti1Image\n\n    another_img: nibabel.Nifti1Image\n\n    only_check_3d: bool\n        If True will extract only the 3D part of the affine matrices when they have more dimensions.\n\n    Returns\n    -------\n    bool\n\n    Raises\n    ------\n    ValueError"
        ],
        [
            "Printing of img or imgs"
        ],
        [
            "Returns true if array1 and array2 have the same shapes, false\n    otherwise.\n\n    Parameters\n    ----------\n    array1: numpy.ndarray\n\n    array2: numpy.ndarray\n\n    nd_to_check: int\n        Number of the dimensions to check, i.e., if == 3 then will check only the 3 first numbers of array.shape.\n    Returns\n    -------\n    bool"
        ],
        [
            "Create a list of regex matches that result from the match_regex\n    of all file names within wd.\n    The list of files will have wd as path prefix.\n\n    @param regex: string\n    @param wd: string\n    working directory\n    @return:"
        ],
        [
            "Returns absolute paths of folders that match the regex within folder_path and\n    all its children folders.\n\n    Note: The regex matching is done using the match function\n    of the re module.\n\n    Parameters\n    ----------\n    folder_path: string\n\n    regex: string\n\n    Returns\n    -------\n    A list of strings."
        ],
        [
            "Creates a list of files that match the search_regex within file_dir.\n    The list of files will have file_dir as path prefix.\n\n    Parameters\n    ----------\n    @param file_dir:\n\n    @param search_regex:\n\n    Returns:\n    --------\n    List of paths to files that match the search_regex"
        ],
        [
            "Returns absolute paths of files that match the regex within file_dir and\n    all its children folders.\n\n    Note: The regex matching is done using the search function\n    of the re module.\n\n    Parameters\n    ----------\n    folder_path: string\n\n    regex: string\n\n    Returns\n    -------\n    A list of strings."
        ],
        [
            "Returns absolute paths of files that match the regexs within folder_path and\n    all its children folders.\n\n    This is an iterator function that will use yield to return each set of\n    file_paths in one iteration.\n\n    Will only return value if all the strings in regex match a file name.\n\n    Note: The regex matching is done using the search function\n    of the re module.\n\n    Parameters\n    ----------\n    folder_path: string\n\n    regex: strings\n\n    Returns\n    -------\n    A list of strings."
        ],
        [
            "Generator that loops through all absolute paths of the files within folder\n\n    Parameters\n    ----------\n    folder: str\n    Root folder start point for recursive search.\n\n    Yields\n    ------\n    fpath: str\n    Absolute path of one file in the folders"
        ],
        [
            "Uses glob to find all files or folders that match the regex\n    starting from the base_directory.\n\n    Parameters\n    ----------\n    base_directory: str\n\n    regex: str\n\n    Returns\n    -------\n    files: list"
        ],
        [
            "Append key-value pairs to msg, for display.\n\n    Parameters\n    ----------\n    msg: string\n        arbitrary message\n    kwargs: dict\n        arbitrary dictionary\n\n    Returns\n    -------\n    updated_msg: string\n        msg, with \"key: value\" appended. Only string values are appended.\n\n    Example\n    -------\n    >>> compose_err_msg('Error message with arguments...', arg_num=123, \\\n        arg_str='filename.nii', arg_bool=True)\n    'Error message with arguments...\\\\narg_str: filename.nii'\n    >>>"
        ],
        [
            "Gets a list of DICOM file absolute paths and returns a list of lists of\n    DICOM file paths. Each group contains a set of DICOM files that have\n    exactly the same headers.\n\n    Parameters\n    ----------\n    dicom_file_paths: list of str\n        List or set of DICOM file paths\n\n    header_fields: list of str\n        List of header field names to check on the comparisons of the DICOM files.\n\n    Returns\n    -------\n    dict of DicomFileSets\n        The key is one filepath representing the group (the first found)."
        ],
        [
            "Copy the DICOM file groups to folder_path. Each group will be copied into\n    a subfolder with named given by groupby_field.\n\n    Parameters\n    ----------\n    dicom_groups: boyle.dicom.sets.DicomFileSet\n\n    folder_path: str\n     Path to where copy the DICOM files.\n\n    groupby_field_name: str\n     DICOM field name. Will get the value of this field to name the group\n     folder."
        ],
        [
            "Calculates the DicomFileDistance between all files in dicom_files, using an\n    weighted Levenshtein measure between all field names in field_weights and\n    their corresponding weights.\n\n    Parameters\n    ----------\n    dicom_files: iterable of str\n        Dicom file paths\n\n    field_weights: dict of str to float\n        A dict with header field names to float scalar values, that\n        indicate a distance measure ratio for the levenshtein distance\n        averaging of all the header field names in it. e.g., {'PatientID': 1}\n\n    dist_method_cls: DicomFileDistance class\n        Distance method object to compare the files.\n        If None, the default DicomFileDistance method using Levenshtein\n        distance between the field_wieghts will be used.\n\n    kwargs: DicomFileDistance instantiation named arguments\n        Apart from the field_weitghts argument.\n\n    Returns\n    -------\n    file_dists: np.ndarray or scipy.sparse.lil_matrix of shape NxN\n        Levenshtein distances between each of the N items in dicom_files."
        ],
        [
            "Check the field values in self.dcmf1 and self.dcmf2 and returns True\n        if all the field values are the same, False otherwise.\n\n        Returns\n        -------\n        bool"
        ],
        [
            "Updates the status of the file clusters comparing the cluster\n        key files with a levenshtein weighted measure using either the\n        header_fields or self.header_fields.\n\n        Parameters\n        ----------\n        field_weights: dict of strings with floats\n            A dict with header field names to float scalar values, that indicate a distance measure\n            ratio for the levenshtein distance averaging of all the header field names in it.\n            e.g., {'PatientID': 1}"
        ],
        [
            "Thresholds a distance matrix and returns the result.\n\n        Parameters\n        ----------\n\n        dist_matrix: array_like\n        Input array or object that can be converted to an array.\n\n        perc_thr: float in range of [0,100]\n        Percentile to compute which must be between 0 and 100 inclusive.\n\n        k: int, optional\n        Diagonal above which to zero elements.\n        k = 0 (the default) is the main diagonal,\n        k < 0 is below it and k > 0 is above.\n\n        Returns\n        -------\n        array_like"
        ],
        [
            "Returns a list of 2-tuples with pairs of dicom groups that\n        are in the same folder within given depth.\n\n        Parameters\n        ----------\n        folder_depth: int\n        Path depth to check for folder equality.\n\n        Returns\n        -------\n        list of tuples of str"
        ],
        [
            "Extend the lists within the DICOM groups dictionary.\n        The indices will indicate which list have to be extended by which\n        other list.\n\n        Parameters\n        ----------\n        indices: list or tuple of 2 iterables of int, bot having the same len\n             The indices of the lists that have to be merged, both iterables\n             items will be read pair by pair, the first is the index to the\n             list that will be extended with the list of the second index.\n             The indices can be constructed with Numpy e.g.,\n             indices = np.where(square_matrix)"
        ],
        [
            "Copy the file groups to folder_path. Each group will be copied into\n        a subfolder with named given by groupby_field.\n\n        Parameters\n        ----------\n        folder_path: str\n         Path to where copy the DICOM files.\n\n        groupby_field_name: str\n         DICOM field name. Will get the value of this field to name the group\n         folder. If empty or None will use the basename of the group key file."
        ],
        [
            "Return a dictionary where the key is the group key file path and\n        the values are sets of unique values of the field name of all DICOM\n        files in the group.\n\n        Parameters\n        ----------\n        field_name: str\n         Name of the field to read from all files\n\n        field_to_use_as_key: str\n         Name of the field to get the value and use as key.\n         If None, will use the same key as the dicom_groups.\n\n        Returns\n        -------\n        Dict of sets"
        ],
        [
            "Gets a config by name.\n\n    In the case where the config name is not found, will use fallback value."
        ],
        [
            "Checks if a config value is set to a valid bool value."
        ],
        [
            "Set a config by name to a value."
        ],
        [
            "Path to certificate related files, either a single file path or a\n    tuple. In the case of no security, returns None."
        ],
        [
            "Set AAD token cache."
        ],
        [
            "Set AAD metadata."
        ],
        [
            "Set certificate usage paths"
        ],
        [
            "Returns a list with of the objects in olist that have a fieldname valued as fieldval\n\n    Parameters\n    ----------\n    olist: list of objects\n\n    fieldname: string\n\n    fieldval: anything\n\n    Returns\n    -------\n    list of objets"
        ],
        [
            "Checks whether the re module can compile the given regular expression.\n\n    Parameters\n    ----------\n    string: str\n\n    Returns\n    -------\n    boolean"
        ],
        [
            "Returns True if the given string is considered a fnmatch\n    regular expression, False otherwise.\n    It will look for\n\n    :param string: str"
        ],
        [
            "Return index of the nth match found of pattern in strings\n\n    Parameters\n    ----------\n    strings: list of str\n        List of strings\n\n    pattern: str\n        Pattern to be matched\n\n    nth: int\n        Number of times the match must happen to return the item index.\n\n    lookup_func: callable\n        Function to match each item in strings to the pattern, e.g., re.match or re.search.\n\n    Returns\n    -------\n    index: int\n        Index of the nth item that matches the pattern.\n        If there are no n matches will return -1"
        ],
        [
            "Generate a dcm2nii configuration file that disable the interactive\n    mode."
        ],
        [
            "Converts all DICOM files within `work_dir` into one or more\n    NifTi files by calling dcm2nii on this folder.\n\n    Parameters\n    ----------\n    work_dir: str\n        Path to the folder that contain the DICOM files\n\n    arguments: str\n        String containing all the flag arguments for `dcm2nii` CLI.\n\n    Returns\n    -------\n    sys_code: int\n        dcm2nii execution return code"
        ],
        [
            "Call MRICron's `dcm2nii` to convert the DICOM files inside `input_dir`\n    to Nifti and save the Nifti file in `output_dir` with a `filename` prefix.\n\n    Parameters\n    ----------\n    input_dir: str\n        Path to the folder that contains the DICOM files\n\n    output_dir: str\n        Path to the folder where to save the NifTI file\n\n    filename: str\n        Output file basename\n\n    Returns\n    -------\n    filepaths: list of str\n        List of file paths created in `output_dir`."
        ],
        [
            "Return a subset of `filepaths`. Keep only the files that have a basename longer than the\n    others with same suffix.\n    This works based on that dcm2nii appends a preffix character for each processing\n    step it does automatically in the DICOM to NifTI conversion.\n\n    Parameters\n    ----------\n    filepaths: iterable of str\n\n    Returns\n    -------\n    cleaned_paths: iterable of str"
        ],
        [
            "Transform a named tuple into a dictionary"
        ],
        [
            "Extend the within a dict of lists. The indices will indicate which\n    list have to be extended by which other list.\n\n    Parameters\n    ----------\n    adict: OrderedDict\n        An ordered dictionary of lists\n\n    indices: list or tuple of 2 iterables of int, bot having the same length\n        The indices of the lists that have to be merged, both iterables items\n         will be read pair by pair, the first is the index to the list that\n         will be extended with the list of the second index.\n         The indices can be constructed with Numpy e.g.,\n         indices = np.where(square_matrix)\n\n    pop_later: bool\n        If True will oop out the lists that are indicated in the second\n         list of indices.\n\n    copy: bool\n        If True will perform a deep copy of the input adict before\n         modifying it, hence not changing the original input.\n\n    Returns\n    -------\n    Dictionary of lists\n\n    Raises\n    ------\n    IndexError\n        If the indices are out of range"
        ],
        [
            "Return a dict of lists from a list of dicts with the same keys.\n    For each dict in list_of_dicts with look for the values of the\n    given keys and append it to the output dict.\n\n    Parameters\n    ----------\n    list_of_dicts: list of dicts\n\n    keys: list of str\n        List of keys to create in the output dict\n        If None will use all keys in the first element of list_of_dicts\n    Returns\n    -------\n    DefaultOrderedDict of lists"
        ],
        [
            "Imports the contents of filepath as a Python module.\n\n    :param filepath: string\n\n    :param mod_name: string\n    Name of the module when imported\n\n    :return: module\n    Imported module"
        ],
        [
            "Copies the files in the built file tree map\n    to despath.\n\n    :param configfile: string\n     Path to the FileTreeMap config file\n\n    :param destpath: string\n     Path to the files destination\n\n    :param overwrite: bool\n     Overwrite files if they already exist.\n\n    :param sub_node: string\n     Tree map configuration sub path.\n     Will copy only the contents within this sub-node"
        ],
        [
            "Transforms the input .sav SPSS file into other format.\n    If you don't specify an outputfile, it will use the\n    inputfile and change its extension to .csv"
        ],
        [
            "Load a Nifti mask volume.\n\n    Parameters\n    ----------\n    image: img-like object or boyle.nifti.NeuroImage or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    allow_empty: boolean, optional\n        Allow loading an empty mask (full of 0 values)\n\n    Returns\n    -------\n    nibabel.Nifti1Image with boolean data."
        ],
        [
            "Load a Nifti mask volume and return its data matrix as boolean and affine.\n\n    Parameters\n    ----------\n    image: img-like object or boyle.nifti.NeuroImage or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    allow_empty: boolean, optional\n        Allow loading an empty mask (full of 0 values)\n\n    Returns\n    -------\n    numpy.ndarray with dtype==bool, numpy.ndarray of affine transformation"
        ],
        [
            "Creates a binarised mask with the union of the files in filelist.\n\n    Parameters\n    ----------\n    filelist: list of img-like object or boyle.nifti.NeuroImage or str\n        List of paths to the volume files containing the ROIs.\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    Returns\n    -------\n    ndarray of bools\n        Mask volume\n\n    Raises\n    ------\n    ValueError"
        ],
        [
            "Read a Nifti file nii_file and a mask Nifti file.\n    Returns the voxels in nii_file that are within the mask, the mask indices\n    and the mask shape.\n\n    Parameters\n    ----------\n    image: img-like object or boyle.nifti.NeuroImage or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    mask_img: img-like object or boyle.nifti.NeuroImage or str\n        3D mask array: True where a voxel should be used.\n        See img description.\n\n    Returns\n    -------\n    vol[mask_indices], mask_indices\n\n    Note\n    ----\n    nii_file and mask_file must have the same shape.\n\n    Raises\n    ------\n    NiftiFilesNotCompatible, ValueError"
        ],
        [
            "Read a Nifti file nii_file and a mask Nifti file.\n    Extract the signals in nii_file that are within the mask, the mask indices\n    and the mask shape.\n\n    Parameters\n    ----------\n    image: img-like object or boyle.nifti.NeuroImage or str\n        Can either be:\n        - a file path to a Nifti image\n        - any object with get_data() and get_affine() methods, e.g., nibabel.Nifti1Image.\n        If niimg is a string, consider it as a path to Nifti image and\n        call nibabel.load on it. If it is an object, check if get_data()\n        and get_affine() methods are present, raise TypeError otherwise.\n\n    mask_img: img-like object or boyle.nifti.NeuroImage or str\n        3D mask array: True where a voxel should be used.\n        See img description.\n\n    smooth_mm: float #TBD\n        (optional) The size in mm of the FWHM Gaussian kernel to smooth the signal.\n        If True, remove_nans is True.\n\n    remove_nans: bool #TBD\n        If remove_nans is True (default), the non-finite values (NaNs and\n        infs) found in the images will be replaced by zeros.\n\n    Returns\n    -------\n    session_series, mask_data\n\n    session_series: numpy.ndarray\n        2D array of series with shape (voxel number, image number)\n\n    Note\n    ----\n    nii_file and mask_file must have the same shape.\n\n    Raises\n    ------\n    FileNotFound, NiftiFilesNotCompatible"
        ],
        [
            "Transform a given vector to a volume. This is a reshape function for\n    3D flattened and maybe masked vectors.\n\n    Parameters\n    ----------\n    arr: np.array\n        1-Dimensional array\n\n    mask: numpy.ndarray\n        Mask image. Must have 3 dimensions, bool dtype.\n\n    Returns\n    -------\n    np.ndarray"
        ],
        [
            "Transform a given vector to a volume. This is a reshape function for\n    4D flattened masked matrices where the second dimension of the matrix\n    corresponds to the original 4th dimension.\n\n    Parameters\n    ----------\n    arr: numpy.array\n        2D numpy.array\n\n    mask: numpy.ndarray\n        Mask image. Must have 3 dimensions, bool dtype.\n\n    dtype: return type\n        If None, will get the type from vector\n\n    Returns\n    -------\n    data: numpy.ndarray\n        Unmasked data.\n        Shape: (mask.shape[0], mask.shape[1], mask.shape[2], X.shape[1])"
        ],
        [
            "From the list of absolute paths to nifti files, creates a Numpy array\n    with the masked data.\n\n    Parameters\n    ----------\n    img_filelist: list of str\n        List of absolute file paths to nifti files. All nifti files must have\n        the same shape.\n\n    mask_file: str\n        Path to a Nifti mask file.\n        Should be the same shape as the files in nii_filelist.\n\n    outdtype: dtype\n        Type of the elements of the array, if not set will obtain the dtype from\n        the first nifti file.\n\n    Returns\n    -------\n    outmat:\n        Numpy array with shape N x prod(vol.shape) containing the N files as flat vectors.\n\n    mask_indices:\n        Tuple with the 3D spatial indices of the masking voxels, for reshaping\n        with vol_shape and remapping.\n\n    vol_shape:\n        Tuple with shape of the volumes, for reshaping."
        ],
        [
            "Create a client for Service Fabric APIs."
        ],
        [
            "Aggregate the rows of the DataFrame into a single value.\n\n        :param clazz: name of a class that extends class Callable\n        :type clazz: class\n        :param new_col: name of the new column\n        :type new_col: str\n        :param args: list of column names of the object that function \n        should be applied to\n        :type args: tuple\n        :return: returns a new dataframe object with the aggregated value\n        :rtype: DataFrame"
        ],
        [
            "Pipeable grouping method.\n\n    Takes either\n      - a dataframe and a tuple of strings for grouping,\n      - a tuple of strings if a dataframe has already been piped into.\n    \n    :Example:\n        \n    group(dataframe, \"column\")\n    \n    :Example:\n    \n    dataframe >> group(\"column\")\n    \n    :param args: tuple of arguments\n    :type args: tuple\n    :return: returns a grouped dataframe object\n    :rtype: GroupedDataFrame"
        ],
        [
            "Pipeable aggregation method.\n    \n    Takes either \n     - a dataframe and a tuple of arguments required for aggregation,\n     - a tuple of arguments if a dataframe has already been piped into.\n    In any case one argument has to be a class that extends callable.\n\n    :Example:\n\n    aggregate(dataframe, Function, \"new_col_name\", \"old_col_name\")\n\n    :Example:\n\n    dataframe >> aggregate(Function, \"new_col_name\", \"old_col_name\")\n\n    :param args: tuple of arguments\n    :type args: tuple\n    :return: returns a dataframe object\n    :rtype: DataFrame"
        ],
        [
            "Pipeable subsetting method.\n\n    Takes either\n     - a dataframe and a tuple of arguments required for subsetting,\n     - a tuple of arguments if a dataframe has already been piped into.\n\n    :Example:\n        \n    subset(dataframe, \"column\")\n    \n    :Example:\n    \n    dataframe >> subset(\"column\")\n\n    :param args: tuple of arguments\n    :type args: tuple\n    :return: returns a dataframe object\n    :rtype: DataFrame"
        ],
        [
            "Pipeable modification method \n    \n    Takes either \n     - a dataframe and a tuple of arguments required for modification,\n     - a tuple of arguments if a dataframe has already been piped into.\n    In any case one argument has to be a class that extends callable.\n\n    :Example:\n\n    modify(dataframe, Function, \"new_col_name\", \"old_col_name\")\n    \n    :Example:\n\n    dataframe >> modify(Function, \"new_col_name\", \"old_col_name\")\n\n    :param args: tuple of arguments\n    :type args: tuple\n    :return: returns a dataframe object\n    :rtype: DataFrame"
        ],
        [
            "Escape a single character"
        ],
        [
            "Escape a string so that it only contains characters in a safe set.\n\n    Characters outside the safe list will be escaped with _%x_,\n    where %x is the hex value of the character.\n\n    If `allow_collisions` is True, occurrences of `escape_char`\n    in the input will not be escaped.\n\n    In this case, `unescape` cannot be used to reverse the transform\n    because occurrences of the escape char in the resulting string are ambiguous.\n    Only use this mode when:\n\n    1. collisions cannot occur or do not matter, and\n    2. unescape will never be called.\n\n    .. versionadded: 1.0\n        allow_collisions argument.\n        Prior to 1.0, behavior was the same as allow_collisions=False (default)."
        ],
        [
            "Unescape a string escaped with `escape`\n    \n    escape_char must be the same as that used in the call to escape."
        ],
        [
            "Determines whether this backend is allowed to send a notification to\n        the given user and notice_type."
        ],
        [
            "Returns a dictionary with the format identifier as the key. The values are\n        are fully rendered templates with the given context."
        ],
        [
            "Copy the attributes from a source object to a destination object."
        ],
        [
            "Returns DataFrameRow of the DataFrame given its index.\n\n        :param idx: the index of the row in the DataFrame.\n        :return: returns a DataFrameRow"
        ],
        [
            "The notice settings view.\n\n    Template: :template:`notification/notice_settings.html`\n\n    Context:\n\n        notice_types\n            A list of all :model:`notification.NoticeType` objects.\n\n        notice_settings\n            A dictionary containing ``column_headers`` for each ``NOTICE_MEDIA``\n            and ``rows`` containing a list of dictionaries: ``notice_type``, a\n            :model:`notification.NoticeType` object and ``cells``, a list of\n            tuples whose first value is suitable for use in forms and the second\n            value is ``True`` or ``False`` depending on a ``request.POST``\n            variable called ``form_label``, whose valid value is ``on``."
        ],
        [
            "Query Wolfram Alpha and return a Result object"
        ],
        [
            "Return list of all Pod objects in result"
        ],
        [
            "Find a node in the tree. If the node is not found it is added first and then returned.\n\n        :param args: a tuple\n        :return: returns the node"
        ],
        [
            "Returns site-specific notification language for this user. Raises\n    LanguageStoreNotAvailable if this site does not use translated\n    notifications."
        ],
        [
            "Creates a new notice.\n\n    This is intended to be how other apps create new notices.\n\n    notification.send(user, \"friends_invite_sent\", {\n        \"spam\": \"eggs\",\n        \"foo\": \"bar\",\n    )"
        ],
        [
            "A basic interface around both queue and send_now. This honors a global\n    flag NOTIFICATION_QUEUE_ALL that helps determine whether all calls should\n    be queued or not. A per call ``queue`` or ``now`` keyword argument can be\n    used to always override the default global behavior."
        ],
        [
            "Queue the notification in NoticeQueueBatch. This allows for large amounts\n    of user notifications to be deferred to a seperate process running outside\n    the webserver."
        ],
        [
            "A helper function to write lammps pair potentials to string. Assumes that\n    functions are vectorized.\n\n    Parameters\n    ----------\n    func: function\n       A function that will be evaluated for the force at each radius. Required to\n       be numpy vectorizable.\n    dfunc: function\n       Optional. A function that will be evaluated for the energy at each\n       radius. If not supplied the centered difference method will be\n       used. Required to be numpy vectorizable.\n    bounds: tuple, list\n       Optional. specifies min and max radius to evaluate the\n       potential. Default 1 length unit, 10 length unit.\n    samples: int\n       Number of points to evaluate potential. Default 1000. Note that\n       a low number of sample points will reduce accuracy.\n    tollerance: float\n       Value used to centered difference differentiation.\n    keyword: string\n       Lammps keyword to use to pair potential. This keyword will need\n       to be used in the lammps pair_coeff. Default ``PAIR``\n    filename: string\n       Optional. filename to write lammps table potential as. Default\n       ``lammps.table`` it is highly recomended to change the value.\n\n    A file for each unique pair potential is required."
        ],
        [
            "Write tersoff potential file from parameters to string\n\n    Parameters\n    ----------\n    parameters: dict\n       keys are tuple of elements with the values being the parameters length 14"
        ],
        [
            "Aggregate the rows of each group into a single value.\n\n        :param clazz: name of a class that extends class Callable\n        :type clazz: class\n        :param new_col: name of the new column\n        :type new_col: str\n        :param args: list of column names of the object that\n         function should be applied to\n        :type args: varargs\n        :return: returns a new dataframe object with the aggregated value\n        :rtype: DataFrame"
        ],
        [
            "Checks if elements of set2 are in set1.\n\n    :param set1: a set of values\n    :param set2: a set of values\n    :param warn: the error message that should be thrown\n     when the sets are NOT disjoint\n    :return: returns true no elements of set2 are in set1"
        ],
        [
            "Checks if all elements from set2 are in set1.\n\n    :param set1:  a set of values\n    :param set2:  a set of values\n    :param warn: the error message that should be thrown \n     when the sets are not containd\n    :return: returns true if all values of set2 are in set1"
        ],
        [
            "Serialize object back to XML string.\n\n        Returns:\n            str: String which should be same as original input, if everything\\\n                 works as expected."
        ],
        [
            "Parse MARC XML document to dicts, which are contained in\n        self.controlfields and self.datafields.\n\n        Args:\n            xml (str or HTMLElement): input data\n\n        Also detect if this is oai marc format or not (see elf.oai_marc)."
        ],
        [
            "Parse control fields.\n\n        Args:\n            fields (list): list of HTMLElements\n            tag_id (str):  parameter name, which holds the information, about\n                           field name this is normally \"tag\", but in case of\n                           oai_marc \"id\"."
        ],
        [
            "Parse data fields.\n\n        Args:\n            fields (list): of HTMLElements\n            tag_id (str): parameter name, which holds the information, about\n                          field name this is normally \"tag\", but in case of\n                          oai_marc \"id\"\n            sub_id (str): id of parameter, which holds informations about\n                          subfield name this is normally \"code\" but in case of\n                          oai_marc \"label\""
        ],
        [
            "This method is used mainly internally, but it can be handy if you work\n        with with raw MARC XML object and not using getters.\n\n        Args:\n            num (int): Which indicator you need (1/2).\n            is_oai (bool/None): If None, :attr:`.oai_marc` is\n                   used.\n\n        Returns:\n            str: current name of ``i1``/``ind1`` parameter based on \\\n                 :attr:`oai_marc` property."
        ],
        [
            "Return content of given `subfield` in `datafield`.\n\n        Args:\n            datafield (str): Section name (for example \"001\", \"100\", \"700\").\n            subfield (str):  Subfield name (for example \"a\", \"1\", etc..).\n            i1 (str, default None): Optional i1/ind1 parameter value, which\n               will be used for search.\n            i2 (str, default None): Optional i2/ind2 parameter value, which\n               will be used for search.\n            exception (bool): If ``True``, :exc:`~exceptions.KeyError` is\n                      raised when method couldn't found given `datafield` /\n                      `subfield`. If ``False``, blank array ``[]`` is returned.\n\n        Returns:\n            list: of :class:`.MARCSubrecord`.\n\n        Raises:\n            KeyError: If the subfield or datafield couldn't be found.\n\n        Note:\n            MARCSubrecord is practically same thing as string, but has defined\n            :meth:`.MARCSubrecord.i1` and :attr:`.MARCSubrecord.i2`\n            methods.\n\n            You may need to be able to get this, because MARC XML depends on\n            i/ind parameters from time to time (names of authors for example)."
        ],
        [
            "Get the given param from each of the DOFs for a joint."
        ],
        [
            "Set the given param for each of the DOFs for a joint."
        ],
        [
            "Given an angle and an axis, create a quaternion."
        ],
        [
            "Given a set of bodies, compute their center of mass in world coordinates."
        ],
        [
            "Set the state of this body.\n\n        Parameters\n        ----------\n        state : BodyState tuple\n            The desired state of the body."
        ],
        [
            "Set the rotation of this body using a rotation matrix.\n\n        Parameters\n        ----------\n        rotation : sequence of 9 floats\n            The desired rotation matrix for this body."
        ],
        [
            "Convert a body-relative offset to world coordinates.\n\n        Parameters\n        ----------\n        position : 3-tuple of float\n            A tuple giving body-relative offsets.\n\n        Returns\n        -------\n        position : 3-tuple of float\n            A tuple giving the world coordinates of the given offset."
        ],
        [
            "Convert a point in world coordinates to a body-relative offset.\n\n        Parameters\n        ----------\n        position : 3-tuple of float\n            A world coordinates position.\n\n        Returns\n        -------\n        offset : 3-tuple of float\n            A tuple giving the body-relative offset of the given position."
        ],
        [
            "Convert a relative body offset to world coordinates.\n\n        Parameters\n        ----------\n        offset : 3-tuple of float\n            The offset of the desired point, given as a relative fraction of the\n            size of this body. For example, offset (0, 0, 0) is the center of\n            the body, while (0.5, -0.2, 0.1) describes a point halfway from the\n            center towards the maximum x-extent of the body, 20% of the way from\n            the center towards the minimum y-extent, and 10% of the way from the\n            center towards the maximum z-extent.\n\n        Returns\n        -------\n        position : 3-tuple of float\n            A position in world coordinates of the given body offset."
        ],
        [
            "Add a force to this body.\n\n        Parameters\n        ----------\n        force : 3-tuple of float\n            A vector giving the forces along each world or body coordinate axis.\n        relative : bool, optional\n            If False, the force values are assumed to be given in the world\n            coordinate frame. If True, they are assumed to be given in the\n            body-relative coordinate frame. Defaults to False.\n        position : 3-tuple of float, optional\n            If given, apply the force at this location in world coordinates.\n            Defaults to the current position of the body.\n        relative_position : 3-tuple of float, optional\n            If given, apply the force at this relative location on the body. If\n            given, this method ignores the ``position`` parameter."
        ],
        [
            "Add a torque to this body.\n\n        Parameters\n        ----------\n        force : 3-tuple of float\n            A vector giving the torque along each world or body coordinate axis.\n        relative : bool, optional\n            If False, the torque values are assumed to be given in the world\n            coordinate frame. If True, they are assumed to be given in the\n            body-relative coordinate frame. Defaults to False."
        ],
        [
            "Connect this body to another one using a joint.\n\n        This method creates a joint to fasten this body to the other one. See\n        :func:`World.join`.\n\n        Parameters\n        ----------\n        joint : str\n            The type of joint to use when connecting these bodies.\n        other_body : :class:`Body` or str, optional\n            The other body to join with this one. If not given, connects this\n            body to the world."
        ],
        [
            "Move another body next to this one and join them together.\n\n        This method will move the ``other_body`` so that the anchor points for\n        the joint coincide. It then creates a joint to fasten the two bodies\n        together. See :func:`World.move_next_to` and :func:`World.join`.\n\n        Parameters\n        ----------\n        joint : str\n            The type of joint to use when connecting these bodies.\n        other_body : :class:`Body` or str\n            The other body to join with this one.\n        offset : 3-tuple of float, optional\n            The body-relative offset where the anchor for the joint should be\n            placed. Defaults to (0, 0, 0). See :func:`World.move_next_to` for a\n            description of how offsets are specified.\n        other_offset : 3-tuple of float, optional\n            The offset on the second body where the joint anchor should be\n            placed. Defaults to (0, 0, 0). Like ``offset``, this is given as an\n            offset relative to the size and shape of ``other_body``."
        ],
        [
            "List of positions for linear degrees of freedom."
        ],
        [
            "List of position rates for linear degrees of freedom."
        ],
        [
            "List of angles for rotational degrees of freedom."
        ],
        [
            "List of angle rates for rotational degrees of freedom."
        ],
        [
            "List of axes for this object's degrees of freedom."
        ],
        [
            "Set the lo stop values for this object's degrees of freedom.\n\n        Parameters\n        ----------\n        lo_stops : float or sequence of float\n            A lo stop value to set on all degrees of freedom, or a list\n            containing one such value for each degree of freedom. For rotational\n            degrees of freedom, these values must be in radians."
        ],
        [
            "Set the hi stop values for this object's degrees of freedom.\n\n        Parameters\n        ----------\n        hi_stops : float or sequence of float\n            A hi stop value to set on all degrees of freedom, or a list\n            containing one such value for each degree of freedom. For rotational\n            degrees of freedom, these values must be in radians."
        ],
        [
            "Set the target velocities for this object's degrees of freedom.\n\n        Parameters\n        ----------\n        velocities : float or sequence of float\n            A target velocity value to set on all degrees of freedom, or a list\n            containing one such value for each degree of freedom. For rotational\n            degrees of freedom, these values must be in radians / second."
        ],
        [
            "Set the maximum forces for this object's degrees of freedom.\n\n        Parameters\n        ----------\n        max_forces : float or sequence of float\n            A maximum force value to set on all degrees of freedom, or a list\n            containing one such value for each degree of freedom."
        ],
        [
            "Set the ERP values for this object's degrees of freedom.\n\n        Parameters\n        ----------\n        erps : float or sequence of float\n            An ERP value to set on all degrees of freedom, or a list\n            containing one such value for each degree of freedom."
        ],
        [
            "Set the CFM values for this object's degrees of freedom.\n\n        Parameters\n        ----------\n        cfms : float or sequence of float\n            A CFM value to set on all degrees of freedom, or a list\n            containing one such value for each degree of freedom."
        ],
        [
            "Set the CFM values for this object's DOF limits.\n\n        Parameters\n        ----------\n        stop_cfms : float or sequence of float\n            A CFM value to set on all degrees of freedom limits, or a list\n            containing one such value for each degree of freedom limit."
        ],
        [
            "Set the ERP values for this object's DOF limits.\n\n        Parameters\n        ----------\n        stop_erps : float or sequence of float\n            An ERP value to set on all degrees of freedom limits, or a list\n            containing one such value for each degree of freedom limit."
        ],
        [
            "Set the linear axis of displacement for this joint.\n\n        Parameters\n        ----------\n        axes : list containing one 3-tuple of floats\n            A list of the axes for this joint. For a slider joint, which has one\n            degree of freedom, this must contain one 3-tuple specifying the X,\n            Y, and Z axis for the joint."
        ],
        [
            "Set the angular axis of rotation for this joint.\n\n        Parameters\n        ----------\n        axes : list containing one 3-tuple of floats\n            A list of the axes for this joint. For a hinge joint, which has one\n            degree of freedom, this must contain one 3-tuple specifying the X,\n            Y, and Z axis for the joint."
        ],
        [
            "A list of axes of rotation for this joint."
        ],
        [
            "Create a new body.\n\n        Parameters\n        ----------\n        shape : str\n            The \"shape\" of the body to be created. This should name a type of\n            body object, e.g., \"box\" or \"cap\".\n        name : str, optional\n            The name to use for this body. If not given, a default name will be\n            constructed of the form \"{shape}{# of objects in the world}\".\n\n        Returns\n        -------\n        body : :class:`Body`\n            The created body object."
        ],
        [
            "Create a new joint that connects two bodies together.\n\n        Parameters\n        ----------\n        shape : str\n            The \"shape\" of the joint to use for joining together two bodies.\n            This should name a type of joint, such as \"ball\" or \"piston\".\n        body_a : str or :class:`Body`\n            The first body to join together with this joint. If a string is\n            given, it will be used as the name of a body to look up in the\n            world.\n        body_b : str or :class:`Body`, optional\n            If given, identifies the second body to join together with\n            ``body_a``. If not given, ``body_a`` is joined to the world.\n        name : str, optional\n            If given, use this name for the created joint. If not given, a name\n            will be constructed of the form\n            \"{body_a.name}^{shape}^{body_b.name}\".\n\n        Returns\n        -------\n        joint : :class:`Joint`\n            The joint object that was created."
        ],
        [
            "Move one body to be near another one.\n\n        After moving, the location described by ``offset_a`` on ``body_a`` will\n        be coincident with the location described by ``offset_b`` on ``body_b``.\n\n        Parameters\n        ----------\n        body_a : str or :class:`Body`\n            The body to use as a reference for moving the other body. If this is\n            a string, it is treated as the name of a body to look up in the\n            world.\n        body_b : str or :class:`Body`\n            The body to move next to ``body_a``. If this is a string, it is\n            treated as the name of a body to look up in the world.\n        offset_a : 3-tuple of float\n            The offset of the anchor point, given as a relative fraction of the\n            size of ``body_a``. See :func:`Body.relative_offset_to_world`.\n        offset_b : 3-tuple of float\n            The offset of the anchor point, given as a relative fraction of the\n            size of ``body_b``.\n\n        Returns\n        -------\n        anchor : 3-tuple of float\n            The location of the shared point, which is often useful to use as a\n            joint anchor."
        ],
        [
            "Set the states of some bodies in the world.\n\n        Parameters\n        ----------\n        states : sequence of states\n            A complete state tuple for one or more bodies in the world. See\n            :func:`get_body_states`."
        ],
        [
            "Step the world forward by one frame.\n\n        Parameters\n        ----------\n        substeps : int, optional\n            Split the step into this many sub-steps. This helps to prevent the\n            time delta for an update from being too large."
        ],
        [
            "Determine whether the given bodies are currently connected.\n\n        Parameters\n        ----------\n        body_a : str or :class:`Body`\n            One body to test for connectedness. If this is a string, it is\n            treated as the name of a body to look up.\n        body_b : str or :class:`Body`\n            One body to test for connectedness. If this is a string, it is\n            treated as the name of a body to look up.\n\n        Returns\n        -------\n        connected : bool\n            Return True iff the two bodies are connected."
        ],
        [
            "Parse an AMC motion capture data file.\n\n    Parameters\n    ----------\n    source : file\n        A file-like object that contains AMC motion capture text.\n\n    Yields\n    ------\n    frame : dict\n        Yields a series of motion capture frames. Each frame is a dictionary\n        that maps a bone name to a list of the DOF configurations for that bone."
        ],
        [
            "Traverse the bone hierarchy and create physics bodies."
        ],
        [
            "Traverse the bone hierarchy and create physics joints."
        ],
        [
            "Parse informations about corporations from given field identified\n        by `datafield` parameter.\n\n        Args:\n            datafield (str): MARC field ID (\"``110``\", \"``610``\", etc..)\n            subfield (str):  MARC subfield ID with name, which is typically\n                             stored in \"``a``\" subfield.\n            roles (str): specify which roles you need. Set to ``[\"any\"]`` for\n                         any role, ``[\"dst\"]`` for distributors, etc.. For\n                         details, see\n                         http://www.loc.gov/marc/relators/relaterm.html\n\n        Returns:\n            list: :class:`Corporation` objects."
        ],
        [
            "Parse persons from given datafield.\n\n        Args:\n            datafield (str): code of datafield (\"010\", \"730\", etc..)\n            subfield (char):  code of subfield (\"a\", \"z\", \"4\", etc..)\n            role (list of str): set to [\"any\"] for any role, [\"aut\"] for\n                 authors, etc.. For details see\n                 http://www.loc.gov/marc/relators/relaterm.html\n\n        Main records for persons are: \"100\", \"600\" and \"700\", subrecords \"c\".\n\n        Returns:\n            list: Person objects."
        ],
        [
            "Get list of VALID ISBN.\n\n        Returns:\n            list: List with *valid* ISBN strings."
        ],
        [
            "Content of field ``856u42``. Typically URL pointing to producers\n        homepage.\n\n        Returns:\n            list: List of URLs defined by producer."
        ],
        [
            "URL's, which may point to edeposit, aleph, kramerius and so on.\n\n        Fields ``856u40``, ``998a`` and ``URLu``.\n\n        Returns:\n            list: List of internal URLs."
        ],
        [
            "r'''Create a callable that implements a PID controller.\n\n    A PID controller returns a control signal :math:`u(t)` given a history of\n    error measurements :math:`e(0) \\dots e(t)`, using proportional (P), integral\n    (I), and derivative (D) terms, according to:\n\n    .. math::\n\n       u(t) = kp * e(t) + ki * \\int_{s=0}^t e(s) ds + kd * \\frac{de(s)}{ds}(t)\n\n    The proportional term is just the current error, the integral term is the\n    sum of all error measurements, and the derivative term is the instantaneous\n    derivative of the error measurement.\n\n    Parameters\n    ----------\n    kp : float\n        The weight associated with the proportional term of the PID controller.\n    ki : float\n        The weight associated with the integral term of the PID controller.\n    kd : float\n        The weight associated with the derivative term of the PID controller.\n    smooth : float in [0, 1]\n        Derivative values will be smoothed with this exponential average. A\n        value of 1 never incorporates new derivative information, a value of 0.5\n        uses the mean of the historic and new information, and a value of 0\n        discards historic information (i.e., the derivative in this case will be\n        unsmoothed). The default is 0.1.\n\n    Returns\n    -------\n    controller : callable (float, float) -> float\n        Returns a function that accepts an error measurement and a delta-time\n        value since the previous measurement, and returns a control signal."
        ],
        [
            "Given a sequence of sequences, return a flat numpy array.\n\n    Parameters\n    ----------\n    iterables : sequence of sequence of number\n        A sequence of tuples or lists containing numbers. Typically these come\n        from something that represents each joint in a skeleton, like angle.\n\n    Returns\n    -------\n    ndarray :\n        An array of flattened data from each of the source iterables."
        ],
        [
            "Load a skeleton definition from a file.\n\n        Parameters\n        ----------\n        source : str or file\n            A filename or file-like object that contains text information\n            describing a skeleton. See :class:`pagoda.parser.Parser` for more\n            information about the format of the text file."
        ],
        [
            "Load a skeleton definition from a text file.\n\n        Parameters\n        ----------\n        source : str or file\n            A filename or file-like object that contains text information\n            describing a skeleton. See :class:`pagoda.parser.BodyParser` for\n            more information about the format of the text file."
        ],
        [
            "Load a skeleton definition from an ASF text file.\n\n        Parameters\n        ----------\n        source : str or file\n            A filename or file-like object that contains text information\n            describing a skeleton, in ASF format."
        ],
        [
            "Set PID parameters for all joints in the skeleton.\n\n        Parameters for this method are passed directly to the `pid` constructor."
        ],
        [
            "Get a list of all current joint torques in the skeleton."
        ],
        [
            "Get a list of the indices for a specific joint.\n\n        Parameters\n        ----------\n        name : str\n            The name of the joint to look up.\n\n        Returns\n        -------\n        list of int :\n            A list of the index values for quantities related to the named\n            joint. Often useful for getting, say, the angles for a specific\n            joint in the skeleton."
        ],
        [
            "Get a list of the indices for a specific body.\n\n        Parameters\n        ----------\n        name : str\n            The name of the body to look up.\n        step : int, optional\n            The number of numbers for each body. Defaults to 3, should be set\n            to 4 for body rotation (since quaternions have 4 values).\n\n        Returns\n        -------\n        list of int :\n            A list of the index values for quantities related to the named body."
        ],
        [
            "Get the current joint separations for the skeleton.\n\n        Returns\n        -------\n        distances : list of float\n            A list expressing the distance between the two joint anchor points,\n            for each joint in the skeleton. These quantities describe how\n            \"exploded\" the bodies in the skeleton are; a value of 0 indicates\n            that the constraints are perfectly satisfied for that joint."
        ],
        [
            "Enable the joint motors in this skeleton.\n\n        This method sets the maximum force that can be applied by each joint to\n        attain the desired target velocities. It also enables torque feedback\n        for all joint motors.\n\n        Parameters\n        ----------\n        max_force : float\n            The maximum force that each joint is allowed to apply to attain its\n            target velocity."
        ],
        [
            "Move each joint toward a target angle.\n\n        This method uses a PID controller to set a target angular velocity for\n        each degree of freedom in the skeleton, based on the difference between\n        the current and the target angle for the respective DOF.\n\n        PID parameters are by default set to achieve a tiny bit less than\n        complete convergence in one time step, using only the P term (i.e., the\n        P coefficient is set to 1 - \\delta, while I and D coefficients are set\n        to 0). PID parameters can be updated by calling the `set_pid_params`\n        method.\n\n        Parameters\n        ----------\n        angles : list of float\n            A list of the target angles for every joint in the skeleton."
        ],
        [
            "Add torques for each degree of freedom in the skeleton.\n\n        Parameters\n        ----------\n        torques : list of float\n            A list of the torques to add to each degree of freedom in the\n            skeleton."
        ],
        [
            "Return the names of our marker labels in canonical order."
        ],
        [
            "Load marker data from a CSV file.\n\n        The file will be imported using Pandas, which must be installed to use\n        this method. (``pip install pandas``)\n\n        The first line of the CSV file will be used for header information. The\n        \"time\" column will be used as the index for the data frame. There must\n        be columns named 'markerAB-foo-x','markerAB-foo-y','markerAB-foo-z', and\n        'markerAB-foo-c' for marker 'foo' to be included in the model.\n\n        Parameters\n        ----------\n        filename : str\n            Name of the CSV file to load."
        ],
        [
            "Load marker data from a C3D file.\n\n        The file will be imported using the c3d module, which must be installed\n        to use this method. (``pip install c3d``)\n\n        Parameters\n        ----------\n        filename : str\n            Name of the C3D file to load.\n        start_frame : int, optional\n            Discard the first N frames. Defaults to 0.\n        max_frames : int, optional\n            Maximum number of frames to load. Defaults to loading all frames."
        ],
        [
            "Process data to produce velocity and dropout information."
        ],
        [
            "Create physics bodies corresponding to each marker in our data."
        ],
        [
            "Load attachment configuration from the given text source.\n\n        The attachment configuration file has a simple format. After discarding\n        Unix-style comments (any part of a line that starts with the pound (#)\n        character), each line in the file is then expected to have the following\n        format::\n\n            marker-name body-name X Y Z\n\n        The marker name must correspond to an existing \"channel\" in our marker\n        data. The body name must correspond to a rigid body in the skeleton. The\n        X, Y, and Z coordinates specify the body-relative offsets where the\n        marker should be attached: 0 corresponds to the center of the body along\n        the given axis, while -1 and 1 correspond to the minimal (maximal,\n        respectively) extent of the body's bounding box along the corresponding\n        dimension.\n\n        Parameters\n        ----------\n        source : str or file-like\n            A filename or file-like object that we can use to obtain text\n            configuration that describes how markers are attached to skeleton\n            bodies.\n\n        skeleton : :class:`pagoda.skeleton.Skeleton`\n            The skeleton to attach our marker data to."
        ],
        [
            "Attach marker bodies to the corresponding skeleton bodies.\n\n        Attachments are only made for markers that are not in a dropout state in\n        the given frame.\n\n        Parameters\n        ----------\n        frame_no : int\n            The frame of data we will use for attaching marker bodies."
        ],
        [
            "Reposition markers to a specific frame of data.\n\n        Parameters\n        ----------\n        frame_no : int\n            The frame of data where we should reposition marker bodies. Markers\n            will be positioned in the appropriate places in world coordinates.\n            In addition, linear velocities of the markers will be set according\n            to the data as long as there are no dropouts in neighboring frames."
        ],
        [
            "Get a list of the distances between markers and their attachments.\n\n        Returns\n        -------\n        distances : ndarray of shape (num-markers, 3)\n            Array of distances for each marker joint in our attachment setup. If\n            a marker does not currently have an associated joint (e.g. because\n            it is not currently visible) this will contain NaN for that row."
        ],
        [
            "Return an array of the forces exerted by marker springs.\n\n        Notes\n        -----\n\n        The forces exerted by the marker springs can be approximated by::\n\n          F = kp * dx\n\n        where ``dx`` is the current array of marker distances. An even more\n        accurate value is computed by approximating the velocity of the spring\n        displacement::\n\n          F = kp * dx + kd * (dx - dx_tm1) / dt\n\n        where ``dx_tm1`` is an array of distances from the previous time step.\n\n        Parameters\n        ----------\n        dx_tm1 : ndarray\n            An array of distances from markers to their attachment targets,\n            measured at the previous time step.\n\n        Returns\n        -------\n        F : ndarray\n            An array of forces that the markers are exerting on the skeleton."
        ],
        [
            "Create and configure a skeleton in our model.\n\n        Parameters\n        ----------\n        filename : str\n            The name of a file containing skeleton configuration data.\n        pid_params : dict, optional\n            If given, use this dictionary to set the PID controller\n            parameters on each joint in the skeleton. See\n            :func:`pagoda.skeleton.pid` for more information."
        ],
        [
            "Load marker data and attachment preferences into the model.\n\n        Parameters\n        ----------\n        filename : str\n            The name of a file containing marker data. This currently needs to\n            be either a .C3D or a .CSV file. CSV files must adhere to a fairly\n            strict column naming convention; see :func:`Markers.load_csv` for\n            more information.\n        attachments : str\n            The name of a text file specifying how markers are attached to\n            skeleton bodies.\n        max_frames : number, optional\n            Only read in this many frames of marker data. By default, the entire\n            data file is read into memory.\n\n        Returns\n        -------\n        markers : :class:`Markers`\n            Returns a markers object containing loaded marker data as well as\n            skeleton attachment configuration."
        ],
        [
            "Advance the physics world by one step.\n\n        Typically this is called as part of a :class:`pagoda.viewer.Viewer`, but\n        it can also be called manually (or some other stepping mechanism\n        entirely can be used)."
        ],
        [
            "Settle the skeleton to our marker data at a specific frame.\n\n        Parameters\n        ----------\n        frame_no : int, optional\n            Settle the skeleton to marker data at this frame. Defaults to 0.\n        max_distance : float, optional\n            The settling process will stop when the mean marker distance falls\n            below this threshold. Defaults to 0.1m (10cm). Setting this too\n            small prevents the settling process from finishing (it will loop\n            indefinitely), and setting it too large prevents the skeleton from\n            settling to a stable state near the markers.\n        max_iters : int, optional\n            Attempt to settle markers for at most this many iterations. Defaults\n            to 1000.\n        states : list of body states, optional\n            If given, set the bodies in our skeleton to these kinematic states\n            before starting the settling process."
        ],
        [
            "Iterate over a set of marker data, dragging its skeleton along.\n\n        Parameters\n        ----------\n        start : int, optional\n            Start following marker data after this frame. Defaults to 0.\n        end : int, optional\n            Stop following marker data after this frame. Defaults to the end of\n            the marker data.\n        states : list of body states, optional\n            If given, set the states of the skeleton bodies to these values\n            before starting to follow the marker data."
        ],
        [
            "Update the simulator to a specific frame of marker data.\n\n        This method returns a generator of body states for the skeleton! This\n        generator must be exhausted (e.g., by consuming this call in a for loop)\n        for the simulator to work properly.\n\n        This process involves the following steps:\n\n        - Move the markers to their new location:\n          - Detach from the skeleton\n          - Update marker locations\n          - Reattach to the skeleton\n        - Detect ODE collisions\n        - Yield the states of the bodies in the skeleton\n        - Advance the ODE world one step\n\n        Parameters\n        ----------\n        frame_no : int\n            Step to this frame of marker data.\n        dt : float, optional\n            Step with this time duration. Defaults to ``self.dt``.\n\n        Returns\n        -------\n        states : sequence of state tuples\n            A generator of a sequence of one body state for the skeleton. This\n            generator must be exhausted for the simulation to work properly."
        ],
        [
            "Follow a set of marker data, yielding kinematic joint angles.\n\n        Parameters\n        ----------\n        start : int, optional\n            Start following marker data after this frame. Defaults to 0.\n        end : int, optional\n            Stop following marker data after this frame. Defaults to the end of\n            the marker data.\n        states : list of body states, optional\n            If given, set the states of the skeleton bodies to these values\n            before starting to follow the marker data.\n        max_force : float, optional\n            Allow each degree of freedom in the skeleton to exert at most this\n            force when attempting to maintain its equilibrium position. This\n            defaults to 20N. Set this value higher to simulate a stiff skeleton\n            while following marker data.\n\n        Returns\n        -------\n        angles : sequence of angle frames\n            Returns a generator of joint angle data for the skeleton. One set of\n            joint angles will be generated for each frame of marker data between\n            `start` and `end`."
        ],
        [
            "Follow a set of angle data, yielding dynamic joint torques.\n\n        Parameters\n        ----------\n        angles : ndarray (num-frames x num-dofs)\n            Follow angle data provided by this array of angle values.\n        start : int, optional\n            Start following angle data after this frame. Defaults to the start\n            of the angle data.\n        end : int, optional\n            Stop following angle data after this frame. Defaults to the end of\n            the angle data.\n        states : list of body states, optional\n            If given, set the states of the skeleton bodies to these values\n            before starting to follow the marker data.\n        max_force : float, optional\n            Allow each degree of freedom in the skeleton to exert at most this\n            force when attempting to follow the given joint angles. Defaults to\n            100N. Setting this value to be large results in more accurate\n            following but can cause oscillations in the PID controllers,\n            resulting in noisy torques.\n\n        Returns\n        -------\n        torques : sequence of torque frames\n            Returns a generator of joint torque data for the skeleton. One set\n            of joint torques will be generated for each frame of angle data\n            between `start` and `end`."
        ],
        [
            "Move the body according to a set of torque data."
        ],
        [
            "Sort values, but put numbers after alphabetically sorted words.\n\n    This function is here to make outputs diff-compatible with Aleph.\n\n    Example::\n        >>> sorted([\"b\", \"1\", \"a\"])\n        ['1', 'a', 'b']\n        >>> resorted([\"b\", \"1\", \"a\"])\n        ['a', 'b', '1']\n\n    Args:\n        values (iterable): any iterable object/list/tuple/whatever.\n\n    Returns:\n        list of sorted values, but with numbers after words"
        ],
        [
            "Draw all bodies in the world."
        ],
        [
            "Get room stream to listen for messages.\n\n        Kwargs:\n            error_callback (func): Callback to call when an error occurred (parameters: exception)\n            live (bool): If True, issue a live stream, otherwise an offline stream\n\n        Returns:\n            :class:`Stream`. Stream"
        ],
        [
            "Get list of users in the room.\n\n        Kwargs:\n            sort (bool): If True, sort rooms by name\n\n        Returns:\n            array. List of users"
        ],
        [
            "Set the room name.\n\n        Args:\n            name (str): Name\n\n        Returns:\n            bool. Success"
        ],
        [
            "Set the room topic.\n\n        Args:\n            topic (str): Topic\n\n        Returns:\n            bool. Success"
        ],
        [
            "Post a message.\n\n        Args:\n            message (:class:`Message` or string): Message\n\n        Returns:\n            bool. Success"
        ],
        [
            "Returns a list of paths specified by the XDG_CONFIG_DIRS environment\n        variable or the appropriate default.\n\n        The list is sorted by precedence, with the most important item coming\n        *last* (required by the existing config_resolver logic)."
        ],
        [
            "Returns the value specified in the XDG_CONFIG_HOME environment variable\n        or the appropriate default."
        ],
        [
            "Returns the filename which is effectively used by the application. If\n        overridden by an environment variable, it will return that filename."
        ],
        [
            "Check if ``filename`` can be read. Will return boolean which is True if\n        the file can be read, False otherwise."
        ],
        [
            "Searches for an appropriate config file. If found, loads the file into\n        the current instance. This method can also be used to reload a\n        configuration. Note that you may want to set ``reload`` to ``True`` to\n        clear the configuration before loading in that case.  Without doing\n        that, values will remain available even if they have been removed from\n        the config files.\n\n        :param reload: if set to ``True``, the existing values are cleared\n                       before reloading.\n        :param require_load: If set to ``True`` this will raise a\n                             :py:exc:`IOError` if no config file has been found\n                             to load."
        ],
        [
            "Get styles."
        ],
        [
            "Create a connection with given settings.\n\n        Args:\n            settings (dict): A dictionary of settings\n\n        Returns:\n            :class:`Connection`. The connection"
        ],
        [
            "Issue a PUT request.\n\n        Kwargs:\n            url (str): Destination URL\n            post_data (dict): Dictionary of parameter and values\n            parse_data (bool): If true, parse response data\n            key (string): If parse_data==True, look for this key when parsing data\n            parameters (dict): Additional GET parameters to append to the URL\n\n        Returns:\n            dict. Response (a dict with keys: success, data, info, body)\n        \n        Raises:\n            AuthenticationError, ConnectionError, urllib2.HTTPError, ValueError, Exception"
        ],
        [
            "Issue a POST request.\n\n        Kwargs:\n            url (str): Destination URL\n            post_data (dict): Dictionary of parameter and values\n            parse_data (bool): If true, parse response data\n            key (string): If parse_data==True, look for this key when parsing data\n            parameters (dict): Additional GET parameters to append to the URL\n            listener (func): callback called when uploading a file\n\n        Returns:\n            dict. Response (a dict with keys: success, data, info, body)\n        \n        Raises:\n            AuthenticationError, ConnectionError, urllib2.HTTPError, ValueError, Exception"
        ],
        [
            "Issue a GET request.\n\n        Kwargs:\n            url (str): Destination URL\n            parse_data (bool): If true, parse response data\n            key (string): If parse_data==True, look for this key when parsing data\n            parameters (dict): Additional GET parameters to append to the URL\n\n        Returns:\n            dict. Response (a dict with keys: success, data, info, body)\n\n        Raises:\n            AuthenticationError, ConnectionError, urllib2.HTTPError, ValueError, Exception"
        ],
        [
            "Get headers.\n\n        Returns:\n            tuple: Headers"
        ],
        [
            "Get URL used for authentication\n\n        Returns:\n            string: URL"
        ],
        [
            "Parses a response.\n\n        Args:\n            text (str): Text to parse\n\n        Kwargs:\n            key (str): Key to look for, if any\n\n        Returns:\n            Parsed value\n\n        Raises:\n            ValueError"
        ],
        [
            "Build a request for twisted\n\n        Args:\n            method (str): Request method (GET/POST/PUT/DELETE/etc.) If not specified, it will be POST if post_data is not None\n            url (str): Destination URL (full, or relative)\n\n        Kwargs:\n            extra_headers (dict): Headers (override default connection headers, if any)\n            body_producer (:class:`twisted.web.iweb.IBodyProducer`): Object producing request body\n            full_url (bool): If False, URL is relative\n\n        Returns:\n            tuple. Tuple with two elements: reactor, and request"
        ],
        [
            "Issue a request.\n\n        Args:\n            method (str): Request method (GET/POST/PUT/DELETE/etc.) If not specified, it will be POST if post_data is not None\n\n        Kwargs:\n            url (str): Destination URL\n            post_data (str): A string of what to POST\n            parse_data (bool): If true, parse response data\n            key (string): If parse_data==True, look for this key when parsing data\n            parameters (dict): Additional GET parameters to append to the URL\n            listener (func): callback called when uploading a file\n            full_return (bool): If set to True, get a full response (with success, data, info, body)\n\n        Returns:\n            dict. Response. If full_return==True, a dict with keys: success, data, info, body, otherwise the parsed data\n\n        Raises:\n            AuthenticationError, ConnectionError, urllib2.HTTPError, ValueError"
        ],
        [
            "Build destination URL.\n\n        Kwargs:\n            url (str): Destination URL\n            parameters (dict): Additional GET parameters to append to the URL\n\n        Returns:\n            str. URL"
        ],
        [
            "Tells if this message is a text message.\n\n        Returns:\n            bool. Success"
        ],
        [
            "Get rooms list.\n\n        Kwargs:\n            sort (bool): If True, sort rooms by name\n\n        Returns:\n            array. List of rooms (each room is a dict)"
        ],
        [
            "Get a room by name.\n\n        Returns:\n            :class:`Room`. Room\n\n        Raises:\n            RoomNotFoundException"
        ],
        [
            "Get room.\n\n        Returns:\n            :class:`Room`. Room"
        ],
        [
            "Get user.\n\n        Returns:\n            :class:`User`. User"
        ],
        [
            "Search transcripts.\n\n        Args:\n            terms (str): Terms for search\n\n        Returns:\n            array. Messages"
        ],
        [
            "Attach an observer.\n\n        Args:\n            observer (func): A function to be called when new messages arrive\n\n        Returns:\n            :class:`Stream`. Current instance to allow chaining"
        ],
        [
            "Called when incoming messages arrive.\n\n        Args:\n            messages (tuple): Messages (each message is a dict)"
        ],
        [
            "Fetch new messages."
        ],
        [
            "Called when new messages arrive.\n\n        Args:\n            messages (tuple): Messages"
        ],
        [
            "Called when a connection is made, and used to send out headers"
        ],
        [
            "Callback issued by twisted when new line arrives.\n\n        Args:\n            line (str): Incoming line"
        ],
        [
            "Process data.\n\n        Args:\n            data (str): Incoming data"
        ],
        [
            "Get a dictionary of CSL styles."
        ],
        [
            "Start producing.\n\n        Args:\n            consumer: Consumer"
        ],
        [
            "Cleanup code after asked to stop producing.\n\n        Kwargs:\n            forced (bool): If True, we were forced to stop"
        ],
        [
            "Send a block of bytes to the consumer.\n\n        Args:\n            block (str): Block of bytes"
        ],
        [
            "Returns total length for this request.\n\n        Returns:\n            int. Length"
        ],
        [
            "Build headers for each field."
        ],
        [
            "Returns the file size for given file field.\n\n        Args:\n            field (str): File field\n\n        Returns:\n            int. File size"
        ],
        [
            "Generate a path value of type result_type.\n\n    result_type can either be bytes or text_type"
        ],
        [
            "Given an ASCII str, returns a path of the given type."
        ],
        [
            "Generates a root component for a path."
        ],
        [
            "A strategy which generates filesystem path values.\n\n    The generated values include everything which the builtin\n    :func:`python:open` function accepts i.e. which won't lead to\n    :exc:`ValueError` or :exc:`TypeError` being raised.\n\n    Note that the range of the returned values depends on the operating\n    system, the Python version, and the filesystem encoding as returned by\n    :func:`sys.getfilesystemencoding`.\n\n    :param allow_pathlike:\n        If :obj:`python:None` makes the strategy include objects implementing\n        the :class:`python:os.PathLike` interface when Python >= 3.6 is used.\n        If :obj:`python:False` no pathlike objects will be generated. If\n        :obj:`python:True` pathlike will be generated (Python >= 3.6 required)\n\n    :type allow_pathlike: :obj:`python:bool` or :obj:`python:None`\n\n    .. versionadded:: 3.15"
        ],
        [
            "exec compiled code"
        ],
        [
            "replace all blocks in extends with current blocks"
        ],
        [
            "flush all buffered string into code"
        ],
        [
            "Add POST data.\n\n        Args:\n            data (dict): key => value dictionary"
        ],
        [
            "Given some error text it will log the text if self.log_errors is True\n\n        :param text: Error text to log"
        ],
        [
            "Processes the texts using TweeboParse and returns them in CoNLL format.\n\n        :param texts: The List of Strings to be processed by TweeboParse.\n        :param retry_count: The number of times it has retried for. Default\n                            0 does not require setting, main purpose is for\n                            recursion.\n        :return: A list of CoNLL formated strings.\n        :raises ServerError: Caused when the server is not running.\n        :raises :py:class:`requests.exceptions.HTTPError`: Caused when the\n                input texts is not formated correctly e.g. When you give it a\n                String not a list of Strings.\n        :raises :py:class:`json.JSONDecodeError`: Caused if after self.retries\n                attempts to parse the data it cannot decode the data.\n\n        :Example:"
        ],
        [
            "Set entity data\n\n        Args:\n            data (dict): Entity data\n            datetime_fields (array): Fields that should be parsed as datetimes"
        ],
        [
            "validates XML text"
        ],
        [
            "validates XML name"
        ],
        [
            "Prepare the actors, the world, and the messaging system to begin \n        playing the game.\n        \n        This method is guaranteed to be called exactly once upon entering the \n        game stage."
        ],
        [
            "Sequentially update the actors, the world, and the messaging system.  \n        The theater terminates once all of the actors indicate that they are done."
        ],
        [
            "Give the actors, the world, and the messaging system a chance to react \n        to the end of the game."
        ],
        [
            "Template variables."
        ],
        [
            "Use when application is starting."
        ],
        [
            "Catch a connection asyncrounosly."
        ],
        [
            "Initialize self."
        ],
        [
            "Asyncronously wait for a connection from the pool."
        ],
        [
            "Release waiters."
        ],
        [
            "Listen for an id from the server.\n\n        At the beginning of a game, each client receives an IdFactory from the \n        server.  This factory are used to give id numbers that are guaranteed \n        to be unique to tokens that created locally.  This method checks to see if such \n        a factory has been received.  If it hasn't, this method does not block \n        and immediately returns False.  If it has, this method returns True \n        after saving the factory internally.  At this point it is safe to enter \n        the GameStage."
        ],
        [
            "Respond when the server indicates that the client is out of sync.\n\n        The server can request a sync when this client sends a message that \n        fails the check() on the server.  If the reason for the failure isn't \n        very serious, then the server can decide to send it as usual in the \n        interest of a smooth gameplay experience.  When this happens, the \n        server sends out an extra response providing the clients with the\n        information they need to resync themselves."
        ],
        [
            "Manage the response when the server rejects a message.\n\n        An undo is when required this client sends a message that the server \n        refuses to pass on to the other clients playing the game.  When this \n        happens, the client must undo the changes that the message made to the \n        world before being sent or crash.  Note that unlike sync requests, undo \n        requests are only reported to the client that sent the offending \n        message."
        ],
        [
            "Relay messages from the forum on the server to the client represented \n        by this actor."
        ],
        [
            "Create a new DataItem."
        ],
        [
            "Raise an ApiUsageError if the given object is not a token that is currently \n    participating in the game.  To be participating in the game, the given \n    token must have an id number and be associated with the world."
        ],
        [
            "Iterate through each member of the class being created and add a \n        safety check to every method that isn't marked as read-only."
        ],
        [
            "Register the given callback to be called whenever the method with the \n        given name is called.  You can easily take advantage of this feature in \n        token extensions by using the @watch_token decorator."
        ],
        [
            "Clear all the internal data the token needed while it was part of \n        the world.\n\n        Note that this method doesn't actually remove the token from the \n        world.  That's what World._remove_token() does.  This method is just \n        responsible for setting the internal state of the token being removed."
        ],
        [
            "Allow tokens to modify the world for the duration of a with-block.\n\n        It's important that tokens only modify the world at appropriate times, \n        otherwise the changes they make may not be communicated across the \n        network to other clients.  To help catch and prevent these kinds of \n        errors, the game engine keeps the world locked most of the time and \n        only briefly unlocks it (using this method) when tokens are allowed to \n        make changes.  When the world is locked, token methods that aren't \n        marked as being read-only can't be called.  When the world is unlocked, \n        any token method can be called.  These checks can be disabled by \n        running python with optimization enabled.\n\n        You should never call this method manually from within your own game.  \n        This method is intended to be used by the game engine, which was \n        carefully designed to allow the world to be modified only when safe.  \n        Calling this method yourself disables an important safety check."
        ],
        [
            "Converts XML tree to event generator"
        ],
        [
            "Converts events stream into lXML tree"
        ],
        [
            "Parses file content into events stream"
        ],
        [
            "selects sub-tree events"
        ],
        [
            "merges each run of successive text events into one text event"
        ],
        [
            "locates ENTER peer for each EXIT object. Convenient when selectively\n    filtering out XML markup"
        ],
        [
            "construct BusinessDate instance from datetime.date instance,\n        raise ValueError exception if not possible\n\n        :param datetime.date datetime_date: calendar day\n        :return bool:"
        ],
        [
            "construct datetime.date instance represented calendar date of BusinessDate instance\n\n        :return datetime.date:"
        ],
        [
            "addition of a period object\n\n        :param BusinessDate d:\n        :param p:\n        :type p: BusinessPeriod or str\n        :param list holiday_obj:\n        :return bankdate:"
        ],
        [
            "addition of a number of months\n\n        :param BusinessDate d:\n        :param int month_int:\n        :return bankdate:"
        ],
        [
            "private method for the addition of business days, used in the addition of a BusinessPeriod only\n\n        :param BusinessDate d:\n        :param int days_int:\n        :param list holiday_obj:\n        :return: BusinessDate"
        ],
        [
            "Parses as much as possible until it encounters a matching closing quote.\n    \n    By default matches any_token, but can be provided with a more specific parser if required.\n    Returns a string"
        ],
        [
            "returns number of days for the given year and month\n\n    :param int year: calendar year\n    :param int month: calendar month\n    :return int:"
        ],
        [
            "Initialize the application."
        ],
        [
            "Register connection's middleware and prepare self database."
        ],
        [
            "Close all connections."
        ],
        [
            "Register a model in self."
        ],
        [
            "Manage a database connection."
        ],
        [
            "Write your migrations here.\n\n    > Model = migrator.orm['name']\n\n    > migrator.sql(sql)\n    > migrator.create_table(Model)\n    > migrator.drop_table(Model, cascade=True)\n    > migrator.add_columns(Model, **fields)\n    > migrator.change_columns(Model, **fields)\n    > migrator.drop_columns(Model, *field_names, cascade=True)\n    > migrator.rename_column(Model, old_field_name, new_field_name)\n    > migrator.rename_table(Model, new_table_name)\n    > migrator.add_index(Model, *col_names, unique=False)\n    > migrator.drop_index(Model, index_name)\n    > migrator.add_not_null(Model, field_name)\n    > migrator.drop_not_null(Model, field_name)\n    > migrator.add_default(Model, field_name, default)"
        ],
        [
            "Runs a series of parsers in sequence passing the result of each parser to the next.\n    The result of the last parser is returned."
        ],
        [
            "Returns the current token if is found in the collection provided.\n    \n    Fails otherwise."
        ],
        [
            "Returns the current token if it is not found in the collection provided.\n    \n    The negative of one_of."
        ],
        [
            "Returns the current token if it satisfies the guard function provided.\n    \n    Fails otherwise.\n    This is the a generalisation of one_of."
        ],
        [
            "Succeeds if the given parser cannot consume input"
        ],
        [
            "Applies the parser to input zero or more times.\n    \n    Returns a list of parser results."
        ],
        [
            "Consumes as many of these as it can until it term is encountered.\n    \n    Returns a tuple of the list of these results and the term result"
        ],
        [
            "Like many_until but must consume at least one of these."
        ],
        [
            "Like sep but must consume at least one of parser."
        ],
        [
            "fills the internal buffer from the source iterator"
        ],
        [
            "Advances to and returns the next token or returns EndOfFile"
        ],
        [
            "Run a game being developed with the kxg game engine.\n\nUsage:\n    {exe_name} sandbox [<num_ais>] [-v...]\n    {exe_name} client [--host HOST] [--port PORT] [-v...]\n    {exe_name} server <num_guis> [<num_ais>] [--host HOST] [--port PORT] [-v...] \n    {exe_name} debug <num_guis> [<num_ais>] [--host HOST] [--port PORT] [-v...]\n    {exe_name} --help\n\nCommands:\n    sandbox\n        Play a single-player game with the specified number of AIs.  None of \n        the multiplayer machinery will be used.\n\n    client\n        Launch a client that will try to connect to a server on the given host \n        and port.  Once it connects and the game starts, the client will allow \n        you to play the game against any other connected clients.\n\n    server\n        Launch a server that will manage a game between the given number of \n        human and AI players.  The human players must connect using this \n        command's client mode.\n\n    debug\n        Debug a multiplayer game locally.  This command launches a server and \n        the given number of clients all in different processes, and configures \n        the logging system such that the output from each process can be easily \n        distinguished.\n\nArguments:\n    <num_guis>\n        The number of human players that will be playing the game.  Only needed \n        by commands that will launch some sort of multiplayer server.\n\n    <num_ais>\n        The number of AI players that will be playing the game.  Only needed by \n        commands that will launch single-player games or multiplayer servers.\n\nOptions:\n    -x --host HOST          [default: {default_host}]\n        The address of the machine running the server.  Must be accessible from \n        the machines running the clients.\n\n    -p --port PORT          [default: {default_port}]\n        The port that the server should listen on.  Don't specify a value less \n        than 1024 unless the server is running with root permissions.\n\n    -v --verbose \n        Have the game engine log more information about what it's doing.  You \n        can specify this option several times to get more and more information.\n\nThis command is provided so that you can start writing your game with the least \npossible amount of boilerplate code.  However, the clients and servers provided \nby this command are not capable of running a production game.  Once you have \nwritten your game and want to give it a polished set of menus and options, \nyou'll have to write new Stage subclasses encapsulating that logic and you'll \nhave to call those stages yourself by interacting more directly with the \nTheater class.  The online documentation has more information on this process."
        ],
        [
            "Poll the queues that the worker can use to communicate with the \n        supervisor, until all the workers are done and all the queues are \n        empty.  Handle messages as they appear."
        ],
        [
            "Return database field type."
        ],
        [
            "Parse value from database."
        ],
        [
            "Parse the fsapi endpoint from the device url."
        ],
        [
            "Create a session on the frontier silicon device."
        ],
        [
            "Execute a frontier silicon API call."
        ],
        [
            "Helper method for setting a value by using the fsapi API."
        ],
        [
            "Helper method for fetching a text value."
        ],
        [
            "Helper method for fetching a integer value."
        ],
        [
            "Helper method for fetching a long value. Result is integer."
        ],
        [
            "Check if the device is on."
        ],
        [
            "Power on or off the device."
        ],
        [
            "Get the modes supported by this device."
        ],
        [
            "Read the maximum volume level of the device."
        ],
        [
            "Check if the device is muted."
        ],
        [
            "Mute or unmute the device."
        ],
        [
            "Get the play status of the device."
        ],
        [
            "Get the equaliser modes supported by this device."
        ],
        [
            "Set device sleep timer."
        ],
        [
            "Assumes that start and stop are already in 'buffer' coordinates. value is a byte iterable.\n        value_len is fractional."
        ],
        [
            "Parse genotype from VCF line data"
        ],
        [
            "toIndex - An optional method which will return the value prepped for index.\n\n\t\t\tBy default, \"toStorage\" will be called. If you provide \"hashIndex=True\" on the constructor,\n\t\t\tthe field will be md5summed for indexing purposes. This is useful for large strings, etc."
        ],
        [
            "copy - Create a copy of this IRField.\n\n\t\t\t  Each subclass should implement this, as you'll need to pass in the args to constructor.\n\n\t\t\t@return <IRField (or subclass)> - Another IRField that has all the same values as this one."
        ],
        [
            "objHasUnsavedChanges - Check if any object has unsaved changes, cascading."
        ],
        [
            "Check that a value has a certain JSON type.\n\n    Raise TypeError if the type does not match.\n\n    Supported types: str, int, float, bool, list, dict, and None.\n    float will match any number, int will only match numbers without\n    fractional part.\n\n    The special type JList(x) will match a list value where each\n    item is of type x:\n\n    >>> assert_json_type([1, 2, 3], JList(int))"
        ],
        [
            "Load json or yaml data from file handle.\n\n        Args:\n            fh (file): File handle to load from.\n\n        Examlple:\n            >>> with open('data.json', 'r') as json:\n            >>>    jsdata = composite.load(json)\n            >>>\n            >>> with open('data.yml', 'r') as yml:\n            >>>    ymldata = composite.load(yml)"
        ],
        [
            "Load json from file handle.\n\n        Args:\n            fh (file): File handle to load from.\n\n        Examlple:\n            >>> with open('data.json', 'r') as json:\n            >>>    data = composite.load(json)"
        ],
        [
            "Recursively compute intersection of data. For dictionaries, items\n        for specific keys will be reduced to unique items. For lists, items\n        will be reduced to unique items. This method is meant to be analogous\n        to set.intersection for composite objects.\n\n        Args:\n            other (composite): Other composite object to intersect with.\n            recursive (bool): Whether or not to perform the operation recursively,\n                for all nested composite objects."
        ],
        [
            "Recursively compute union of data. For dictionaries, items\n        for specific keys will be combined into a list, depending on the\n        status of the overwrite= parameter. For lists, items will be appended\n        and reduced to unique items. This method is meant to be analogous\n        to set.union for composite objects.\n\n        Args:\n            other (composite): Other composite object to union with.\n            recursive (bool): Whether or not to perform the operation recursively,\n                for all nested composite objects.\n            overwrite (bool): Whether or not to overwrite entries with the same\n                key in a nested dictionary."
        ],
        [
            "Append to object, if object is list."
        ],
        [
            "Extend list from object, if object is list."
        ],
        [
            "Write composite object to file handle in JSON format.\n\n        Args:\n            fh (file): File handle to write to.\n            pretty (bool): Sort keys and indent in output."
        ],
        [
            "Return list of files in filetree."
        ],
        [
            "Prune leaves of filetree according to specified\n        regular expression.\n\n        Args:\n            regex (str): Regular expression to use in pruning tree."
        ],
        [
            "Returns the value this reference is pointing to. This method uses 'ctx' to resolve the reference and return\n        the value this reference references.\n        If the call was already made, it returns a cached result.\n        It also makes sure there's no cyclic reference, and if so raises CyclicReferenceError."
        ],
        [
            "delete - Delete all objects in this list.\n\n\t\t\t@return <int> - Number of objects deleted"
        ],
        [
            "save - Save all objects in this list"
        ],
        [
            "reload - Reload all objects in this list. \n\t\t\t\tUpdates in-place. To just fetch all these objects again, use \"refetch\"\n\n\t\t\t@return - List (same order as current objects) of either exception (KeyError) if operation failed,\n\t\t\t  or a dict of fields changed -> (old, new)"
        ],
        [
            "refetch - Fetch a fresh copy of all items in this list.\n\t\t\t\tReturns a new list. To update in-place, use \"reload\".\n\n\t\t\t@return IRQueryableList<IndexedRedisModel> - List of fetched items"
        ],
        [
            "Renders as a str"
        ],
        [
            "Returns the elements HTML start tag"
        ],
        [
            "Returns a repr of an object and falls back to a minimal representation of type and ID if the call to repr raised\n    an error.\n\n    :param obj: object to safe repr\n    :returns: repr string or '(type<id> repr error)' string\n    :rtype: str"
        ],
        [
            "Match a genome VCF to variants in the ClinVar VCF file\n\n    Acts as a generator, yielding tuples of:\n    (ClinVarVCFLine, ClinVarAllele, zygosity)\n\n    'zygosity' is a string and corresponds to the genome's zygosity for that\n    ClinVarAllele. It can be either: 'Het' (heterozygous), 'Hom' (homozygous),\n    or 'Hem' (hemizygous, e.g. X chromosome in XY individuals)."
        ],
        [
            "Return Allele data as dict object."
        ],
        [
            "Create list of Alleles from VCF line data"
        ],
        [
            "Parse the VCF info field"
        ],
        [
            "Dict representation of parsed VCF data"
        ],
        [
            "Very lightweight parsing of a vcf line to get position.\n\n        Returns a dict containing:\n        'chrom': index of chromosome (int), indicates sort order\n        'pos': position on chromosome (int)"
        ],
        [
            "_toStorage - Convert the value to a string representation for storage.\n\n\t\t\t@param value - The value of the item to convert\n\t\t\t@return A string value suitable for storing."
        ],
        [
            "Navigate an open ftplib.FTP to appropriate directory for ClinVar VCF files.\n\n    Args:\n        ftp:   (type: ftplib.FTP) an open connection to ftp.ncbi.nlm.nih.gov\n        build: (type: string) genome build, either 'b37' or 'b38'"
        ],
        [
            "Return ClinVarAllele data as dict object."
        ],
        [
            "Parse frequency data in ClinVar VCF"
        ],
        [
            "Parse alleles for ClinVar VCF, overrides parent method."
        ],
        [
            "Returns back a class decorator that enables registering Blox to this factory"
        ],
        [
            "Decorator for warning user of depricated functions before use.\n\n    Args:\n        newmethod (str): Name of method to use instead."
        ],
        [
            "setDefaultRedisConnectionParams - Sets the default parameters used when connecting to Redis.\n\n\t\t  This should be the args to redis.Redis in dict (kwargs) form.\n\n\t\t  @param connectionParams <dict> - A dict of connection parameters.\n\t\t    Common keys are:\n\n\t\t       host <str> - hostname/ip of Redis server (default '127.0.0.1')\n\t\t       port <int> - Port number\t\t\t(default 6379)\n\t\t       db  <int>  - Redis DB number\t\t(default 0)\n\n\t\t   Omitting any of those keys will ensure the default value listed is used.\n\n\t\t  This connection info will be used by default for all connections to Redis, unless explicitly set otherwise.\n\t\t  The common way to override is to define REDIS_CONNECTION_PARAMS on a model, or use AltConnectedModel = MyModel.connectAlt( PARAMS )\n\n\t\t  Any omitted fields in these connection overrides will inherit the value from the global default.\n\n\t\t  For example, if your global default connection params define host = 'example.com', port=15000, and db=0, \n\t\t    and then one of your models has\n\t\t       \n\t\t       REDIS_CONNECTION_PARAMS = { 'db' : 1 }\n\t\t    \n\t\t    as an attribute, then that model's connection will inherit host='example.com\" and port=15000 but override db and use db=1\n\n\n\t\t    NOTE: Calling this function will clear the connection_pool attribute of all stored managed connections, disconnect all managed connections,\n\t\t      and close-out the connection pool.\n\t\t     It may not be safe to call this function while other threads are potentially hitting Redis (not that it would make sense anyway...)\n\n\t\t     @see clearRedisPools   for more info"
        ],
        [
            "clearRedisPools - Disconnect all managed connection pools, \n\t\t   and clear the connectiobn_pool attribute on all stored managed connection pools.\n\n\t\t   A \"managed\" connection pool is one where REDIS_CONNECTION_PARAMS does not define the \"connection_pool\" attribute.\n\t\t   If you define your own pools, IndexedRedis will use them and leave them alone.\n\n\t\t  This method will be called automatically after calling setDefaultRedisConnectionParams.\n\n\t\t  Otherwise, you shouldn't have to call it.. Maybe as some sort of disaster-recovery call.."
        ],
        [
            "getRedisPool - Returns and possibly also creates a Redis connection pool\n\t\t\tbased on the REDIS_CONNECTION_PARAMS passed in.\n\n\t\t\tThe goal of this method is to keep a small connection pool rolling\n\t\t\tto each unique Redis instance, otherwise during network issues etc\n\t\t\tpython-redis will leak connections and in short-order can exhaust\n\t\t\tall the ports on a system. There's probably also some minor\n\t\t\tperformance gain in sharing Pools.\n\n\t\t\tWill modify \"params\", if \"host\" and/or \"port\" are missing, will fill\n\t\t\tthem in with defaults, and prior to return will set \"connection_pool\"\n\t\t\ton params, which will allow immediate return on the next call,\n\t\t\tand allow access to the pool directly from the model object.\n\n\t\t\t@param params <dict> - REDIS_CONNECTION_PARAMS - kwargs to redis.Redis\n\n\t\t\t@return redis.ConnectionPool corrosponding to this unique server."
        ],
        [
            "pprint - Pretty-print a dict representation of this object.\n\n\t\t\t@param stream <file/None> - Either a stream to output, or None to default to sys.stdout"
        ],
        [
            "hasUnsavedChanges - Check if any unsaved changes are present in this model, or if it has never been saved.\n\n\t\t\t@param cascadeObjects <bool> default False, if True will check if any foreign linked objects themselves have unsaved changes (recursively).\n\t\t\t\tOtherwise, will just check if the pk has changed.\n\n\t\t\t@return <bool> - True if any fields have changed since last fetch, or if never saved. Otherwise, False"
        ],
        [
            "diff - Compare the field values on two IndexedRedisModels.\n\n\t\t\t@param firstObj <IndexedRedisModel instance> - First object (or self)\n\n\t\t\t@param otherObj <IndexedRedisModel instance> - Second object\n\n\t\t\t@param includeMeta <bool> - If meta information (like pk) should be in the diff results.\n\n\n\t\t\t@return <dict> - Dict of  'field' : ( value_firstObjForField, value_otherObjForField ).\n\t\t\t\t\n\t\t\t\tKeys are names of fields with different values.\n\t\t\t\tValue is a tuple of ( value_firstObjForField, value_otherObjForField )\n\n\t\t\tCan be called statically, like: IndexedRedisModel.diff ( obj1, obj2 )\n\n\t\t\t  or in reference to an obj   : obj1.diff(obj2)"
        ],
        [
            "save - Save this object.\n\t\t\t\n\t\t\tWill perform an \"insert\" if this object had not been saved before,\n\t\t\t  otherwise will update JUST the fields changed on THIS INSTANCE of the model.\n\n\t\t\t  i.e. If you have two processes fetch the same object and change different fields, they will not overwrite\n\t\t\t  eachother, but only save the ones each process changed.\n\n\t\t\tIf you want to save multiple objects of type MyModel in a single transaction,\n\t\t\tand you have those objects in a list, myObjs, you can do the following:\n\n\t\t\t\tMyModel.saver.save(myObjs)\n\n\t\t\t@param cascadeSave <bool> Default True - If True, any Foreign models linked as attributes that have been altered\n\t\t\t   or created will be saved with this object. If False, only this object (and the reference to an already-saved foreign model) will be saved.\n\n\t\t\t@see #IndexedRedisSave.save\n\n\t\t\t@return <list> - Single element list, id of saved object (if successful)"
        ],
        [
            "hasSameValues - Check if this and another model have the same fields and values.\n\n\t\t\tThis does NOT include id, so the models can have the same values but be different objects in the database.\n\n\t\t\t@param other <IndexedRedisModel> - Another model\n\n\t\t\t@param cascadeObject <bool> default True - If True, foreign link values with changes will be considered a difference.\n\t\t\t\tOtherwise, only the immediate values are checked.\n\n\t\t\t@return <bool> - True if all fields have the same value, otherwise False"
        ],
        [
            "copy - Copies this object.\n\n                    @param copyPrimaryKey <bool> default False - If True, any changes to the copy will save over-top the existing entry in Redis.\n                        If False, only the data is copied, and nothing is saved.\n\n\t\t    @param copyValues <bool> default False - If True, every field value on this object will be explicitly copied. If False,\n\t\t      an object will be created with the same values, and depending on the type may share the same reference.\n\t\t      \n\t\t      This is the difference between a copy and a deepcopy.\n\n\t            @return <IndexedRedisModel> - Copy of this object, per above\n\n\t\t    If you need a copy that IS linked, @see IndexedRedisModel.copy"
        ],
        [
            "saveToExternal - Saves this object to a different Redis than that specified by REDIS_CONNECTION_PARAMS on this model.\n\n\t\t\t@param redisCon <dict/redis.Redis> - Either a dict of connection params, a la REDIS_CONNECTION_PARAMS, or an existing Redis connection.\n\t\t\t\tIf you are doing a lot of bulk copies, it is recommended that you create a Redis connection and pass it in rather than establish a new\n\t\t\t\tconnection with each call.\n\n\t\t\t@note - You will generate a new primary key relative to the external Redis environment. If you need to reference a \"shared\" primary key, it is better\n\t\t\t\t\tto use an indexed field than the internal pk."
        ],
        [
            "reload - Reload this object from the database, overriding any local changes and merging in any updates.\n\n\n\t\t    @param cascadeObjects <bool> Default True. If True, foreign-linked objects will be reloaded if their values have changed\n\t\t      since last save/fetch. If False, only if the pk changed will the foreign linked objects be reloaded.\n\n                    @raises KeyError - if this object has not been saved (no primary key)\n\n                    @return - Dict with the keys that were updated. Key is field name that was updated,\n\t\t       and value is tuple of (old value, new value). \n\n\t\t    NOTE: Currently, this will cause a fetch of all Foreign Link objects, one level"
        ],
        [
            "copyModel - Copy this model, and return that copy.\n\n\t\t\t  The copied model will have all the same data, but will have a fresh instance of the FIELDS array and all members,\n\t\t\t    and the INDEXED_FIELDS array.\n\t\t\t  \n\t\t\t  This is useful for converting, like changing field types or whatever, where you can load from one model and save into the other.\n\n\t\t\t@return <IndexedRedisModel> - A copy class of this model class with a unique name."
        ],
        [
            "connectAlt - Create a class of this model which will use an alternate connection than the one specified by REDIS_CONNECTION_PARAMS on this model.\n\n\t\t\t@param redisConnectionParams <dict> - Dictionary of arguments to redis.Redis, same as REDIS_CONNECTION_PARAMS.\n\n\t\t\t@return - A class that can be used in all the same ways as the existing IndexedRedisModel, but that connects to a different instance.\n\n\t\t\t  The fields and key will be the same here, but the connection will be different. use #copyModel if you want an independent class for the model"
        ],
        [
            "_get_new_connection - Get a new connection\n\t\t\tinternal"
        ],
        [
            "_get_connection - Maybe get a new connection, or reuse if passed in.\n\t\t\t\tWill share a connection with a model\n\t\t\tinternal"
        ],
        [
            "_add_id_to_keys - Adds primary key to table\n\t\t\tinternal"
        ],
        [
            "_rem_id_from_keys - Remove primary key from table\n\t\t\tinternal"
        ],
        [
            "_add_id_to_index - Adds an id to an index\n\t\t\tinternal"
        ],
        [
            "_rem_id_from_index - Removes an id from an index\n\t\t\tinternal"
        ],
        [
            "_get_key_for_index - Returns the key name that would hold the indexes on a value\n\t\t\tInternal - does not validate that indexedFields is actually indexed. Trusts you. Don't let it down.\n\n\t\t\t@param indexedField - string of field name\n\t\t\t@param val - Value of field\n\n\t\t\t@return - Key name string, potentially hashed."
        ],
        [
            "_compat_rem_str_id_from_index - Used in compat_convertHashedIndexes to remove the old string repr of a field,\n\t\t\t\tin order to later add the hashed value,"
        ],
        [
            "_peekNextID - Look at, but don't increment the primary key for this model.\n\t\t\t\tInternal.\n\n\t\t\t@return int - next pk"
        ],
        [
            "Internal for handling filters; the guts of .filter and .filterInline"
        ],
        [
            "count - gets the number of records matching the filter criteria\n\n\t\t\tExample:\n\t\t\t\ttheCount = Model.objects.filter(field1='value').count()"
        ],
        [
            "exists - Tests whether a record holding the given primary key exists.\n\n\t\t\t@param pk - Primary key (see getPk method)\n\n\t\t\tExample usage: Waiting for an object to be deleted without fetching the object or running a filter. \n\n\t\t\tThis is a very cheap operation.\n\n\t\t\t@return <bool> - True if object with given pk exists, otherwise False"
        ],
        [
            "getPrimaryKeys - Returns all primary keys matching current filterset.\n\n\t\t\t@param sortByAge <bool> - If False, return will be a set and may not be ordered.\n\t\t\t\tIf True, return will be a list and is guarenteed to represent objects oldest->newest\n\n\t\t\t@return <set> - A set of all primary keys associated with current filters."
        ],
        [
            "all - Get the underlying objects which match the filter criteria.\n\n\t\t\tExample:   objs = Model.objects.filter(field1='value', field2='value2').all()\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\t\t\t@return - Objects of the Model instance associated with this query."
        ],
        [
            "allOnlyFields - Get the objects which match the filter criteria, only fetching given fields.\n\n\t\t\t@param fields - List of fields to fetch\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\n\t\t\t@return - Partial objects with only the given fields fetched"
        ],
        [
            "allOnlyIndexedFields - Get the objects which match the filter criteria, only fetching indexed fields.\n\n\t\t\t@return - Partial objects with only the indexed fields fetched"
        ],
        [
            "Random - Returns a random record in current filterset.\n\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\t\t\t@return - Instance of Model object, or None if no items math current filters"
        ],
        [
            "delete - Deletes all entries matching the filter criteria"
        ],
        [
            "get - Get a single value with the internal primary key.\n\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\t\t\t@param pk - internal primary key (can be found via .getPk() on an item)"
        ],
        [
            "_doCascadeFetch - Takes an object and performs a cascading fetch on all foreign links, and all theirs, and so on.\n\n\t\t\t@param obj <IndexedRedisModel> - A fetched model"
        ],
        [
            "getMultiple - Gets multiple objects with a single atomic operation\n\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\t\t\t@param pks - list of internal keys"
        ],
        [
            "getOnlyFields - Gets only certain fields from a paticular primary key. For working on entire filter set, see allOnlyFields\n\n\t\t\t@param pk <int> - Primary Key\n\n\t\t\t@param fields list<str> - List of fields\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\n\t\t\treturn - Partial objects with only fields applied"
        ],
        [
            "getMultipleOnlyFields - Gets only certain fields from a list of  primary keys. For working on entire filter set, see allOnlyFields\n\n\t\t\t@param pks list<str> - Primary Keys\n\n\t\t\t@param fields list<str> - List of fields\n\n\n\t\t\t@param cascadeFetch <bool> Default False, If True, all Foreign objects associated with this model\n\t\t\t   will be fetched immediately. If False, foreign objects will be fetched on-access.\n\n\t\t\treturn - List of partial objects with only fields applied"
        ],
        [
            "compat_convertHashedIndexes - Reindex fields, used for when you change the propery \"hashIndex\" on one or more fields.\n\n\t\t\tFor each field, this will delete both the hash and unhashed keys to an object, \n\t\t\t  and then save a hashed or unhashed value, depending on that field's value for \"hashIndex\".\n\n\t\t\tFor an IndexedRedisModel class named \"MyModel\", call as \"MyModel.objects.compat_convertHashedIndexes()\"\n\n\t\t\tNOTE: This works one object at a time (regardless of #fetchAll), so that an unhashable object does not trash all data.\n\n\t\t\tThis method is intended to be used while your application is offline,\n\t\t\t  as it doesn't make sense to be changing your model while applications are actively using it.\n\n\t\t\t@param fetchAll <bool>, Default True - If True, all objects will be fetched first, then converted.\n\t\t\t  This is generally what you want to do, as it is more efficient. If you are memory contrainted,\n\t\t\t  you can set this to \"False\", and it will fetch one object at a time, convert it, and save it back."
        ],
        [
            "_doSave - Internal function to save a single object. Don't call this directly. \n\t\t\t            Use \"save\" instead.\n\n\t\t\t  If a pipeline is provided, the operations (setting values, updating indexes, etc)\n\t\t\t    will be queued into that pipeline.\n\t\t\t  Otherwise, everything will be executed right away.\n\n\t\t\t  @param obj - Object to save\n\t\t\t  @param isInsert - Bool, if insert or update. Either way, obj._id is expected to be set.\n\t\t\t  @param conn - Redis connection\n\t\t\t  @param pipeline - Optional pipeline, if present the items will be queued onto it. Otherwise, go directly to conn."
        ],
        [
            "compat_convertHashedIndexes - Reindex all fields for the provided objects, where the field value is hashed or not.\n\t\t\tIf the field is unhashable, do not allow.\n\n\t\t\tNOTE: This works one object at a time. It is intended to be used while your application is offline,\n\t\t\t  as it doesn't make sense to be changing your model while applications are actively using it.\n\n\t\t\t@param objs <IndexedRedisModel objects to convert>\n\t\t\t@param conn <redis.Redis or None> - Specific Redis connection or None to reuse."
        ],
        [
            "deleteOne - Delete one object\n\n\t\t\t@param obj - object to delete\n\t\t\t@param conn - Connection to reuse, or None\n\n\t\t\t@return - number of items deleted (0 or 1)"
        ],
        [
            "deleteByPk - Delete object associated with given primary key"
        ],
        [
            "deleteMultiple - Delete multiple objects\n\n\t\t\t@param objs - List of objects\n\n\t\t\t@return - Number of objects deleted"
        ],
        [
            "deleteMultipleByPks - Delete multiple objects given their primary keys\n\n\t\t\t@param pks - List of primary keys\n\n\t\t\t@return - Number of objects deleted"
        ],
        [
            "Returns a blox template from an html string"
        ],
        [
            "Returns a blox template from a file stream object"
        ],
        [
            "Returns a blox template from a valid file path"
        ],
        [
            "Accumulate all dictionary and named arguments as\n    keyword argument dictionary. This is generally useful for\n    functions that try to automatically resolve inputs.\n\n    Examples:\n        >>> @keywords\n        >>> def test(*args, **kwargs):\n        >>>     return kwargs\n        >>>\n        >>> print test({'one': 1}, two=2)\n        {'one': 1, 'two': 2}"
        ],
        [
            "getCompressMod - Return the module used for compression on this field\n\n\t\t\t@return <module> - The module for compression"
        ],
        [
            "toBytes - Convert a value to bytes using the encoding specified on this field\n\n\t\t\t@param value <str> - The field to convert to bytes\n\n\t\t\t@return <bytes> - The object encoded using the codec specified on this field.\n\n\t\t\tNOTE: This method may go away."
        ],
        [
            "Like functools.partial but instead of using the new kwargs, keeps the old ones."
        ],
        [
            "Callable to configure Bokeh's show method when a proxy must be\n    configured.\n\n    If port is None we're asking about the URL\n    for the origin header."
        ],
        [
            "Called at the start of notebook execution to setup the environment.\n\n    This will configure bokeh, and setup the logging library to be\n    reasonable."
        ],
        [
            "Creates a overview of the hosts per range."
        ],
        [
            "Create an OrderedDict\n\n    :param hierarchy: a dictionary\n    :param level: single key\n    :return: deeper dictionary"
        ],
        [
            "Groups line reference together\n\n    :param text: Text object\n    :type text: MyCapytains.resources.text.api\n    :param getreffs: Callback function to retrieve text\n    :type getreffs: function(level)\n    :param lines: Number of lines to use by group\n    :type lines: int\n    :return: List of grouped urn references with their human readable version\n    :rtype: [(str, str)]"
        ],
        [
            "Chunk a text at the passage level\n\n    :param text: Text object\n    :type text: MyCapytains.resources.text.api\n    :param getreffs: Callback function to retrieve text\n    :type getreffs: function(level)\n    :return: List of urn references with their human readable version\n    :rtype: [(str, str)]"
        ],
        [
            "Create a numpy.ndarray with all observed fields and\n    computed teff and luminosity values."
        ],
        [
            "Return the numpy array with rounded teff and luminosity columns."
        ],
        [
            "Checks the arguments to brutefore and spawns greenlets to perform the bruteforcing."
        ],
        [
            "Given a cluster create a Bokeh plot figure using the\n    cluster's image."
        ],
        [
            "Returns rounded teff and luminosity lists."
        ],
        [
            "Given a cluster create a Bokeh plot figure creating an\n    H-R diagram."
        ],
        [
            "Given a numpy array calculate what the ranges of the H-R\n    diagram should be."
        ],
        [
            "Given a numpy array create a Bokeh plot figure creating an\n    H-R diagram."
        ],
        [
            "Filter the cluster data catalog into the filtered_data\n        catalog, which is what is shown in the H-R diagram.\n\n        Filter on the values of the sliders, as well as the lasso\n        selection in the skyviewer."
        ],
        [
            "Creates a tempfile and starts the given editor, returns the data afterwards."
        ],
        [
            "This functions gives the user a way to change the data that is given as input."
        ],
        [
            "Performs a bruteforce for the given users, password, domain on the given host."
        ],
        [
            "Set the access and modified times of the file specified by path."
        ],
        [
            "Strip \\\\?\\ prefix in init phase"
        ],
        [
            "Return the path always without the \\\\?\\ prefix."
        ],
        [
            "Formats the output of another tool in the given way.\n        Has default styles for ranges, hosts and services."
        ],
        [
            "Print the given line to stdout"
        ],
        [
            "Gets the IP from the inet interfaces."
        ],
        [
            "Create a pandas DataFrame from a numpy ndarray.\n\n    By default use temp and lum with max rows of 32 and precision of 2.\n\n    arr - An numpy.ndarray.\n    columns - The columns to include in the pandas DataFrame. Defaults to\n              temperature and luminosity.\n    names - The column names for the pandas DataFrame. Defaults to\n            Temperature and Luminosity.\n    max_rows - If max_rows is an integer then set the pandas\n               display.max_rows option to that value. If max_rows\n               is True then set display.max_rows option  to 1000.\n    precision - An integer to set the pandas precision option."
        ],
        [
            "Strips labels."
        ],
        [
            "Remove namespace in the passed document in place."
        ],
        [
            "Check to see if this URI is retrievable by this Retriever implementation\n\n        :param uri: the URI of the resource to be retrieved\n        :type uri: str\n        :return: True if it can be, False if not\n        :rtype: bool"
        ],
        [
            "Decorator used to tag a method that should be used as a hook for the\n  specified `name` hook type."
        ],
        [
            "Subscribes `callable` to listen to events of `name` type. The\n    parameters passed to `callable` are dependent on the specific\n    event being triggered."
        ],
        [
            "Configures this engine based on the options array passed into\n    `argv`. If `argv` is ``None``, then ``sys.argv`` is used instead.\n    During configuration, the command line options are merged with\n    previously stored values. Then the logging subsystem and the\n    database model are initialized, and all storable settings are\n    serialized to configurations files."
        ],
        [
            "Alias for _assemble_with_columns"
        ],
        [
            "Execute a query with provided parameters \n\n        Parameters\n        :query:     SQL string with parameter placeholders\n        :commit:    If True, the query will commit\n        :returns:   List of rows"
        ],
        [
            "Handle provided columns and if necessary, convert columns to a list for \n        internal strage.\n\n        :columns: A sequence of columns for the table. Can be list, comma\n            -delimited string, or IntEnum."
        ],
        [
            "Execute a DML query \n\n        :sql_string:    An SQL string template\n        :*args:         Arguments to be passed for query parameters.\n        :commit:        Whether or not to commit the transaction after the query\n        :returns:       Psycopg2 result"
        ],
        [
            "Execute a SELECT statement \n\n        :sql_string:    An SQL string template\n        :columns:       A list of columns to be returned by the query\n        :*args:         Arguments to be passed for query parameters.\n        :returns:       Psycopg2 result"
        ],
        [
            "Retreive a single record from the table.  Lots of reasons this might be\n        best implemented in the model\n\n        :pk:            The primary key ID for the record\n        :returns:       List of single result"
        ],
        [
            "Creates the final payload based on the x86 and x64 meterpreters."
        ],
        [
            "Combines the files 1 and 2 into 3."
        ],
        [
            "Runs the checker.py scripts to detect the os."
        ],
        [
            "Starts the exploiting phase, you should run setup before running this function.\n            if auto is set, this function will fire the exploit to all systems. Otherwise a curses interface is shown."
        ],
        [
            "Exploits a single ip, exploit is based on the given operating system."
        ],
        [
            "Create server instance with an optional WebSocket handler\n\n    For pure WebSocket server ``app`` may be ``None`` but an attempt to access\n    any path other than ``ws_path`` will cause server error.\n    \n    :param host: hostname or IP\n    :type host: str\n    :param port: server port\n    :type port: int\n    :param app: WSGI application\n    :param server_class: WSGI server class, defaults to AsyncWsgiServer\n    :param handler_class: WSGI handler class, defaults to AsyncWsgiHandler\n    :param ws_handler_class: WebSocket hanlder class, defaults to ``None``\n    :param ws_path: WebSocket path on the server, defaults to '/ws'\n    :type ws_path: str, optional\n    :return: initialized server instance"
        ],
        [
            "Poll active sockets once\n\n        This method can be used to allow aborting server polling loop\n        on some condition.\n\n        :param timeout: polling timeout"
        ],
        [
            "Start serving HTTP requests\n\n        This method blocks the current thread.\n\n        :param poll_interval: polling timeout\n        :return:"
        ],
        [
            "write triples into a translation file."
        ],
        [
            "write triples to file."
        ],
        [
            "Returns protobuf mapcontainer. Read from translation file."
        ],
        [
            "Returns map with entity or relations from plain text."
        ],
        [
            "Prints an overview of the tags of the hosts."
        ],
        [
            "Main credentials tool"
        ],
        [
            "Provides an overview of the duplicate credentials."
        ],
        [
            "Register nemo and parses annotations\n\n        .. note:: Process parses the annotation and extends informations about the target URNs by retrieving resource in range\n\n        :param nemo: Nemo"
        ],
        [
            "Starts the loop to provide the data from jackal."
        ],
        [
            "Creates a search query based on the section of the config file."
        ],
        [
            "Creates the workers based on the given configfile to provide named pipes in the directory."
        ],
        [
            "Loads the config and handles the workers."
        ],
        [
            "Replace isocode by its language equivalent\n\n    :param isocode: Three character long language code\n    :param lang: Lang in which to return the language name\n    :return: Full Text Language Name"
        ],
        [
            "A function to construct a hierarchical dictionary representing the different citation layers of a text\n\n    :param reffs: passage references with human-readable equivalent\n    :type reffs: [(str, str)]\n    :param citation: Main Citation\n    :type citation: Citation\n    :return: nested dictionary representing where keys represent the names of the levels and the final values represent the passage reference\n    :rtype: OrderedDict"
        ],
        [
            "Take a string of form %citation_type|passage% and format it for human\n\n    :param string: String of formation %citation_type|passage%\n    :param lang: Language to translate to\n    :return: Human Readable string\n\n    .. note :: To Do : Use i18n tools and provide real i18n"
        ],
        [
            "Annotation filtering filter\n\n    :param annotations: List of annotations\n    :type annotations: [AnnotationResource]\n    :param type_uri: URI Type on which to filter\n    :type type_uri: str\n    :param number: Number of the annotation to return\n    :type number: int\n    :return: Annotation(s) matching the request\n    :rtype: [AnnotationResource] or AnnotationResource"
        ],
        [
            "Connect to a service to see if it is a http or https server."
        ],
        [
            "Retrieves services starts check_service in a gevent pool of 100."
        ],
        [
            "Imports the given nmap result."
        ],
        [
            "Start an nmap process with the given args on the given ips."
        ],
        [
            "Scans the given hosts with nmap."
        ],
        [
            "Scans available smb services in the database for smb signing and ms17-010."
        ],
        [
            "Function to create an overview of the services.\n        Will print a list of ports found an the number of times the port was seen."
        ],
        [
            "Rename endpoint function name to avoid conflict when namespacing is set to true\n\n    :param fn_name: Name of the route function\n    :param instance: Instance bound to the function\n    :return: Name of the new namespaced function name"
        ],
        [
            "Retrieve the best matching locale using request headers\n\n        .. note:: Probably one of the thing to enhance quickly.\n\n        :rtype: str"
        ],
        [
            "Transform input according to potentially registered XSLT\n\n        .. note:: Since 1.0.0, transform takes an objectId parameter which represent the passage which is called\n\n        .. note:: Due to XSLT not being able to be used twice, we rexsltise the xml at every call of xslt\n\n        .. warning:: Until a C libxslt error is fixed ( https://bugzilla.gnome.org/show_bug.cgi?id=620102 ), \\\n        it is not possible to use strip tags in the xslt given to this application\n\n        :param work: Work object containing metadata about the xml\n        :type work: MyCapytains.resources.inventory.Text\n        :param xml: XML to transform\n        :type xml: etree._Element\n        :param objectId: Object Identifier\n        :type objectId: str\n        :param subreference: Subreference\n        :type subreference: str\n        :return: String representation of transformed resource\n        :rtype: str"
        ],
        [
            "Request the api endpoint to retrieve information about the inventory\n\n        :return: Main Collection\n        :rtype: Collection"
        ],
        [
            "Retrieve and transform a list of references.\n\n        Returns the inventory collection object with its metadata and a callback function taking a level parameter \\\n        and returning a list of strings.\n\n        :param objectId: Collection Identifier\n        :type objectId: str\n        :param subreference: Subreference from which to retrieve children\n        :type subreference: str\n        :param collection: Collection object bearing metadata\n        :type collection: Collection\n        :param export_collection: Return collection metadata\n        :type export_collection: bool\n        :return: Returns either the list of references, or the text collection object with its references as tuple\n        :rtype: (Collection, [str]) or [str]"
        ],
        [
            "Retrieve the passage identified by the parameters\n\n        :param objectId: Collection Identifier\n        :type objectId: str\n        :param subreference: Subreference of the passage\n        :type subreference: str\n        :return: An object bearing metadata and its text\n        :rtype: InteractiveTextualNode"
        ],
        [
            "Get siblings of a browsed subreference\n\n        .. note:: Since 1.0.0c, there is no more prevnext dict. Nemo uses the list of original\\\n        chunked references to retrieve next and previous, or simply relies on the resolver to get siblings\\\n        when the subreference is not found in given original chunks.\n\n        :param objectId: Id of the object\n        :param subreference: Subreference of the object\n        :param passage: Current Passage\n        :return: Previous and next references\n        :rtype: (str, str)"
        ],
        [
            "Generates a SEO friendly string for given collection\n\n        :param collection: Collection object to generate string for\n        :param parent: Current collection parent\n        :return: SEO/URL Friendly string"
        ],
        [
            "Creates a CoINS Title string from information\n\n        :param collection: Collection to create coins from\n        :param text: Text/Passage object\n        :param subreference: Subreference\n        :param lang: Locale information\n        :return: Coins HTML title value"
        ],
        [
            "Build an ancestor or descendant dict view based on selected information\n\n        :param member: Current Member to build for\n        :param collection: Collection from which we retrieved it\n        :param lang: Language to express data in\n        :return:"
        ],
        [
            "Build member list for given collection\n\n        :param collection: Collection to build dict view of for its members\n        :param lang: Language to express data in\n        :return: List of basic objects"
        ],
        [
            "Build parents list for given collection\n\n        :param collection: Collection to build dict view of for its members\n        :param lang: Language to express data in\n        :return: List of basic objects"
        ],
        [
            "Retrieve the top collections of the inventory\n\n        :param lang: Lang in which to express main data\n        :type lang: str\n        :return: Collections information and template\n        :rtype: {str: Any}"
        ],
        [
            "Collection content browsing route function\n\n        :param objectId: Collection identifier\n        :type objectId: str\n        :param lang: Lang in which to express main data\n        :type lang: str\n        :return: Template and collections contained in given collection\n        :rtype: {str: Any}"
        ],
        [
            "Text exemplar references browsing route function\n\n        :param objectId: Collection identifier\n        :type objectId: str\n        :param lang: Lang in which to express main data\n        :type lang: str\n        :return: Template and required information about text with its references"
        ],
        [
            "Provides a redirect to the first passage of given objectId\n\n        :param objectId: Collection identifier\n        :type objectId: str\n        :return: Redirection to the first passage of given text"
        ],
        [
            "Retrieve the text of the passage\n\n        :param objectId: Collection identifier\n        :type objectId: str\n        :param lang: Lang in which to express main data\n        :type lang: str\n        :param subreference: Reference identifier\n        :type subreference: str\n        :return: Template, collections metadata and Markup object representing the text\n        :rtype: {str: Any}"
        ],
        [
            "Route for specific assets.\n\n        :param filetype: Asset Type\n        :param asset: Filename of an asset\n        :return: Response"
        ],
        [
            "Merge and register assets, both as routes and dictionary\n\n        :return: None"
        ],
        [
            "Create blueprint and register rules\n\n        :return: Blueprint of the current nemo app\n        :rtype: flask.Blueprint"
        ],
        [
            "Create a view\n\n        :param name: Name of the route function to use for the view.\n        :type name: str\n        :return: Route function which makes use of Nemo context (such as menu informations)\n        :rtype: function"
        ],
        [
            "Retrieve main parent collections of a repository\n\n        :param lang: Language to retrieve information in\n        :return: Sorted collections representations"
        ],
        [
            "This function is built to provide cache keys for templates\n\n        :param endpoint: Current endpoint\n        :param kwargs: Keyword Arguments\n        :return: tuple of i18n dependant cache key and i18n ignoring cache key\n        :rtype: tuple(str)"
        ],
        [
            "Render a route template and adds information to this route.\n\n        :param template: Template name.\n        :type template: str\n        :param kwargs: dictionary of named arguments used to be passed to the template\n        :type kwargs: dict\n        :return: Http Response with rendered template\n        :rtype: flask.Response"
        ],
        [
            "Register the app using Blueprint\n\n        :return: Nemo blueprint\n        :rtype: flask.Blueprint"
        ],
        [
            "Register filters for Jinja to use\n\n       .. note::  Extends the dictionary filters of jinja_env using self._filters list"
        ],
        [
            "Register plugins in Nemo instance\n\n        - Clear routes first if asked by one plugin\n        - Clear assets if asked by one plugin and replace by the last plugin registered static_folder\n        - Register each plugin\n            - Append plugin routes to registered routes\n            - Append plugin filters to registered filters\n            - Append templates directory to given namespaces\n            - Append assets (CSS, JS, statics) to given resources \n            - Append render view (if exists) to Nemo.render stack"
        ],
        [
            "Handle a list of references depending on the text identifier using the chunker dictionary.\n\n        :param text: Text object from which comes the references\n        :type text: MyCapytains.resources.texts.api.Text\n        :param reffs: List of references to transform\n        :type reffs: References\n        :return: Transformed list of references\n        :rtype: [str]"
        ],
        [
            "Obtains the data from the pipe and appends the given tag."
        ],
        [
            "Creates the section value if it does not exists and sets the value.\n            Use write_config to actually set the value."
        ],
        [
            "This function tries to retrieve the value from the configfile\n            otherwise will return a default."
        ],
        [
            "Returns the configuration directory"
        ],
        [
            "Write the current config to disk to store them."
        ],
        [
            "Track the specified remote branch if it is not already tracked."
        ],
        [
            "Checkout, update and branch from the specified branch."
        ],
        [
            "Returns the interface name of the first not link_local and not loopback interface."
        ],
        [
            "load_targets will load the services with smb signing disabled and if ldap is enabled the services with the ldap port open."
        ],
        [
            "write_targets will write the contents of ips and ldap_strings to the targets_file."
        ],
        [
            "Starts the ntlmrelayx.py and responder processes.\n            Assumes you have these programs in your path."
        ],
        [
            "Function that gets called on each event from pyinotify."
        ],
        [
            "Watches directory for changes"
        ],
        [
            "Terminate the processes."
        ],
        [
            "This function waits for the relay and responding processes to exit.\n            Captures KeyboardInterrupt to shutdown these processes."
        ],
        [
            "Retrieve annotations from the query provider\n\n        :param targets: The CTS URN(s) to query as the target of annotations\n        :type targets: [MyCapytain.common.reference.URN], URN or None\n        :param wildcard: Wildcard specifier for how to match the URN\n        :type wildcard: str\n        :param include: URI(s) of Annotation types to include in the results\n        :type include: list(str)\n        :param exclude: URI(s) of Annotation types to include in the results\n        :type exclude: list(str)\n        :param limit: The max number of results to return (Default is None for no limit)\n        :type limit: int\n        :param start: the starting record to return (Default is 1)\n        :type start: int \n        :param expand: Flag to state whether Annotations are expanded (Default is False)\n        :type expand: bool\n    \n        :return: Tuple representing the query results. The first element\n                 The first element is the number of total Annotations found\n                 The second element is the list of Annotations\n        :rtype: (int, list(Annotation)\n\n        .. note::\n\n            Wildcard should be one of the following value\n\n            - '.' to match exact,\n            - '.%' to match exact plus lower in the hierarchy\n            - '%.' to match exact + higher in the hierarchy\n            - '-' to match in the range\n            - '%.%' to match all"
        ],
        [
            "Make breadcrumbs for a route\n\n        :param kwargs: dictionary of named arguments used to construct the view\n        :type kwargs: dict\n        :return: List of dict items the view can use to construct the link.\n        :rtype: {str: list({ \"link\": str, \"title\", str, \"args\", dict})}"
        ],
        [
            "This function obtains hosts from core and starts a nessus scan on these hosts.\n        The nessus tag is appended to the host tags."
        ],
        [
            "Retrieves the uuid of the given template name."
        ],
        [
            "Creates a scan with the given host ips\n            Returns the scan id of the created object."
        ],
        [
            "Starts the scan identified by the scan_id.s"
        ],
        [
            "Bases the comparison of the datastores on URI alone."
        ],
        [
            "Adds a tag to the list of tags and makes sure the result list contains only unique results."
        ],
        [
            "Removes a tag from this object"
        ],
        [
            "Returns the result as a dictionary, provide the include_meta flag to als show information like index and doctype."
        ],
        [
            "Route to retrieve annotations by target\n\n        :param target_urn: The CTS URN for which to retrieve annotations  \n        :type target_urn: str\n        :return: a JSON string containing count and list of resources\n        :rtype: {str: Any}"
        ],
        [
            "Returns the label for a given Enum key"
        ],
        [
            "Returns the verbose name for a given enum value"
        ],
        [
            "Returns the configured DNS servers with the use f nmcli."
        ],
        [
            "Tries to perform a zone transfer."
        ],
        [
            "Resolves the list of domains and returns the ips."
        ],
        [
            "Parses the list of ips, turns these into ranges based on the netmask given.\n        Set include_public to True to include public IP adresses."
        ],
        [
            "Creates a connection based upon the given configuration object."
        ],
        [
            "Searches the elasticsearch instance to retrieve the requested documents."
        ],
        [
            "Uses the command line arguments to fill the search function and call it."
        ],
        [
            "Returns the number of results after filtering with the given arguments."
        ],
        [
            "Uses the command line arguments to fill the count function and call it."
        ],
        [
            "Returns a generator that maps the input of the pipe to an elasticsearch object.\n            Will call id_to_object if it cannot serialize the data from json."
        ],
        [
            "Resolves an ip adres to a range object, creating it if it doesn't exists."
        ],
        [
            "Argparser option with search functionality specific for ranges."
        ],
        [
            "Searches elasticsearch for objects with the same address, protocol, port and state."
        ],
        [
            "Resolves the given id to a user object, if it doesn't exists it will be created."
        ],
        [
            "Retrieves the domains of the users from elastic."
        ],
        [
            "Returns a list that maps the input of the pipe to an elasticsearch object.\n            Will call id_to_object if it cannot serialize the data from json."
        ],
        [
            "Consumes an ET protocol tree and converts it to state.Command commands"
        ],
        [
            "Initializes the indices"
        ],
        [
            "Parse the entry into a computer object."
        ],
        [
            "Parse the file and extract the computers, import the computers that resolve into jackal."
        ],
        [
            "Parses a single entry from the domaindump"
        ],
        [
            "Parses the domain users and groups files."
        ],
        [
            "Parses ldapdomaindump files and stores hosts and users in elasticsearch."
        ],
        [
            "Make an autocomplete API request\n\n    This can be used to find cities and/or hurricanes by name\n\n    :param string query: city\n    :param string country: restrict search to a specific country. Must be a two letter country code\n    :param boolean hurricanes: whether to search for hurricanes or not\n    :param boolean cities: whether to search for cities or not\n    :param integer timeout: timeout of the api request\n    :returns: result of the autocomplete API request\n    :rtype: dict"
        ],
        [
            "Make an API request\n\n    :param string key: API key to use\n    :param list features: features to request. It must be a subset of :data:`FEATURES`\n    :param string query: query to send\n    :param integer timeout: timeout of the request\n    :returns: result of the API request\n    :rtype: dict"
        ],
        [
            "Try to convert a string to unicode using different encodings"
        ],
        [
            "Handle HTTP GET requests on an authentication endpoint.\n\n    Authentication flow begins when ``params`` has a ``login`` key with a value\n    of ``start``. For instance, ``/auth/twitter?login=start``.\n\n    :param str provider: An provider to obtain a user ID from.\n    :param str request_url: The authentication endpoint/callback.\n    :param dict params: GET parameters from the query string.\n    :param str token_secret: An app secret to encode/decode JSON web tokens.\n    :param str token_cookie: The current JSON web token, if available.\n    :return: A dict containing any of the following possible keys:\n\n        ``status``: an HTTP status code the server should sent\n\n        ``redirect``: where the client should be directed to continue the flow\n\n        ``set_token_cookie``: contains a JSON web token and should be stored by\n        the client and passed in the next call.\n\n        ``provider_user_id``: the user ID from the login provider\n\n        ``provider_user_name``: the user name from the login provider"
        ],
        [
            "Method to call to get a serializable object for json.dump or jsonify based on the target\n\n        :return: dict"
        ],
        [
            "Read the contents of the Annotation Resource\n\n        :return: the contents of the resource\n        :rtype: str or bytes or flask.response"
        ],
        [
            "index all triples into indexes and return their mappings"
        ],
        [
            "recover triples from mapping."
        ],
        [
            "Transform triple index into a 1-D numpy array."
        ],
        [
            "Packs a list of triple indexes into a 2D numpy array."
        ],
        [
            "If entity pairs in a relation is as close as another relations, only keep one relation of such set."
        ],
        [
            "Remove direct links in the training sets."
        ],
        [
            "Uses a union find to find segment."
        ],
        [
            "Create a usable data structure for serializing."
        ],
        [
            "Logs an operation done on an entity, possibly with other arguments"
        ],
        [
            "Logs a new state of an entity"
        ],
        [
            "Logs an update done on an entity"
        ],
        [
            "Logs an error"
        ],
        [
            "Decorator that provides a dictionary cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.DICT) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side dictionary cursor"
        ],
        [
            "Decorator that provides a cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor() coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side cursor"
        ],
        [
            "Decorator that provides a namedtuple cursor to the calling function\n\n    Adds the cursor as the second argument to the calling functions\n\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.NAMEDTUPLE) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side namedtuple cursor"
        ],
        [
            "Provides a transacted cursor which will run in autocommit=false mode\n\n    For any exception the transaction will be rolled back.\n    Requires that the function being decorated is an instance of a class or object\n    that yields a cursor from a get_cursor(cursor_type=CursorType.NAMEDTUPLE) coroutine or provides such an object\n    as the first argument in its signature\n\n    Yields:\n        A client-side transacted named cursor"
        ],
        [
            "gives the number of records in the table\n\n        Args:\n            table: a string indicating the name of the table\n\n        Returns:\n            an integer indicating the number of records in the table"
        ],
        [
            "Creates an insert statement with only chosen fields\n\n        Args:\n            table: a string indicating the name of the table\n            values: a dict of fields and values to be inserted\n\n        Returns:\n            A 'Record' object with table columns as properties"
        ],
        [
            "Creates an update query with only chosen fields\n        Supports only a single field where clause\n\n        Args:\n            table: a string indicating the name of the table\n            values: a dict of fields and values to be inserted\n            where_keys: list of dictionary\n            example of where keys: [{'name':('>', 'cip'),'url':('=', 'cip.com'},{'type':{'<=', 'manufacturer'}}]\n            where_clause will look like ((name>%s and url=%s) or (type <= %s))\n            items within each dictionary get 'AND'-ed and dictionaries themselves get 'OR'-ed\n\n        Returns:\n            an integer indicating count of rows deleted"
        ],
        [
            "Creates a delete query with where keys\n        Supports multiple where clause with and or or both\n\n        Args:\n            table: a string indicating the name of the table\n            where_keys: list of dictionary\n            example of where keys: [{'name':('>', 'cip'),'url':('=', 'cip.com'},{'type':{'<=', 'manufacturer'}}]\n            where_clause will look like ((name>%s and url=%s) or (type <= %s))\n            items within each dictionary get 'AND'-ed and dictionaries themselves get 'OR'-ed\n\n        Returns:\n            an integer indicating count of rows deleted"
        ],
        [
            "Creates a select query for selective columns with where keys\n        Supports multiple where claus with and or or both\n\n        Args:\n            table: a string indicating the name of the table\n            order_by: a string indicating column name to order the results on\n            columns: list of columns to select from\n            where_keys: list of dictionary\n            limit: the limit on the number of results\n            offset: offset on the results\n\n            example of where keys: [{'name':('>', 'cip'),'url':('=', 'cip.com'},{'type':{'<=', 'manufacturer'}}]\n            where_clause will look like ((name>%s and url=%s) or (type <= %s))\n            items within each dictionary get 'AND'-ed and across dictionaries get 'OR'-ed\n\n        Returns:\n            A list of 'Record' object with table columns as properties"
        ],
        [
            "Run a raw sql query\n\n        Args:\n            query : query string to execute\n            values : tuple of values to be used with the query\n\n        Returns:\n            result of query as list of named tuple"
        ],
        [
            "This method is used to append content of the `text`\n    argument to the `out` argument.\n\n    Depending on how many lines in the text, a\n    padding can be added to all lines except the first\n    one.\n\n    Concatenation result is appended to the `out` argument."
        ],
        [
            "This function should return unicode representation of the value"
        ],
        [
            "Helper function to traverse an element tree rooted at element, yielding nodes matching the query."
        ],
        [
            "Given a simplified XPath query string, returns an array of normalized query parts."
        ],
        [
            "Inserts a new element as a child of this element, before the specified index or sibling.\n\n        :param before: An :class:`XmlElement` or a numeric index to insert the new node before\n        :param name: The tag name to add\n        :param attrs: Attributes for the new tag\n        :param data: CDATA for the new tag\n        :returns: The newly-created element\n        :rtype: :class:`XmlElement`"
        ],
        [
            "A generator yielding children of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :param reverse: If ``True``, children will be yielded in reverse declaration order"
        ],
        [
            "Helper function to determine if this node matches the given predicate."
        ],
        [
            "Returns a canonical path to this element, relative to the root node.\n\n        :param include_root: If ``True``, include the root node in the path. Defaults to ``False``."
        ],
        [
            "Recursively find any descendants of this node with the given tag name. If a tag name is omitted, this will\n        yield every descendant node.\n\n        :param name: If specified, only consider elements with this tag name\n        :returns: A generator yielding descendants of this node"
        ],
        [
            "Returns the last child of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`"
        ],
        [
            "Yields all parents of this element, back to the root element.\n\n        :param name: If specified, only consider elements with this tag name"
        ],
        [
            "Returns the next sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`"
        ],
        [
            "Returns the previous sibling of this node.\n\n        :param name: If specified, only consider elements with this tag name\n        :rtype: :class:`XmlElement`"
        ],
        [
            "Parses the HTML table into a list of dictionaries, each of which\n        represents a single observation."
        ],
        [
            "Calculates cache key based on `args` and `kwargs`.\n    `args` and `kwargs` must be instances of hashable types."
        ],
        [
            "Cache result of function execution into the django cache backend.\n    Calculate cache key based on `prefix`, `args` and `kwargs` of the function.\n    For using like object method set `method=True`."
        ],
        [
            "Wrapper around Django's ORM `get` functionality.\n    Wrap anything that raises ObjectDoesNotExist exception\n    and provide the default value if necessary.\n    `default` by default is None. `default` can be any callable,\n    if it is callable it will be called when ObjectDoesNotExist\n    exception will be raised."
        ],
        [
            "Turn column inputs from user into list of simple numbers.\n\n    Inputs can be:\n\n      - individual number: 1\n      - range: 1-3\n      - comma separated list: 1,2,3,4-6"
        ],
        [
            "Return only the part of the row which should be printed."
        ],
        [
            "Writes a single observation to the output file.\n\n        If the ``observation_data`` parameter is a dictionary, it is\n        converted to a list to keep a consisted field order (as described\n        in format specification). Otherwise it is assumed that the data\n        is a raw record ready to be written to file.\n\n        :param observation_data: a single observation as a dictionary or list"
        ],
        [
            "Takes a dictionary of observation data and converts it to a list\n        of fields according to AAVSO visual format specification.\n\n        :param cls: current class\n        :param observation_data: a single observation as a dictionary"
        ],
        [
            "Converts a raw input record to a dictionary of observation data.\n\n        :param cls: current class\n        :param row: a single observation as a list or tuple"
        ],
        [
            "Get the name of the view function used to prevent having to set the tag\n    manually for every endpoint"
        ],
        [
            "Downloads all variable star observations by a given observer.\n\n    Performs a series of HTTP requests to AAVSO's WebObs search and\n    downloads the results page by page. Each page is then passed to\n    :py:class:`~pyaavso.parsers.webobs.WebObsResultsParser` and parse results\n    are added to the final observation list."
        ],
        [
            "Generates likely unique image path using md5 hashes"
        ],
        [
            "Extract, transform, and load metadata from Lander-based projects.\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n    github_api_token : `str`\n        A GitHub personal API token. See the `GitHub personal access token\n        guide`_.\n    ltd_product_data : `dict`\n        Contents of ``metadata.yaml``, obtained via `download_metadata_yaml`.\n        Data for this technote from the LTD Keeper API\n        (``GET /products/<slug>``). Usually obtained via\n        `lsstprojectmeta.ltd.get_ltd_product`.\n    mongo_collection : `motor.motor_asyncio.AsyncIOMotorCollection`, optional\n        MongoDB collection. This should be the common MongoDB collection for\n        LSST projectmeta JSON-LD records. If provided, ths JSON-LD is upserted\n        into the MongoDB collection.\n\n    Returns\n    -------\n    metadata : `dict`\n        JSON-LD-formatted dictionary.\n\n    Raises\n    ------\n    NotLanderPageError\n        Raised when the LTD product cannot be interpreted as a Lander page\n        because the ``/metadata.jsonld`` file is absent. This implies that\n        the LTD product *could* be of a different format.\n\n    .. `GitHub personal access token guide`: https://ls.st/41d"
        ],
        [
            "Upsert the technote resource into the projectmeta MongoDB collection.\n\n    Parameters\n    ----------\n    collection : `motor.motor_asyncio.AsyncIOMotorCollection`\n        The MongoDB collection.\n    jsonld : `dict`\n        The JSON-LD document that represents the document resource."
        ],
        [
            "Converts a Open511 JSON document to XML.\n\n    lang: the appropriate language code\n\n    Takes a dict deserialized from JSON, returns an lxml Element.\n\n    Accepts only the full root-level JSON object from an Open511 response."
        ],
        [
            "Converts a Open511 JSON fragment to XML.\n\n    Takes a dict deserialized from JSON, returns an lxml Element.\n\n    This won't provide a conforming document if you pass in a full JSON document;\n    it's for translating little fragments, and is mostly used internally."
        ],
        [
            "Given a dict deserialized from a GeoJSON object, returns an lxml Element\n    of the corresponding GML geometry."
        ],
        [
            "Transform a GEOS or OGR geometry object into an lxml Element\n    for the GML geometry."
        ],
        [
            "Delete latex comments from TeX source.\n\n    Parameters\n    ----------\n    tex_source : str\n        TeX source content.\n\n    Returns\n    -------\n    tex_source : str\n        TeX source without comments."
        ],
        [
            "r\"\"\"Replace macros in the TeX source with their content.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source content.\n    macros : `dict`\n        Keys are macro names (including leading ``\\``) and values are the\n        content (as `str`) of the macros. See\n        `lsstprojectmeta.tex.scraper.get_macros`.\n\n    Returns\n    -------\n    tex_source : `str`\n        TeX source with known macros replaced.\n\n    Notes\n    -----\n    Macros with arguments are not supported.\n\n    Examples\n    --------\n    >>> macros = {r'\\handle': 'LDM-nnn'}\n    >>> sample = r'This is document \\handle.'\n    >>> replace_macros(sample, macros)\n    'This is document LDM-nnn.'\n\n    Any trailing slash after the macro command is also replaced by this\n    function.\n\n    >>> macros = {r'\\product': 'Data Management'}\n    >>> sample = r'\\title    [Test Plan]  { \\product\\ Test Plan}'\n    >>> replace_macros(sample, macros)\n    '\\\\title    [Test Plan]  { Data Management Test Plan}'"
        ],
        [
            "Ensures that the provided document is an lxml Element or json dict."
        ],
        [
            "Convert an Open511 document between formats.\n    input_doc - either an lxml open511 Element or a deserialized JSON dict\n    output_format - short string name of a valid output format, as listed above"
        ],
        [
            "Construct an `LsstLatexDoc` instance by reading and parsing the\n        LaTeX source.\n\n        Parameters\n        ----------\n        root_tex_path : `str`\n            Path to the LaTeX source on the filesystem. For multi-file LaTeX\n            projects this should be the path to the root document.\n\n        Notes\n        -----\n        This method implements the following pipeline:\n\n        1. `lsstprojectmeta.tex.normalizer.read_tex_file`\n        2. `lsstprojectmeta.tex.scraper.get_macros`\n        3. `lsstprojectmeta.tex.normalizer.replace_macros`\n\n        Thus ``input`` and ``includes`` are resolved along with simple macros."
        ],
        [
            "Get the document content in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content."
        ],
        [
            "Get the document title in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content or `None` if the title is not available in\n            the document."
        ],
        [
            "Get the document short title in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content or `None` if the short title is not available in\n            the document."
        ],
        [
            "Get the document abstract in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `str`\n            Converted content or `None` if the title is not available in\n            the document."
        ],
        [
            "Get the document authors in the specified markup format.\n\n        Parameters\n        ----------\n        format : `str`, optional\n            Output format (such as ``'html5'`` or ``'plain'``).\n        deparagraph : `bool`, optional\n            Remove the paragraph tags from single paragraph content.\n        mathjax : `bool`, optional\n            Allow pandoc to use MathJax math markup.\n        smart : `True`, optional\n            Allow pandoc to create \"smart\" unicode punctuation.\n        extra_args : `list`, optional\n            Additional command line flags to pass to Pandoc. See\n            `lsstprojectmeta.pandoc.convert.convert_text`.\n\n        Returns\n        -------\n        output_text : `list` of `str`\n            Sequence of author names in the specified output markup format."
        ],
        [
            "Parse documentclass options.\n\n        Sets the the ``_document_options`` attribute."
        ],
        [
            "Parse the title from TeX source.\n\n        Sets these attributes:\n\n        - ``_title``\n        - ``_short_title``"
        ],
        [
            "Parse the document handle.\n\n        Sets the ``_series``, ``_serial``, and ``_handle`` attributes."
        ],
        [
            "r\"\"\"Parse the author from TeX source.\n\n        Sets the ``_authors`` attribute.\n\n        Goal is to parse::\n\n           \\author{\n           A.~Author,\n           B.~Author,\n           and\n           C.~Author}\n\n        Into::\n\n           ['A. Author', 'B. Author', 'C. Author']"
        ],
        [
            "Parse the abstract from the TeX source.\n\n        Sets the ``_abstract`` attribute."
        ],
        [
            "Process a LaTeX snippet of content for better transformation\n        with pandoc.\n\n        Currently runs the CitationLinker to convert BibTeX citations to\n        href links."
        ],
        [
            "r\"\"\"Load the BibTeX bibliography referenced by the document.\n\n        This method triggered by the `bib_db` attribute and populates the\n        `_bib_db` private attribute.\n\n        The ``\\bibliography`` command is parsed to identify the bibliographies\n        referenced by the document."
        ],
        [
            "r\"\"\"Parse the ``\\date`` command, falling back to getting the\n        most recent Git commit date and the current datetime.\n\n        Result is available from the `revision_datetime` attribute."
        ],
        [
            "Create a JSON-LD representation of this LSST LaTeX document.\n\n        Parameters\n        ----------\n        url : `str`, optional\n            URL where this document is published to the web. Prefer\n            the LSST the Docs URL if possible.\n            Example: ``'https://ldm-151.lsst.io'``.\n        code_url : `str`, optional\n            Path the the document's repository, typically on GitHub.\n            Example: ``'https://github.com/lsst/LDM-151'``.\n        ci_url : `str`, optional\n            Path to the continuous integration service dashboard for this\n            document's repository.\n            Example: ``'https://travis-ci.org/lsst/LDM-151'``.\n        readme_url : `str`, optional\n            URL to the document repository's README file. Example:\n            ``https://raw.githubusercontent.com/lsst/LDM-151/master/README.rst``.\n        license_id : `str`, optional\n            License identifier, if known. The identifier should be from the\n            listing at https://spdx.org/licenses/. Example: ``CC-BY-4.0``.\n\n        Returns\n        -------\n        jsonld : `dict`\n            JSON-LD-formatted dictionary."
        ],
        [
            "Renames an existing database."
        ],
        [
            "Returns True if database server is running, False otherwise."
        ],
        [
            "Saves the state of a database to a file.\n\n        Parameters\n        ----------\n        name: str\n            the database to be backed up.\n        filename: str\n            path to a file where database backup will be written."
        ],
        [
            "Loads state of a backup file to a database.\n\n        Note\n        ----\n        If database name does not exist, it will be created.\n\n        Parameters\n        ----------\n        name: str\n            the database to which backup will be restored.\n        filename: str\n            path to a file contain a postgres database backup."
        ],
        [
            "Provides a connection string for database.\n\n        Parameters\n        ----------\n        name: str, optional\n            an override database name for the connection string.\n\n        Returns\n        -------\n        str: the connection string (e.g. 'dbname=db1 user=user1 host=localhost port=5432')"
        ],
        [
            "Provides a connection string for database as a sqlalchemy compatible URL.\n\n        NB - this doesn't include special arguments related to SSL connectivity (which are outside the scope\n        of the connection URL format).\n\n        Parameters\n        ----------\n        name: str, optional\n            an override database name for the connection string.\n\n        Returns\n        -------\n        str: the connection URL (e.g. postgresql://user1@localhost:5432/db1)"
        ],
        [
            "Connects the database client shell to the database.\n\n        Parameters\n        ----------\n        expect_module: str\n            the database to which backup will be restored."
        ],
        [
            "Returns settings from the server."
        ],
        [
            "Say something in the morning"
        ],
        [
            "Say something in the afternoon"
        ],
        [
            "Say something in the evening"
        ],
        [
            "Command line entrypoint to reduce technote metadata."
        ],
        [
            "Run a pipeline to process extract, transform, and load metadata for\n    multiple LSST the Docs-hosted projects\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n    product_urls : `list` of `str`\n        List of LSST the Docs product URLs.\n    github_api_token : `str`\n        A GitHub personal API token. See the `GitHub personal access token\n        guide`_.\n    mongo_collection : `motor.motor_asyncio.AsyncIOMotorCollection`, optional\n        MongoDB collection. This should be the common MongoDB collection for\n        LSST projectmeta JSON-LD records."
        ],
        [
            "Ingest any kind of LSST document hosted on LSST the Docs from its\n    source.\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n    github_api_token : `str`\n        A GitHub personal API token. See the `GitHub personal access token\n        guide`_.\n    ltd_product_url : `str`\n        URL of the technote's product resource in the LTD Keeper API.\n    mongo_collection : `motor.motor_asyncio.AsyncIOMotorCollection`, optional\n        MongoDB collection. This should be the common MongoDB collection for\n        LSST projectmeta JSON-LD records. If provided, ths JSON-LD is upserted\n        into the MongoDB collection.\n\n    Returns\n    -------\n    metadata : `dict`\n        JSON-LD-formatted dictionary.\n\n    .. `GitHub personal access token guide`: https://ls.st/41d"
        ],
        [
            "Allows a decorator to be called with or without keyword arguments."
        ],
        [
            "Create a GitHub token for an integration installation.\n\n    Parameters\n    ----------\n    installation_id : `int`\n        Installation ID. This is available in the URL of the integration's\n        **installation** ID.\n    integration_jwt : `bytes`\n        The integration's JSON Web Token (JWT). You can create this with\n        `create_jwt`.\n\n    Returns\n    -------\n    token_obj : `dict`\n        GitHub token object. Includes the fields:\n\n        - ``token``: the token string itself.\n        - ``expires_at``: date time string when the token expires.\n\n    Example\n    -------\n    The typical workflow for authenticating to an integration installation is:\n\n    .. code-block:: python\n\n       from dochubadapter.github import auth\n       jwt = auth.create_jwt(integration_id, private_key_path)\n       token_obj = auth.get_installation_token(installation_id, jwt)\n       print(token_obj['token'])\n\n    Notes\n    -----\n    See\n    https://developer.github.com/early-access/integrations/authentication/#as-an-installation\n    for more information"
        ],
        [
            "Create a JSON Web Token to authenticate a GitHub Integration or\n    installation.\n\n    Parameters\n    ----------\n    integration_id : `int`\n        Integration ID. This is available from the GitHub integration's\n        homepage.\n    private_key_path : `str`\n        Path to the integration's private key (a ``.pem`` file).\n\n    Returns\n    -------\n    jwt : `bytes`\n        JSON Web Token that is good for 9 minutes.\n\n    Notes\n    -----\n    The JWT is encoded with the RS256 algorithm. It includes a payload with\n    fields:\n\n    - ``'iat'``: The current time, as an `int` timestamp.\n    - ``'exp'``: Expiration time, as an `int timestamp. The expiration\n      time is set of 9 minutes in the future (maximum allowance is 10 minutes).\n    - ``'iss'``: The integration ID (`int`).\n\n    For more information, see\n    https://developer.github.com/early-access/integrations/authentication/."
        ],
        [
            "r\"\"\"Get all macro definitions from TeX source, supporting multiple\n    declaration patterns.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source content.\n\n    Returns\n    -------\n    macros : `dict`\n        Keys are macro names (including leading ``\\``) and values are the\n        content (as `str`) of the macros.\n\n    Notes\n    -----\n    This function uses the following function to scrape macros of different\n    types:\n\n    - `get_def_macros`\n    - `get_newcommand_macros`\n\n    This macro scraping has the following caveats:\n\n    - Macro definition (including content) must all occur on one line.\n    - Macros with arguments are not supported."
        ],
        [
            "r\"\"\"Get all ``\\def`` macro definition from TeX source.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source content.\n\n    Returns\n    -------\n    macros : `dict`\n        Keys are macro names (including leading ``\\``) and values are the\n        content (as `str`) of the macros.\n\n    Notes\n    -----\n    ``\\def`` macros with arguments are not supported."
        ],
        [
            "r\"\"\"Get all ``\\newcommand`` macro definition from TeX source.\n\n    Parameters\n    ----------\n    tex_source : `str`\n        TeX source content.\n\n    Returns\n    -------\n    macros : `dict`\n        Keys are macro names (including leading ``\\``) and values are the\n        content (as `str`) of the macros.\n\n    Notes\n    -----\n    ``\\newcommand`` macros with arguments are not supported."
        ],
        [
            "Try to load and return a module\n\n    Will add DIRECTORY_NAME to sys.path and tries to import MODULE_NAME.\n\n    For example:\n    load(\"~/.yaz\", \"yaz_extension\")"
        ],
        [
            "Makes a naive datetime.datetime in a given time zone aware."
        ],
        [
            "Makes an aware datetime.datetime naive in a given time zone."
        ],
        [
            "Converts a datetime to the timezone of this Schedule."
        ],
        [
            "Returns the next Period this event is in effect, or None if the event\n        has no remaining periods."
        ],
        [
            "Returns an iterator of Period tuples for every day this event is in effect, between range_start\n        and range_end."
        ],
        [
            "Returns an iterator of Period tuples for continuous stretches of time during\n        which this event is in effect, between range_start and range_end."
        ],
        [
            "Does this schedule include the provided time?\n        query_date and query_time are date and time objects, interpreted\n        in this schedule's timezone"
        ],
        [
            "Returns an iterator of Period tuples for every day this schedule is in effect, between range_start\n        and range_end."
        ],
        [
            "A Period tuple representing the daily start and end time."
        ],
        [
            "A set of integers representing the weekdays the schedule recurs on,\n        with Monday = 0 and Sunday = 6."
        ],
        [
            "A context manager that creates a temporary database.\n\n    Useful for automated tests.\n\n    Parameters\n    ----------\n    db: object\n        a preconfigured DB object\n    name: str, optional\n        name of the database to be created. (default: globally unique name)"
        ],
        [
            "Asynchronously request a URL and get the encoded text content of the\n    body.\n\n    Parameters\n    ----------\n    url : `str`\n        URL to download.\n    session : `aiohttp.ClientSession`\n        An open aiohttp session.\n\n    Returns\n    -------\n    content : `str`\n        Content downloaded from the URL."
        ],
        [
            "Asynchronously download a set of lsst-texmf BibTeX bibliographies from\n    GitHub.\n\n    Parameters\n    ----------\n    bibtex_names : sequence of `str`\n        Names of lsst-texmf BibTeX files to download. For example:\n\n        .. code-block:: python\n\n           ['lsst', 'lsst-dm', 'refs', 'books', 'refs_ads']\n\n    Returns\n    -------\n    bibtexs : `list` of `str`\n        List of BibTeX file content, in the same order as ``bibtex_names``."
        ],
        [
            "Get content of lsst-texmf bibliographies.\n\n    BibTeX content is downloaded from GitHub (``master`` branch of\n    https://github.com/lsst/lsst-texmf or retrieved from an in-memory cache.\n\n    Parameters\n    ----------\n    bibtex_filenames : sequence of `str`, optional\n        List of lsst-texmf BibTeX files to retrieve. These can be the filenames\n        of lsst-bibtex files (for example, ``['lsst.bib', 'lsst-dm.bib']``)\n        or names without an extension (``['lsst', 'lsst-dm']``). The default\n        (recommended) is to get *all* lsst-texmf bibliographies:\n\n        .. code-block:: python\n\n           ['lsst', 'lsst-dm', 'refs', 'books', 'refs_ads']\n\n    Returns\n    -------\n    bibtex : `dict`\n        Dictionary with keys that are bibtex file names (such as ``'lsst'``,\n        ``'lsst-dm'``). Values are the corresponding bibtex file content\n        (`str`)."
        ],
        [
            "Make a pybtex BibliographyData instance from standard lsst-texmf\n    bibliography files and user-supplied bibtex content.\n\n    Parameters\n    ----------\n    lsst_bib_names : sequence of `str`, optional\n        Names of lsst-texmf BibTeX files to include. For example:\n\n        .. code-block:: python\n\n           ['lsst', 'lsst-dm', 'refs', 'books', 'refs_ads']\n\n        Default is `None`, which includes all lsst-texmf bibtex files.\n\n    bibtex : `str`\n        BibTeX source content not included in lsst-texmf. This can be content\n        from a import ``local.bib`` file.\n\n    Returns\n    -------\n    bibliography : `pybtex.database.BibliographyData`\n        A pybtex bibliography database that includes all given sources:\n        lsst-texmf bibliographies and ``bibtex``."
        ],
        [
            "Get a usable URL from a pybtex entry.\n\n    Parameters\n    ----------\n    entry : `pybtex.database.Entry`\n        A pybtex bibliography entry.\n\n    Returns\n    -------\n    url : `str`\n        Best available URL from the ``entry``.\n\n    Raises\n    ------\n    NoEntryUrlError\n        Raised when no URL can be made from the bibliography entry.\n\n    Notes\n    -----\n    The order of priority is:\n\n    1. ``url`` field\n    2. ``ls.st`` URL from the handle for ``@docushare`` entries.\n    3. ``adsurl``\n    4. DOI"
        ],
        [
            "Get and format author-year text from a pybtex entry to emulate\n    natbib citations.\n\n    Parameters\n    ----------\n    entry : `pybtex.database.Entry`\n        A pybtex bibliography entry.\n    parens : `bool`, optional\n        Whether to add parentheses around the year. Default is `False`.\n\n    Returns\n    -------\n    authoryear : `str`\n        The author-year citation text."
        ],
        [
            "Extract, transform, and load Sphinx-based technote metadata.\n\n    Parameters\n    ----------\n    session : `aiohttp.ClientSession`\n        Your application's aiohttp client session.\n        See http://aiohttp.readthedocs.io/en/stable/client.html.\n    github_api_token : `str`\n        A GitHub personal API token. See the `GitHub personal access token\n        guide`_.\n    ltd_product_data : `dict`\n        Contents of ``metadata.yaml``, obtained via `download_metadata_yaml`.\n        Data for this technote from the LTD Keeper API\n        (``GET /products/<slug>``). Usually obtained via\n        `lsstprojectmeta.ltd.get_ltd_product`.\n    mongo_collection : `motor.motor_asyncio.AsyncIOMotorCollection`, optional\n        MongoDB collection. This should be the common MongoDB collection for\n        LSST projectmeta JSON-LD records. If provided, ths JSON-LD is upserted\n        into the MongoDB collection.\n\n    Returns\n    -------\n    metadata : `dict`\n        JSON-LD-formatted dictionary.\n\n    Raises\n    ------\n    NotSphinxTechnoteError\n        Raised when the LTD product cannot be interpreted as a Sphinx-based\n        technote project because it's missing a metadata.yaml file in its\n        GitHub repository. This implies that the LTD product *could* be of a\n        different format.\n\n    .. `GitHub personal access token guide`: https://ls.st/41d"
        ],
        [
            "Reduce a technote project's metadata from multiple sources into a\n    single JSON-LD resource.\n\n    Parameters\n    ----------\n    github_url : `str`\n        URL of the technote's GitHub repository.\n    metadata : `dict`\n        The parsed contents of ``metadata.yaml`` found in a technote's\n        repository.\n    github_data : `dict`\n        The contents of the ``technote_repo`` GitHub GraphQL API query.\n    ltd_product_data : `dict`\n        JSON dataset for the technote corresponding to the\n        ``/products/<product>`` of LTD Keeper.\n\n    Returns\n    -------\n    metadata : `dict`\n        JSON-LD-formatted dictionary.\n\n    .. `GitHub personal access token guide`: https://ls.st/41d"
        ],
        [
            "Download the metadata.yaml file from a technote's GitHub repository."
        ],
        [
            "Return the timezone. If none is set use system timezone"
        ],
        [
            "Convert any timestamp into a datetime and save as _time"
        ],
        [
            "Return a dict that represents the DayOneEntry"
        ],
        [
            "Saves a DayOneEntry as a plist"
        ],
        [
            "Create and return full file path for DayOne entry"
        ],
        [
            "Combine many files into a single file on disk.  Defaults to using the 'time' dimension."
        ],
        [
            "The entry point for a yaz script\n\n    This will almost always be called from a python script in\n    the following manner:\n\n        if __name__ == \"__main__\":\n            yaz.main()\n\n    This function will perform the following steps:\n\n    1. It will load any additional python code from\n       the yaz_extension python module located in the\n       ~/.yaz directory when LOAD_YAZ_EXTENSION is True\n       and the yaz_extension module exists\n\n    2. It collects all yaz tasks and plugins.  When WHITE_LIST\n       is a non-empty list, only the tasks and plugins located\n       therein will be considered\n\n    3. It will parse arguments from ARGV, or the command line\n       when ARGV is not given, resulting in a yaz task or a parser\n       help message.\n\n    4. When a suitable task is found, this task is executed.  In\n       case of a task which is part of a plugin, i.e. class, then\n       this plugin is initialized, possibly resulting in other\n       plugins to also be initialized if there are marked as\n       `@yaz.dependency`."
        ],
        [
            "Returns a tree of Task instances\n\n    The tree is comprised of dictionaries containing strings for\n    keys and either dictionaries or Task instances for values.\n\n    When WHITE_LIST is given, only the tasks and plugins in this\n    list will become part of the task tree.  The WHITE_LIST may\n    contain either strings, corresponding to the task of plugin\n    __qualname__, or, preferable, the WHITE_LIST contains\n    links to the task function or plugin class instead."
        ],
        [
            "Declare a function or method to be a Yaz task\n\n    @yaz.task\n    def talk(message: str = \"Hello World!\"):\n        return message\n\n    Or... group multiple tasks together\n\n    class Tools(yaz.Plugin):\n        @yaz.task\n        def say(self, message: str = \"Hello World!\"):\n            return message\n\n        @yaz.task(option__choices=[\"A\", \"B\", \"C\"])\n        def choose(self, option: str = \"A\"):\n            return option"
        ],
        [
            "Returns a list of parameters"
        ],
        [
            "Returns the configuration for KEY"
        ],
        [
            "Returns an instance of a fully initialized plugin class\n\n    Every plugin class is kept in a plugin cache, effectively making\n    every plugin into a singleton object.\n\n    When a plugin has a yaz.dependency decorator, it will be called\n    as well, before the instance is returned."
        ],
        [
            "Convert an Open511 XML document or document fragment to JSON.\n\n    Takes an lxml Element object. Returns a dict ready to be JSON-serialized."
        ],
        [
            "Given an lxml Element of a GML geometry, returns a dict in GeoJSON format."
        ],
        [
            "Translates a deprecated GML 2.0 geometry to GeoJSON"
        ],
        [
            "Panflute filter function that converts content wrapped in a Para to\n    Plain.\n\n    Use this filter with pandoc as::\n\n        pandoc [..] --filter=lsstprojectmeta-deparagraph\n\n    Only lone paragraphs are affected. Para elements with siblings (like a\n    second Para) are left unaffected.\n\n    This filter is useful for processing strings like titles or author names so\n    that the output isn't wrapped in paragraph tags. For example, without\n    this filter, pandoc converts a string ``\"The title\"`` to\n    ``<p>The title</p>`` in HTML. These ``<p>`` tags aren't useful if you\n    intend to put the title text in ``<h1>`` tags using your own templating\n    system."
        ],
        [
            "Recursively generate of all the subclasses of class cls."
        ],
        [
            "List unique elements, preserving order. Remember only the element just seen."
        ],
        [
            "Returns a masked array with anything outside of values masked.\n    The minv and maxv parameters take precendence over any dict values.\n    The valid_range attribute takes precendence over the valid_min and\n    valid_max attributes."
        ],
        [
            "If input object is an ndarray it will be converted into a list"
        ],
        [
            "If input object is an ndarray it will be converted into a dict\n        holding dtype, shape and the data, base64 encoded."
        ],
        [
            "leftSibling\n        previousSibling\n        leftSib\n        prevSib\n        lsib\n        psib\n        \n        have the same parent,and on the left"
        ],
        [
            "rightSibling\n        nextSibling\n        rightSib\n        nextSib\n        rsib\n        nsib\n        \n        have the same parent,and on the right"
        ],
        [
            "leftCousin\n        previousCousin\n        leftCin\n        prevCin\n        lcin\n        pcin\n        \n        parents are neighbors,and on the left"
        ],
        [
            "rightCousin\n        nextCousin\n        rightCin\n        nextCin\n        rcin\n        ncin\n        \n        parents are neighbors,and on the right"
        ],
        [
            "_creat_child_desc\n            update depth,parent_breadth_path,parent_path,sib_seq,path,lsib_path,rsib_path,lcin_path,rcin_path"
        ],
        [
            "_upgrade_breadth_info\n            update breadth, breadth_path, and add desc to desc_level"
        ],
        [
            "Parse command content from the LaTeX source.\n\n        Parameters\n        ----------\n        source : `str`\n            The full source of the tex document.\n\n        Yields\n        ------\n        parsed_command : `ParsedCommand`\n            Yields parsed commands instances for each occurence of the command\n            in the source."
        ],
        [
            "Parse a single command.\n\n        Parameters\n        ----------\n        source : `str`\n            The full source of the tex document.\n        start_index : `int`\n            Character index in ``source`` where the command begins.\n\n        Returns\n        -------\n        parsed_command : `ParsedCommand`\n            The parsed command from the source at the given index."
        ],
        [
            "r\"\"\"Attempt to parse a single token on the first line of this source.\n\n        This method is used for parsing whitespace-delimited arguments, like\n        ``\\input file``. The source should ideally contain `` file`` along\n        with a newline character.\n\n        >>> source = 'Line 1\\n' r'\\input test.tex' '\\nLine 2'\n        >>> LatexCommand._parse_whitespace_argument(source, 'input')\n        'test.tex'\n\n        Bracket delimited arguments (``\\input{test.tex}``) are handled in\n        the normal logic of `_parse_command`."
        ],
        [
            "Returns a list of TMDDEventConverter elements.\n\n        doc is an XML Element containing one or more <FEU> events"
        ],
        [
            "Mostly ripped from nc3tonc4 in netCDF4-python.\n        Added ability to skip dimension and variables.\n        Removed all of the unpacking logic for shorts."
        ],
        [
            "Returns a Pandas DataFrame of the data.\n        This always returns positive down depths"
        ],
        [
            "Load a pre-made query.\n\n        These queries are distributed with lsstprojectmeta. See\n        :file:`lsstrojectmeta/data/githubv4/README.rst` inside the\n        package repository for details on available queries.\n\n        Parameters\n        ----------\n        query_name : `str`\n            Name of the query, such as ``'technote_repo'``.\n\n        Returns\n        -------\n        github_query : `GitHubQuery\n            A GitHub query or mutation object that you can pass to\n            `github_request` to execute the request itself."
        ],
        [
            "Obtain the timestamp for the most recent commit to a given file in a\n    Git repository.\n\n    Parameters\n    ----------\n    filepath : `str`\n        Absolute or repository-relative path for a file.\n    repo_path : `str`, optional\n        Path to the Git repository. Leave as `None` to use the current working\n        directory or if a ``repo`` argument is provided.\n    repo : `git.Repo`, optional\n        A `git.Repo` instance.\n\n    Returns\n    -------\n    commit_timestamp : `datetime.datetime`\n        The datetime of the most recent commit to the given file.\n\n    Raises\n    ------\n    IOError\n        Raised if the ``filepath`` does not exist in the Git repository."
        ],
        [
            "Get the datetime for the most recent commit to a project that\n    affected certain types of content.\n\n    Parameters\n    ----------\n    extensions : sequence of 'str'\n        Extensions of files to consider in getting the most recent commit\n        date. For example, ``('rst', 'svg', 'png')`` are content extensions\n        for a Sphinx project. **Extension comparision is case sensitive.** add\n        uppercase variants to match uppercase extensions.\n    acceptance_callback : callable\n        Callable function whose sole argument is a file path, and returns\n        `True` or `False` depending on whether the file's commit date should\n        be considered or not. This callback is only run on files that are\n        included by ``extensions``. Thus this callback is a way to exclude\n        specific files that would otherwise be included by their extension.\n    root_dir : 'str`, optional\n        Only content contained within this root directory is considered.\n        This directory must be, or be contained by, a Git repository. This is\n        the current working directory by default.\n\n    Returns\n    -------\n    commit_date : `datetime.datetime`\n        Datetime of the most recent content commit.\n\n    Raises\n    ------\n    RuntimeError\n        Raised if no content files are found."
        ],
        [
            "Iterative over relative filepaths of files in a directory, and\n    sub-directories, with the given extension.\n\n    Parameters\n    ----------\n    extname : `str`\n        Extension name (such as 'txt' or 'rst'). Extension comparison is\n        case sensitive.\n    root_dir : 'str`, optional\n        Root directory. Current working directory by default.\n\n    Yields\n    ------\n    filepath : `str`\n        File path, relative to ``root_dir``, with the given extension."
        ],
        [
            "Returns variables that match specific conditions.\n\n        * Can pass in key=value parameters and variables are returned that\n        contain all of the matches.  For example,\n\n        >>> # Get variables with x-axis attribute.\n        >>> vs = nc.get_variables_by_attributes(axis='X')\n        >>> # Get variables with matching \"standard_name\" attribute.\n        >>> nc.get_variables_by_attributes(standard_name='northward_sea_water_velocity')\n\n        * Can pass in key=callable parameter and variables are returned if the\n        callable returns True.  The callable should accept a single parameter,\n        the attribute value.  None is given as the attribute value when the\n        attribute does not exist on the variable. For example,\n\n        >>> # Get Axis variables.\n        >>> vs = nc.get_variables_by_attributes(axis=lambda v: v in ['X', 'Y', 'Z', 'T'])\n        >>> # Get variables that don't have an \"axis\" attribute.\n        >>> vs = nc.get_variables_by_attributes(axis=lambda v: v is None)\n        >>> # Get variables that have a \"grid_mapping\" attribute.\n        >>> vs = nc.get_variables_by_attributes(grid_mapping=lambda v: v is not None)"
        ],
        [
            "vfuncs can be any callable that accepts a single argument, the\n        Variable object, and returns a dictionary of new attributes to\n        set. These will overwrite existing attributes"
        ],
        [
            "Decorate a function that uses pypandoc to ensure that pandoc is\n    installed if necessary."
        ],
        [
            "Convert text from one markup format to another using pandoc.\n\n    This function is a thin wrapper around `pypandoc.convert_text`.\n\n    Parameters\n    ----------\n    content : `str`\n        Original content.\n\n    from_fmt : `str`\n        Format of the original ``content``. Format identifier must be one of\n        those known by Pandoc. See https://pandoc.org/MANUAL.html for details.\n\n    to_fmt : `str`\n        Output format for the content.\n\n    deparagraph : `bool`, optional\n        If `True`, then the\n        `lsstprojectmeta.pandoc.filters.deparagraph.deparagraph` filter is\n        used to remove paragraph (``<p>``, for example) tags around a single\n        paragraph of content. That filter does not affect content that\n        consists of multiple blocks (several paragraphs, or lists, for\n        example). Default is `False`.\n\n        For example, **without** this filter Pandoc will convert\n        the string ``\"Title text\"`` to ``\"<p>Title text</p>\"`` in HTML. The\n        paragraph tags aren't useful if you intend to wrap the converted\n        content in different tags, like ``<h1>``, using your own templating\n        system.\n\n        **With** this filter, Pandoc will convert the string ``\"Title text\"``\n        to ``\"Title text\"`` in HTML.\n\n    mathjax : `bool`, optional\n        If `True` then Pandoc will markup output content to work with MathJax.\n        Default is False.\n\n    smart : `bool`, optional\n        If `True` (default) then ascii characters will be converted to unicode\n        characters like smart quotes and em dashes.\n\n    extra_args : `list`, optional\n        Sequence of Pandoc arguments command line arguments (such as\n        ``'--normalize'``). The ``deparagraph``, ``mathjax``, and ``smart``\n        arguments are convenience arguments that are equivalent to items\n        in ``extra_args``.\n\n    Returns\n    -------\n    output : `str`\n        Content in the output (``to_fmt``) format.\n\n    Notes\n    -----\n    This function will automatically install Pandoc if it is not available.\n    See `ensure_pandoc`."
        ],
        [
            "Convert lsstdoc-class LaTeX to another markup format.\n\n    This function is a thin wrapper around `convert_text` that automatically\n    includes common lsstdoc LaTeX macros.\n\n    Parameters\n    ----------\n    content : `str`\n        Original content.\n\n    to_fmt : `str`\n        Output format for the content (see https://pandoc.org/MANUAL.html).\n        For example, 'html5'.\n\n    deparagraph : `bool`, optional\n        If `True`, then the\n        `lsstprojectmeta.pandoc.filters.deparagraph.deparagraph` filter is\n        used to remove paragraph (``<p>``, for example) tags around a single\n        paragraph of content. That filter does not affect content that\n        consists of multiple blocks (several paragraphs, or lists, for\n        example). Default is `False`.\n\n        For example, **without** this filter Pandoc will convert\n        the string ``\"Title text\"`` to ``\"<p>Title text</p>\"`` in HTML. The\n        paragraph tags aren't useful if you intend to wrap the converted\n        content in different tags, like ``<h1>``, using your own templating\n        system.\n\n        **With** this filter, Pandoc will convert the string ``\"Title text\"``\n        to ``\"Title text\"`` in HTML.\n\n    mathjax : `bool`, optional\n        If `True` then Pandoc will markup output content to work with MathJax.\n        Default is False.\n\n    smart : `bool`, optional\n        If `True` (default) then ascii characters will be converted to unicode\n        characters like smart quotes and em dashes.\n\n    extra_args : `list`, optional\n        Sequence of Pandoc arguments command line arguments (such as\n        ``'--normalize'``). The ``deparagraph``, ``mathjax``, and ``smart``\n        arguments are convenience arguments that are equivalent to items\n        in ``extra_args``.\n\n    Returns\n    -------\n    output : `str`\n        Content in the output (``to_fmt``) format.\n\n    Notes\n    -----\n    This function will automatically install Pandoc if it is not available.\n    See `ensure_pandoc`."
        ],
        [
            "Decode a JSON-LD dataset, including decoding datetime\n    strings into `datetime.datetime` objects.\n\n    Parameters\n    ----------\n    encoded_dataset : `str`\n        The JSON-LD dataset encoded as a string.\n\n    Returns\n    -------\n    jsonld_dataset : `dict`\n        A JSON-LD dataset.\n\n    Examples\n    --------\n\n    >>> doc = '{\"dt\": \"2018-01-01T12:00:00Z\"}'\n    >>> decode_jsonld(doc)\n    {'dt': datetime.datetime(2018, 1, 1, 12, 0, tzinfo=datetime.timezone.utc)}"
        ],
        [
            "Encode values as JSON strings.\n\n        This method overrides the default implementation from\n        `json.JSONEncoder`."
        ],
        [
            "Get all git repositories within this environment"
        ],
        [
            "Install a python package using pip"
        ],
        [
            "Update a python package using pip"
        ],
        [
            "Returns the nb quantiles for datas in a dataframe"
        ],
        [
            "Returns the root mean square error betwwen a and b"
        ],
        [
            "Returns the normalized mean square error of a and b"
        ],
        [
            "Returns the mean fractionalized bias error"
        ],
        [
            "Returns the factor of exceedance"
        ],
        [
            "Computes the correlation between a and b, says the Pearson's correlation\n    coefficient R"
        ],
        [
            "Geometric mean bias"
        ],
        [
            "Geometric mean variance"
        ],
        [
            "Figure of merit in time"
        ],
        [
            "Performs several stats on a against b, typically a is the predictions\n    array, and b the observations array\n\n    Returns:\n        A dataFrame of stat name, stat description, result"
        ],
        [
            "Path to environments site-packages"
        ],
        [
            "Prior to activating, store everything necessary to deactivate this\n        environment."
        ],
        [
            "Do some serious mangling to the current python environment...\n        This is necessary to activate an environment via python."
        ],
        [
            "Remove this environment"
        ],
        [
            "Command used to launch this application module"
        ],
        [
            "Create a virtual environment. You can pass either the name of a new\n    environment to create in your CPENV_HOME directory OR specify a full path\n    to create an environment outisde your CPENV_HOME.\n\n    Create an environment in CPENV_HOME::\n\n        >>> cpenv.create('myenv')\n\n    Create an environment elsewhere::\n\n        >>> cpenv.create('~/custom_location/myenv')\n\n    :param name_or_path: Name or full path of environment\n    :param config: Environment configuration including dependencies etc..."
        ],
        [
            "Remove an environment or module\n\n    :param name_or_path: name or path to environment or module"
        ],
        [
            "Activates and launches a module\n\n    :param module_name: name of module to launch"
        ],
        [
            "Deactivates an environment by restoring all env vars to a clean state\n    stored prior to activating environments"
        ],
        [
            "Returns a list of available modules."
        ],
        [
            "Add a module to CPENV_ACTIVE_MODULES environment variable"
        ],
        [
            "Remove a module from CPENV_ACTIVE_MODULES environment variable"
        ],
        [
            "Format a list of environments and modules for terminal output"
        ],
        [
            "Show context info"
        ],
        [
            "Activate an environment"
        ],
        [
            "Create a new environment."
        ],
        [
            "Remove an environment"
        ],
        [
            "Add an environment to the cache. Allows you to activate the environment\n    by name instead of by full path"
        ],
        [
            "Remove a cached environment. Removed paths will no longer be able to\n    be activated by name"
        ],
        [
            "Create a new template module.\n\n    You can also specify a filesystem path like \"./modules/new_module\""
        ],
        [
            "Add a module to an environment. PATH can be a git repository path or\n    a filesystem path."
        ],
        [
            "Copy a global module to the active environment."
        ],
        [
            "Resolves VirtualEnvironments with a relative or absolute path"
        ],
        [
            "Resolves VirtualEnvironments in CPENV_HOME"
        ],
        [
            "Resolves VirtualEnvironments in EnvironmentCache"
        ],
        [
            "Resolves module in previously resolved environment."
        ],
        [
            "Resolves modules in currently active environment."
        ],
        [
            "Resolves environment from .cpenv file...recursively walks up the tree\n    in attempt to find a .cpenv file"
        ],
        [
            "Returns a view of the array with axes transposed.\n\n    For a 1-D array, this has no effect.\n    For a 2-D array, this is the usual matrix transpose.\n    For an n-D array, if axes are given, their order indicates how the\n    axes are permuted\n\n    Args:\n      a (array_like): Input array.\n      axes (list of int, optional): By default, reverse the dimensions,\n        otherwise permute the axes according to the values given."
        ],
        [
            "Roll the specified axis backwards, until it lies in a given position.\n\n    Args:\n      a (array_like): Input array.\n      axis (int): The axis to roll backwards.  The positions of the other axes \n        do not change relative to one another.\n      start (int, optional): The axis is rolled until it lies before this \n        position.  The default, 0, results in a \"complete\" roll.\n\n    Returns:\n      res (ndarray)"
        ],
        [
            "Insert a new axis, corresponding to a given position in the array shape\n\n    Args:\n      a (array_like): Input array.\n      axis (int): Position (amongst axes) where new axis is to be inserted."
        ],
        [
            "Join a sequence of arrays together. \n    Will aim to join `ndarray`, `RemoteArray`, and `DistArray` without moving \n    their data, if they happen to be on different engines.\n\n    Args:\n      tup (sequence of array_like): Arrays to be concatenated. They must have\n        the same shape, except in the dimension corresponding to `axis`.\n      axis (int, optional): The axis along which the arrays will be joined.\n\n    Returns: \n      res: `ndarray`, if inputs were all local\n           `RemoteArray`, if inputs were all on the same remote engine\n           `DistArray`, if inputs were already scattered on different engines"
        ],
        [
            "Return the shape that would result from broadcasting the inputs"
        ],
        [
            "Compute the arithmetic mean along the specified axis.\n\n    Returns the average of the array elements.  The average is taken over\n    the flattened array by default, otherwise over the specified axis.\n    `float64` intermediate and return values are used for integer inputs.\n\n    Parameters\n    ----------\n    a : array_like\n        Array containing numbers whose mean is desired. If `a` is not an\n        array, a conversion is attempted.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which the means are computed. The default is to\n        compute the mean of the flattened array.\n        If this is a tuple of ints, a mean is performed over multiple axes,\n        instead of a single axis or all the axes as before.\n    dtype : data-type, optional\n        Type to use in computing the mean.  For integer inputs, the default\n        is `float64`; for floating point inputs, it is the same as the\n        input dtype.\n    out : ndarray, optional\n        Alternate output array in which to place the result.  The default\n        is ``None``; if provided, it must have the same shape as the\n        expected output, but the type will be cast if necessary.\n        See `doc.ufuncs` for details.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `arr`.\n\n    Returns\n    -------\n    m : ndarray, see dtype parameter above\n\n    Notes\n    -----\n    np.mean fails to pass the keepdims parameter to ndarray subclasses.\n    That is the main reason we implement this function."
        ],
        [
            "`ax` is a valid candidate for a distributed axis if the given\n        subarray shapes are all the same when ignoring axis `ax`"
        ],
        [
            "Returns True if successful, False if failure"
        ],
        [
            "Return a command to launch a subshell"
        ],
        [
            "Generate a prompt with a given prefix\n\n    linux/osx: [prefix] user@host cwd $\n          win: [prefix] cwd:"
        ],
        [
            "Launch a subshell"
        ],
        [
            "Append a file to file repository.\n\n        For file monitoring, monitor instance needs file.\n        Please put the name of file to `file` argument.\n\n        :param file: the name of file you want monitor."
        ],
        [
            "Append files to file repository.\n        \n        ModificationMonitor can append files to repository using this.\n        Please put the list of file names to `filelist` argument.\n\n        :param filelist: the list of file nmaes"
        ],
        [
            "Run file modification monitor.\n\n        The monitor can catch file modification using timestamp and file body. \n        Monitor has timestamp data and file body data. And insert timestamp \n        data and file body data before into while roop. In while roop, monitor \n        get new timestamp and file body, and then monitor compare new timestamp\n        to originaltimestamp. If new timestamp and file body differ original,\n        monitor regard thease changes as `modification`. Then monitor create\n        instance of FileModificationObjectManager and FileModificationObject,\n        and monitor insert FileModificationObject to FileModificationObject-\n        Manager. Then, yield this object.\n\n        :param sleep: How times do you sleep in while roop."
        ],
        [
            "Decorator that invokes `add_status_job`.\n\n        ::\n\n            @app.status_job\n            def postgresql():\n                # query/ping postgres\n\n            @app.status_job(name=\"Active Directory\")\n            def active_directory():\n                # query active directory\n\n            @app.status_job(timeout=5)\n            def paypal():\n                # query paypal, timeout after 5 seconds"
        ],
        [
            "Page through text by feeding it to another program.  Invoking a\n    pager through this might support colors."
        ],
        [
            "Calcul du profil annuel\n\n    Param\u00e8tres:\n    df: DataFrame de donn\u00e9es dont l'index est une s\u00e9rie temporelle\n        (cf module xair par exemple)\n    func: function permettant le calcul. Soit un nom de fonction numpy ('mean', 'max', ...)\n        soit la fonction elle-m\u00eame (np.mean, np.max, ...)\n    Retourne:\n    Un DataFrame de moyennes par mois"
        ],
        [
            "Attempt to run a global hook by name with args"
        ],
        [
            "Calcule de moyennes glissantes\n\n    Param\u00e8tres:\n    df: DataFrame de mesures sur lequel appliqu\u00e9 le calcul\n    sur: (int, par d\u00e9faut 8) Nombre d'observations sur lequel s'appuiera le\n    calcul\n    rep: (float, d\u00e9faut 0.75) Taux de r\u00e9pr\u00e9sentativit\u00e9 en dessous duquel le\n    calcul renverra NaN\n\n    Retourne:\n    Un DataFrame des moyennes glissantes calcul\u00e9es"
        ],
        [
            "Calcul de l'AOT40 du 1er mai au 31 juillet\n\n    *AOT40 : AOT 40 ( exprim\u00e9 en micro g/m\u00b3 par heure ) signifie la somme des\n    diff\u00e9rences entre les concentrations horaires sup\u00e9rieures \u00e0 40 parties par\n    milliard ( 40 ppb soit 80 micro g/m\u00b3 ), durant une p\u00e9riode donn\u00e9e en\n    utilisant uniquement les valeurs sur 1 heure mesur\u00e9es quotidiennement\n    entre 8 heures (d\u00e9but de la mesure) et 20 heures (pile, fin de la mesure) CET,\n    ce qui correspond \u00e0 de 8h \u00e0 19h TU (donnant bien 12h de mesures, 8h donnant\n    la moyenne horaire de 7h01 \u00e0 8h00)\n\n    Param\u00e8tres:\n    df: DataFrame de mesures sur lequel appliqu\u00e9 le calcul\n    nb_an: (int) Nombre d'ann\u00e9es contenu dans le df, et servant \u00e0 diviser le\n    r\u00e9sultat retourn\u00e9\n\n    Retourne:\n    Un DataFrame de r\u00e9sultat de calcul"
        ],
        [
            "Validate all the entries in the environment cache."
        ],
        [
            "Load the environment cache from disk."
        ],
        [
            "Save the environment cache to disk."
        ],
        [
            "Prompts a user for input.  This is a convenience function that can\n    be used to prompt a user for input later.\n\n    If the user aborts the input by sending a interrupt signal, this\n    function will catch it and raise a :exc:`Abort` exception.\n\n    .. versionadded:: 6.0\n       Added unicode support for cmd.exe on Windows.\n\n    .. versionadded:: 4.0\n       Added the `err` parameter.\n\n    :param text: the text to show for the prompt.\n    :param default: the default value to use if no input happens.  If this\n                    is not given it will prompt until it's aborted.\n    :param hide_input: if this is set to true then the input value will\n                       be hidden.\n    :param confirmation_prompt: asks for confirmation for the value.\n    :param type: the type to use to check the value against.\n    :param value_proc: if this parameter is provided it's a function that\n                       is invoked instead of the type conversion to\n                       convert a value.\n    :param prompt_suffix: a suffix that should be added to the prompt.\n    :param show_default: shows or hides the default value in the prompt.\n    :param err: if set to true the file defaults to ``stderr`` instead of\n                ``stdout``, the same as with echo."
        ],
        [
            "This function takes a text and shows it via an environment specific\n    pager on stdout.\n\n    .. versionchanged:: 3.0\n       Added the `color` flag.\n\n    :param text: the text to page.\n    :param color: controls if the pager supports ANSI colors or not.  The\n                  default is autodetection."
        ],
        [
            "Prepare all iPython engines for distributed object processing.\n\n    Args:\n      client (ipyparallel.Client, optional): If None, will create a client\n        using the default ipyparallel profile."
        ],
        [
            "Retrieve objects that have been distributed, making them local again"
        ],
        [
            "Apply a function in parallel to each element of the input"
        ],
        [
            "Configure engines so that remote methods returning values of type\n        `real_type` will instead return by proxy, as type `proxy_type`"
        ],
        [
            "Returns True if path is a git repository."
        ],
        [
            "Returns True if path is in CPENV_HOME"
        ],
        [
            "Returns True if path contains a .cpenv file"
        ],
        [
            "Get environment path from redirect file"
        ],
        [
            "Returns an absolute expanded path"
        ],
        [
            "Like os.path.join but also expands and normalizes path parts."
        ],
        [
            "Like os.path.join but acts relative to this packages bin path."
        ],
        [
            "Like os.makedirs but keeps quiet if path already exists"
        ],
        [
            "Walk down a directory tree. Same as os.walk but allows for a depth limit\n    via depth argument"
        ],
        [
            "Walk up a directory tree"
        ],
        [
            "Preprocess a dict to be used as environment variables.\n\n    :param d: dict to be processed"
        ],
        [
            "Add a sequence value to env dict"
        ],
        [
            "Join a bunch of dicts"
        ],
        [
            "Convert a dict containing environment variables into a standard dict.\n    Variables containing multiple values will be split into a list based on\n    the argument passed to pathsep.\n\n    :param env: Environment dict like os.environ.data\n    :param pathsep: Path separator used to split variables"
        ],
        [
            "Convert a python dict to a dict containing valid environment variable\n    values.\n\n    :param d: Dict to convert to an env dict\n    :param pathsep: Path separator used to join lists(default os.pathsep)"
        ],
        [
            "Expand all environment variables in an environment dict\n\n    :param env: Environment dict"
        ],
        [
            "Returns an unused random filepath."
        ],
        [
            "Encode current environment as yaml and store in path or a temporary\n    file. Return the path to the stored environment."
        ],
        [
            "Returns the URL to the upstream data source for the given URI based on configuration"
        ],
        [
            "Return request object for calling the upstream"
        ],
        [
            "Returns time to live in seconds. 0 means no caching.\n\n        Criteria:\n        - response code 200\n        - read-only method (GET, HEAD, OPTIONS)\n        Plus http headers:\n        - cache-control: option1, option2, ...\n          where options are:\n          private | public\n          no-cache\n          no-store\n          max-age: seconds\n          s-maxage: seconds\n          must-revalidate\n          proxy-revalidate\n        - expires: Thu, 01 Dec 1983 20:00:00 GMT\n        - pragma: no-cache (=cache-control: no-cache)\n\n        See http://www.mobify.com/blog/beginners-guide-to-http-cache-headers/\n\n        TODO: tests"
        ],
        [
            "Guarantee the existence of a basic MANIFEST.in.\n\n    manifest doc: http://docs.python.org/distutils/sourcedist.html#manifest\n\n    `options.paved.dist.manifest.include`: set of files (or globs) to include with the `include` directive.\n\n    `options.paved.dist.manifest.recursive_include`: set of files (or globs) to include with the `recursive-include` directive.\n\n    `options.paved.dist.manifest.prune`: set of files (or globs) to exclude with the `prune` directive.\n\n    `options.paved.dist.manifest.include_sphinx_docroot`: True -> sphinx docroot is added as `graft`\n\n    `options.paved.dist.manifest.include_sphinx_docroot`: True -> sphinx builddir is added as `prune`"
        ],
        [
            "Format a pathname\n\n    :param str pathname: Pathname to format\n    :param int max_length: Maximum length of result pathname (> 3)\n    :return: Formatted pathname\n    :rtype: str\n    :raises ValueError: If *max_length* is not larger than 3\n\n    This function formats a pathname so it is not longer than *max_length*\n    characters. The resulting pathname is returned. It does so by replacing\n    characters at the start of the *pathname* with three dots, if necessary.\n    The idea is that the end of the *pathname* is the most important part\n    to be able to identify the file."
        ],
        [
            "Format a UUID string\n\n    :param str uuid: UUID to format\n    :param int max_length: Maximum length of result string (> 3)\n    :return: Formatted UUID\n    :rtype: str\n    :raises ValueError: If *max_length* is not larger than 3\n\n    This function formats a UUID so it is not longer than *max_length*\n    characters. The resulting string is returned. It does so by replacing\n    characters at the end of the *uuid* with three dots, if necessary.\n    The idea is that the start of the *uuid* is the most important part\n    to be able to identify the related entity.\n\n    The default *max_length* is 10, which will result in a string\n    containing the first 7 characters of the *uuid* passed in. Most of\n    the time, such a string is still unique within a collection of UUIDs."
        ],
        [
            "attempts to get next and previous on updates"
        ],
        [
            "Notify the client of the result of handling a request\n\n    The payload contains two elements:\n\n    - client_id\n    - result\n\n    The *client_id* is the id of the client to notify. It is assumed\n    that the notifier service is able to identify the client by this id\n    and that it can pass the *result* to it.\n\n    The *result* always contains a *status_code* element. In case the\n    message passed in is not None, it will also contain a *message*\n    element.\n\n    In case the notifier service does not exist or returns an error,\n    an error message will be logged to *stderr*."
        ],
        [
            "Retrieves the setting value whose name is indicated by name_hyphen.\n\n        Values starting with $ are assumed to reference environment variables,\n        and the value stored in environment variables is retrieved. It's an\n        error if thes corresponding environment variable it not set."
        ],
        [
            "This method does the work of updating settings. Can be passed with\n        enforce_helpstring = False which you may want if allowing end users to\n        add arbitrary metadata via the settings system.\n\n        Preferable to use update_settings (without leading _) in code to do the\n        right thing and always have docstrings."
        ],
        [
            "Return a combined dictionary of setting values and attribute values."
        ],
        [
            "Detect if we get a class or a name, convert a name to a class."
        ],
        [
            "Asserts that the class has a docstring, returning it if successful."
        ],
        [
            "Get absolute path to resource, works for dev and for PyInstaller"
        ],
        [
            "Add new block of logbook selection windows. Only 5 allowed."
        ],
        [
            "Remove logbook menu set."
        ],
        [
            "Return selected log books by type."
        ],
        [
            "Verify enetered user name is on accepted MCC logbook list."
        ],
        [
            "Parse xml elements for pretty printing"
        ],
        [
            "Convert supplied QPixmap object to image file."
        ],
        [
            "Process user inputs and subit logbook entry when user clicks Submit button"
        ],
        [
            "Process log information and push to selected logbooks."
        ],
        [
            "Create graphical objects for menus."
        ],
        [
            "Display menus and connect even signals."
        ],
        [
            "Add or change list of logbooks."
        ],
        [
            "Remove unwanted logbooks from list."
        ],
        [
            "Populate log program list to correspond with log type selection."
        ],
        [
            "Add menus to parent gui."
        ],
        [
            "Iteratively remove graphical objects from layout."
        ],
        [
            "Adds labels to a plot."
        ],
        [
            "Determine the URL corresponding to Python object"
        ],
        [
            "Update the database with model schema. Shorthand for `paver manage syncdb`."
        ],
        [
            "Run the dev server.\n\n    Uses `django_extensions <http://pypi.python.org/pypi/django-extensions/0.5>`, if\n    available, to provide `runserver_plus`.\n\n    Set the command to use with `options.paved.django.runserver`\n    Set the port to use with `options.paved.django.runserver_port`"
        ],
        [
            "Run South's schemamigration command."
        ],
        [
            "This static method validates a BioMapMapper definition.\n        It returns None on success and throws an exception otherwise."
        ],
        [
            "The main method of this class and the essence of the package.\n        It allows to \"map\" stuff.\n\n        Args:\n\n            ID_s: Nested lists with strings as leafs (plain strings also possible)\n            FROM (str): Origin key for the mapping (default: main key)\n            TO (str): Destination key for the mapping (default: main key)\n            target_as_set (bool): Whether to summarize the output as a set (removes duplicates)\n            no_match_sub: Object representing the status of an ID not being able to be matched\n                          (default: None)\n\n        Returns:\n\n            Mapping: a mapping object capturing the result of the mapping request"
        ],
        [
            "Returns all data entries for a particular key. Default is the main key.\n\n        Args:\n\n            key (str): key whose values to return (default: main key)\n\n        Returns:\n\n            List of all data entries for the key"
        ],
        [
            "Returns list of strings split by input delimeter\n\n        Argument:\n        line - Input line to cut"
        ],
        [
            "Get Existing Message\n\n        http://dev.wheniwork.com/#get-existing-message"
        ],
        [
            "Creates a message\n\n        http://dev.wheniwork.com/#create/update-message"
        ],
        [
            "Modify an existing message.\n\n        http://dev.wheniwork.com/#create/update-message"
        ],
        [
            "Delete existing messages.\n\n        http://dev.wheniwork.com/#delete-existing-message"
        ],
        [
            "Returns site data.\n\n        http://dev.wheniwork.com/#get-existing-site"
        ],
        [
            "Returns a list of sites.\n\n        http://dev.wheniwork.com/#listing-sites"
        ],
        [
            "Creates a site\n\n        http://dev.wheniwork.com/#create-update-site"
        ],
        [
            "Returns a link to a view that moves the passed in object up in rank.\n\n    :param obj:\n        Object to move\n    :param link_text:\n        Text to display in the link.  Defaults to \"up\"\n    :returns:\n        HTML link code to view for moving the object"
        ],
        [
            "Returns a link to a view that moves the passed in object down in rank.\n\n    :param obj:\n        Object to move\n    :param link_text:\n        Text to display in the link.  Defaults to \"down\"\n    :returns:\n        HTML link code to view for moving the object"
        ],
        [
            "Shows a figure with a typical orientation so that x and y axes are set up as expected."
        ],
        [
            "Shifts indicies as needed to account for one based indexing\n\n    Positive indicies need to be reduced by one to match with zero based\n    indexing.\n\n    Zero is not a valid input, and as such will throw a value error.\n\n    Arguments:\n        index -     index to shift"
        ],
        [
            "Returns selected positions from cut input source in desired\n        arrangement.\n\n        Argument:\n            line -      input to cut"
        ],
        [
            "Processes positions to account for ranges\n\n        Arguments:\n            positions -     list of positions and/or ranges to process"
        ],
        [
            "Performs cut for range from start position to end\n\n        Arguments:\n            line -              input to cut\n            start -             start of range\n            current_position -  current position in main cut function"
        ],
        [
            "Creates list of values in a range with output delimiters.\n\n        Arguments:\n            start -     range start\n            end -       range end"
        ],
        [
            "Locks the file by writing a '.lock' file.\n       Returns True when the file is locked and\n       False when the file was locked already"
        ],
        [
            "Unlocks the file by remove a '.lock' file.\n       Returns True when the file is unlocked and\n       False when the file was unlocked already"
        ],
        [
            "Initiate the local catalog and push it the cloud"
        ],
        [
            "Initiate the local catalog by downloading the cloud catalog"
        ],
        [
            "Return nodes in the path between 'a' and 'b' going from\n        parent to child NOT including 'a'"
        ],
        [
            "Index of the last occurrence of x in the sequence."
        ],
        [
            "Create and save an admin user.\n\n    :param username:\n        Admin account's username.  Defaults to 'admin'\n    :param email:\n        Admin account's email address.  Defaults to 'admin@admin.com'\n    :param password:\n        Admin account's password.  Defaults to 'admin'\n    :returns:\n        Django user with staff and superuser privileges"
        ],
        [
            "Returns a list of the messages from the django MessageMiddleware\n    package contained within the given response.  This is to be used during\n    unit testing when trying to see if a message was set properly in a view.\n\n    :param response: HttpResponse object, likely obtained through a\n        test client.get() or client.post() call\n\n    :returns: a list of tuples (message_string, message_level), one for each\n        message in the response context"
        ],
        [
            "Authenticates the superuser account via the web login."
        ],
        [
            "Does a django test client ``get`` against the given url after\n        logging in the admin first.\n\n        :param url:\n            URL to fetch\n        :param response_code:\n            Expected response code from the URL fetch.  This value is\n            asserted.  Defaults to 200\n        :param headers:\n            Optional dictionary of headers to send in the request\n        :param follow:\n            When True, the get call will follow any redirect requests.\n            Defaults to False.\n        :returns:\n            Django testing ``Response`` object"
        ],
        [
            "Does a django test client ``post`` against the given url after\n        logging in the admin first.\n\n        :param url:\n            URL to fetch\n        :param data:\n            Dictionary to form contents to post\n        :param response_code:\n            Expected response code from the URL fetch.  This value is\n            asserted.  Defaults to 200\n        :param headers:\n            Optional dictionary of headers to send in with the request\n        :returns:\n            Django testing ``Response`` object"
        ],
        [
            "Returns the value displayed in the column on the web interface for\n        a given instance.\n\n        :param admin_model:\n            Instance of a :class:`admin.ModelAdmin` object that is responsible\n            for displaying the change list\n        :param instance:\n            Object instance that is the row in the admin change list\n        :field_name:\n            Name of the field/column to fetch"
        ],
        [
            "Highest value of input image."
        ],
        [
            "Lowest value of input image."
        ],
        [
            "spawns a greenlet that does not print exceptions to the screen.\n    if you use this function you MUST use this module's join or joinall otherwise the exception will be lost"
        ],
        [
            "Returns usage string with no trailing whitespace."
        ],
        [
            "Setup argparser to process arguments and generate help"
        ],
        [
            "Opens connection to S3 returning bucket and key"
        ],
        [
            "Upload a local file to S3."
        ],
        [
            "Download a remote file from S3."
        ],
        [
            "Creates an ical .ics file for an event using python-card-me."
        ],
        [
            "Returns a list view of all comments for a given event.\n    Combines event comments and update comments in one list."
        ],
        [
            "Returns a list view of updates for a given event.\n    If the event is over, it will be in chronological order.\n    If the event is upcoming or still going,\n    it will be in reverse chronological order."
        ],
        [
            "Displays list of videos for given event."
        ],
        [
            "Public form to add an event."
        ],
        [
            "Adds a memory to an event."
        ],
        [
            "Inserts Interpreter Library of imports into sketch in a very non-consensual way"
        ],
        [
            "Sets the beam moments directly.\n\n        Parameters\n        ----------\n        sx : float\n            Beam moment where :math:`\\\\text{sx}^2 = \\\\langle x^2 \\\\rangle`.\n        sxp : float\n            Beam moment where :math:`\\\\text{sxp}^2 = \\\\langle x'^2 \\\\rangle`.\n        sxxp : float\n            Beam moment where :math:`\\\\text{sxxp} = \\\\langle x x' \\\\rangle`."
        ],
        [
            "Sets the beam moments indirectly using Courant-Snyder parameters.\n\n        Parameters\n        ----------\n        beta : float\n            Courant-Snyder parameter :math:`\\\\beta`.\n        alpha : float\n            Courant-Snyder parameter :math:`\\\\alpha`.\n        emit : float\n            Beam emittance :math:`\\\\epsilon`.\n        emit_n : float\n            Normalized beam emittance :math:`\\\\gamma \\\\epsilon`."
        ],
        [
            "Given a slice object, return appropriate values for use in the range function\n\n    :param slice_obj: The slice object or integer provided in the `[]` notation\n    :param length: For negative indexing we need to know the max length of the object."
        ],
        [
            "Helper to add error to messages field. It fills placeholder with extra call parameters\n        or values from message_value map.\n\n        :param error_code: Error code to use\n        :rparam error_code: str\n        :param value: Value checked\n        :param kwargs: Map of values to use in placeholders"
        ],
        [
            "File copy that support compress and decompress of zip files"
        ],
        [
            "Apply to the 'catalog' the changesets in the metafile list 'changesets"
        ],
        [
            "Validate that an event with this name on this date does not exist."
        ],
        [
            "When entering the context, spawns a greenlet that sleeps for `interval` seconds between `callback` executions.\n    When leaving the context stops the greenlet.\n    The yielded object is the `GeventLoop` object so the loop can be stopped from within the context.\n\n    For example:\n    ```\n    with loop_in_background(60.0, purge_cache) as purge_cache_job:\n        ...\n        ...\n        if should_stop_cache():\n            purge_cache_job.stop()\n    ```"
        ],
        [
            "Main loop - used internally."
        ],
        [
            "Starts the loop. Calling a running loop is an error."
        ],
        [
            "Kills the running loop and waits till it gets killed."
        ],
        [
            "Used to plot a set of coordinates.\n\n\n    Parameters\n    ----------\n    x, y : :class:`numpy.ndarray`\n        1-D ndarrays of lengths N and M, respectively, specifying pixel centers\n    z : :class:`numpy.ndarray`\n        An (M, N) ndarray or masked array of values to be colormapped, or a (M, N, 3) RGB array, or a (M, N, 4) RGBA array.\n    ax : :class:`matplotlib.axes.Axes`, optional\n        The axis to plot to.\n    fig : :class:`matplotlib.figure.Figure`, optional\n        The figure to plot to.\n    cmap : :class:`matplotlib.colors.Colormap`, optional\n        The colormap to use.\n    alpha : float, optional\n        The transparency to use.\n    scalex : bool, optional\n        To set the x limits to available data\n    scaley : bool, optional\n        To set the y limits to available data\n    add_cbar : bool, optional\n        Whether ot add a colorbar or not.\n\n    Returns\n    -------\n    img : :class:`matplotlib.image.NonUniformImage`\n        Object representing the :class:`matplotlib.image.NonUniformImage`."
        ],
        [
            "Fix common spacing errors caused by LaTeX's habit\n        of using an inter-sentence space after any full stop."
        ],
        [
            "Transform hyphens to various kinds of dashes"
        ],
        [
            "Replace target with replacement"
        ],
        [
            "Regex substitute target with replacement"
        ],
        [
            "Call the Sphinx Makefile with the specified targets.\n\n    `options.paved.docs.path`: the path to the Sphinx folder (where the Makefile resides)."
        ],
        [
            "Upload the docs to a remote location via rsync.\n\n    `options.paved.docs.rsync_location`: the target location to rsync files to.\n\n    `options.paved.docs.path`: the path to the Sphinx folder (where the Makefile resides).\n\n    `options.paved.docs.build_rel`: the path of the documentation\n        build folder, relative to `options.paved.docs.path`."
        ],
        [
            "Push Sphinx docs to github_ gh-pages branch.\n\n     1. Create file .nojekyll\n     2. Push the branch to origin/gh-pages\n        after committing using ghp-import_\n\n    Requirements:\n     - easy_install ghp-import\n\n    Options:\n     - `options.paved.docs.*` is not used\n     - `options.sphinx.docroot` is used (default=docs)\n     - `options.sphinx.builddir` is used (default=.build)\n\n    .. warning::\n        This will DESTROY your gh-pages branch.\n        If you love it, you'll want to take backups\n        before playing with this. This script assumes\n        that gh-pages is 100% derivative. You should\n        never edit files in your gh-pages branch by hand\n        if you're using this script because you will\n        lose your work.\n\n    .. _github: https://github.com\n    .. _ghp-import: https://github.com/davisp/ghp-import"
        ],
        [
            "Open your web browser and display the generated html documentation."
        ],
        [
            "Tries to minimize the length of CSS code passed as parameter. Returns string."
        ],
        [
            "Return an open file-object to the index file"
        ],
        [
            "Create the tasks on the server"
        ],
        [
            "Update existing tasks on the server"
        ],
        [
            "Reconcile this collection with the server."
        ],
        [
            "Prompts the user for yes or no."
        ],
        [
            "Prompts the user with custom options."
        ],
        [
            "Reading the configure file and adds non-existing attributes to 'args"
        ],
        [
            "Writing the configure file with the attributes in 'args"
        ],
        [
            "Create a new instance of a game. Note, a mode MUST be provided and MUST be of\n        type GameMode.\n\n        :param mode: <required>"
        ],
        [
            "Bumps the Version given a target\n\n        The target can be either MAJOR, MINOR or PATCH"
        ],
        [
            "Returns a copy of this object"
        ],
        [
            "Returns a Tag with a given revision"
        ],
        [
            "Parses a string into a Tag"
        ],
        [
            "Tiles open figures."
        ],
        [
            "When a Comment is added, updates the Update to set \"last_updated\" time"
        ],
        [
            "Adds useful global items to the context for use in templates.\n\n    * *request*: the request object\n    * *HOST*: host name of server\n    * *IN_ADMIN*: True if you are in the django admin area"
        ],
        [
            "Create the challenge on the server"
        ],
        [
            "Update existing challenge on the server"
        ],
        [
            "Check if a challenge exists on the server"
        ],
        [
            "Returns position data.\n\n        http://dev.wheniwork.com/#get-existing-position"
        ],
        [
            "Returns a list of positions.\n\n        http://dev.wheniwork.com/#listing-positions"
        ],
        [
            "Creates a position\n\n        http://dev.wheniwork.com/#create-update-position"
        ],
        [
            "Print \"Source Lines of Code\" and export to file.\n\n    Export is hudson_ plugin_ compatible: sloccount.sc\n\n    requirements:\n     - sloccount_ should be installed.\n     - tee and pipes are used\n\n    options.paved.pycheck.sloccount.param\n\n    .. _sloccount: http://www.dwheeler.com/sloccount/\n    .. _hudson: http://hudson-ci.org/\n    .. _plugin: http://wiki.hudson-ci.org/display/HUDSON/SLOCCount+Plugin"
        ],
        [
            "passive check of python programs by pyflakes.\n\n    requirements:\n     - pyflakes_ should be installed. ``easy_install pyflakes``\n\n    options.paved.pycheck.pyflakes.param\n\n    .. _pyflakes: http://pypi.python.org/pypi/pyflakes"
        ],
        [
            "Handle HTTP exception\n\n    :param werkzeug.exceptions.HTTPException exception: Raised exception\n\n    A response is returned, as formatted by the :py:func:`response` function."
        ],
        [
            "Returns True if the value given is a valid CSS colour, i.e. matches one\n    of the regular expressions in the module or is in the list of\n    predetefined values by the browser."
        ],
        [
            "Reynold number utility function that return Reynold number for vehicle at specific length and speed.\n    Optionally, it can also take account of temperature effect of sea water.\n\n        Kinematic viscosity from: http://web.mit.edu/seawater/2017_MIT_Seawater_Property_Tables_r2.pdf\n\n    :param length: metres length of the vehicle\n    :param speed: m/s speed of the vehicle\n    :param temperature: degree C \n    :return: Reynolds number of the vehicle (dimensionless)"
        ],
        [
            "Froude number utility function that return Froude number for vehicle at specific length and speed.\n\n    :param speed: m/s speed of the vehicle\n    :param length: metres length of the vehicle\n    :return: Froude number of the vehicle (dimensionless)"
        ],
        [
            "Residual resistance coefficient estimation from slenderness function, prismatic coefficient and Froude number.\n\n    :param slenderness: Slenderness coefficient dimensionless :math:`L/(\u2207^{1/3})` where L is length of ship, \u2207 is displacement\n    :param prismatic_coef: Prismatic coefficient dimensionless :math:`\u2207/(L\\cdot A_m)` where L is length of ship, \u2207 is displacement Am is midsection area of the ship\n    :param froude_number: Froude number of the ship dimensionless \n    :return: Residual resistance of the ship"
        ],
        [
            "Assign values for the main dimension of a ship.\n\n        :param length: metres length of the vehicle\n        :param draught: metres draught of the vehicle\n        :param beam: metres beam of the vehicle\n        :param speed: m/s speed of the vehicle\n        :param slenderness_coefficient: Slenderness coefficient dimensionless :math:`L/(\u2207^{1/3})` where L is length of ship,\n            \u2207 is displacement\n        :param prismatic_coefficient: Prismatic coefficient dimensionless :math:`\u2207/(L\\cdot A_m)` where L is length of ship,\n            \u2207 is displacement Am is midsection area of the ship"
        ],
        [
            "Return resistance of the vehicle.\n\n        :return: newton the resistance of the ship"
        ],
        [
            "Return the maximum deck area of the ship\n\n        :param water_plane_coef: optional water plane coefficient\n        :return: Area of the deck"
        ],
        [
            "Total propulsion power of the ship.\n\n        :param propulsion_eff: Shaft efficiency of the ship\n        :param sea_margin: Sea margin take account of interaction between ship and the sea, e.g. wave\n        :return: Watts shaft propulsion power of the ship"
        ],
        [
            "Configure the api to use given url and token or to get them from the\n        Config."
        ],
        [
            "Send zipfile to TMC for given exercise"
        ],
        [
            "Ensures that the request url is valid.\n        Sometimes we have URLs that the server gives that are preformatted,\n        sometimes we need to form our own."
        ],
        [
            "Extract json from a response.\n            Assumes response is valid otherwise.\n            Internal use only."
        ],
        [
            "Wrapper for gevent.joinall if the greenlet that waits for the joins is killed, it kills all the greenlets it\n    joins for."
        ],
        [
            "Creates an error from the given code, and args and kwargs.\n\n    :param code: The acknowledgement code\n    :param args: Exception args\n    :param kwargs: Exception kwargs\n    :return: the error for the given acknowledgement code"
        ],
        [
            "Creates an error Acknowledgement message.\n        The message's code and message are taken from this exception.\n\n        :return: the message representing this exception"
        ],
        [
            "Clean up extra files littering the source tree.\n\n    options.paved.clean.dirs: directories to search recursively\n    options.paved.clean.patterns: patterns to search for and remove"
        ],
        [
            "print paver options.\n\n    Prettified by json.\n    `long_description` is removed"
        ],
        [
            "\\\n        Parses a binary protobuf message into a Message object."
        ],
        [
            "Creates a new ``Node`` based on the extending class and adds it as\n        a child to this ``Node``.\n\n        :param kwargs: \n            arguments for constructing the data object associated with this\n            ``Node``\n        :returns: \n            extender of the ``Node`` class"
        ],
        [
            "Returns a list of the ancestors of this node."
        ],
        [
            "Returns a list of the ancestors of this node but does not pass the\n        root node, even if the root has parents due to cycles."
        ],
        [
            "Returns a list of descendents of this node."
        ],
        [
            "Returns True if it is legal to remove this node and still leave the\n        graph as a single connected entity, not splitting it into a forest.\n        Only nodes with no children or those who cause a cycle can be deleted."
        ],
        [
            "Removes the node and all descendents without looping back past the\n        root.  Note this does not remove the associated data objects.\n\n        :returns:\n            list of :class:`BaseDataNode` subclassers associated with the\n            removed ``Node`` objects."
        ],
        [
            "Returns a list of nodes that would be removed if prune were called\n        on this element."
        ],
        [
            "Called to verify that the given rule can become a child of the\n        current node.  \n\n        :raises AttributeError: \n            if the child is not allowed"
        ],
        [
            "Returns location data.\n\n        http://dev.wheniwork.com/#get-existing-location"
        ],
        [
            "Returns a list of locations.\n\n        http://dev.wheniwork.com/#listing-locations"
        ],
        [
            "The reduced chi-square of the linear least squares"
        ],
        [
            "Create the task on the server"
        ],
        [
            "Update existing task on the server"
        ],
        [
            "Retrieve a task from the server"
        ],
        [
            "Formats a string with color"
        ],
        [
            "Returns user profile data.\n\n        http://dev.wheniwork.com/#get-existing-user"
        ],
        [
            "Returns a list of users.\n\n        http://dev.wheniwork.com/#listing-users"
        ],
        [
            "Attempt to set the virtualenv activate command, if it hasn't been specified."
        ],
        [
            "Recursively update the destination dict-like object with the source dict-like object.\n\n    Useful for merging options and Bunches together!\n\n    Based on:\n    http://code.activestate.com/recipes/499335-recursively-update-a-dictionary-without-hitting-py/#c1"
        ],
        [
            "Send the given arguments to `pip install`."
        ],
        [
            "When I Work GET method. Return representation of the requested\n        resource."
        ],
        [
            "When I Work PUT method."
        ],
        [
            "When I Work POST method."
        ],
        [
            "When I Work DELETE method."
        ],
        [
            "Creates a shift\n\n        http://dev.wheniwork.com/#create/update-shift"
        ],
        [
            "Delete existing shifts.\n\n        http://dev.wheniwork.com/#delete-shift"
        ],
        [
            "Returns combined list of event and update comments."
        ],
        [
            "Returns chained list of event and update images."
        ],
        [
            "Gets count of all images from both event and updates."
        ],
        [
            "Gets images and videos to populate top assets.\n\n        Map is built separately."
        ],
        [
            "Decorated methods progress will be displayed to the user as a spinner.\n        Mostly for slower functions that do some network IO."
        ],
        [
            "Launches a new menu. Wraps curses nicely so exceptions won't screw with\n        the terminal too much."
        ],
        [
            "Overridden method that handles that re-ranking of objects and the\n        integrity of the ``rank`` field.\n\n        :param rerank:\n            Added parameter, if True will rerank other objects based on the\n            change in this save.  Defaults to True."
        ],
        [
            "Removes any blank ranks in the order."
        ],
        [
            "Returns the field names of a Django model object.\n\n    :param obj: the Django model class or object instance to get the fields\n        from\n    :param ignore_auto: ignore any fields of type AutoField. Defaults to True\n    :param ignore_relations: ignore any fields that involve relations such as\n        the ForeignKey or ManyToManyField\n    :param exclude: exclude anything in this list from the results\n\n    :returns: generator of found field names"
        ],
        [
            "Register all HTTP error code error handlers\n\n    Currently, errors are handled by the JSON error handler."
        ],
        [
            "Plots but automatically resizes x axis.\n\n    .. versionadded:: 1.4\n\n    Parameters\n    ----------\n    args\n        Passed on to :meth:`matplotlib.axis.Axis.plot`.\n    ax : :class:`matplotlib.axis.Axis`, optional\n        The axis to plot to.\n    kwargs\n        Passed on to :meth:`matplotlib.axis.Axis.plot`."
        ],
        [
            "Create a vector of values over an interval with a specified step size.\n\n    Parameters\n    ----------\n\n    start : float\n        The beginning of the interval.\n    stop : float\n        The end of the interval.\n    step : float\n        The step size.\n\n    Returns\n    -------\n    vector : :class:`numpy.ndarray`\n        The vector of values."
        ],
        [
            "Passes the selected course as the first argument to func."
        ],
        [
            "Passes the selected exercise as the first argument to func."
        ],
        [
            "If func returns False the program exits immediately."
        ],
        [
            "Configure tmc.py to use your account."
        ],
        [
            "Download the exercises from the server."
        ],
        [
            "Go to the next exercise."
        ],
        [
            "Spawns a process with `command path-of-exercise`"
        ],
        [
            "Select a course or an exercise."
        ],
        [
            "Submit the selected exercise to the server."
        ],
        [
            "Sends the selected exercise to the TMC pastebin."
        ],
        [
            "Update the data of courses and or exercises from server."
        ],
        [
            "Determine the type of x"
        ],
        [
            "map for a directory"
        ],
        [
            "Apply the types on the elements of the line"
        ],
        [
            "Convert a file to a .csv file"
        ],
        [
            "Returns a link to the django admin change list with a filter set to\n    only the object given.\n\n    :param obj:\n        Object to create the admin change list display link for\n    :param display:\n        Text to display in the link.  Defaults to string call of the object\n    :returns:\n        Text containing HTML for a link"
        ],
        [
            "Returns string representation of an object, either the default or based\n    on the display template passed in."
        ],
        [
            "Adds a ``list_display`` attribute that appears as a link to the\n        django admin change page for the type of object being shown. Supports\n        double underscore attribute name dereferencing.\n\n        :param attr:\n            Name of the attribute to dereference from the corresponding\n            object, i.e. what will be lined to.  This name supports double\n            underscore object link referencing for ``models.ForeignKey``\n            members.\n\n        :param title:\n            Title for the column of the django admin table.  If not given it\n            defaults to a capitalized version of ``attr``\n\n        :param display:\n            What to display as the text for the link being shown.  If not\n            given it defaults to the string representation of the object for\n            the row: ``str(obj)`` .  This parameter supports django\n            templating, the context for which contains a dictionary key named\n            \"obj\" with the value being the object for the row.\n\n        Example usage:\n\n        .. code-block:: python\n\n            # ---- admin.py file ----\n\n            base = fancy_modeladmin('id')\n            base.add_link('author', 'Our Authors',\n                '{{obj.name}} (id={{obj.id}})')\n\n            @admin.register(Book)\n            class BookAdmin(base):\n                pass\n\n        The django admin change page for the Book class would have a column\n        for \"id\" and another titled \"Our Authors\". The \"Our Authors\" column\n        would have a link for each Author object referenced by \"book.author\".\n        The link would go to the Author django admin change listing. The\n        display of the link would be the name of the author with the id in\n        brakcets, e.g. \"Douglas Adams (id=42)\""
        ],
        [
            "Adds a ``list_display`` attribute showing an object.  Supports\n        double underscore attribute name dereferencing.\n\n        :param attr:\n            Name of the attribute to dereference from the corresponding\n            object, i.e. what will be lined to.  This name supports double\n            underscore object link referencing for ``models.ForeignKey``\n            members.\n\n        :param title:\n            Title for the column of the django admin table.  If not given it\n            defaults to a capitalized version of ``attr``\n\n        :param display:\n            What to display as the text for the link being shown.  If not\n            given it defaults to the string representation of the object for\n            the row: ``str(obj)``.  This parameter supports django templating,\n            the context for which contains a dictionary key named \"obj\" with\n            the value being the object for the row."
        ],
        [
            "Adds a ``list_display`` attribute showing a field in the object\n        using a python %formatted string.\n\n        :param field:\n            Name of the field in the object.\n\n        :param format_string:\n            A old-style (to remain python 2.x compatible) % string formatter\n            with a single variable reference. The named ``field`` attribute\n            will be passed to the formatter using the \"%\" operator. \n\n        :param title:\n            Title for the column of the django admin table.  If not given it\n            defaults to a capitalized version of ``field``"
        ],
        [
            "View decorator that enforces that the method was called using POST.\n    This decorator can be called with or without parameters.  As it is\n    expected to wrap a view, the first argument of the method being wrapped is\n    expected to be a ``request`` object.\n\n    .. code-block:: python\n\n        @post_required\n        def some_view(request):\n            pass\n\n\n        @post_required(['firstname', 'lastname'])\n        def some_view(request):\n            pass\n\n    The optional parameter contains a single list which specifies the names of\n    the expected fields in the POST dictionary.  The list is not exclusive,\n    you can pass in fields that are not checked by the decorator.\n\n    :param options:\n        List of the names of expected POST keys."
        ],
        [
            "View decorator that enforces that the method was called using POST and\n    contains a field containing a JSON dictionary. This method should\n    only be used to wrap views and assumes the first argument of the method\n    being wrapped is a ``request`` object.\n\n    .. code-block:: python\n\n        @json_post_required('data', 'json_data')\n        def some_view(request):\n            username = request.json_data['username']\n\n    :param field:\n        The name of the POST field that contains a JSON dictionary\n    :param request_name:\n        [optional] Name of the parameter on the request to put the\n        deserialized JSON data. If not given the field name is used"
        ],
        [
            "Divergence of matched beam"
        ],
        [
            "The plasma density in SI units."
        ],
        [
            "Semver tag triggered deployment helper"
        ],
        [
            "Performs some environment checks prior to the program's execution"
        ],
        [
            "Prints latest tag's information"
        ],
        [
            "Prompts user before proceeding"
        ],
        [
            "Gets an array from datasets.\n\n    .. versionadded:: 1.4"
        ],
        [
            "Get the current directory state"
        ],
        [
            "Add one tick to progress bar"
        ],
        [
            "Push k to the top of the list\n\n        >>> l = DLL()\n        >>> l.push(1)\n        >>> l\n        [1]\n        >>> l.push(2)\n        >>> l\n        [2, 1]\n        >>> l.push(3)\n        >>> l\n        [3, 2, 1]"
        ],
        [
            "Call this method to increment the named counter.  This is atomic on\n        the database.\n\n        :param name:\n            Name for a previously created ``Counter`` object"
        ],
        [
            "print loading message on screen\n\n        .. note::\n\n            loading message only write to `sys.stdout`\n\n\n        :param int wait: seconds to wait\n        :param str message: message to print\n        :return: None"
        ],
        [
            "print warn type message,\n        if file handle is `sys.stdout`, print color message\n\n\n        :param str message: message to print\n        :param file fh: file handle,default is `sys.stdout`\n        :param str prefix: message prefix,default is `[warn]`\n        :param str suffix: message suffix ,default is `...`\n        :return: None"
        ],
        [
            "print error type message\n        if file handle is `sys.stderr`, print color message\n\n        :param str message: message to print\n        :param file fh: file handle, default is `sys.stdout`\n        :param str prefix: message prefix,default is `[error]`\n        :param str suffix: message suffix ,default is '...'\n        :return: None"
        ],
        [
            "a built-in wrapper make dry-run easier.\n        you should use this instead use `os.system`\n\n        .. note::\n\n            to use it,you need add '--dry-run' option in\n            your argparser options\n\n\n        :param str cmd: command to execute\n        :param bool fake_code: only display command\n            when is True,default is False\n        :return:"
        ],
        [
            "Returns a Corrected URL to be used for a Request\n        as per the REST API."
        ],
        [
            "Main method.\n\n    This method holds what you want to execute when\n    the script is run on command line."
        ],
        [
            "Pickle and compress."
        ],
        [
            "Decompress and unpickle."
        ],
        [
            "Displays the contact form and sends the email"
        ],
        [
            "try use gitconfig info.\n        author,email etc."
        ],
        [
            "Init project."
        ],
        [
            "In general, you don't need to overwrite this method.\n\n        :param options:\n        :return:"
        ],
        [
            "Return a new filename to use as the combined file name for a\n    bunch of files, based on the SHA of their contents.\n    A precondition is that they all have the same file extension\n\n    Given that the list of files can have different paths, we aim to use the\n    most common path.\n\n    Example:\n      /somewhere/else/foo.js\n      /somewhere/bar.js\n      /somewhere/different/too/foobar.js\n    The result will be\n      /somewhere/148713695b4a4b9083e506086f061f9c.js\n\n    Another thing to note, if the filenames have timestamps in them, combine\n    them all and use the highest timestamp."
        ],
        [
            "Extract the oritentation EXIF tag from the image, which should be a PIL Image instance,\n    and if there is an orientation tag that would rotate the image, apply that rotation to\n    the Image instance given to do an in-place rotation.\n\n    :param Image im: Image instance to inspect\n    :return: A possibly transposed image instance"
        ],
        [
            "Start a new piece"
        ],
        [
            "Start a new site."
        ],
        [
            "Publish the site"
        ],
        [
            "Returns a list of the branches"
        ],
        [
            "Returns the currently active branch"
        ],
        [
            "Create a patch between tags"
        ],
        [
            "Create a callable that applies ``func`` to a value in a sequence.\n\n    If the value is not a sequence or is an empty sequence then ``None`` is\n    returned.\n\n    :type  func: `callable`\n    :param func: Callable to be applied to each result.\n\n    :type  n: `int`\n    :param n: Index of the value to apply ``func`` to."
        ],
        [
            "Create a callable that applies ``func`` to every value in a sequence.\n\n    If the value is not a sequence then an empty list is returned.\n\n    :type  func: `callable`\n    :param func: Callable to be applied to the first result."
        ],
        [
            "Parse a value as text.\n\n    :type  value: `unicode` or `bytes`\n    :param value: Text value to parse\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat ``bytes`` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `unicode`\n    :return: Parsed text or ``None`` if ``value`` is neither `bytes` nor\n        `unicode`."
        ],
        [
            "Parse a value as an integer.\n\n    :type  value: `unicode` or `bytes`\n    :param value: Text value to parse\n\n    :type  base: `unicode` or `bytes`\n    :param base: Base to assume ``value`` is specified in.\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat ``bytes`` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `int`\n    :return: Parsed integer or ``None`` if ``value`` could not be parsed as an\n        integer."
        ],
        [
            "Parse a value as a boolean.\n\n    :type  value: `unicode` or `bytes`\n    :param value: Text value to parse.\n\n    :type  true: `tuple` of `unicode`\n    :param true: Values to compare, ignoring case, for ``True`` values.\n\n    :type  false: `tuple` of `unicode`\n    :param false: Values to compare, ignoring case, for ``False`` values.\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat `bytes` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `bool`\n    :return: Parsed boolean or ``None`` if ``value`` did not match ``true`` or\n        ``false`` values."
        ],
        [
            "Parse a value as a delimited list.\n\n    :type  value: `unicode` or `bytes`\n    :param value: Text value to parse.\n\n    :type  parser: `callable` taking a `unicode` parameter\n    :param parser: Callable to map over the delimited text values.\n\n    :type  delimiter: `unicode`\n    :param delimiter: Delimiter text.\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat `bytes` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `list`\n    :return: List of parsed values."
        ],
        [
            "Parse a value as a POSIX timestamp in seconds.\n\n    :type  value: `unicode` or `bytes`\n    :param value: Text value to parse, which should be the number of seconds\n        since the epoch.\n\n    :type  _divisor: `float`\n    :param _divisor: Number to divide the value by.\n\n    :type  tz: `tzinfo`\n    :param tz: Timezone, defaults to UTC.\n\n    :type  encoding: `bytes`\n    :param encoding: Encoding to treat `bytes` values as, defaults to\n        ``utf-8``.\n\n    :rtype: `datetime.datetime`\n    :return: Parsed datetime or ``None`` if ``value`` could not be parsed."
        ],
        [
            "Parse query parameters.\n\n    :type  expected: `dict` mapping `bytes` to `callable`\n    :param expected: Mapping of query argument names to argument parsing\n        callables.\n\n    :type  query: `dict` mapping `bytes` to `list` of `bytes`\n    :param query: Mapping of query argument names to lists of argument values,\n        this is the form that Twisted Web's `IRequest.args\n        <twisted:twisted.web.iweb.IRequest.args>` value takes.\n\n    :rtype: `dict` mapping `bytes` to `object`\n    :return: Mapping of query argument names to parsed argument values."
        ],
        [
            "Put metrics to cloudwatch. Metric shoult be instance or list of\n        instances of CloudWatchMetric"
        ],
        [
            "Render a given resource.\n\n    See `IResource.render <twisted:twisted.web.resource.IResource.render>`."
        ],
        [
            "Adapt a result to `IResource`.\n\n        Several adaptions are tried they are, in order: ``None``,\n        `IRenderable <twisted:twisted.web.iweb.IRenderable>`, `IResource\n        <twisted:twisted.web.resource.IResource>`, and `URLPath\n        <twisted:twisted.python.urlpath.URLPath>`. Anything else is returned as\n        is.\n\n        A `URLPath <twisted:twisted.python.urlpath.URLPath>` is treated as\n        a redirect."
        ],
        [
            "Handle the result from `IResource.render`.\n\n        If the result is a `Deferred` then return `NOT_DONE_YET` and add\n        a callback to write the result to the request when it arrives."
        ],
        [
            "Negotiate a handler based on the content types acceptable to the\n        client.\n\n        :rtype: 2-`tuple` of `twisted.web.iweb.IResource` and `bytes`\n        :return: Pair of a resource and the content type."
        ],
        [
            "Parse and sort an ``Accept`` header.\n\n    The header is sorted according to the ``q`` parameter for each header value.\n\n    @rtype: `OrderedDict` mapping `bytes` to `dict`\n    @return: Mapping of media types to header parameters."
        ],
        [
            "Split an HTTP header whose components are separated with commas.\n\n    Each component is then split on semicolons and the component arguments\n    converted into a `dict`.\n\n    @return: `list` of 2-`tuple` of `bytes`, `dict`\n    @return: List of header arguments and mapping of component argument names\n        to values."
        ],
        [
            "Extract an encoding from a ``Content-Type`` header.\n\n    @type  requestHeaders: `twisted.web.http_headers.Headers`\n    @param requestHeaders: Request headers.\n\n    @type  encoding: `bytes`\n    @param encoding: Default encoding to assume if the ``Content-Type``\n        header is lacking one. Defaults to ``UTF-8``.\n\n    @rtype: `bytes`\n    @return: Content encoding."
        ],
        [
            "Create a nil-safe callable decorator.\n\n    If the wrapped callable receives ``None`` as its argument, it will return\n    ``None`` immediately."
        ],
        [
            "Get or set `Settings._wrapped`\n\n    :param str path: a python module file,\n        if user set it,write config to `Settings._wrapped`\n    :param str with_path: search path\n    :return: A instance of `Settings`"
        ],
        [
            "bind user variable to `_wrapped`\n\n        .. note::\n\n            you don't need call this method by yourself.\n\n            program will call it in  `cliez.parser.parse`\n\n\n        .. expection::\n\n            if path is not correct,will cause an `ImportError`\n\n\n        :param str mod_path: module path, *use dot style,'mod.mod1'*\n        :param str with_path: add path to `sys.path`,\n            if path is file,use its parent.\n        :return: A instance of `Settings`"
        ],
        [
            "Get the version from version module without importing more than\n    necessary."
        ],
        [
            "send a transaction immediately. Failed transactions are picked up by the TxBroadcaster\n\n        :param ip: specific peer IP to send tx to\n        :param port: port of specific peer\n        :param use_open_peers: use Arky's broadcast method"
        ],
        [
            "check if a tx is confirmed, else resend it.\n\n        :param use_open_peers: select random peers fro api/peers endpoint"
        ],
        [
            "Get sub-command list\n\n    .. note::\n\n        Don't use logger handle this function errors.\n\n        Because the error should be a code error,not runtime error.\n\n\n    :return: `list` matched sub-parser"
        ],
        [
            "Add class options to argparser options.\n\n    :param cliez.component.Component klass: subclass of Component\n    :param Namespace sub_parsers:\n    :param str default_epilog: default_epilog\n    :param list general_arguments: global options, defined by user\n    :return: Namespace subparser"
        ],
        [
            "parser cliez app\n\n    :param argparse.ArgumentParser parser: an instance\n        of argparse.ArgumentParser\n    :param argv: argument list,default is `sys.argv`\n    :type argv: list or tuple\n\n    :param str settings: settings option name,\n        default is settings.\n\n    :param object no_args_func: a callable object.if no sub-parser matched,\n        parser will call it.\n\n    :return:  an instance of `cliez.component.Component` or its subclass"
        ],
        [
            "Convert Hump style to underscore\n\n    :param name: Hump Character\n    :return: str"
        ],
        [
            "Fetches fuel prices for all stations."
        ],
        [
            "Gets the fuel prices for a specific fuel station."
        ],
        [
            "Gets all the fuel prices within the specified radius."
        ],
        [
            "Gets the fuel price trends for the given location and fuel types."
        ],
        [
            "Fetches API reference data.\n\n        :param modified_since: The response will be empty if no\n        changes have been made to the reference data since this\n        timestamp, otherwise all reference data will be returned."
        ],
        [
            "Called before template is applied."
        ],
        [
            "Match a route parameter.\n\n    `Any` is a synonym for `Text`.\n\n    :type  name: `bytes`\n    :param name: Route parameter name.\n\n    :type  encoding: `bytes`\n    :param encoding: Default encoding to assume if the ``Content-Type``\n        header is lacking one.\n\n    :return: ``callable`` suitable for use with `route` or `subroute`."
        ],
        [
            "Match an integer route parameter.\n\n    :type  name: `bytes`\n    :param name: Route parameter name.\n\n    :type  base: `int`\n    :param base: Base to interpret the value in.\n\n    :type  encoding: `bytes`\n    :param encoding: Default encoding to assume if the ``Content-Type``\n        header is lacking one.\n\n    :return: ``callable`` suitable for use with `route` or `subroute`."
        ],
        [
            "Match a request path against our path components.\n\n    The path components are always matched relative to their parent is in the\n    resource hierarchy, in other words it is only possible to match URIs nested\n    more deeply than the parent resource.\n\n    :type  components: ``iterable`` of `bytes` or `callable`\n    :param components: Iterable of path components, to match against the\n        request, either static strings or dynamic parameters. As a convenience,\n        a single `bytes` component containing ``/`` may be given instead of\n        manually separating the components. If no components are given the null\n        route is matched, this is the case where ``segments`` is empty.\n\n    :type  segments: ``sequence`` of `bytes`\n    :param segments: Sequence of path segments, from the request, to match\n        against.\n\n    :type  partialMatching: `bool`\n    :param partialMatching: Allow partial matching against the request path?\n\n    :rtype: 2-`tuple` of `dict` keyed on `bytes` and `list` of `bytes`\n    :return: Pair of parameter results, mapping parameter names to processed\n        values, and a list of the remaining request path segments. If there is\n        no route match the result will be ``None`` and the original request path\n        segments."
        ],
        [
            "Decorate a router-producing callable to instead produce a resource.\n\n    This simply produces a new callable that invokes the original callable, and\n    calls ``resource`` on the ``routerAttribute``.\n\n    If the router producer has multiple routers the attribute can be altered to\n    choose the appropriate one, for example:\n\n    .. code-block:: python\n\n        class _ComplexRouter(object):\n            router = Router()\n            privateRouter = Router()\n\n            @router.route('/')\n            def publicRoot(self, request, params):\n                return SomethingPublic(...)\n\n            @privateRouter.route('/')\n            def privateRoot(self, request, params):\n                return SomethingPrivate(...)\n\n        PublicResource = routedResource(_ComplexRouter)\n        PrivateResource = routedResource(_ComplexRouter, 'privateRouter')\n\n    :type  f: ``callable``\n    :param f: Callable producing an object with a `Router` attribute, for\n        example, a type.\n\n    :type  routerAttribute: `str`\n    :param routerAttribute: Name of the `Router` attribute on the result of\n        calling ``f``.\n\n    :rtype: `callable`\n    :return: Callable producing an `IResource`."
        ],
        [
            "Create a new `Router` instance, with it's own set of routes, for\n        ``obj``."
        ],
        [
            "Add a route handler and matcher to the collection of possible routes."
        ],
        [
            "See `txspinneret.route.route`.\n\n        This decorator can be stacked with itself to specify multiple routes\n        with a single handler."
        ],
        [
            "See `txspinneret.route.subroute`.\n\n        This decorator can be stacked with itself to specify multiple routes\n        with a single handler."
        ],
        [
            "Create a NamedTemporaryFile instance to be passed to atomic_writer"
        ],
        [
            "Open a NamedTemoraryFile handle in a context manager"
        ],
        [
            "Read entry from JSON file"
        ],
        [
            "Save entry to JSON file"
        ],
        [
            "Update entry by UUID in the JSON file"
        ],
        [
            "Get the number of the shell command."
        ],
        [
            "Execute a shell command."
        ],
        [
            "Simple program that creates an temp S3 link."
        ],
        [
            "Poll ``self.stdout`` and return True if it is readable.\n\n        :param float timeout: seconds to wait I/O\n        :return: True if readable, else False\n        :rtype: boolean"
        ],
        [
            "Retrieve a list of characters and escape codes where each escape\n        code uses only one index. The indexes will not match up with the\n        indexes in the original string."
        ],
        [
            "Strip all color codes from a string.\n        Returns empty string for \"falsey\" inputs."
        ],
        [
            "Called when builder group collect files\n        Resolves absolute url if relative passed\n\n        :type asset: static_bundle.builders.Asset\n        :type builder: static_bundle.builders.StandardBuilder"
        ],
        [
            "Add single file or list of files to bundle\n\n        :type: file_path: str|unicode"
        ],
        [
            "Add directory or directories list to bundle\n\n        :param exclusions: List of excluded paths\n\n        :type path: str|unicode\n        :type exclusions: list"
        ],
        [
            "Add custom path objects\n\n        :type: path_object: static_bundle.paths.AbstractPath"
        ],
        [
            "Add prepare handler to bundle\n\n        :type: prepare_handler: static_bundle.handlers.AbstractPrepareHandler"
        ],
        [
            "Called when builder run collect files in builder group\n\n        :rtype: list[static_bundle.files.StaticFileResult]"
        ],
        [
            "Get the number of files in the folder."
        ],
        [
            "Register the contents as JSON"
        ],
        [
            "Translate the data with the translation table"
        ],
        [
            "Get the data in JSON form"
        ],
        [
            "Get the data as JSON tuples"
        ],
        [
            "Issues a GET request against the API, properly formatting the params\n\n        :param url: a string, the url you are requesting\n        :param params: a dict, the key-value of all the paramaters needed\n                       in the request\n        :returns: a dict parsed of the JSON response"
        ],
        [
            "Issues a POST request against the API, allows for multipart data uploads\n\n        :param url: a string, the url you are requesting\n        :param params: a dict, the key-value of all the parameters needed\n                       in the request\n        :param files: a list, the list of tuples of files\n\n        :returns: a dict parsed of the JSON response"
        ],
        [
            "Go through the env var map, transferring the values to this object\n        as attributes.\n\n        :raises: RuntimeError if a required env var isn't defined."
        ],
        [
            "Create a temporary directory with input data for the test.\n    The directory contents is copied from a directory with the same name as the module located in the same directory of\n    the test module."
        ],
        [
            "Compare two files contents. If the files differ, show the diff and write a nice HTML\n        diff file into the data directory.\n\n        Searches for the filenames both inside and outside the data directory (in that order).\n\n        :param unicode obtained_fn: basename to obtained file into the data directory, or full path.\n\n        :param unicode expected_fn: basename to expected file into the data directory, or full path.\n\n        :param bool binary:\n            Thread both files as binary files.\n\n        :param unicode encoding:\n            File's encoding. If not None, contents obtained from file will be decoded using this\n            `encoding`.\n\n        :param callable fix_callback:\n            A callback to \"fix\" the contents of the obtained (first) file.\n            This callback receives a list of strings (lines) and must also return a list of lines,\n            changed as needed.\n            The resulting lines will be used to compare with the contents of expected_fn.\n\n        :param bool binary:\n            .. seealso:: zerotk.easyfs.GetFileContents"
        ],
        [
            "Returns a nice side-by-side diff of the given files, as a string."
        ],
        [
            "Add a peer or multiple peers to the PEERS variable, takes a single string or a list.\n\n        :param peer(list or string)"
        ],
        [
            "remove one or multiple peers from PEERS variable\n\n        :param peer(list or string):"
        ],
        [
            "check the status of the network and the peers\n\n        :return: network_height, peer_status"
        ],
        [
            "broadcasts a transaction to the peerslist using ark-js library"
        ],
        [
            "Exposes a given service to this API."
        ],
        [
            "Main entry point, expects doctopt arg dict as argd."
        ],
        [
            "Print a message only if DEBUG is truthy."
        ],
        [
            "Parse a string as an integer.\n        Exit with a message on failure."
        ],
        [
            "If `s` is a file name, read the file and return it's content.\n        Otherwise, return the original string.\n        Returns None if the file was opened, but errored during reading."
        ],
        [
            "Wait for response until timeout.\n        If timeout is specified to None, ``self.timeout`` is used.\n\n        :param float timeout: seconds to wait I/O"
        ],
        [
            "If the file-object is not seekable, return  ArchiveTemp of the fileobject,\n    otherwise return the file-object itself"
        ],
        [
            "Setup before_request, after_request handlers for tracing."
        ],
        [
            "Records the starting time of this reqeust."
        ],
        [
            "Calculates the request duration, and adds a transaction\n        ID to the header."
        ],
        [
            "Insert spaces between words until it is wide enough for `width`."
        ],
        [
            "Prepend or append text to lines. Yields each line."
        ],
        [
            "Format block by splitting on individual characters."
        ],
        [
            "Format block by wrapping on spaces."
        ],
        [
            "Remove spaces in between words until it is small enough for\n            `width`.\n            This will always leave at least one space between words,\n            so it may not be able to get below `width` characters."
        ],
        [
            "Check IP trough the httpBL API\n\n        :param ip: ipv4 ip address\n        :return: httpBL results or None if any error is occurred"
        ],
        [
            "Check if IP is a threat\n\n        :param result: httpBL results; if None, then results from last check_ip() used (optional)\n        :param harmless_age: harmless age for check if httpBL age is older (optional)\n        :param threat_score: threat score for check if httpBL threat is lower (optional)\n        :param threat_type:  threat type, if not equal httpBL score type, then return False (optional)\n        :return: True or False"
        ],
        [
            "Check if IP is suspicious\n\n        :param result: httpBL results; if None, then results from last check_ip() used (optional)\n        :return: True or False"
        ],
        [
            "Invalidate httpBL cache for IP address\n\n        :param ip: ipv4 IP address"
        ],
        [
            "Invalidate httpBL cache"
        ],
        [
            "Runs the consumer."
        ],
        [
            "Upload the next batch of items, return whether successful."
        ],
        [
            "Return the next batch of items to upload."
        ],
        [
            "Get a single item from the queue."
        ],
        [
            "Attempt to upload the batch and retry before raising an error"
        ],
        [
            "Translate camelCase into underscore format.\n\n    >>> _camelcase_to_underscore('minutesBetweenSummaries')\n    'minutes_between_summaries'"
        ],
        [
            "Creates the Trello endpoint tree.\n\n    >>> r = {'1': { \\\n                 'actions': {'METHODS': {'GET'}}, \\\n                 'boards': { \\\n                     'members': {'METHODS': {'DELETE'}}}} \\\n            }\n    >>> r == create_tree([ \\\n                 'GET /1/actions/[idAction]', \\\n                 'DELETE /1/boards/[board_id]/members/[idMember]'])\n    True"
        ],
        [
            "Prints the complete YAML."
        ],
        [
            "Connect by wmi and run wql."
        ],
        [
            "Wrapper for the other log methods, decide which one based on the\n        URL parameter."
        ],
        [
            "Write to a local log file"
        ],
        [
            "Write to a remote host via HTTP POST"
        ],
        [
            "Helper method to store username and password"
        ],
        [
            "Set connection parameters. Call set_connection with no arguments to clear."
        ],
        [
            "Set delegate parameters. Call set_delegate with no arguments to clear."
        ],
        [
            "Takes a single address and returns the current balance."
        ],
        [
            "returns a list of named tuples,  x.timestamp, x.amount including block rewards"
        ],
        [
            "Massages the 'true' and 'false' strings to bool equivalents.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :rtype: bool\n    :return: True or False, depending on the value."
        ],
        [
            "If the value is ``None``, fail validation.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :raises: ValueError if the config value is None."
        ],
        [
            "Make sure the value evaluates to boolean True.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :raises: ValueError if the config value evaluates to boolean False."
        ],
        [
            "Convert an evar value into a Python logging level constant.\n\n    :param str config_val: The env var value.\n    :param EnvironmentVariable evar: The EVar object we are validating\n        a value for.\n    :return: A validated string.\n    :raises: ValueError if the log level is invalid."
        ],
        [
            "Register a new range type as a PostgreSQL range.\n\n        >>> register_range_type(\"int4range\", intrange, conn)\n\n    The above will make sure intrange is regarded as an int4range for queries\n    and that int4ranges will be cast into intrange when fetching rows.\n\n    pgrange should be the full name including schema for the custom range type.\n\n    Note that adaption is global, meaning if a range type is passed to a regular\n    psycopg2 connection it will adapt it to its proper range type. Parsing of\n    rows from the database however is not global and just set on a per connection\n    basis."
        ],
        [
            "Acquires the correct error for a given response.\n\n  :param requests.Response response: HTTP error response\n  :returns: the appropriate error for a given response\n  :rtype: APIError"
        ],
        [
            "Converts the request parameters to Python.\n\n    :param request: <pyramid.request.Request> || <dict>\n\n    :return: <dict>"
        ],
        [
            "Extracts ORB context information from the request.\n\n    :param request: <pyramid.request.Request>\n    :param model: <orb.Model> || None\n\n    :return: {<str> key: <variant> value} values, <orb.Context>"
        ],
        [
            "Handles real-time updates to the order book."
        ],
        [
            "Used exclusively as a thread which keeps the WebSocket alive."
        ],
        [
            "Connects and subscribes to the WebSocket Feed."
        ],
        [
            "Marks a view function as being exempt from the cached httpbl view protection."
        ],
        [
            "Hook point for overriding how the CounterPool gets its connection to\n        AWS."
        ],
        [
            "Hook point for overriding how the CounterPool determines the schema\n        to be used when creating a missing table."
        ],
        [
            "Hook point for overriding how the CounterPool creates a new table\n        in DynamooDB"
        ],
        [
            "Hook point for overriding how the CounterPool transforms table_name\n        into a boto DynamoDB Table object."
        ],
        [
            "Hook point for overriding how the CouterPool creates a DynamoDB item\n        for a given counter when an existing item can't be found."
        ],
        [
            "Hook point for overriding how the CouterPool fetches a DynamoDB item\n        for a given counter."
        ],
        [
            "Gets the DynamoDB item behind a counter and ties it to a Counter\n        instace."
        ],
        [
            "Use an event to build a many-to-one relationship on a class.\n\n    This makes use of the :meth:`.References._reference_table` method\n    to generate a full foreign key relationship to the remote table."
        ],
        [
            "Use an event to build a one-to-many relationship on a class.\n\n    This makes use of the :meth:`.References._reference_table` method\n    to generate a full foreign key relationship from the remote table."
        ],
        [
            "Djeffify data between tags"
        ],
        [
            "Create a foreign key reference from the local class to the given remote\n        table.\n\n        Adds column references to the declarative class and adds a\n        ForeignKeyConstraint."
        ],
        [
            "Path join helper method\n    Join paths if list passed\n\n    :type path: str|unicode|list\n    :rtype: str|unicode"
        ],
        [
            "Read helper method\n\n    :type file_path: str|unicode\n    :type encoding: str|unicode\n    :rtype: str|unicode"
        ],
        [
            "Write helper method\n\n    :type file_path: str|unicode\n    :type contents: str|unicode\n    :type encoding: str|unicode"
        ],
        [
            "Copy file helper method\n\n    :type src: str|unicode\n    :type dest: str|unicode"
        ],
        [
            "Split file name and extension\n\n    :type path: str|unicode\n    :rtype: one str|unicode"
        ],
        [
            "Helper method for absolute and relative paths resolution\n        Split passed path and return each directory parts\n\n        example: \"/usr/share/dir\"\n        return: [\"usr\", \"share\", \"dir\"]\n\n        @type path: one of (unicode, str)\n        @rtype: list"
        ],
        [
            "Creates fully qualified endpoint URIs.\n\n    :param parts: the string parts that form the request URI"
        ],
        [
            "Makes sure we have proper ISO 8601 time.\n\n    :param time: either already ISO 8601 a string or datetime.datetime\n    :returns: ISO 8601 time\n    :rtype: str"
        ],
        [
            "Returns the given response or raises an APIError for non-2xx responses.\n\n    :param requests.Response response: HTTP response\n    :returns: requested data\n    :rtype: requests.Response\n    :raises APIError: for non-2xx responses"
        ],
        [
            "Checks if a next message is possible.\n\n    :returns: True if a next message is possible, otherwise False\n    :rtype: bool"
        ],
        [
            "Colors text with code and given format"
        ],
        [
            "Registers the given message type in the local database.\n\n    Args:\n      message: a message.Message, to be registered.\n\n    Returns:\n      The provided message."
        ],
        [
            "Insert object before index.\n\n        :param int index: index to insert in\n        :param string value: path to insert"
        ],
        [
            "Parse runtime path representation to list.\n\n        :param string string: runtime path string\n        :return: list of runtime paths\n        :rtype: list of string"
        ],
        [
            "Add some bundle to build group\n\n        :type bundle: static_bundle.bundles.AbstractBundle\n        @rtype: BuildGroup"
        ],
        [
            "Return collected files links\n\n        :rtype: list[static_bundle.files.StaticFileResult]"
        ],
        [
            "Asset minifier\n        Uses default minifier in bundle if it's not defined\n\n        :rtype: static_bundle.minifiers.DefaultMinifier|None"
        ],
        [
            "Render all includes in asset by names\n\n        :type name: str|unicode\n        :rtype: str|unicode"
        ],
        [
            "Return links without build files"
        ],
        [
            "Coerce everything to strings.\n    All objects representing time get output according to default_date_fmt."
        ],
        [
            "Initialize the zlogger.\n\n    Sets up a rotating file handler to the specified path and file with\n    the given size and backup count limits, sets the default\n    application_name, server_hostname, and default/whitelist fields.\n\n    :param path: path to write the log file\n    :param target: name of the log file\n    :param logger_name: name of the logger (defaults to root)\n    :param level: log level for this logger (defaults to logging.DEBUG)\n    :param maxBytes: size of the file before rotation (default 1MB)\n    :param application_name: app name to add to each log entry\n    :param server_hostname: hostname to add to each log entry\n    :param fields: default/whitelist fields.\n    :type path: string\n    :type target: string\n    :type logger_name: string\n    :type level: int\n    :type maxBytes: int\n    :type backupCount: int\n    :type application_name: string\n    :type server_hostname: string\n    :type fields: dict"
        ],
        [
            "formats a logging.Record into a standard json log entry\n\n        :param record: record to be formatted\n        :type record: logging.Record\n        :return: the formatted json string\n        :rtype: string"
        ],
        [
            "Initialize the model for a Pyramid app.\n\n    Activate this setup using ``config.include('baka_model')``."
        ],
        [
            "Return absolute and relative path for file\n\n        :type root_path: str|unicode\n        :type file_name: str|unicode\n        :type input_dir: str|unicode\n        :rtype: tuple"
        ],
        [
            "Adds an EnumDescriptor to the pool.\n\n    This method also registers the FileDescriptor associated with the message.\n\n    Args:\n      enum_desc: An EnumDescriptor."
        ],
        [
            "Gets the FileDescriptor for the file containing the specified symbol.\n\n    Args:\n      symbol: The name of the symbol to search for.\n\n    Returns:\n      A FileDescriptor that contains the specified symbol.\n\n    Raises:\n      KeyError: if the file can not be found in the pool."
        ],
        [
            "Loads the named descriptor from the pool.\n\n    Args:\n      full_name: The full name of the descriptor to load.\n\n    Returns:\n      The descriptor for the named type."
        ],
        [
            "Loads the named enum descriptor from the pool.\n\n    Args:\n      full_name: The full name of the enum descriptor to load.\n\n    Returns:\n      The enum descriptor for the named type."
        ],
        [
            "Loads the named extension descriptor from the pool.\n\n    Args:\n      full_name: The full name of the extension descriptor to load.\n\n    Returns:\n      A FieldDescriptor, describing the named extension."
        ],
        [
            "Make a protobuf EnumDescriptor given an EnumDescriptorProto protobuf.\n\n    Args:\n      enum_proto: The descriptor_pb2.EnumDescriptorProto protobuf message.\n      package: Optional package name for the new message EnumDescriptor.\n      file_desc: The file containing the enum descriptor.\n      containing_type: The type containing this enum.\n      scope: Scope containing available types.\n\n    Returns:\n      The added descriptor"
        ],
        [
            "Creates a field descriptor from a FieldDescriptorProto.\n\n    For message and enum type fields, this method will do a look up\n    in the pool for the appropriate descriptor for that type. If it\n    is unavailable, it will fall back to the _source function to\n    create it. If this type is still unavailable, construction will\n    fail.\n\n    Args:\n      field_proto: The proto describing the field.\n      message_name: The name of the containing message.\n      index: Index of the field\n      is_extension: Indication that this field is for an extension.\n\n    Returns:\n      An initialized FieldDescriptor object"
        ],
        [
            "Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.\n\n    This function will hook the session to the transaction manager which\n    will take care of committing any changes.\n\n    - When using pyramid_tm it will automatically be committed or aborted\n      depending on whether an exception is raised.\n\n    - When using scripts you should wrap the session in a manager yourself.\n      For example::\n\n          import transaction\n\n          engine = get_engine(settings)\n          session_factory = get_session_factory(engine)\n          with transaction.manager:\n              dbsession = get_tm_session(session_factory, transaction.manager)"
        ],
        [
            "Generate a random string of the specified length.\n\n    The returned string is composed of an alphabet that shouldn't include any\n    characters that are easily mistakeable for one another (I, 1, O, 0), and\n    hopefully won't accidentally contain any English-language curse words."
        ],
        [
            "Require that the named `field` has the right `data_type`"
        ],
        [
            "Forces a flush from the internal queue to the server"
        ],
        [
            "Use all decompressor possible to make the stream"
        ],
        [
            "Manage a Marv site"
        ],
        [
            "Returns a decoder for a MessageSet item.\n\n  The parameter is the _extensions_by_number map for the message class.\n\n  The message set message looks like this:\n    message MessageSet {\n      repeated group Item = 1 {\n        required int32 type_id = 2;\n        required string message = 3;\n      }\n    }"
        ],
        [
            "Flask like implementation of getting the applicaiton name via\n    the filename of the including file"
        ],
        [
            "Given a Python function name, return the function it refers to."
        ],
        [
            "Add a function to the function list, in order."
        ],
        [
            "Return the mapping of a document according to the function list."
        ],
        [
            "Reduce several mapped documents by several reduction functions."
        ],
        [
            "Re-reduce a set of values, with a list of rereduction functions."
        ],
        [
            "Validate...this function is undocumented, but still in CouchDB."
        ],
        [
            "The main function called to handle a request."
        ],
        [
            "Log an event on the CouchDB server."
        ],
        [
            "Generates a universally unique ID.\n    Any arguments only create more randomness."
        ],
        [
            "revoke_token removes the access token from the data_store"
        ],
        [
            "_auth - internal method to ensure the client_id and client_secret passed with\n        the nonce match"
        ],
        [
            "_validate_request_code - internal method for verifying the the given nonce.\n        also removes the nonce from the data_store, as they are intended for\n        one-time use."
        ],
        [
            "_generate_token - internal function for generating randomized alphanumberic\n        strings of a given length"
        ],
        [
            "Merge multiple ordered so that within-ordered order is preserved"
        ],
        [
            "Helps us validate the parameters for the request\n\n    :param valid_options: a list of strings of valid options for the\n                          api request\n    :param params: a dict, the key-value store which we really only care about\n                   the key which has tells us what the user is using for the\n                   API request\n\n    :returns: None or throws an exception if the validation fails"
        ],
        [
            "Get current datetime for every file."
        ],
        [
            "run your main spider here\n        as for branch spider result data, you can return everything or do whatever with it\n        in your own code\n\n        :return: None"
        ],
        [
            "Read version info from a file without importing it"
        ],
        [
            "Make a protobuf Descriptor given a DescriptorProto protobuf.\n\n  Handles nested descriptors. Note that this is limited to the scope of defining\n  a message inside of another message. Composite fields can currently only be\n  resolved if the message is defined in the same scope as the field.\n\n  Args:\n    desc_proto: The descriptor_pb2.DescriptorProto protobuf message.\n    package: Optional package name for the new message Descriptor (string).\n    build_file_if_cpp: Update the C++ descriptor pool if api matches.\n                       Set to False on recursion, so no duplicates are created.\n    syntax: The syntax/semantics that should be used.  Set to \"proto3\" to get\n            proto3 field presence semantics.\n  Returns:\n    A Descriptor for protobuf messages."
        ],
        [
            "Returns the root if this is a nested type, or itself if its the root."
        ],
        [
            "Searches for the specified method, and returns its descriptor."
        ],
        [
            "Converts protobuf message to JSON format.\n\n  Args:\n    message: The protocol buffers message instance to serialize.\n    including_default_value_fields: If True, singular primitive fields,\n        repeated fields, and map fields will always be serialized.  If\n        False, only serialize non-empty fields.  Singular message fields\n        and oneof fields are not affected by this option.\n\n  Returns:\n    A string containing the JSON formatted protocol buffer message."
        ],
        [
            "Converts message to an object according to Proto3 JSON Specification."
        ],
        [
            "Converts Struct message according to Proto3 JSON Specification."
        ],
        [
            "Parses a JSON representation of a protocol message into a message.\n\n  Args:\n    text: Message JSON representation.\n    message: A protocol beffer message to merge into.\n\n  Returns:\n    The same message passed as argument.\n\n  Raises::\n    ParseError: On JSON parsing problems."
        ],
        [
            "Convert field value pairs into regular message.\n\n  Args:\n    js: A JSON object to convert the field value pairs.\n    message: A regular protocol message to record the data.\n\n  Raises:\n    ParseError: In case of problems converting."
        ],
        [
            "Convert a JSON object into a message.\n\n  Args:\n    value: A JSON object.\n    message: A WKT or regular protocol message to record the data.\n\n  Raises:\n    ParseError: In case of convert problems."
        ],
        [
            "Convert a JSON representation into Value message."
        ],
        [
            "Convert a JSON representation into ListValue message."
        ],
        [
            "Convert a JSON representation into Struct message."
        ],
        [
            "Update config options with the provided dictionary of options."
        ],
        [
            "Completes measuring time interval and updates counter."
        ],
        [
            "Converts Duration to string format.\n\n    Returns:\n      A string converted from self. The string format will contains\n      3, 6, or 9 fractional digits depending on the precision required to\n      represent the exact Duration value. For example: \"1s\", \"1.010s\",\n      \"1.000000100s\", \"-3.100s\""
        ],
        [
            "Converts a string to Duration.\n\n    Args:\n      value: A string to be converted. The string must end with 's'. Any\n          fractional digits (or none) are accepted as long as they fit into\n          precision. For example: \"1s\", \"1.01s\", \"1.0000001s\", \"-3.100s\n\n    Raises:\n      ParseError: On parsing problems."
        ],
        [
            "Converts string to FieldMask according to proto3 JSON spec."
        ],
        [
            "Return a CouchDB document, given its ID, revision and database name."
        ],
        [
            "Give reST format README for pypi."
        ],
        [
            "remove records from collection whose parameters match kwargs"
        ],
        [
            "Resolve the URL to this point.\n\n        >>> trello = TrelloAPIV1('APIKEY')\n        >>> trello.batch._url\n        '1/batch'\n        >>> trello.boards(board_id='BOARD_ID')._url\n        '1/boards/BOARD_ID'\n        >>> trello.boards(board_id='BOARD_ID')(field='FIELD')._url\n        '1/boards/BOARD_ID/FIELD'\n        >>> trello.boards(board_id='BOARD_ID').cards(filter='FILTER')._url\n        '1/boards/BOARD_ID/cards/FILTER'"
        ],
        [
            "Makes the HTTP request."
        ],
        [
            "Skips over a field value.\n\n  Args:\n    tokenizer: A tokenizer to parse the field name and values.\n\n  Raises:\n    ParseError: In case an invalid field value is found."
        ],
        [
            "Parses an integer.\n\n  Args:\n    text: The text to parse.\n    is_signed: True if a signed integer must be parsed.\n    is_long: True if a long integer must be parsed.\n\n  Returns:\n    The integer value.\n\n  Raises:\n    ValueError: Thrown Iff the text is not a valid integer."
        ],
        [
            "Convert protobuf message to text format.\n\n    Args:\n      message: The protocol buffers message."
        ],
        [
            "Converts an text representation of a protocol message into a message.\n\n    Args:\n      lines: Lines of a message's text representation.\n      message: A protocol buffer message to merge into.\n\n    Raises:\n      ParseError: On text parsing problems."
        ],
        [
            "Merges a single scalar field into a message.\n\n    Args:\n      tokenizer: A tokenizer to parse the field value.\n      message: The message of which field is a member.\n      field: The descriptor of the field to be merged.\n\n    Raises:\n      ParseError: In case of text parsing problems."
        ],
        [
            "Consumes protocol message field identifier.\n\n    Returns:\n      Identifier string.\n\n    Raises:\n      ParseError: If an identifier couldn't be consumed."
        ],
        [
            "Consumes a signed 32bit integer number.\n\n    Returns:\n      The integer parsed.\n\n    Raises:\n      ParseError: If a signed 32bit integer couldn't be consumed."
        ],
        [
            "Consumes an floating point number.\n\n    Returns:\n      The number parsed.\n\n    Raises:\n      ParseError: If a floating point number couldn't be consumed."
        ],
        [
            "Consumes a boolean value.\n\n    Returns:\n      The bool parsed.\n\n    Raises:\n      ParseError: If a boolean value couldn't be consumed."
        ],
        [
            "Consume one token of a string literal.\n\n    String literals (whether bytes or text) can come in multiple adjacent\n    tokens which are automatically concatenated, like in C or Python.  This\n    method only consumes one token.\n\n    Returns:\n      The token parsed.\n    Raises:\n      ParseError: When the wrong format data is found."
        ],
        [
            "convert ark timestamp to unix timestamp"
        ],
        [
            "Close the connection."
        ],
        [
            "Replace macros with content defined in the config.\n\n        :param content: Markdown content\n\n        :returns: Markdown content without macros"
        ],
        [
            "Return a pathname possibly with a number appended to it so that it is\r\n\tunique in the directory."
        ],
        [
            "Append numbers in sequential order to the filename or folder name\r\n\tNumbers should be appended before the extension on a filename."
        ],
        [
            "Custom version of splitext that doesn't perform splitext on directories"
        ],
        [
            "Set the modified time of a file"
        ],
        [
            "Get the modified time for a file as a datetime instance"
        ],
        [
            "wrap a function that returns a dir, making sure it exists"
        ],
        [
            "Check whether a file is presumed hidden, either because\r\n\tthe pathname starts with dot or because the platform\r\n\tindicates such."
        ],
        [
            "Get closer to your EOL"
        ],
        [
            "Open a connection over the serial line and receive data lines"
        ],
        [
            "create & start main thread\n\n        :return: None"
        ],
        [
            "Scans through all children of node and gathers the\n    text. If node has non-text child-nodes then\n    NotTextNodeError is raised."
        ],
        [
            "Get the number of credits remaining at AmbientSMS"
        ],
        [
            "Send a mesage via the AmbientSMS API server"
        ],
        [
            "Inteface for sending web requests to the AmbientSMS API Server"
        ],
        [
            "Called for each file\n        Must return file content\n        Can be wrapped\n\n        :type f: static_bundle.files.StaticFileResult\n        :type text: str|unicode\n        :rtype: str|unicode"
        ],
        [
            "Return True if the class is a date type."
        ],
        [
            "Convert a date or time to a datetime. If when is a date then it sets the time to midnight. If\n    when is a time it sets the date to the epoch. If when is None or a datetime it returns when.\n    Otherwise a TypeError is raised. Returned datetimes have tzinfo set to None unless when is a\n    datetime with tzinfo set in which case it remains the same."
        ],
        [
            "Return a date, time, or datetime converted to a datetime in the given timezone. If when is a\n    datetime and has no timezone it is assumed to be local time. Date and time objects are also\n    assumed to be UTC. The tz value defaults to UTC. Raise TypeError if when cannot be converted to\n    a datetime."
        ],
        [
            "Return a Unix timestamp in seconds for the provided datetime. The `totz` function is called\n    on the datetime to convert it to the provided timezone. It will be converted to UTC if no\n    timezone is provided."
        ],
        [
            "Return a Unix timestamp in milliseconds for the provided datetime. The `totz` function is\n    called on the datetime to convert it to the provided timezone. It will be converted to UTC if\n    no timezone is provided."
        ],
        [
            "Return the datetime representation of the provided Unix timestamp. By defaults the timestamp is\n    interpreted as UTC. If tzin is set it will be interpreted as this timestamp instead. By default\n    the output datetime will have UTC time. If tzout is set it will be converted in this timezone\n    instead."
        ],
        [
            "Return the Unix timestamp in milliseconds as a datetime object. If tz is set it will be\n    converted to the requested timezone otherwise it defaults to UTC."
        ],
        [
            "Return the datetime truncated to the precision of the provided unit."
        ],
        [
            "Return the date for the day of this week."
        ],
        [
            "Internal function that determines EOL_STYLE_NATIVE constant with the proper value for the\n    current platform."
        ],
        [
            "Normalizes a path maintaining the final slashes.\n\n    Some environment variables need the final slash in order to work.\n\n    Ex. The SOURCES_DIR set by subversion must end with a slash because of the way it is used\n    in the Visual Studio projects.\n\n    :param unicode path:\n        The path to normalize.\n\n    :rtype: unicode\n    :returns:\n        Normalized path"
        ],
        [
            "Returns a version of a path that is unique.\n\n    Given two paths path1 and path2:\n        CanonicalPath(path1) == CanonicalPath(path2) if and only if they represent the same file on\n        the host OS. Takes account of case, slashes and relative paths.\n\n    :param unicode path:\n        The original path.\n\n    :rtype: unicode\n    :returns:\n        The unique path."
        ],
        [
            "Replaces all slashes and backslashes with the target separator\n\n    StandardPath:\n        We are defining that the standard-path is the one with only back-slashes in it, either\n        on Windows or any other platform.\n\n    :param bool strip:\n        If True, removes additional slashes from the end of the path."
        ],
        [
            "Copy a file from source to target.\n\n    :param  source_filename:\n        @see _DoCopyFile\n\n    :param  target_filename:\n        @see _DoCopyFile\n\n    :param bool md5_check:\n        If True, checks md5 files (of both source and target files), if they match, skip this copy\n        and return MD5_SKIP\n\n        Md5 files are assumed to be {source, target} + '.md5'\n\n        If any file is missing (source, target or md5), the copy will always be made.\n\n    :param  copy_symlink:\n        @see _DoCopyFile\n\n    :raises FileAlreadyExistsError:\n        If target_filename already exists, and override is False\n\n    :raises NotImplementedProtocol:\n        If file protocol is not accepted\n\n        Protocols allowed are:\n            source_filename: local, ftp, http\n            target_filename: local, ftp\n\n    :rtype: None | MD5_SKIP\n    :returns:\n        MD5_SKIP if the file was not copied because there was a matching .md5 file\n\n    .. seealso:: FTP LIMITATIONS at this module's doc for performance issues information"
        ],
        [
            "Copy a file locally to a directory.\n\n    :param unicode source_filename:\n        The filename to copy from.\n\n    :param unicode target_filename:\n        The filename to copy to.\n\n    :param bool copy_symlink:\n        If True and source_filename is a symlink, target_filename will also be created as\n        a symlink.\n\n        If False, the file being linked will be copied instead."
        ],
        [
            "Copy files from the given source to the target.\n\n    :param unicode source_dir:\n        A filename, URL or a file mask.\n        Ex.\n            x:\\coilib50\n            x:\\coilib50\\*\n            http://server/directory/file\n            ftp://server/directory/file\n\n\n    :param unicode target_dir:\n        A directory or an URL\n        Ex.\n            d:\\Temp\n            ftp://server/directory\n\n    :param bool create_target_dir:\n        If True, creates the target path if it doesn't exists.\n\n    :param bool md5_check:\n        .. seealso:: CopyFile\n\n    :raises DirectoryNotFoundError:\n        If target_dir does not exist, and create_target_dir is False\n\n    .. seealso:: CopyFile for documentation on accepted protocols\n\n    .. seealso:: FTP LIMITATIONS at this module's doc for performance issues information"
        ],
        [
            "Copies files into directories, according to a file mapping\n\n    :param list(tuple(unicode,unicode)) file_mapping:\n        A list of mappings between the directory in the target and the source.\n        For syntax, @see: ExtendedPathMask\n\n    :rtype: list(tuple(unicode,unicode))\n    :returns:\n        List of files copied. (source_filename, target_filename)\n\n    .. seealso:: FTP LIMITATIONS at this module's doc for performance issues information"
        ],
        [
            "Recursively copy a directory tree.\n\n    :param unicode source_dir:\n        Where files will come from\n\n    :param unicode target_dir:\n        Where files will go to\n\n    :param bool override:\n        If True and target_dir already exists, it will be deleted before copying.\n\n    :raises NotImplementedForRemotePathError:\n        If trying to copy to/from remote directories"
        ],
        [
            "Deletes the given local filename.\n\n    .. note:: If file doesn't exist this method has no effect.\n\n    :param unicode target_filename:\n        A local filename\n\n    :raises NotImplementedForRemotePathError:\n        If trying to delete a non-local path\n\n    :raises FileOnlyActionError:\n        Raised when filename refers to a directory."
        ],
        [
            "Appends content to a local file.\n\n    :param unicode filename:\n\n    :param unicode contents:\n\n    :type eol_style: EOL_STYLE_XXX constant\n    :param eol_style:\n        Replaces the EOL by the appropriate EOL depending on the eol_style value.\n        Considers that all content is using only \"\\n\" as EOL.\n\n    :param unicode encoding:\n        Target file's content encoding.\n        Defaults to sys.getfilesystemencoding()\n\n    :param bool binary:\n        If True, content is appended in binary mode. In this case, `contents` must be `bytes` and not\n        `unicode`\n\n    :raises NotImplementedForRemotePathError:\n        If trying to modify a non-local path\n\n    :raises ValueError:\n        If trying to mix unicode `contents` without `encoding`, or `encoding` without\n        unicode `contents`"
        ],
        [
            "Moves a file.\n\n    :param unicode source_filename:\n\n    :param unicode target_filename:\n\n    :raises NotImplementedForRemotePathError:\n        If trying to operate with non-local files."
        ],
        [
            "Moves a directory.\n\n    :param unicode source_dir:\n\n    :param unicode target_dir:\n\n    :raises NotImplementedError:\n        If trying to move anything other than:\n            Local dir -> local dir\n            FTP dir -> FTP dir (same host)"
        ],
        [
            "Reads a file and returns its contents. Works for both local and remote files.\n\n    :param unicode filename:\n\n    :param bool binary:\n        If True returns the file as is, ignore any EOL conversion.\n\n    :param unicode encoding:\n        File's encoding. If not None, contents obtained from file will be decoded using this\n        `encoding`.\n\n    :param None|''|'\\n'|'\\r'|'\\r\\n' newline:\n        Controls universal newlines.\n        See 'io.open' newline parameter documentation for more details.\n\n    :returns str|unicode:\n        The file's contents.\n        Returns unicode string when `encoding` is not None.\n\n    .. seealso:: FTP LIMITATIONS at this module's doc for performance issues information"
        ],
        [
            "Reads a file and returns its contents as a list of lines. Works for both local and remote files.\n\n    :param unicode filename:\n\n    :param None|''|'\\n'|'\\r'|'\\r\\n' newline:\n        Controls universal newlines.\n        See 'io.open' newline parameter documentation for more details.\n\n    :param unicode encoding:\n        File's encoding. If not None, contents obtained from file will be decoded using this\n        `encoding`.\n\n    :returns list(unicode):\n        The file's lines\n\n    .. seealso:: FTP LIMITATIONS at this module's doc for performance issues information"
        ],
        [
            "Lists the files in the given directory\n\n    :type directory: unicode | unicode\n    :param directory:\n        A directory or URL\n\n    :rtype: list(unicode) | list(unicode)\n    :returns:\n        List of filenames/directories found in the given directory.\n        Returns None if the given directory does not exists.\n\n        If `directory` is a unicode string, all files returned will also be unicode\n\n    :raises NotImplementedProtocol:\n        If file protocol is not local or FTP\n\n    .. seealso:: FTP LIMITATIONS at this module's doc for performance issues information"
        ],
        [
            "Create a file with the given contents.\n\n    :param unicode filename:\n        Filename and path to be created.\n\n    :param unicode contents:\n        The file contents as a string.\n\n    :type eol_style: EOL_STYLE_XXX constant\n    :param eol_style:\n        Replaces the EOL by the appropriate EOL depending on the eol_style value.\n        Considers that all content is using only \"\\n\" as EOL.\n\n    :param bool create_dir:\n        If True, also creates directories needed in filename's path\n\n    :param unicode encoding:\n        Target file's content encoding. Defaults to sys.getfilesystemencoding()\n        Ignored if `binary` = True\n\n    :param bool binary:\n        If True, file is created in binary mode. In this case, `contents` must be `bytes` and not\n        `unicode`\n\n    :return unicode:\n        Returns the name of the file created.\n\n    :raises NotImplementedProtocol:\n        If file protocol is not local or FTP\n\n    :raises ValueError:\n        If trying to mix unicode `contents` without `encoding`, or `encoding` without\n        unicode `contents`\n\n    .. seealso:: FTP LIMITATIONS at this module's doc for performance issues information"
        ],
        [
            "Replaces all occurrences of \"old\" by \"new\" in the given file.\n\n    :param unicode filename:\n        The name of the file.\n\n    :param unicode old:\n        The string to search for.\n\n    :param unicode new:\n        Replacement string.\n\n    :return unicode:\n        The new contents of the file."
        ],
        [
            "Create directory including any missing intermediate directory.\n\n    :param unicode directory:\n\n    :return unicode|urlparse.ParseResult:\n        Returns the created directory or url (see urlparse).\n\n    :raises NotImplementedProtocol:\n        If protocol is not local or FTP.\n\n    .. seealso:: FTP LIMITATIONS at this module's doc for performance issues information"
        ],
        [
            "Deletes a directory.\n\n    :param unicode directory:\n\n    :param bool skip_on_error:\n        If True, ignore any errors when trying to delete directory (for example, directory not\n        found)\n\n    :raises NotImplementedForRemotePathError:\n        If trying to delete a remote directory."
        ],
        [
            "On Windows, returns a list of mapped network drives\n\n    :return: tuple(string, string, bool)\n        For each mapped netword drive, return 3 values tuple:\n            - the local drive\n            - the remote path-\n            - True if the mapping is enabled (warning: not reliable)"
        ],
        [
            "Create a symbolic link at `link_path` pointing to `target_path`.\n\n    :param unicode target_path:\n        Link target\n\n    :param unicode link_path:\n        Fullpath to link name\n\n    :param bool override:\n        If True and `link_path` already exists as a link, that link is overridden."
        ],
        [
            "Read the target of the symbolic link at `path`.\n\n    :param unicode path:\n        Path to a symbolic link\n\n    :returns unicode:\n        Target of a symbolic link"
        ],
        [
            "Checks if a given path is local, raise an exception if not.\n\n    This is used in filesystem functions that do not support remote operations yet.\n\n    :param unicode path:\n\n    :raises NotImplementedForRemotePathError:\n        If the given path is not local"
        ],
        [
            "Replaces eol on each line by the given eol_style.\n\n    :param unicode contents:\n    :type eol_style: EOL_STYLE_XXX constant\n    :param eol_style:"
        ],
        [
            "Verifies if a filename match with given patterns.\n\n    :param str filename: The filename to match.\n    :param list(str) masks: The patterns to search in the filename.\n    :return bool:\n        True if the filename has matched with one pattern, False otherwise."
        ],
        [
            "Searches for files in a given directory that match with the given patterns.\n\n    :param str dir_: the directory root, to search the files.\n    :param list(str) in_filters: a list with patterns to match (default = all). E.g.: ['*.py']\n    :param list(str) out_filters: a list with patterns to ignore (default = none). E.g.: ['*.py']\n    :param bool recursive: if True search in subdirectories, otherwise, just in the root.\n    :param bool include_root_dir: if True, includes the directory being searched in the returned paths\n    :param bool standard_paths: if True, always uses unix path separators \"/\"\n    :return list(str):\n        A list of strings with the files that matched (with the full path in the filesystem)."
        ],
        [
            "os.path.expanduser wrapper, necessary because it cannot handle unicode strings properly.\n\n    This is not necessary in Python 3.\n\n    :param path:\n        .. seealso:: os.path.expanduser"
        ],
        [
            "Helper to iterate over the files in a directory putting those in the passed StringIO in ini\n    format.\n\n    :param unicode directory:\n        The directory for which the hash should be done.\n\n    :param StringIO stringio:\n        The string to which the dump should be put.\n\n    :param unicode base:\n        If provided should be added (along with a '/') before the name=hash of file.\n\n    :param unicode exclude:\n        Pattern to match files to exclude from the hashing. E.g.: *.gz\n\n    :param unicode include:\n        Pattern to match files to include in the hashing. E.g.: *.zip"
        ],
        [
            "Iterator for random hexadecimal hashes\n\n    :param iterator_size:\n        Amount of hashes return before this iterator stops.\n        Goes on forever if `iterator_size` is negative.\n\n    :param int hash_length:\n        Size of each hash returned.\n\n    :return generator(unicode):"
        ],
        [
            "A context manager to replace and restore a value using a getter and setter.\n\n    :param object obj: The object to replace/restore.\n    :param object key: The key to replace/restore in the object.\n    :param object value: The value to replace.\n\n    Example::\n\n      with PushPop2(sys.modules, 'alpha', None):\n        pytest.raises(ImportError):\n          import alpha"
        ],
        [
            "Return the database specifier for a database string.\n    \n    This accepts a database name or URL, and returns a database specifier in the\n    format accepted by ``specifier_to_db``. It is recommended that you consult\n    the documentation for that function for an explanation of the format."
        ],
        [
            "Return a CouchDB database instance from a database string."
        ],
        [
            "Make sure a DB specifier exists, creating it if necessary."
        ],
        [
            "Exclude NoSet objec\n\n    .. code-block::\n\n        >>> coerce(NoSet, 'value')\n        'value'"
        ],
        [
            "Parse a hub key into a dictionary of component parts\n\n    :param key: str, a hub key\n    :returns: dict, hub key split into parts\n    :raises: ValueError"
        ],
        [
            "Raise an exception if string doesn't match a part's regex\n\n    :param string: str\n    :param part: a key in the PARTS dict\n    :raises: ValueError, TypeError"
        ],
        [
            "apply default settings to commands\n            not static, shadow \"self\" in eval"
        ],
        [
            "add commands to parser"
        ],
        [
            "get config for subparser and create commands"
        ],
        [
            "custom command line  action to show version"
        ],
        [
            "custom command line action to check file exist"
        ],
        [
            "Return the consumer and oauth tokens with three-legged OAuth process and\n    save in a yaml file in the user's home directory."
        ],
        [
            "Adds properties for all fields in this protocol message type."
        ],
        [
            "Unpacks Any message and returns the unpacked message.\n\n  This internal method is differnt from public Any Unpack method which takes\n  the target message as argument. _InternalUnpackAny method does not have\n  target message type and need to find the message type in descriptor pool.\n\n  Args:\n    msg: An Any message to be unpacked.\n\n  Returns:\n    The unpacked message."
        ]
    ]
}