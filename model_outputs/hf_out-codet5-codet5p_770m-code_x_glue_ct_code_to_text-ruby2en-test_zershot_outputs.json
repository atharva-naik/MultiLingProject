{
    "accuracy": 0,
    "bleu": {
        "bleu": 0.006174076850064478,
        "precisions": [
            0.04039205800797758,
            0.006923867240429428,
            0.003035332466095486,
            0.0017117374134746769
        ],
        "brevity_penalty": 1.0,
        "length_ratio": 7.349498692240628,
        "translation_length": 67439,
        "reference_length": 9176
    },
    "codebleu": 0,
    "preds": [
        "\nend\n\ndef fans_by_name(name)\n      data = api('user.get_fans_by_name', :name => name)\n      data['fans'].map {|id| User.new(client, :id => id)}\nend\n\ndef fans_by_id(id)\n      data = api('user.get_fans_by_id', :id => id)\n      data['fans'].map {|id| User.new(client, :id => id)}\nend\n\ndef fans_by_id_and_name(id, name)\n      data = api('user.get_fans_by_id_and_name', :id => id, :name => name)\n      data['fans'].map {|id| User.new(client, :id => id)}\nend\n\ndef fans_by_id_and_name_and_id(id, name, id)\n      data = api('user.get_fans_by_id_and_name_and_id', :id => id, :name => name, :id => id)\n      data['fans'].map {|id| User.new(client, :id => id)}\nend\n\ndef fans_by_id_and_name_and_",
        "\n    def stickers_purchased_by_user(user_id)\n      data = api('sticker.get_purchased_stickers_by_user', :user_id => user_id)\n      data['stickers'].map {|sticker_id| Sticker.new(client, :id => sticker_id)}\n    end\n\n    def stickers_purchased_by_user_and_category(user_id, category_id)\n      data = api('sticker.get_purchased_stickers_by_user_and_category', :user_id => user_id, :category_id => category_id)\n      data['stickers'].map {|sticker_id| Sticker.new(client, :id => sticker_id)}\n    end\n\n    def stickers_purchased_by_category(category_id)\n      data = api('sticker.get_purchased_stickers_by_category', :category_id => category_id)\n      data['stickers'].map {|sticker_id| Sticker.new(client, :id => sticker_id)}\n    end\n\n    def stickers_purchased_by_category_and_user(category_id, user",
        "\n    def block_by_id(id)\n      data = api('block.get', id)\n      User.new(client, data['block'])\n    end\n\n    def block_by_name(name)\n      data = api('block.get', name)\n      User.new(client, data['block'])\n    end\n\n    def block_by_description(description)\n      data = api('block.get', description)\n      User.new(client, data['block'])\n    end\n\n    def block_by_state(state)\n      data = api('block.get', state)\n      User.new(client, data['block'])\n    end\n\n    def block_by_state_name(state_name)\n      data = api('block.get', state_name)\n      User.new(client, data['block'])\n    end\n\n    def block_by_state_description(state_description)\n      data = api('block.get', state_description)\n      User.new(client, data['block'])\n    end\n\n    def block_by_state_state(state_state)\n      data = api('block.get', state_state)\n      User.new(client, data['block'])\n    end\n\n    def block_by_state",
        "\n    def update_profile_with_attributes(attributes = {})\n      assert_valid_keys(attributes, :name, :twitter_id, :facebook_url, :website, :about, :top_artists, :hangout)\n\n      # Convert attribute names over to their Turntable equivalent\n      {:twitter_id => :twitter, :facebook_url => :facebook, :top_artists => :topartists}.each do |from, to|\n        attributes[to] = attributes.delete(from) if attributes.has_key?(from)\n      end\n\n      api('user.modify_profile_with_attributes', attributes)\n      self.attributes = attributes\n      true\n    end\n\n    def update_profile_with_attributes_with_ids(attributes = {})\n      assert_valid_keys(attributes, :name, :twitter_id, :facebook_url, :website, :about, :top_artists, :hangout)\n\n      # Convert attribute names over to their Turntable equivalent\n      {:twitter_id => :twitter, :facebook_url => :facebook, :top_artists => :topartists}.each do |from, to|\n        attributes[to] = attributes.delete(from) if attributes.has_key?(from)\n      end\n\n      api",
        "\n    end\n\n    def update_laptop_name(name)\n      assert_valid_values(name, *%w(mac pc linux chrome iphone cake intel android))\n\n      api('user.modify', :laptop => name)\n      self.attributes = {'laptop' => name}\n      true\n    end\n\n    def update_laptop_name_with_id(id)\n      assert_valid_values(id, *%w(mac pc linux chrome iphone cake intel android))\n\n      api('user.modify', :laptop => id)\n      self.attributes = {'laptop' => id}\n      true\n    end\n\n    def update_laptop_name_with_name(name)\n      assert_valid_values(name, *%w(mac pc linux chrome iphone cake intel android))\n\n      api('user.modify', :laptop => name)\n      self.attributes = {'laptop' => name}\n      true\n    end\n\n    def update_laptop_name_with_name_with_id(name, id)\n      assert_valid_values(name, *%w(mac pc linux chrome iphone cake intel android))\n\n      api('user.modify', :",
        "\n    def update_status_with_interval(status = self.status, interval = self.interval)\n      assert_valid_values(status, *%w(available unavailable away))\n\n      now = Time.now.to_i\n      result = api('presence.update', :status => status, :interval => interval)\n\n      client.reset_keepalive(result['interval'])\n      client.clock_delta = ((now + Time.now.to_i) / 2 - result['now']).round\n      self.attributes = {'status' => status, 'interval' => interval}\n\n      true\n    end\n\n    def update_status_with_now(status = self.status, now = self.now)\n      assert_valid_values(status, *%w(available unavailable away))\n\n      now = Time.now.to_i\n      result = api('presence.update', :status => status, :now => now)\n\n      client.reset_keepalive(result['interval'])\n      client.clock_delta = ((now + Time.now.to_i) / 2 - result['now']).round\n      self.attributes = {'status' => status, 'now' => now}\n\n      true\n    end\n\n    def update_status_with_away(status = self.status,",
        "\n      if input.index(/\\s+/).nil?\n        word      = normalize_word input\n        self.word = word unless word == ''\n      elsif input.scan(SENTENCE_DELIMITER).length < 2\n        self.sentence = input.gsub(SENTENCE_DELIMITER, '')\n      else\n        self.passage = input\n      end\n    end\n\n    def normalize_word(input)\n      input.gsub(/\\s+/, ' ').strip\n    end\n\n    def sentence\n      self.sentence.split(SENTENCE_DELIMITER)\n    end\n\n    def word\n      self.word.strip\n    end\n\n    def passage\n      self.passage.strip\n    end\n\n    def sentence_delimiter\n      SENTENCE_DELIMITER\n    end\n\n    def to_s\n      \"#{self.word} #{self.sentence}\"\n    end\n\n    def to_json\n      {\n        'passage' => self.passage,\n        'sentence' => self.sentence,\n        'word' => self.word\n      }\n    end\n\n    def to_yaml\n      YAML.dump(self.to_s)\n    end\n\n    def to_yaml_pretty\n      YAML.dump(self.to_s, pretty_print: true)\n",
        "\n    end\n\n    def weighted_select(type, group)\n      weighted(type, group)\n    end\n\n    def weighted_select_all(type, group)\n      weighted(type, group)\n    end\n\n    def weighted_select_all_with_group(type, group)\n      weighted_select(type, group)\n    end\n\n    def weighted_select_all_with_group_and_type(type, group)\n      weighted_select(type, group)\n    end\n\n    def weighted_select_all_with_type(type, group)\n      weighted_select(type, group)\n    end\n\n    def weighted_select_all_with_type_and_group(type, group)\n      weighted_select(type, group)\n    end\n\n    def weighted_select_all_with_type_and_group_and_type(type, group)\n      weighted_select(type, group)\n    end\n\n    def weighted_select_all_with_type_and_group_and_type_and_group(type, group)\n      weighted_select(type, group)\n    end\n\n    def weighted_select_all_with_type_and_group_and_type_and_group_and_type(type, group)",
        "\n    end\n\n    def conditions_match?(data)\n      data.keys.include?(:conditions)\n    end\n\n    def block\n      @block\n    end\n\n    def logger\n      @logger ||= Logger.new(STDOUT)\n    end\n\nend\n",
        "\n    end\n\n    def conditions_match?(data, conditions)\n      conditions.all? {|(key, value)| data[key] == value }\n    end\n\n    def conditions_match?(data, conditions)\n      conditions.all? {|(key, value)| data[key] == value }\n    end\n\n    def conditions_match?(data, conditions)\n      conditions.all? {|(key, value)| data[key] == value }\n    end\n\n    def conditions_match?(data, conditions)\n      conditions.all? {|(key, value)| data[key] == value }\n    end\n\n    def conditions_match?(data, conditions)\n      conditions.all? {|(key, value)| data[key] == value }\n    end\n\n    def conditions_match?(data, conditions)\n      conditions.all? {|(key, value)| data[key] == value }\n    end\n\n    def conditions_match?(data, conditions)\n      conditions.all? {|(key, value)| data[key] == value }\n    end\n\n    def conditions_match?(data, conditions)\n      conditions.all? {|(key, value)| data[key] == value }\n    end\n\n    def conditions_match?",
        "\n    end\n\n    def remove(storable, *coordinate)\n      validate_type(storable)\n      loc = create_location(coordinate)\n      pos = storable.position || storable.position_class.new\n      pos.location = loc\n      pos.occupant = nil\n      pos.holder = self\n      logger.debug { \"Removed #{storable.qp} from #{qp} at #{loc.coordinate}.\" }\n      update_full_flag\n      self\n    end\n\n    def update_full_flag\n      self.full = true\n    end\n\n    def update_full_flag!\n      self.full = false\n    end\n\n    def update_full_flag_with_position(position)\n      self.full = true\n      self.position = position\n    end\n\n    def update_full_flag_without_position(position)\n      self.full = false\n    end\n\n    def update_full_flag_with_position!(position)\n      self.full = true\n      self.position = position\n    end\n\n    def update_full_flag_without_position!(position)\n      self.full = false\n    end\n\n    def update_full_flag_with_position!(position, &block)\n      self.full = true\n",
        "\n    def copy_container_type_size\n      return unless container_type and container_type.size\n      self.size = cps = container_type.size.copy(:rows, :columns)\n      logger.debug { \"Initialized #{qp} size from #{container_type.qp} size #{cps}.\" }\n      update_full_flag\n      cps\n    end\n\n    def copy_container_type_size_to_full\n      return unless container_type and container_type.size\n      self.size = cps = container_type.size.copy(:rows, :columns)\n      logger.debug { \"Initialized #{qp} size from #{container_type.qp} size #{cps}.\" }\n      update_full_flag\n      cps\n    end\n\n    def copy_container_type_size_to_full_with_size_limit\n      return unless container_type and container_type.size\n      self.size = cps = container_type.size.copy(:rows, :columns)\n      logger.debug { \"Initialized #{qp} size from #{container_type.qp} size #{cps} with size limit #{container_type.size_limit}.\" }\n      update_full_flag\n      cps\n    end\n\n    def copy_container_type_size_to_full_",
        "\n    end\n\n    def save\n      data = api('user.set_pref', self.attributes)\n      self.attributes = data['result']\n      super\n    end\n\n    def delete\n      data = api('user.delete_pref', self.attributes)\n      self.attributes = data['result']\n      super\n    end\n\n    def api(method, *args)\n      api_url = \"#{self.class.api_url}/#{method}\"\n      url = \"#{api_url}?#{args.join('&')}\"\n      response = Net::HTTP.get_response(URI.parse(url))\n      response.body\n    end\n\n    def self.api_url\n      'https://api.github.com/repos/matt-n/matt-n/prefs'\n    end\n\nend\n",
        "\n      File.open(out_file, 'w') do |o|\n        File.new(in_file, 'r').each_with_index do |line, index|\n          extraction = col_filter.process(row_filter.process(line.chomp, row: index))\n          o.puts extraction unless extraction.nil?\n        end\n      end\n    end\n\n    def process(line, row:)\n      line.chomp\n    end\n\n    def col_filter\n      @col_filter ||= ColumnFilter.new\n    end\n\n    def row_filter\n      @row_filter ||= RowFilter.new\n    end\n\n    def out_file\n      @out_file ||= 'out.csv'\n    end\n\n    def in_file\n      @in_file ||= 'in.csv'\n    end\n\n    def output_file\n      @output_file ||= 'out.csv'\n    end\n\n    def output_format\n      @output_format ||= :csv\n    end\n\n    def output_file_format\n      @output_file_format ||= :csv\n    end\n\n    def output_file_extension\n      @output_file_extension ||= '.csv'\n    end\n\n    def output_file_extension_format\n      @output_file_extension",
        "\n  def team(team_id, optional={})\n    region = optional[:region] || @sightstone.region\n    id = if team_id.is_a? Team\n      team_id\n    else\n      team_id\n    end\n    \n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v2.2/team/by-id/#{id}\"\n\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      team = Team.new(data)\n      if block_given?\n        yield team\n      else\n        return team\n      end\n    }\n  end\n\n  def team_by_name(team_name, optional={})\n    region = optional[:region] || @sightstone.region\n    id = if team_name.is_a? Team\n      team_name\n    else\n      team_name\n    end\n    \n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v2.2/team/by-name/#{id}\"\n\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data",
        "\n    def get_doctype_from_file(path)\n      doc_type = nil\n      begin\n        metadata = YAML.load_file(path + 'template.yml')\n        doc_type = metadata['type']\n        if doc_type.nil?\n          say 'Type value not found. Check template.yml in the document directory', :red\n          say 'Make sure there is an entry `type: DOC_TYPE` in the file.'\n          say \"  #{path}\"\n          raise_error('DOC_TYPE not found in template.yml')\n        end\n      rescue Errno::ENOENT # File not found\n        say 'No template.yml found in the document directory. Did you forget to add it?', :red\n        say 'Did you run the command in the directory where the document is located?'\n        say \"  #{path}\"\n        raise_error('template.yml not found')\n      end\n      return doc_type\n    end\n\n    def get_doctype_from_path(path)\n      doc_type = nil\n      begin\n        metadata = YAML.load_file(path + 'template.yml')\n        doc_type = metadata['type']\n        if doc_type.nil?\n          say 'Type value not found. Check template.yml in the document directory', :red\n          say",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\",
        "\n    end\n\n    def span_to_point(spanner)\n      Vector.new((@x - spanner.x).abs, (@y - spanner.y).abs)\n    end\n\n    def span_to_point_with_angle(spanner)\n      Vector.new((@x - spanner.x).abs, (@y - spanner.y).abs, (@angle - spanner.angle).abs)\n    end\n\n    def span_to_point_with_angle_and_angle(spanner)\n      Vector.new((@x - spanner.x).abs, (@y - spanner.y).abs, (@angle - spanner.angle).abs, (@angle - spanner.angle).abs)\n    end\n\n    def span_to_point_with_angle_and_angle_and_angle(spanner)\n      Vector.new((@x - spanner.x).abs, (@y - spanner.y).abs, (@angle - spanner.angle).abs, (@angle - spanner.angle).abs, (@angle - spanner.angle).abs)\n    end\n\n    def span_to_point_with_angle_and_angle_and_angle(spanner)\n      Vector.new((@x -",
        "\n    def request_and_build_feeds\n      subscription_list.each do |subscription|\n        feed_name = subscription.feed_name\n        feed_url = subscription.feed_url\n        feed_description = subscription.feed_description\n        feed_image = subscription.feed_image\n        feed_link = subscription.feed_link\n        feed_category = subscription.feed_category\n        feed_language = subscription.feed_language\n        feed_category_id = subscription.feed_category_id\n        feed_category_name = subscription.feed_category_name\n        feed_category_slug = subscription.feed_category_slug\n        feed_category_description = subscription.feed_category_description\n        feed_category_image = subscription.feed_category_image\n        feed_category_link = subscription.feed_category_link\n        feed_category_category_id = subscription.feed_category_category_id\n        feed_category_category_name = subscription.feed_category_category_name\n        feed_category_category_slug = subscription.feed_category_category_slug\n        feed_category_category_description = subscription.feed_category_category_description\n        feed_category_category_image = subscription.feed_category_category_image\n        feed_category_category_link = subscription.feed_category",
        "\n    Mako.logger.info \"Mako Version: #{Mako.version}\"\n    Mako.logger.info \"Mako Version: #{Mako.version.to_s}\"\n    Mako.logger.info \"Mako Version: #{Mako.version.to_i}\"\n    Mako.logger.info \"Mako Version: #{Mako.version.to_f}\"\n    Mako.logger.info \"Mako Version: #{Mako.version.to_s}\"\n    Mako.logger.info \"Mako Version: #{Mako.version.to_i}\"\n    Mako.logger.info \"Mako Version: #{Mako.version.to_f}\"\n    Mako.logger.info \"Mako Version: #{Mako.version.to_s}\"\n    Mako.logger.info \"Mako Version: #{Mako.version.to_i}\"\n    Mako.logger.info \"Mako Version: #{Mako.version.to_f}\"\n    Mako.logger.info \"Mako Version: #{Mako.version.to_s}\"\n    Mako.logger.info \"Mako Version: #{M",
        "\n    def log_time_with_block\n      Mako.logger.info 'Generating...'\n      start_time = Time.now.to_f\n      yield\n      generation_time = Time.now.to_f - start_time\n      Mako.logger.info \"done in #{generation_time} seconds\"\n    end\n\n    def log_time_with_block_and_block\n      Mako.logger.info 'Generating...'\n      start_time = Time.now.to_f\n      yield\n      generation_time = Time.now.to_f - start_time\n      Mako.logger.info \"done in #{generation_time} seconds\"\n    end\n\n    def log_time_with_block_and_block_and_block\n      Mako.logger.info 'Generating...'\n      start_time = Time.now.to_f\n      yield\n      generation_time = Time.now.to_f - start_time\n      Mako.logger.info \"done in #{generation_time} seconds\"\n    end\n\n    def log_time_with_block_and_block_and_block\n      Mako.logger.info 'Generating...'\n      start_time = Time.now.to_f\n      yield\n      generation_time = Time",
        "\n    def operation\n      @operation ||= ARGV[0]\n    end\n\n    def outfile\n      @outfile ||= ARGV[1]\n    end\n\n    def print\n      @print ||= ARGV[2] == 'true'\n    end\n\n    def outfile=(value)\n      @outfile = value\n    end\n\n    def print=(value)\n      @print = value\n    end\n\n    def operation=(value)\n      @operation = value\n    end\n\n    def eval(operation)\n      eval(operation.split(';').join(' '))\n    end\nend\n\nif __FILE__ == $0\n  execute\nend\n",
        "\n      def create_operands_from_csv(opts)\n        files   = opts[:files].split(',')\n        rlabels = opts[:rlabels].split(',').collect { |l| l.upcase == \"TRUE\" }\n        clabels = opts[:clabels].split(',').collect { |l| l.upcase == \"TRUE\" }\n\n        operands = {}\n        opts[:aliases].split(',').each_with_index do |a,i|\n          operands[a] = SpreadSheet.new(file: files[i], ds: opts[:ds], \n                                        equalize: opts[:equalize],\n                                        r: rlabels[i], c: clabels[i])\n        end\n\n        operands\n      end\n\n      def create_operands_from_csv_with_aliases(opts)\n        files   = opts[:files].split(',')\n        rlabels = opts[:rlabels].split(',').collect { |l| l.upcase == \"TRUE\" }\n        clabels = opts[:clabels].split(',').collect { |l| l.upcase == \"TRUE\" }\n\n        operands = {}\n        opts[:aliases].split(',').each_with_index do |a,i|\n          operands[",
        "\n    def publish_to_http(params)\n      logger.debug \"Publishing to http: #{params.inspect}\"\n\n      begin\n        response = @http_client.post(URI.parse(params[:url]), params[:body])\n        logger.debug \"Response: #{response.inspect}\"\n      rescue Net::HTTPServerException => e\n        logger.error \"Error sending message to http: #{e.message}\"\n      end\n    end\n\n    def publish_to_socket(params)\n      logger.debug \"Publishing to socket: #{params.inspect}\"\n\n      begin\n        response = @socket_client.post(URI.parse(params[:url]), params[:body])\n        logger.debug \"Response: #{response.inspect}\"\n      rescue Net::HTTPServerException => e\n        logger.error \"Error sending message to socket: #{e.message}\"\n      end\n    end\n\n    def next_message_id\n      @next_message_id ||= 0\n      @next_message_id += 1\n    end\n\n    def dispatch(params)\n      logger.debug \"Dispatching: #{params.inspect}\"\n\n      if params[:command] == 'response_received'\n        logger.debug \"Response received: #{params[:body]}\"\n        response = JSON.parse(params[:body])\n        logger.",
        "\n    def publish_to_socket_with_block(params)\n      message = params.is_a?(String) ? params : params.to_json\n      data = \"~m~#{message.length}~m~#{message}\"\n      @socket.send(data) do |response|\n        response.body = response.body.to_s\n      end\n    end\n\n    def publish_to_socket_with_block_with_block(params)\n      message = params.is_a?(String) ? params : params.to_json\n      data = \"~m~#{message.length}~m~#{message}\"\n      @socket.send(data) do |response|\n        response.body = response.body.to_s\n      end\n    end\n\n    def publish_to_socket_with_block_with_block_with_block(params)\n      message = params.is_a?(String) ? params : params.to_json\n      data = \"~m~#{message.length}~m~#{message}\"\n      @socket.send(data) do |response|\n        response.body = response.body.to_s\n      end\n    end\n\n    def publish_to_socket_with_block_with_block_with_block(params)\n      message",
        "\n    def on_message(event)\n      message = JSON.parse(event.data)\n      message.delete!('success')\n      message.delete!('error')\n      message.delete!('msgid')\n      message.delete!('result')\n      message.delete!('api')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n      message.delete!('msgid')\n     ",
        "\n    def on_error(event)\n      logger.error \"Error: #{event.data}\"\n    end\n\n    def on_close(event)\n      logger.debug \"Connection closed\"\n    end\n\n    def on_open(event)\n      logger.debug \"Connection opened\"\n    end\n\n    def on_heartbeat(event)\n      logger.debug \"Heartbeat received\"\n    end\n\n    def on_response_received(event)\n      logger.debug \"Response received\"\n    end\n\n    def on_no_session(event)\n      logger.debug \"No session received\"\n    end\n\n    def on_heartbeat_received(event)\n      logger.debug \"Heartbeat received\"\n    end\n\n    def on_no_session_received(event)\n      logger.debug \"No session received\"\n    end\n\n    def on_heartbeat_received(event)\n      logger.debug \"Heartbeat received\"\n    end\n\n    def on_no_session_received(event)\n      logger.debug \"No session received\"\n    end\n\n    def on_heartbeat_received(event)\n      logger.debug \"Heartbeat received\"\n    end\n\n    def on_no_session_received(event)\n      logger.debug \"No session received\"\n    end\n\n    def on_",
        "\n    def add_defaults_remote\n      super\n      self.capacity ||= Capacity.new.add_defaults\n      self.row_label ||= capacity.rows && capacity.rows > 0 ? 'Row' : 'Unused'\n      self.column_label ||= capacity.columns && capacity.columns > 0 ? 'Column' : 'Unused'\n    end\n\n    def add_defaults_local_remote\n      super\n      self.capacity ||= Capacity.new.add_defaults\n      self.row_label ||= capacity.rows && capacity.rows > 0 ? 'Row' : 'Unused'\n      self.column_label ||= capacity.columns && capacity.columns > 0 ? 'Column' : 'Unused'\n    end\n\n    def add_defaults_local_local_remote\n      super\n      self.capacity ||= Capacity.new.add_defaults\n      self.row_label ||= capacity.rows && capacity.rows > 0 ? 'Row' : 'Unused'\n      self.column_label ||= capacity.columns && capacity.columns > 0 ? 'Column' : 'Unused'\n    end\n\n    def add_defaults_remote_local\n      super\n      self.capacity ||= Capacity.new.add_defaults\n      self.row_label ||= capacity.rows && capacity.rows > 0 ? 'Row' : 'Unused'\n      self.column_label ||=",
        " end\n\ndef address\n  @address ||= begin\n    begin\n      Socket.new(address, 22)\n    rescue SocketError\n      fail \"Failed to connect to #{address}\"\n    end\n  end\nend\n\ndef fail (msg)\n  log.error msg\n  exit 1\nend\n\ndef log (msg)\n  log.debug msg\nend\n\ndef log_debug (msg)\n  log.debug msg\nend\n\ndef log_info (msg)\n  log.info msg\nend\n\ndef log_warn (msg)\n  log.warn msg\nend\n\ndef log_error (msg)\n  log.error msg\nend\n\ndef log_fatal (msg)\n  log.fatal msg\nend\n\ndef log_fatal_debug (msg)\n  log.fatal_debug msg\nend\n\ndef log_fatal_info (msg)\n  log.fatal_info msg\nend\n\ndef log_fatal_warn (msg)\n  log.fatal_warn msg\nend\n\ndef log_fatal_error (msg)\n  log.fatal_error msg\nend\n\ndef log_fatal_fatal (msg)\n  log.fatal_fatal msg\nend\n\ndef log_fatal_fatal_debug (msg)\n  log.fatal_fatal_debug msg\nend\n\n",
        "\n\ndef rm (froms, to, as: nil, quiet: false)\n      as ||= @user\n      output = \"\"\n      synchronize do\n        [froms].flatten.each do |from|\n          if from.is_a?(String)\n            to += \"/\" if to[-1] != \"/\" && from.is_a?(Array)\n            command = [\"rm\", \"-e\", ssh_command, \"-r\"]\n            command += [*from, \"#{as}@#{@address}:#{to}\"]\n            log.trace command.shelljoin, quiet: quiet\n            IO.popen(command, in: :close, err: %i(child out)) do |io|\n              until io.eof?\n                begin\n                  output << io.read_nonblock(100)\n                  rescue IO::WaitReadable\n                    IO.select([io])\n                    retry\n                  end\n              end\n              io.close\n              if !$?.success?\n                log.fatal \"exit status #{$?.exitstatus}: #{command}\", quiet: quiet\n                log.fatal output, quiet: quiet\n                fail \"failed to remove files\"\n              end\n            end\n          elsif from.respond_to?(:read)\n            cmd = \"echo #{Base64.strict_encode64(from.read).shellescape} | base",
        "\n    end\n\n    def cp (string, to, as: nil, quiet: false)\n      if as.nil?\n        as = string.encoding\n      end\n\n      if to.nil?\n        to = string.encoding\n      end\n\n      if as.nil?\n        as = string.encoding\n      end\n\n      if quiet\n        puts string\n      else\n        puts string.encode(as)\n      end\n    end\n\n    def cp_to (string, to, as: nil, quiet: false)\n      cp string, to, as: as, quiet: quiet\n    end\n\n    def cp_to_to (string, to, as: nil, quiet: false)\n      cp string, to, as: as, quiet: quiet\n    end\n\n    def cp_to_to_with_encoding (string, to, as: nil, quiet: false)\n      cp string, to, as: as, encoding: as.encoding\n    end\n\n    def cp_to_to_with_encoding (string, to, as: nil, quiet: false)\n      cp string, to, as: as, encoding: as.encoding\n    end\n\n    def cp_to_to_with_encoding_with_encoding (string, to, as: nil, encoding: nil, encoding:",
        "\n  end\n\n  def write (filename, data, as: nil, quiet: false)\n      sh(\"echo #{data} | #{filename.shellescape}\", as: as, quiet: quiet)\n    end\n\n  def sh (cmd, as: nil, quiet: false)\n    if as\n      sh(\"#{cmd} | #{as}\", quiet: quiet)\n    else\n      sh(cmd, quiet: quiet)\n    end\n  end\n\n  def shell (cmd, as: nil, quiet: false)\n    if as\n      sh(\"#{cmd} | #{as}\", quiet: quiet)\n    else\n      sh(cmd, quiet: quiet)\n    end\n  end\n\n  def shellescape (str)\n    str.shellescape\n  end\n\n  def shellescape_shellescape (str)\n    str.shellescape_shellescape\n  end\n\n  def shellescape_shellescape_shellescape (str)\n    str.shellescape_shellescape_shellescape\n  end\n\n  def shellescape_shellescape_shellescape_shellescape (str)\n    str.shellescape_shellescape_shellescape_shellescape\n  end\n\n  def shellescape_shellescape_shellescape_shellescape (str)\n    str.shellescape_shellescape_shellescape_shellescape",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\nend\n\ndef can_hold_child?(storable)\n      Specimen === storable and storable.specimen_class == specimen_class and specimen_types.include?(storable.specimen_type)\nend\n\ndef can_hold_child?(storable)\n      Specimen === storable and storable.specimen_class == specimen_class and specimen_types.include?(storable.specimen_type)\nend\n\ndef can_hold_child?(storable)\n      Specimen === storable and storable.specimen_class == specimen_class and specimen_types.include?(storable.specimen_type)\nend\n\ndef can_hold_child?(storable)\n      Specimen === storable and storable.specimen_class == specimen_class and specimen_types.include?(storable.specimen_type)\nend\n\ndef can_hold_child?(storable)\n      Specimen === storable and storable.specimen_class == specimen_class and specimen_types.include?(storable.specimen_type)\nend\n\ndef can_hold_child?(storable)\n      Specimen === storable and storable.specimen_class == specimen_class and specimen_types.include?(storable.specimen_type)\nend\n\ndef can_hold_child?",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\",
        "\n    end\n\n    def write_result_with_key_values\n      sum_line = [sum_row_title]\n      (heading.size - 2).times { sum_line << \"\" }\n      sum_line << sums[sum_col_title]\n      row = 0;\n      File.open(outfile, 'w') do |out|\n        out.puts sum_line.join(';') if row == sum_row ; row += 1\n        out.puts heading.join(';')\n        key_values.each do |k, v|\n          out.puts sum_line.join(';') if row == sum_row ; row += 1\n          out.puts [k, v].join(';')\n        end\n      end\n    end\n\n    def write_result_with_key_values_with_sums\n      sum_line = [sum_row_title]\n      (heading.size - 2).times { sum_line << \"\" }\n      sum_line << sums[sum_col_title]\n      row = 0;\n      File.open(outfile, 'w') do |out|\n        out.puts sum_line.join(';') if row == sum_row ; row += 1\n        out.puts heading.join(';')\n        key_values.each do",
        "\n      def sum_row\n        @sum_row\n      end\n\n      def sum_col\n        @sum_col\n      end\n\n      def sum_row_title\n        @sum_row_title\n      end\n\n      def sum_col_title\n        @sum_col_title\n      end\n\n      def sum_col\n        @sum_col\n      end\n\n      def sum_row_title=(sum_row_title)\n        @sum_row_title = sum_row_title\n      end\n\n      def sum_col_title=(sum_col_title)\n        @sum_col_title = sum_col_title\n      end\n\n      def sum_col\n        @sum_col\n      end\n\n      def sum_row=(sum_row)\n        @sum_row = sum_row\n      end\n\n      def sum_col=(sum_col)\n        @sum_col = sum_col\n      end\n\n      def sum_row=(sum_row)\n        @sum_row = sum_row\n      end\n\n      def sum_col=(sum_col)\n        @sum_col = sum_col\n      end\n\n      def sum_row=(sum_row)\n        @sum_row = sum_row\n      end\n\n      def sum",
        "\n      self\n    end\n\n    def attributes=(&block)\n      raise ArgumentError, \"You should provide block\" unless block_given?\n\n      attributes = Morf::AttributesParser.parse(&block)\n      self.class_variable_set(:@@attributes, attributes)\n    end\n\n    def attributes_for(&block)\n      raise ArgumentError, \"You should provide block\" unless block_given?\n\n      attributes = Morf::AttributesParser.parse(&block)\n      self.class_variable_set(:@@attributes, attributes)\n    end\n\n    def attributes_for_all(&block)\n      raise ArgumentError, \"You should provide block\" unless block_given?\n\n      attributes = Morf::AttributesParser.parse(&block)\n      self.class_variable_set(:@@attributes, attributes)\n    end\n\n    def attributes_for_all_with_defaults(&block)\n      raise ArgumentError, \"You should provide block\" unless block_given?\n\n      attributes = Morf::AttributesParser.parse(&block)\n      self.class_variable_set(:@@attributes, attributes)\n    end\n\n    def attributes_for_all_with_defaults_and_defaults(&block)\n      raise ArgumentError, \"You should provide block\" unless block_given?\n\n",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.codec;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.Generated;\nimport com.hazelcast.client.impl.protocol.codec.builtin.*;\nimport com.hazelcast.client.impl.protocol.codec.custom.*;\n\nimport javax.annotation.Nullable;\n\nimport static com.hazelcast.client.impl.protocol.ClientMessage.*;\nimport static com.hazelcast.client.impl.protocol",
        "end\n\ndef move(stone)\n      x, y = stone.to_coord\n\n      if internal_board[y][x] == stone\n        internal_board[y][x] = nil\n      else\n        internal_board[y][x] = stone.next\n      end\nend\n\ndef draw()\n    puts \"Board: \"\n    for y in range(0, board.length)\n      for x in range(0, board[0].length)\n        puts \"  \" + board[y][x]\n      end\nend\n\ndef main()\n    puts \"Welcome to the game!\"\n    puts \"Type 'place' to place a stone.\"\n    puts \"Type 'move' to move a stone.\"\n    puts \"Type 'draw' to draw the board.\"\n    puts \"Type 'quit' to quit.\"\n    puts \"Type 'exit' to exit.\"\n    puts \"Type 'help' to see this help.\"\n    puts \"Type 'exit' to quit.\"\n    puts \"Type 'help' to see this help.\"\n    puts \"Type 'exit' to quit.\"\n    puts \"Type 'help' to see this help.\"\n    puts \"Type 'exit' to quit.\"\n    puts \"Type 'help' to see this help.\"\n    puts \"Type 'exit'",
        "\n    end\n\n    def usage_and_help(options)\n      puts \"Usage: #{File.basename(__FILE__)} [options]\"\n      puts \"  -t <text_file>  <text_file> ...\"\n      puts \"  -w <weights_file> <weights_file> ...\"\n      puts \"  -o <output_file> <output_file> ...\"\n      puts \"  -h, --help  Show this help message\"\n      puts \"  -v, --version  Show version\"\n    end\n\n    def assign_text_file(options)\n      options.text_file = ARGV[0]\n    end\n\n    def assign_weights_file(options)\n      options.weights_file = ARGV[0]\n    end\n\n    def assign_output_file(options)\n      options.output_file = ARGV[0]\n    end\n\nend\n\nparse(ARGV)\n",
        "\n      self.last_command = command_string(command, params)\n      xmlrpc_client.call(command, params)\n    end\n\n    def command_string(command, params)\n      command = command.to_s.downcase\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command = command.gsub(/\\s+/, '_')\n      command =",
        "\n  def summoners(summoner, optional={})\n    region = optional[:region] || @sightstone.region\n    id = if summoner.is_a? Summoner\n      summoner.id\n    else\n      summoner\n    end\n    \n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v2.3/summoner/by-summoner/#{id}\"\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      summoners = []\n      data.each do |summoner|\n        summoners << Summoner.new(summoner)\n      end\n      if block_given?\n        yield summoners\n      else\n        return summoners\n      end\n    }\n  end\n\n  def summoners_by_region(region, optional={})\n    region = optional[:region] || @sightstone.region\n    summoners = []\n    summoners.concat(summoners(region))\n    summoners.concat(summoners(region, {region: region}))\n    summoners.concat(summoners(region, {region: region",
        "\n  def league_entries_by_summoner(summoner, optional={})\n    region = optional[:region] || @sightstone.region\n    id = if summoner.is_a? Summoner\n      summoner.id\n    else\n      summoner\n    end\n    \n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v2.3/league/by-summoner/#{id}/entry\"\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      entries = []\n      data.each do |entry|\n        entries << LeagueItem.new(entry)\n      end\n      if block_given?\n        yield entries\n      else\n        return entries\n      end\n    }\n  end\n\n  def league_entries_by_summoner_id(summoner_id, optional={})\n    region = optional[:region] || @sightstone.region\n    id = if summoner_id.is_a? Summoner\n      summoner_id\n    else\n      summoner_id\n    end\n    \n    uri = \"https://prod.api.pvp",
        "\n    def place_with_room(top, left, angle, room_id)\n      api('sticker.place', :placement => [:sticker_id => id, :top => top, :left => left, :angle => angle], :is_dj => client.user.dj?, :roomid => room_id, :section => room.section)\n      true\n    end\n\n    def place_with_room_with_room_id(top, left, angle, room_id, room_section)\n      api('sticker.place', :placement => [:sticker_id => id, :top => top, :left => left, :angle => angle], :is_dj => client.user.dj?, :roomid => room_id, :section => room_section)\n      true\n    end\n\n    def place_with_room_with_room_id_with_room_section(top, left, angle, room_id, room_section, room_id)\n      api('sticker.place', :placement => [:sticker_id => id, :top => top, :left => left, :angle => angle], :is_dj => client.user.dj?, :roomid => room_id, :section => room_section, :roomid => room_id)\n",
        "\n    def find_by_uri(uri)\n      request_uris.find { |request| request[:uri] == uri }\n    end\n\n    def find_by_uri_and_type(uri, type)\n      request_uris.find { |request| request[:uri] == uri && request[:type] == type }\n    end\n\n    def find_by_type(type)\n      request_uris.find { |request| request[:type] == type }\n    end\n\n    def find_by_type_and_uri(type, uri)\n      request_uris.find { |request| request[:type] == type && request[:uri] == uri }\n    end\n\n    def find_by_type_and_uri_and_type(type, uri, type)\n      request_uris.find { |request| request[:type] == type && request[:uri] == uri && request[:type] == type }\n    end\n\n    def find_by_type_and_uri_and_type_and_uri(type, uri, type, uri)\n      request_uris.find { |request| request[:type] == type && request[:uri] == uri && request[:type] == type && request[:uri] == uri }\n    end\n\n    def find_by_type_and",
        "\nend\n\ndef collection_status\n      @collection_status ||= begin\n        if specimens.any?\n          specimens.each { |spc| spc.collection_status = 'Collected' if spc.pending? }\n        end\n        @collection_status ||= 'Complete'\n      end\n    end\n\ndef collection_name=(value)\n      @collection_name ||= begin\n        if specimens.any?\n          specimens.each { |spc| spc.collection_name = 'Collected' if spc.pending? }\n        end\n        @collection_name ||= 'Complete'\n      end\n    end\n\ndef collection_name\n      @collection_name ||= begin\n        if specimens.any?\n          specimens.each { |spc| spc.collection_name = 'Collected' if spc.pending? }\n        end\n        @collection_name ||= 'Complete'\n      end\n    end\n\ndef collection_description=(value)\n      @collection_description ||= begin\n        if specimens.any?\n          specimens.each { |spc| spc.collection_description = 'Collected' if spc.pending? }\n        end\n        @collection_description ||= 'Complete'\n      end\n    end\n\ndef collection_description\n      @collection_",
        "\n    def make_default_consent_tier_statuses_for_response_tiers\n      return if registration.nil? or registration.consent_tier_responses.empty?\n      \n      # the consent tiers\n      ctses = consent_tier_statuses.map { |cts| cts.consent_tier }\n      # ensure that there is a CT status for each consent tier\n      registration.consent_tier_responses.each do |ctr|\n        ct = ctr.consent_tier\n        next if ctses.include?(ct)\n        cts = CaTissue::ConsentTierStatus.new(:consent_tier => ct)\n        cts.add_defaults\n        consent_tier_statuses << cts\n        logger.debug { \"Made default #{qp} #{cts.qp} for consent tier #{ct.qp}.\" }\n      end\n    end\n\n    def make_default_consent_tier_statuses_for_response_tiers_for_registration\n      return if registration.nil? or registration.consent_tier_responses.empty?\n      \n      # the consent tiers\n      ctses = consent_tier_statuses.map { |cts| cts.consent_tier }\n      # ensure that there is a",
        "\n    end\n\n    def default_event\n      return if registration.nil?\n      pcl = registration.protocol || return\n      # if no protocol event, then add the default event\n      pcl.add_defaults if pcl.events.empty?\n      ev = pcl.sorted_events.first || return\n      logger.debug { \"Default #{qp} event is the registration protocol #{pcl.qp} first event #{ev.qp}.\" }\n      ev\n    end\n\n    def default_event_name\n      return if registration.nil?\n      pcl = registration.protocol || return\n      # if no protocol event, then add the default event\n      pcl.add_defaults if pcl.events.empty?\n      ev = pcl.sorted_events.first || return\n      logger.debug { \"Default #{qp} event name is the registration protocol #{pcl.qp} first event #{ev.qp}.\" }\n      ev.name\n    end\n\n    def default_event_description\n      return if registration.nil?\n      pcl = registration.protocol || return\n      # if no protocol event, then add the default event\n      pcl.add_defaults if pcl.events.empty?\n      ev = pcl.sorted_events.first || return\n      logger.debug { \"Default #{qp} event description",
        "\nend\n\ndef default_protocol\n      cep = collection_event_parameters\n      cp = cep.protocol if cep\n      return cp if cp\n      cp = collection_protocol || return\n      cp.add_defaults\n      cp.coordinators.first\n    end\n\ndef default_collection_protocol\n      cep = collection_event_parameters\n      cp = cep.protocol if cep\n      return cp if cp\n      cp = collection_protocol || return\n      cp.add_defaults\n      cp.coordinators.first\n    end\n\ndef default_collection_event_parameters\n      cep = collection_event_parameters\n      cep.user if cep\n    end\n\ndef default_collection_event_parameters\n      cep = collection_event_parameters\n      cep.protocol if cep\n    end\n\ndef default_collection_protocol\n      cep = collection_event_parameters\n      cep.user if cep\n    end\n\ndef default_collection_protocol_name\n      cep = collection_event_parameters\n      cep.protocol if cep\n    end\n\ndef default_collection_protocol_name\n      cep = collection_event_parameters\n      cep.user if cep\n    end\n\ndef default_collection_protocol_name_with_protocol\n      c",
        "\n    def increment_derived_quantity(child)\n      return unless specimen_type == child.specimen_type and child.initial_quantity\n      if available_quantity.nil? then\n        raise Jinx::ValidationError.new(\"Derived specimen has an initial quantity #{child.initial_quantity} but the parent is missing an available quantity\")\n      elsif (available_quantity - child.initial_quantity).abs < 0.00000001 then\n        # rounding error\n        self.available_quantity = 0.0\n      elsif child.initial_quantity <= available_quantity then\n        self.available_quantity += child.initial_quantity\n      else\n        raise Jinx::ValidationError.new(\"Derived specimen initial quantity #{child.initial_quantity} exceeds parent available quantity #{available_quantity}\")\n      end\n    end\n\n    def increment_derived_quantity_by(child)\n      return unless specimen_type == child.specimen_type and child.initial_quantity\n      if available_quantity.nil? then\n        raise Jinx::ValidationError.new(\"Derived specimen has an initial quantity #{child.initial_quantity} but the parent is missing an available quantity\")\n      elsif (available_quantity - child.initial_quantity).abs < 0.00000001 then\n        # rounding error\n        self.available_quantity = 0.0\n      elsif child.initial_quantity <= available_quantity then",
        "\n    def update_from_template(owner)\n      if CaTissue::User === owner and property.attribute == :address then\n        update_user_address(owner, owner)\n      end\n      if CaTissue::Specimen === owner and CaTissue::Specimen === dependent then\n        logger.debug { \"Work around caTissue bug by resaving the collected #{owner} #{dependent} directly rather than via a cascade...\" }\n        prepare_specimen_for_update(dependent)\n        update_from_template(dependent)\n      end\n      if CaTissue::ConsentTierStatus === owner and CaTissue::ConsentTierStatus === dependent then\n        logger.debug { \"Work around caTissue bug to update #{dependent} separately after the parent #{owner} update...\" }\n        prepare_specimen_for_update(dependent)\n        update_from_template(dependent)\n      end\n      super\n    end\n\n    def update_user_address(owner, dependent)\n      if CaTissue::User === owner and property.attribute == :address then\n        owner.update_attribute(:address, dependent.address)\n      end\n    end\n\n    def prepare_specimen_for_update(dependent)\n      if CaTissue::Specimen === owner and CaTissue::Specimen === dependent then\n        logger.debug { \"Work",
        "\n    end\n\n    def create_user_address(user, address)\n      logger.debug { \"Work around caTissue prohibition of #{user} address #{address} create by creating a new address record for a dummy user...\" }\n      address.identifier = nil\n      perform(:create, address) { create_object(address) }\n      logger.debug { \"Worked around caTissue address create bug by swizzling the #{user} address #{address} identifier.\" }\n      perform(:update, user) { update_object(user) }\n      user\n    end\n\n    def update_user_address_with_identifier(user, address)\n      logger.debug { \"Work around caTissue prohibition of #{user} address #{address} update by creating a new address record for a dummy user...\" }\n      address.identifier = nil\n      perform(:create, address) { create_object(address) }\n      logger.debug { \"Worked around caTissue address update bug by swizzling the #{user} address #{address} identifier.\" }\n      perform(:update, user) { update_object(user) }\n      user\n    end\n\n    def create_user_address_with_identifier_and_identifier_type(user, address)\n      logger.debug { \"Work around caTissue prohibition of",
        "\n    def add_position_to_specimen_template_with_values(specimen, template)\n      pos = specimen.position\n      # the non-domain position attributes\n      pas = pos.class.nondomain_attributes\n      # the template position reflects the old values, if available\n      ss = pos.snapshot\n      vh = ss ? pas.to_compact_hash { |pas| ss[pas] } : pos.value_hash(pas)\n      template.position = pos.class.new(vh)\n      logger.debug { \"Work around #{specimen} update anomaly by copying position #{template.position.qp} to update template #{template.qp} as #{template.position.qp} with values #{vh.qp}...\" }\n    end\n\n    def add_position_to_specimen_template_with_values_with_values(specimen, template)\n      pos = specimen.position\n      # the non-domain position attributes\n      pas = pos.class.nondomain_attributes\n      # the template position reflects the old values, if available\n      ss = pos.snapshot\n      vh = ss ? pas.to_compact_hash { |pas| ss[pas] } : pos.value_hash(pas)\n      template.position = pos.class.new(vh)\n",
        "\n    def ensure_primary_annotation_has_hook_and_primary_annotation_has_hook(annotation)\n      ensure_primary_annotation_has_hook(annotation)\n      ensure_primary_annotation_has_hook(annotation.primary_annotation)\n    end\n\n    def ensure_primary_annotation_has_hook_and_primary_annotation_has_hook_and_primary_annotation_has_hook(annotation)\n      ensure_primary_annotation_has_hook(annotation)\n      ensure_primary_annotation_has_hook(annotation.primary_annotation)\n      ensure_primary_annotation_has_hook(annotation.primary_annotation.primary_annotation)\n    end\n\n    def ensure_primary_annotation_has_hook_and_primary_annotation_has_hook_and_primary_annotation_has_hook(annotation)\n      ensure_primary_annotation_has_hook(annotation)\n      ensure_primary_annotation_has_hook(annotation.primary_annotation.primary_annotation)\n      ensure_primary_annotation_has_hook(annotation.primary_annotation.primary_annotation.primary_annotation)\n    end\n\n    def ensure_primary_annotation_has_hook_and_primary_annotation_has_hook_and_primary_annotation_has_hook(annotation)\n      ensure_primary_annotation_has",
        "\n    def copy_annotation_proxy_owner_from_template(obj, template)\n      prop = obj.class.proxy_property\n      # Ignore the proxy attribute if it is defined by caRuby rather than caTissue.\n      return unless prop and prop.java_property?\n      rdr, wtr = prop.java_accessors\n      pxy = template.send(rdr)\n      logger.debug { \"Setting #{obj.qp} template #{template.qp} proxy owner from #{pxy}...\" }\n      obj.send(wtr, pxy)\n    end\n\n    def copy_annotation_proxy_owner_to_template_with_proxy_owner(obj, template, proxy_owner)\n      prop = obj.class.proxy_property\n      # Ignore the proxy attribute if it is defined by caRuby rather than caTissue.\n      return unless prop and prop.java_property?\n      rdr, wtr = prop.java_accessors\n      pxy = obj.send(rdr)\n      logger.debug { \"Setting #{obj.qp} template #{template.qp} proxy owner to #{pxy} with proxy owner #{proxy_owner}...\" }\n      template.send(wtr, pxy, proxy_owner)\n    end\n\n    def copy_annotation_proxy_owner_",
        "\n    end\n\n    def create_row(create_key, line)\n      @columns.each do |column|\n        @rows[create_key][column] = line.chomp\n      end\n    end\n\n    def unstring(line)\n      line.gsub(/\\s+/, '')\n    end\n\n    def header\n      @header ||= begin\n        header_filter.process(infile)\n      end\n    end\n\n    def row_filter\n      @row_filter ||= begin\n        row_filter_filter.process(infile)\n      end\n    end\n\n    def create_key\n      @create_key ||= begin\n        create_key_filter.process(infile)\n      end\n    end\n\n    def infile\n      @infile ||= begin\n        infile_filter.process(infile)\n      end\n    end\n\n    def outfile\n      @outfile ||= begin\n        outfile_filter.process(infile)\n      end\n    end\n\n    def create_key_filter\n      @create_key_filter ||= begin\n        create_key_filter_filter.process(infile)\n      end\n    end\n\n    def infile_filter\n      @infile_filter ||= begin\n        infile_filter_filter.process(infile)\n      end\n",
        "\n    def create_sum_row\n      row = []\n      header.clear_header_cols.each_with_index do |col, index|\n        row << col\n      end\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '0'\n      row << '",
        "\n        value = convert_to_en(value)\n        return value.to_f unless value =~ /\\./\n        return value.to_i if     value =~ /\\./ \n      end\n\n  def to_date(value)\n        value = convert_to_en(value)\n        return value.to_date unless value =~ /\\./\n        return value.to_date if     value =~ /\\./ \n      end\n\n  def to_time(value)\n        value = convert_to_en(value)\n        return value.to_time unless value =~ /\\./\n        return value.to_time if     value =~ /\\./ \n      end\n\n  def to_datetime(value)\n        value = convert_to_en(value)\n        return value.to_datetime unless value =~ /\\./\n        return value.to_datetime if     value =~ /\\./ \n      end\n\n  def to_datetime_local(value)\n        value = convert_to_en(value)\n        return value.to_datetime_local unless value =~ /\\./\n        return value.to_datetime_local if     value =~ /\\./ \n      end\n\n  def to_datetime_utc(value)\n        value = convert_to_en(value)\n        return value.to_datetime_",
        "\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase!\n        @sum_row_pos.downcase",
        "\n      def evaluate(pattern, value)\n        return unless pattern\n        pattern.gsub(/\\(?c\\d+[=~+.]/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\").gsub(/\\)/, \"\"",
        "\n      end\n\n      def create_sum_row_with_header\n        line = []\n        header.clear_header_cols.each do |col|\n          line << @sum_row[col] || \"\"\n        end\n        line.join(';')\n      end\n\n      def create_sum_row_with_header_with_header_cols\n        line = []\n        header.clear_header_cols.each do |col|\n          line << @sum_row[col] || \"\"\n        end\n        line.join(';')\n      end\n\n      def create_sum_row_with_header_with_header_cols_with_header_cols\n        line = []\n        header.clear_header_cols.each do |col|\n          line << @sum_row[col] || \"\"\n        end\n        line.join(';')\n      end\n\n      def create_sum_row_with_header_with_header_cols_with_header_cols_with_header_cols\n        line = []\n        header.clear_header_cols.each do |col|\n          line << @sum_row[col] || \"\"\n        end\n        line.join(';')\n      end\n\n      def create_sum_row_with_header_with_header_cols_",
        "\n    def _rewrap_hash(result)\n      if @wrap_results\n        newcoll = @collection.class.new(result)\n        self.class.new(newcoll, @wrapfunc_in, @wrapfunc_out)\n      else\n        @collection.class.new(result.map(&@wrapfunc_out))\n      end\n    end\n\n    def _rewrap_string(result)\n      if @wrap_results\n        newcoll = @collection.class.new(result)\n        self.class.new(newcoll, @wrapfunc_in, @wrapfunc_out)\n      else\n        @collection.class.new(result.map(&@wrapfunc_out))\n      end\n    end\n\n    def _rewrap_symbol(result)\n      if @wrap_results\n        newcoll = @collection.class.new(result)\n        self.class.new(newcoll, @wrapfunc_in, @wrapfunc_out)\n      else\n        @collection.class.new(result.map(&@wrapfunc_out))\n      end\n    end\n\n    def _rewrap_nil(result)\n      if @wrap_results\n        newcoll = @collection.class.new(result)\n        self.class.new(newcoll, @",
        "\n    def resolve_dependencies\n      @dependencies.each do |dependency|\n        dependency.resolve_dependencies\n      end\n    end\n\n    def node_for_key_or_new(key)\n      @nodes[key] ||= Node.new(key)\n    end\n\n    def node_for_key(key)\n      @nodes[key]\n    end\n\n    def node_for_key_or_new_with_edges(key)\n      @nodes[key] ||= Node.new(key)\n      @nodes[key].addEdges(edges)\n    end\n\n    def edges\n      @edges ||= @graph.edges\n    end\n\n    def edges_for_key(key)\n      @edges[key]\n    end\n\n    def edges_for_key_or_new(key)\n      @edges[key]\n    end\n\n    def edges_for_key_or_new_with_edges(key)\n      @edges[key]\n    end\n\n    def edges_for_key_with_edges(key)\n      @edges[key]\n    end\n\n    def edges_for_key_with_edges_for_key(key)\n      @edges[key]\n    end\n\n    def edges_for_key_with_edges_for",
        "\n    def resolve_dependencies\n      @seen_this_pass.each do |node|\n        resolve_dependency node\n      end\n    end\n\n    def resolve_dependencies_recursive\n      @seen_this_pass.each do |node|\n        resolve_dependencies_recursive node\n      end\n    end\n\n    def resolve_dependencies_recursive(node)\n      node.seen = true\n      @seen_this_pass << node\n\n      node.edges.each do |edge|\n        unless @resolved.include? edge\n          unless @seen_this_pass.include? edge\n            unless edge.seen?\n              resolve_dependencies_recursive edge\n            end\n          else\n            raise CircularDependencyError, \"Circular reference detected: #{node.key.to_s} - #{edge.key.to_s}\"\n          end\n        end\n      end\n      @resolved << node\n    end\n\n    def resolve_dependencies_recursive_recursive(node)\n      node.seen = true\n      @seen_this_pass << node\n\n      node.edges.each do |edge|\n        unless @resolved.include? edge\n          unless @seen_this_pass.include? edge\n            unless edge.seen?\n              resolve_dependencies_recursive_recursive edge\n            end\n          else\n            raise CircularDependencyError,",
        "\nend\n\nclass Room < ActiveRecord::Base\n  belongs_to :user\n  has_many :friends, :class_name => 'User', :foreign_key => 'friend_id'\n  has_many :friends_with_friends, :class_name => 'User', :foreign_key => 'friend_id'\n  has_many :friends_with_friends_with_friends, :class_name => 'User', :foreign_key => 'friend_id'\n  has_many :friends_with_friends_with_friends_with_friends, :class_name => 'User', :foreign_key => 'friend_id'\n  has_many :friends_with_friends_with_friends_with_friends, :class_name => 'User', :foreign_key => 'friend_id'\n  has_many :friends_with_friends_with_friends_with_friends_with_friends, :class_name => 'User', :foreign_key => 'friend_id'\n  has_many :friends_with_friends_with_friends_with_friends_with_friends, :class_name => 'User', :foreign_key => 'friend_id'\n",
        "\n    def create(room, options = {})\n      assert_valid_keys(options, :name, :description, :location, :location_id, :location_type, :location_name, :location_type_id, :location_type_name, :location_type_name_id, :location_type_name_type, :location_type_name_type_id, :location_type_name_type_name, :location_type_name_type_id, :location_type_name_type_name, :location_type_name_type_id, :location_type_name_type_name, :location_type_name_type_id, :location_type_name_type_name, :location_type_name_type_id, :location_type_name_type_name, :location_type_name_type_id, :location_type_name_type_name, :location_type_name_type_id, :location_type_name_type_name, :location_type_name_type_id, :location_type_name_type_name, :location_type_name_type_id, :location_type_name_type_name, :location_type_name_type_id, :location_type_name_type_name, :location",
        "\n    end\n\n    def api(method, options = {})\n      options = {:minimal => false}.merge(options)\n\n      data = api_request(method, options)\n      data = data.to_json\n      data = JSON.parse(data)\n\n      data\n    end\n\n    def api_request(method, options = {})\n      url = \"#{api_url}/#{method}\"\n      options = {:minimal => false}.merge(options)\n\n      response = Net::HTTP.get_response(URI.parse(url), options)\n      response.body\n    end\n\n    def api_url\n      \"https://api.playlist.com/v1/#{api_version}\"\n    end\n\n    def api_version\n      \"v1\"\n    end\n\n    def api_url_with_version\n      \"#{api_url}/#{api_version}\"\n    end\n\n    def api_version_with_version\n      \"v1\"\n    end\n\n    def api_version_with_version_and_format\n      \"v1/#{api_version}\"\n    end\n\n    def api_version_with_format\n      \"v1/#{api_version}\"\n    end\n\n    def api_version_with_format_and_format\n      \"v1/#{",
        "\n    end\n\n    def create(attributes = {})\n      assert_valid_keys(attributes, :name)\n\n      # Create name\n      name = attributes.delete(:name)\n      name = name.strip if name\n      name = name.gsub(/\\s+/, '') if name\n      name = name.downcase if name\n\n      # Create email\n      email = attributes.delete(:email)\n      email = email.strip if email\n      email = email.gsub(/\\s+/, '') if email\n      email = email.downcase if email\n\n      # Create phone\n      phone = attributes.delete(:phone)\n      phone = phone.strip if phone\n      phone = phone.gsub(/\\s+/, '') if phone\n      phone = phone.downcase if phone\n\n      # Create password\n      password = attributes.delete(:password)\n      password = password.strip if password\n      password = password.gsub(/\\s+/, '') if password\n      password = password.downcase if password\n\n      # Create password confirmation\n      password_confirmation = attributes.delete(:password_confirmation)\n      password_confirmation = password_confirmation.strip if password_confirmation\n      password_confirmation = password_confirmation.gsub(/\\s+/, '') if password_confirmation\n      password_confirmation = password_confirmation.down",
        "\nend\n\ndef active?\n      !active.nil?\nend\n\ndef play\n      client.user.playlists.create(playlist_params)\n    end\n\ndef play!\n      client.user.playlists.create(playlist_params)\n    end\n\ndef play_next\n      client.user.playlists.create(playlist_params)\n    end\n\ndef play_previous\n      client.user.playlists.create(playlist_params)\n    end\n\ndef play_last\n      client.user.playlists.create(playlist_params)\n    end\n\ndef play_next_or_previous\n      client.user.playlists.create(playlist_params)\n    end\n\ndef play_last_or_previous\n      client.user.playlists.create(playlist_params)\n    end\n\ndef play_next_or_previous_or_next\n      client.user.playlists.create(playlist_params)\n    end\n\ndef play_next_or_previous_or_next_or_previous\n      client.user.playlists.create(playlist_params)\n    end\n\ndef play_next_or_previous_or_next_or_previous_or_next\n      client.user.playlists.create(",
        "\n      end\n    end\n\n    def add_attribute(name, options = {}, &coercer)\n      name  = name.to_sym\n      value = Attribute.new(name, options, &coercer)\n      clone_with do\n        @attributes = attributes.merge(name => value)\n        @transformer = nil\n      end\n    end\n\n    def add_attribute_with_transformer(name, options = {}, &coercer)\n      name  = name.to_sym\n      value = Attribute.new(name, options, &coercer)\n      clone_with do\n        @attributes = attributes.merge(name => value)\n        @transformer = transformer\n      end\n    end\n\n    def add_attribute_with_transformer_with_options(name, options = {}, &coercer)\n      name  = name.to_sym\n      value = Attribute.new(name, options, &coercer)\n      clone_with do\n        @attributes = attributes.merge(name => value)\n        @transformer = transformer.with_options(options)\n      end\n    end\n\n    def add_attribute_with_transformer_with_options_with_coercer(name, options = {}, &coercer)\n      name  = name.to_sym\n      value =",
        "\n    def add_specimen_collection_group(*args)\n      hash = args.pop\n      spcs = args\n      # validate arguments\n      unless Hash === hash then\n        raise ArgumentError.new(\"Collection parameters are missing when adding specimens to protocol #{self}\")\n      end\n      # Make the default registration, if necessary.\n      unless hash.has_key?(:registration) || hash.has_key?(:collection_protocol_registration) then\n        # the participant\n        pnt = hash.delete(:participant)\n        unless pnt then\n          raise ArgumentError.new(\"Registration or participant missing from collection parameters: #{hash.qp}\")\n        end\n        hash[:registration] = registration(pnt) || make_cpr(pnt)\n      end\n      # the new SCG\n      scg = SpecimenCollectionGroup.new(hash)\n      # set each Specimen SCG\n      spcs.each { |spc| spc.specimen_collection_group = scg }\n      scg\n    end\n\n    def add_specimen_collection_group_with_participant(*args)\n      hash = args.pop\n      spcs = args\n      # validate arguments\n      unless Hash === hash then\n        raise ArgumentError.new(\"Collection parameters are missing when adding specimens to protocol #{self}\")\n      end",
        "\n  def summoners(name_or_id, optional={})\n    region = optional[:region] || @sightstone.region\n    uri = if name_or_id.is_a? Integer\n      \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoners/#{name_or_id}\"\n    else\n      \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoners/by-name/#{URI::encode(name_or_id)}\"\n    end\n    \n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      s = Summoner.new(data.values[0])\n      if block_given?\n        yield s\n      else\n        return s\n      end\n    }\n  end\n\n  def summoner_by_name(name_or_id, optional={})\n    region = optional[:region] || @sightstone.region\n    uri = if name_or_id.is_a? Integer\n      \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoners/by-name",
        "\n  def names_for_region(region, optional={})\n    ids = [region]\n    names(ids, optional)\n  end\n\n  def names_for_region_and_id(region, id, optional={})\n    ids = [region, id]\n    names(ids, optional)\n  end\n\n  def names_for_region_and_ids(region, ids, optional={})\n    ids = ids.join(',')\n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{ids}/name\"\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n\n      names_hash = Hash.new\n      data.each do |id, name|\n        names_hash[id.to_i] = name\n      end\n      if block_given?\n        yield names_hash\n      else\n        return names_hash\n      end\n    }\n  end\n\n  def names_for_region_and_ids_for_region(region, ids, optional={})\n    ids = ids.join(',')\n    uri = \"https://prod.api.pvp.net/api/l",
        "\n  def runebook_by_id(summoner, optional={})\n    region = optional[:region] || @sightstone.region\n    id = if summoner.is_a? Summoner\n      summoner.id\n    else\n      summoner\n    end\n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{id}/runes\"\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      book = RuneBook.new(data.values[0])\n      if block_given?\n        yield book\n      else\n        return book\n      end\n    }\n  end\n\n  def runebook_by_name(summoner, optional={})\n    region = optional[:region] || @sightstone.region\n    name = if summoner.is_a? Summoner\n      summoner.name\n    else\n      summoner\n    end\n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{name}/runes\"\n    response = _get_api_response(uri)\n",
        "\n  def summoners(summoner_ids, optional={})\n    return {} if summoner_ids.empty?\n\n    region = optional[:region] || @sightstone.region\n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{summoner_ids.join(',')}/runes\"\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      summoners = {}\n      data.each do |key, raw_book|\n        summoners[key] = RuneBook.new(raw_book)\n      end\n      if block_given?\n        yield summoners\n      else\n        return summoners\n      end\n    }\n  end\n\n  def summoner_books(summoner_ids, optional={})\n    return {} if summoner_ids.empty?\n\n    region = optional[:region] || @sightstone.region\n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{summoner_ids.join(',')}/runes\"\n    response = _get",
        "\n        def create_zip(entries, ignore_entries)\n            buffer = \"\"\n\n            entries.each do |entry|\n                buffer << entry.to_zip\n            end\n\n            buffer << \"\\n\"\n\n            if ignore_entries\n                buffer << \"\\n\"\n                buffer << \"ignore entries:\"\n                ignore_entries.each do |entry|\n                    buffer << entry.to_zip\n                end\n            end\n\n            buffer\n        end\nend\n",
        "\n      self\n    end\n\n    def extract_event_parameters(opts)\n      opts.merge!(\n        :event_id => event_id,\n        :event_type => event_type,\n        :event_name => event_name,\n        :event_description => event_description,\n        :event_start_time => event_start_time,\n        :event_end_time => event_end_time,\n        :event_location => event_location,\n        :event_location_id => event_location_id,\n        :event_location_name => event_location_name,\n        :event_location_description => event_location_description,\n        :event_location_start_time => event_location_start_time,\n        :event_location_end_time => event_location_end_time,\n        :event_location_location_id => event_location_location_id,\n        :event_location_location_name => event_location_location_name,\n        :event_location_location_description => event_location_location_description,\n        :event_location_start_time => event_location_start_time,\n        :event_location_end_time => event_location_end_time,\n        :event_location_location_id =>",
        "\n    def boolean_row(id, args, block)\n      if id =~ /^(\\d+)$/\n        return true\n      elsif id =~ /^(\\d+)-(\\d+)$/\n        return true\n      elsif id =~ /^(\\d+)-(\\d+)-(\\d+)$/\n        return true\n      elsif id =~ /^(\\d+)-(\\d+)-(\\d+)$/\n        return true\n      elsif id =~ /^(\\d+)-(\\d+)-(\\d+)-(\\d+)$/\n        return true\n      elsif id =~ /^(\\d+)-(\\d+)-(\\d+)-(\\d+)$/\n        return true\n      elsif id =~ /^(\\d+)-(\\d+)-(\\d+)-(\\d+)-(\\d+)$/\n        return true\n      elsif id =~ /^(\\d+)-(\\d+)-(\\d+)-(\\d+)-(\\d+)$/\n        return true\n      elsif id =~ /^(\\d+)-(\\d+)-(\\d+)-(\\d+)-(\\d+)$/\n        return true\n      elsif id =~ /^(\\d+)-(\\d+)-(\\d+)-(\\d+)-(\\d+)-(\\d+)$/\n        return true\n      elsif id =~ /^(\\d+)-(\\d+)-(\\d+)-(\\d+)-(\\",
        "\n    def match_date_filter?(values=[])\n      return false if date_filter.empty? or values.empty?\n      expression = date_filter\n      columns = expression.scan(/(([nsd])(\\d+))([<!=~>]{1,2})(.*?)(?:[\\|&]{2}|$)/)\n      columns.each do |c|\n        value = case c[1]\n        when 'n'\n          values[c[2].to_i].empty? ? '0' : values[c[2].to_i]\n        when 's'\n          \"\\\"#{values[c[2].to_i]}\\\"\"\n        when 'd'\n          begin\n            Date.strptime(values[c[2].to_i], date_format)\n          rescue Exception => e\n            case c[3]\n            when '<', '<=', '=='\n              \"#{c[4]}+1\"\n            when '>', '>='\n              '0'\n            when '!='\n              c[4]\n            end \n        end\n        expression = expression.gsub(c[0], value)\n      end\n      eval(expression)\n    end\n\n    def match_number_filter?(values=[])\n      return false if number_filter.empty? or values.empty?\n      expression = number",
        "\n    end\n\n    def pivot_each_row(values=[])\n      pivot.each do |column, parameters|\n        value = values[parameters[:row].to_i]\n        value = value.strip.gsub(/^\"|\"$/, \"\") unless value.nil?\n        match = false\n        begin\n          match = eval(parameters[:operation].gsub('[value]', value))\n        rescue Exception => e\n\n        end\n        yield column, match\n      end\n    end\n\n    def pivot_each_column_with_values(values=[])\n      pivot.each do |column, parameters|\n        value = values[parameters[:col].to_i]\n        value = value.strip.gsub(/^\"|\"$/, \"\") unless value.nil?\n        match = false\n        begin\n          match = eval(parameters[:operation].gsub('[value]', value))\n        rescue Exception => e\n\n        end\n        yield column, match\n      end\n    end\n\n    def pivot_each_row_with_values(values=[])\n      pivot.each do |column, parameters|\n        value = values[parameters[:row].to_i]\n        value = value.strip.gsub(/^\"|\"$/, \"\") unless value.nil?\n        match = false\n       ",
        "\n        values.scan(/(?<=,|^)(BEGIN.*?END|\\/.*?\\/|.*?)(?=,|$)/i).flatten.each do |value|\n          send(value)\n        end unless values.nil?\n      end\n\n  def create_filter_with_options(values, options)\n    create_filter(values)\n    options.each do |option|\n      send(option)\n    end\n  end\n\n  def create_filter_with_options_and_values(values, options)\n    create_filter(values)\n    options.each do |option|\n      send(option)\n    end\n    values.each do |value|\n      send(value)\n    end\n  end\n\n  def create_filter_with_options_and_values_and_options(values, options)\n    create_filter(values)\n    options.each do |option|\n      send(option)\n    end\n    values.each do |value|\n      send(value)\n    end\n    options.each do |option|\n      send(option)\n    end\n  end\n\n  def create_filter_with_options_and_values_and_options_and_values(values, options)\n    create_filter(values)\n    options.each do |option|",
        "\n        filter << value.to_i unless filter.index(value.to_i)\n      end\n\n      def not_equal(value, args, block)\n        filter << value.to_i unless filter.index(value.to_i)\n      end\n\n      def greater(value, args, block)\n        filter << value.to_i unless filter.index(value.to_i)\n      end\n\n      def lesser(value, args, block)\n        filter << value.to_i unless filter.index(value.to_i)\n      end\n\n      def greater_equal(value, args, block)\n        filter << value.to_i unless filter.index(value.to_i)\n      end\n\n      def lesser_equal(value, args, block)\n        filter << value.to_i unless filter.index(value.to_i)\n      end\n\n      def in(value, args, block)\n        filter << value.to_i unless filter.index(value.to_i)\n      end\n\n      def not_in(value, args, block)\n        filter << value.to_i unless filter.index(value.to_i)\n      end\n\n      def between(value, args, block)\n        filter << value.to_i",
        "\n      def equal(value, args, block)\n        filter.push(value, args, block)\n      end\n\n      def equal_type_with_block(type, value, args, block)\n        filter.push(value, args, block)\n      end\n\n      def equal_type_with_block_with_block(type, value, args, block)\n        filter.push(value, args, block)\n      end\n\n      def equal_type_with_block_with_block_with_block(type, value, args, block)\n        filter.push(value, args, block)\n      end\n\n      def equal_type_with_block_with_block_with_block(type, value, args, block)\n        filter.push(value, args, block)\n      end\n\n      def equal_type_with_block_with_block_with_block(type, value, args, block)\n        filter.push(value, args, block)\n      end\n\n      def equal_type_with_block_with_block_with_block(type, value, args, block)\n        filter.push(value, args, block)\n      end\n\n      def equal_type_with_block_with_block_with_block(type, value, args, block",
        "\n      args << filter\n      block.call(*args)\nend\n\ndef range_with_args(start_value, end_value, args, block)\n        filter << (start_value.to_i..end_value.to_i).to_a\n      args << filter\n      block.call(*args)\nend\n\ndef range_with_args_and_block(start_value, end_value, args, block)\n        filter << (start_value.to_i..end_value.to_i).to_a\n      args << filter\n      block.call(*args)\nend\n\ndef range_with_args_and_block_with_args(start_value, end_value, args, block)\n        filter << (start_value.to_i..end_value.to_i).to_a\n      args << filter\n      block.call(*args)\nend\n\ndef range_with_args_and_block_with_args_and_block(start_value, end_value, args, block)\n        filter << (start_value.to_i..end_value.to_i).to_a\n      args << filter\n      block.call(*args)\nend\n\ndef range_with_args_and_block_with_args_and_block",
        "\n      def range(start_value, end_value, args, block)\n        filter.each do |value|\n          if value >= start_value && value <= end_value\n            yield value\n          end\n        end\n      end\n\n      def range_type_with_block(type, start_value, end_value, args, block)\n        filter_size_before = filter.size\n        range(start_value, end_value, args, block)\n        (filter.size - filter_size_before).times { types << type }\n      end\n\n      def range_type_with_block_with_args(type, start_value, end_value, args, block)\n        filter_size_before = filter.size\n        range(start_value, end_value, args, block)\n        (filter.size - filter_size_before).times { types << type }\n      end\n\n      def range_type_with_block_with_args_with_block(type, start_value, end_value, args, block)\n        filter_size_before = filter.size\n        range(start_value, end_value, args, block)\n        (filter.size - filter_size_before).times { types << type }\n      end\n\n      def range_type_with",
        "\n        if block\n          block.call(pivot)\n        end\n      end\n\n      def col_regex_with_args(col, r, args, block)\n        operation = \"'[value]' =~ Regexp.new('#{r}')\"\n        pivot[r] = { col: col, operation: operation }\n\n        if block\n          block.call(pivot)\n        end\n      end\n\n      def col_regex_with_block(col, r, args, block)\n        operation = \"'[value]' =~ Regexp.new('#{r}')\"\n        pivot[r] = { col: col, operation: operation }\n\n        if block\n          block.call(pivot)\n        end\n      end\n\n      def col_regex_with_block_with_args(col, r, args, block)\n        operation = \"'[value]' =~ Regexp.new('#{r}')\"\n        pivot[r] = { col: col, operation: operation }\n\n        if block\n          block.call(pivot)\n        end\n      end\n\n      def col_regex_with_block_with_block(col, r, args, block)\n        operation = \"'[value]' =~ Regexp.new('#{r}')\"\n        pivot[r] = { col: col, operation: operation }\n\n        if",
        "\n      def date_format\n        \"yyyy-MM-dd\"\n      end\n\n      def date_format_args\n        [date_format]\n      end\n\n      def date_format_block\n        lambda { |value| value.to_date }\n      end\n\n      def date_format_block_args\n        [date_format_args]\n      end\n\n      def date_format_block_block\n        lambda { |value| value.to_date }\n      end\n\n      def date_format_block_block_args\n        [date_format_block_args]\n      end\n\n      def date_format_block_block_block\n        lambda { |value| value.to_date }\n      end\n\n      def date_format_block_block_args\n        [date_format_block_block_args]\n      end\n\n      def date_format_block_block_block\n        lambda { |value| value.to_date }\n      end\n\n      def date_format_block_block_args\n        [date_format_block_block_args]\n      end\n\n      def date_format_block_block_block\n        lambda { |value| value.to_date }\n      end\n\n      def date_format_block_block_args\n       ",
        "\n      def date_range_with_args(col, start_date, end_date, args, block)\n        operation = \"   Date.strptime(\\\"#{start_date}\\\",  \\\"#{date_format}\\\") \"    +\n                    \"<= Date.strptime(\\\"[value]\\\",        \\\"#{date_format}\\\") && \" +\n                    \"   Date.strptime(\\\"#{end_date}\\\",    \\\"#{date_format}\\\")\"\n        pivot[\"#{start_date}-#{end_date}\"] = { col: col, operation: operation }\n      end\n\n      def date_range_with_block(col, start_date, end_date, args, block)\n        operation = \"   Date.strptime(\\\"#{start_date}\\\",  \\\"#{date_format}\\\") \"    +\n                    \"<= Date.strptime(\\\"[value]\\\",        \\\"#{date_format}\\\") && \" +\n                    \"   Date.strptime(\\\"#{end_date}\\\",    \\\"#{date_format}\\\")\"\n        pivot[\"#{start_date}-#{end_date}\"] = { col: col, operation: operation }\n      end\n\n      def date_range_with_args_and_block(col, start_date, end_date, args, block)\n        operation = \"   Date.strptime(\\\"#{",
        "\n        pivot[comparator + number] = { col: col, operation: operation }\n      end\n\n      def number_array(col, comparator, number, args, block)\n        comparator = '==' if comparator == '='\n        operation = \"[value] #{comparator} #{number}\"\n        pivot[\"#{comparator}#{number}\"] = { col: col, operation: operation }\n      end\n\n      def number_array_array(col, comparator, number, args, block)\n        comparator = '==' if comparator == '='\n        operation = \"[value] #{comparator} #{number}\"\n        pivot[\"#{comparator}#{number}\"] = { col: col, operation: operation }\n      end\n\n      def number_array_array_array(col, comparator, number, args, block)\n        comparator = '==' if comparator == '='\n        operation = \"[value] #{comparator} #{number}\"\n        pivot[\"#{comparator}#{number}\"] = { col: col, operation: operation }\n      end\n\n      def number_array_array_array(col, comparator, number, args, block)\n        comparator = '==' if comparator == '='\n        operation = \"[value] #{comparator} #{number}\"\n        pivot[\"#{comparator}#{number}\"] = { col: col, operation: operation }\n      end\n\n      def number_array",
        "\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation",
        "\n    def update_annotation(hook, annotation)\n      # validate the arguments\n      if hook.nil? then raise ArgumentError.new(\"Annotated caTissue object is missing\") end\n      if annotation.nil? then raise ArgumentError.new(\"Annotation caTissue object is missing\") end\n      # the annotated object must exist in the database\n      unless hook.identifier then\n        raise AnnotationError.new(\"Annotation writer does not support annotation of a caTissue object without an identifier: #{hook}\") end\n      # load the caRuby annotations if necessary\n      hook.class.ensure_annotations_loaded\n      # set the annotation hook reference\n      annotation.hook = hook\n      # update the annotation in the database\n      annotation.update\n    end\n\n    def delete_annotation(hook, annotation)\n      # validate the arguments\n      if hook.nil? then raise ArgumentError.new(\"Annotated caTissue object is missing\") end\n      if annotation.nil? then raise ArgumentError.new(\"Annotation caTissue object is missing\") end\n      # the annotated object must exist in the database\n      unless hook.identifier then\n        raise AnnotationError.new(\"Annotation writer does not support annotation of a caTissue object without an identifier: #{hook}\") end\n      # load the caRuby annotations if necessary\n      hook.class.ensure_annotations_loaded\n      # set the annotation",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n    end\n\n    def format_syntax_string(string, lexers)\n      if lexers.is_a?(::Rouge::Guessers::Lexers::Syntax)\n        lexers.syntax.to_s\n      else\n        lexers.to_s\n      end\n    end\n\n    def format_multiline_string(string)\n      string.gsub(/\\r?\\n/, \"\\n\").gsub(/\\n\\n/, \"\\n\\n\")\n    end\n\n    def format_plain_string(string)\n      string.gsub(/\\r?\\n/, \"\\n\").gsub(/\\n\\n/, \"\\n\\n\")\n    end\n\n    def r_lexers\n      [\n        ::Rouge::Guessers::Lexers::Syntax,\n        ::Rouge::Guessers::Lexers::Comment,\n        ::Rouge::Guessers::Lexers::Comment,\n        ::Rouge::Guessers::Lexers::Comment,\n        ::Rouge::Guessers::Lexers::Comment,\n        ::Rouge::Guessers::Lexers::Comment,\n        ::Rouge::Guessers::Lexers::Comment,\n        ::Rouge::Guessers::Lexers::Comment,\n        ::Rouge::Guessers::Lexers::Comment,\n        ::",
        "\n    def meta_json\n      meta.to_json\n    end\n\n    def meta_json_safe\n      meta.to_json.safe\n    end\n\n    def meta_json_safe_safe\n      meta.to_json.safe_safe\n    end\n\n    def meta_json_safe_safe_safe\n      meta.to_json.safe_safe_safe.safe\n    end\n\n    def meta_json_safe_safe_safe_safe\n      meta.to_json.safe_safe_safe_safe.safe_safe\n    end\n\n    def meta_json_safe_safe_safe_safe_safe\n      meta.to_json.safe_safe_safe_safe.safe_safe_safe.safe\n    end\n\n    def meta_json_safe_safe_safe_safe_safe\n      meta.to_json.safe_safe_safe_safe.safe_safe_safe.safe_safe\n    end\n\n    def meta_json_safe_safe_safe_safe_safe\n      meta.to_json.safe_safe_safe_safe.safe_safe_safe.safe_safe\n    end\n\n    def meta_json_safe_safe_safe_safe_safe\n      meta.to_json.safe_safe_safe_safe.safe_safe",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\",
        "\n        collection.each do |category, collection|\n          collection.entries.each do |entry|\n            entry.filter.add_category(category)\n          end\n        end\n      end\n\n  def add_entry(entry)\n    collection[entry.category].entries << entry\n  end\n\n  def get_entries(category)\n    collection[category].entries\n  end\n\n  def get_entries_by_category(category)\n    collection[category].entries.select { |e| e.filter.has_category?(category) }\n  end\n\n  def get_entries_by_category_and_filter(category, filter)\n    collection[category].entries.select { |e| e.filter.has_category?(category) && e.filter.matches?(filter) }\n  end\n\n  def get_entries_by_category_and_filter_and_category(category, filter, category)\n    collection[category].entries.select { |e| e.filter.has_category?(category) && e.filter.matches?(filter) && e.category == category }\n  end\n\n  def get_entries_by_category_and_filter_and_category_and_filter(category, filter, category, filter)\n    collection[category].entries.select {",
        "\n    def verbose\n      @verbose ||= false\n    end\n\n    def verbose=(value)\n      @verbose = value\n    end\n\n    def verbose?\n      @verbose\n    end\n\n    def debug\n      @debug ||= false\n    end\n\n    def debug=(value)\n      @debug = value\n    end\n\n    def debug?\n      @debug\n    end\n\n    def info\n      @info ||= false\n    end\n\n    def info=(value)\n      @info = value\n    end\n\n    def info?\n      @info\n    end\n\n    def warn\n      @warn ||= false\n    end\n\n    def warn=(value)\n      @warn = value\n    end\n\n    def warn?\n      @warn\n    end\n\n    def error\n      @error ||= false\n    end\n\n    def error=(value)\n      @error = value\n    end\n\n    def error?\n      @error\n    end\n\n    def fatal\n      @fatal ||= false\n    end\n\n    def fatal=(value)\n      @fatal = value\n    end\n\n    def fatal?\n      @fatal\n    end\n\n    def debug_backtrace\n      @debug_backtrace ||= false\n    end\n\n    def debug_backtrace=(value)\n      @debug_backtrace = value",
        "\n    def require_aether_with_dependencies *deps\n      require_aether *deps\n    end\n\n    def require_aether_with_sources *sources\n      require_aether *sources\n    end\n\n    def require_aether_with_dependencies_and_sources *deps, *sources\n      require_aether *deps, *sources\n    end\n\n    def require_aether_with_dependencies_and_sources_and_dependencies *deps, *sources, &block\n      require_aether *deps, *sources, &block\n    end\n\n    def require_aether_with_dependencies_and_sources_and_dependencies_and_sources *deps, *sources, &block\n      require_aether *deps, *sources, &block\n    end\n\n    def require_aether_with_dependencies_and_sources_and_dependencies_and_sources *deps, *sources, &block\n      require_aether *deps, *sources, &block\n    end\n\n    def require_aether_with_dependencies_and_sources_and_dependencies_and_sources *deps, *sources, &block\n      require_aether *deps, *sources, &block\n    end\n\n    def require_aether_with_dependencies_and_sources_and_dependencies_and_",
        "\n        File.open(source).each_with_index do |line, index|\n          next if line.chomp.empty?\n\n          values = unstring(line).chomp.split(';')\n\n          next if values.empty?\n\n          @joiners.each do |joiner|\n            key = values[joiner.join[0]]\n            joiner.lookup[:rows][key] = []\n\n            joiner.cols.each do |i|\n              joiner.lookup[:rows][key] << values[i]\n            end\n          end\n\n        end\n      end\n\n      def create_lookup_table_with_joiners\n        File.open(source).each_with_index do |line|\n          next if line.chomp.empty?\n\n          values = unstring(line).chomp.split(';')\n\n          next if values.empty?\n\n          @joiners.each do |joiner|\n            key = values[joiner.join[0]]\n            joiner.lookup[:rows][key] = []\n\n            joiner.cols.each do |i|\n              joiner.lookup[:rows][key] << values[i]\n            end\n          end\n\n        end\n      end\n\n      def create_lookup_table_with_joiners_with_cols\n",
        "\nend\n\ndef col_names(pos, cols)\n        if pos.nil? || pos.empty?\n          cols.each { |c| c.name }\n          cols\n        else\n          pos.split(';').collect { |p| p.split(',').collect { |p| p.to_s } }\n        end\n      end\n\ndef col_names_with_spaces(pos, cols)\n        if pos.nil? || pos.empty?\n          cols.each { |c| c.name.gsub(/\\s+/, ' ') }\n          cols\n        else\n          pos.split(';').collect { |p| p.split(',').collect { |p| p.to_s } }\n        end\n      end\n\ndef col_names_with_spaces_and_spaces(pos, cols)\n        if pos.nil? || pos.empty?\n          cols.each { |c| c.name.gsub(/\\s+/, ' ') }\n          cols.each { |c| c.name.gsub(/\\s+/, ' ') }\n          cols\n        else\n          pos.split(';').collect { |p| p.split(',').collect { |p| p.to_s } }\n        end\n      end\n\ndef col_",
        "\n  def col_positions(p, cs)\n    cs.map { |c| c.split('=').collect { |c| c.to_i } }\n  end\n\n  def create_joiners_from_csv(j, c, p)\n    create_joiners(j, c, p)\n  end\n\n  def create_joiners_from_csv_with_rows(j, c, p)\n    create_joiners(j, c, p)\n  end\n\n  def create_joiners_from_csv_with_cols(j, c, p)\n    create_joiners(j, c, p)\n  end\n\n  def create_joiners_from_csv_with_cols_and_rows(j, c, p)\n    create_joiners(j, c, p)\n  end\n\n  def create_joiners_from_csv_with_cols_and_rows_with_rows(j, c, p)\n    create_joiners(j, c, p)\n  end\n\n  def create_joiners_from_csv_with_cols_and_rows_with_cols(j, c, p)\n    create_joiners(j, c, p)\n  end\n\n  def create_joiners",
        "\n      self.end_date ||= Java::JavaUtil::Date.new\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||= start_date\n      self.end_date ||=",
        "\n    def []=(range, value)\n      r, c = range\n      r ||= 0..(nrows-1)\n      c ||= 0..(ncols-1)\n\n      row_selection = rows.values_at(*r)\n      col_selection = []\n\n      if rows_are_arrays?(row_selection)\n        row_selection.each do |row|\n          values = row.values_at(*c)\n          col_selection << (values.respond_to?(:to_ary) ? values : [values]) \n        end \n      else\n        col_selection << row_selection[*c]\n      end\n\n      SpreadSheet.new(*col_selection, \n                      row_labels: row_labels.values_at(*r),\n                      col_labels: col_labels.values_at(*c))\n    end\n\n    def []=(range, value)\n      r, c = range\n      r ||= 0..(nrows-1)\n      c ||= 0..(ncols-1)\n\n      row_selection = rows.values_at(*r)\n      col_selection = []\n\n      if rows_are_arrays?(row_selection)\n        row_selection.each do |row|\n          values = row.values_at(*c)\n          col_",
        "\n    end\n\n    def column_collect_with_index(&block)\n      result = []\n      0.upto(ncols-1) { |i| result << block.call(self[nil,i], i) }\n      result\n    end\n\n    def column_collect_with_index_with_index(&block)\n      result = []\n      0.upto(ncols-1) { |i| result << block.call(self[nil,i], i, i) }\n      result\n    end\n\n    def column_collect_with_index_with_index_with_index(&block)\n      result = []\n      0.upto(ncols-1) { |i| result << block.call(self[nil,i], i, i, i) }\n      result\n    end\n\n    def column_collect_with_index_with_index_with_index(&block)\n      result = []\n      0.upto(ncols-1) { |i| result << block.call(self[nil,i], i, i, i) }\n      result\n    end\n\n    def column_collect_with_index_with_index_with_index(&block)\n      result = []\n      0.upto(ncols-",
        "\n    def row_labels\n      @row_labels ||= []\n    end\n\n    def col_labels\n      @col_labels ||= []\n    end\n\n    def nrows\n      @nrows ||= row_labels.size\n    end\n\n    def ncols\n      @ncols ||= col_labels.size\n    end\n\n    def row_labels=(labels)\n      @row_labels = labels\n    end\n\n    def col_labels=(labels)\n      @col_labels = labels\n    end\n\n    def nrows=(nrows)\n      @nrows = nrows\n    end\n\n    def ncols=(ncols)\n      @ncols = ncols\n    end\n\n    def nrows=(nrows)\n      @nrows = nrows\n    end\n\n    def ncols=(ncols)\n      @ncols = ncols\n    end\n\n    def nrows=(nrows)\n      @nrows = nrows\n    end\n\n    def ncols=(ncols)\n      @ncols = ncols\n    end\n\n    def nrows=(nrows)\n      @nrows = nrows\n    end\n\n    def ncols=(ncols)\n      @ncols = ncols\n    end\n\n    def nrows=(nrows)\n      @nrows = nrows\n    end\n\n    def ncols=(ncols)\n      @n",
        "\n    def to_a\n      rows.map { |row| row.map { |c| c.to_a } }\n    end\n\n    def to_json\n      JSON.generate(to_a)\n    end\n\n    def to_yaml\n      YAML.dump(to_a)\n    end\n\n    def to_csv\n      CSV.generate do |csv|\n        csv << [col_labels.join(\",\"), rows.join(\",\")]\n      end\n    end\n\n    def to_csv_with_header\n      CSV.generate do |csv|\n        csv << [col_labels.join(\",\"), rows.join(\",\")]\n      end\n    end\n\n    def to_csv_with_header_with_header\n      CSV.generate do |csv|\n        csv << [col_labels.join(\",\"), rows.join(\",\")]\n      end\n    end\n\n    def to_csv_with_header_with_header_with_header\n      CSV.generate do |csv|\n        csv << [col_labels.join(\",\"), rows.join(\",\")]\n      end\n    end\n\n    def to_csv_with_header_with_header_with_header\n      CSV.generate do |csv|\n        csv << [col_",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\nend\n\ndef equalize_columns(columns)\n        column_sizes = columns.collect { |c| c.size }\n\n        return columns if column_sizes.uniq.size == 1\n\n        max_size = column_sizes.max\n        small_columns = []\n        column_sizes.each_with_index { |c,i| small_columns << i if c < max_size }\n\n        small_columns.each do |i| \n          columns[i] += [NotAvailable] * (max_size - columns[i].size)\n        end\n\n        columns\n      end\n\ndef equalize_rows_and_columns(rows, columns)\n        equalize_rows(equalize_rows(rows)).collect { |r| equalize_columns(equalize_columns(columns)) }\n      end\n\ndef equalize_rows_and_columns_with_index(rows, columns, index)\n        equalize_rows(equalize_rows(rows)).collect { |r| equalize_columns(equalize_columns(columns)) }.collect { |r| equalize_columns(equalize_columns(columns)) }.collect { |r| equalize_columns(equalize_columns(columns)) }.collect { |r| equalize_columns(equalize_columns(columns",
        "\n      end\n\n      def same_row_size?(rows)\n        offset = opts[:c] ? 1 : 0\n        return true if rows.size == 1 + offset\n        (0 + offset).upto(rows.size - 2) do |i| \n          return true unless rows[i].size == rows[i+1].size\n        end\n        true\n      end\n\n      def same_column_size_and_row_size?(rows)\n        same_column_size?(rows) && same_row_size?(rows)\n      end\n\n      def same_column_size_and_row_size_and_column_size?(rows)\n        same_column_size?(rows) && same_row_size?(rows) && same_column_size?(rows)\n      end\n\n      def same_column_size_and_row_size_and_column_size_and_row_size?(rows)\n        same_column_size?(rows) && same_row_size?(rows) && same_column_size?(rows) && same_row_size?(rows)\n      end\n\n      def same_column_size_and_row_size_and_column_size_and_row_size?(rows)\n        same_",
        "\n        raise ArgumentError, \"Invalid value #{value.inspect}\"\n      end\n\n  def coerce_to_array(value)\n        return SpreadSheet.new([value]) if value.is_a?(Numeric)\n        return SpreadSheet.new(value)   if value.is_a?(Array)\n\n        raise ArgumentError, \"Invalid value #{value.inspect}\"\n      end\n\n  def coerce_to_hash(value)\n        return SpreadSheet.new(value)   if value.is_a?(Array)\n\n        raise ArgumentError, \"Invalid value #{value.inspect}\"\n      end\n\n  def coerce_to_string(value)\n        return SpreadSheet.new(value)   if value.is_a?(Array)\n\n        raise ArgumentError, \"Invalid value #{value.inspect}\"\n      end\n\n  def coerce_to_boolean(value)\n        return SpreadSheet.new(value)   if value.is_a?(Array)\n\n        raise ArgumentError, \"Invalid value #{value.inspect}\"\n      end\n\n  def coerce_to_date(value)\n        return SpreadSheet.new(value)   if value.is_a?(Array)\n\n        raise ArgumentError, \"Invalid value #{value.inspect}\"\n      end\n\n  def coerce_to",
        "\n      def coerce(s)\n        case s\n        when Array\n          s.map { |v| coerce(v) }\n        when Hash\n          s.each { |k, v| coerce(v) }\n        else\n          s\n        end\n      end\n\n      def rows\n        @rows ||= begin\n          rows = []\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(rows.last.dup)\n          rows.push(",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveAllCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapRemoveAllOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants",
        "\n        @sum_col_title = nil\n        @sum_row_title = nil\n\n      end\n\n      def get_sum_scheme\n\n        sum_scheme = nil\n\n        if @sum_row_title.nil?\n          sum_scheme = @sum_col_title.nil? ? @sum_row : @sum_row_title\n        else\n          sum_scheme = @sum_col_title.nil? ? @sum_row : @sum_row_title + \":\" + @sum_col_title\n        end\n\n        init_sum_scheme(sum_scheme)\n\n        sum_scheme\n\n      end\n\n      def get_sum_scheme_as_csv\n\n        sum_scheme = nil\n\n        if @sum_row_title.nil?\n          sum_scheme = @sum_col_title.nil? ? @sum_row : @sum_row_title + \":\" + @sum_col_title\n        else\n          sum_scheme = @sum_col_title.nil? ? @sum_row : @sum_row_title + \":\" + @sum_col_title + \",\" + @sum_col_title\n        end\n\n        sum_scheme.gsub!(/\\n/, \"\")\n\n        sum_scheme.gsub!(/\\r/,",
        "\n        @key_titles.each do |title|\n          @key_columns << title.to_i\n        end\n\n        @key_columns.each do |column|\n          @key_titles << column\n        end\n\n        @key_titles.each do |title|\n          @key_columns << title.to_i\n        end\n\n        @key_columns.each do |column|\n          @key_titles << column\n        end\n\n        @key_titles.each do |title|\n          @key_columns << title.to_i\n        end\n\n        @key_columns.each do |column|\n          @key_titles << column\n        end\n\n        @key_titles.each do |title|\n          @key_columns << title.to_i\n        end\n\n        @key_columns.each do |column|\n          @key_titles << column\n        end\n\n        @key_titles.each do |title|\n          @key_columns << title.to_i\n        end\n\n        @key_columns.each do |column|\n          @key_titles << column\n        end\n\n        @key_titles.each do |title|\n          @key_columns << title.to_i\n        end\n\n        @key_columns.each do |column",
        "\n      end\n\n      def original_pivot_sequence_heading_column_filter\n        (heading.sort - col_filter.pivot.keys << col_filter.pivot.keys).flatten\n      end\n\n      def original_pivot_sequence_heading_column_filter_column_filter\n        (heading.sort - col_filter.pivot.keys << col_filter.pivot.keys).flatten\n      end\n\n      def original_pivot_sequence_heading_column_filter_column_filter_column_filter\n        (heading.sort - col_filter.pivot.keys << col_filter.pivot.keys).flatten\n      end\n\n      def original_pivot_sequence_heading_column_filter_column_filter_column_filter\n        (heading.sort - col_filter.pivot.keys << col_filter.pivot.keys).flatten\n      end\n\n      def original_pivot_sequence_heading_column_filter_column_filter_column_filter_column_filter\n        (heading.sort - col_filter.pivot.keys << col_filter.pivot.keys).flatten\n      end\n\n      def original_pivot_sequence_heading_column_filter_column_filter_column_filter_column_filter\n        (heading.sort - col_filter.pivot.keys << col_filter.pivot.keys).flatten\n      end",
        "\n    def unstring(object)\n      object.gsub(/\\s+/, '')\n    end\n\n    def has_filter?\n      filter.flatten.uniq.index(options[:row]).nil?\n    end\n\n    def filter\n      @filter ||= []\n    end\n\n    def pattern\n      @pattern ||= []\n    end\n\n    def has_filter?\n      filter.flatten.uniq.index(options[:row]).nil?\n    end\n\n    def filter\n      @filter ||= []\n    end\n\n    def pattern\n      @pattern ||= []\n    end\n\n    def has_filter?\n      filter.flatten.uniq.index(options[:row]).nil?\n    end\n\n    def filter\n      @filter ||= []\n    end\n\n    def pattern\n      @pattern ||= []\n    end\n\n    def has_filter?\n      filter.flatten.uniq.index(options[:row]).nil?\n    end\n\n    def filter\n      @filter ||= []\n    end\n\n    def pattern\n      @pattern ||= []\n    end\n\n    def has_filter?\n      filter.flatten.uniq.index(options[:row]).nil?\n    end\n\n    def filter\n      @filter ||= []\n    end\n\n    def pattern\n      @pattern ||=",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\",
        "\n    end\n\n    def become_fan\n      client.user.fan_of << self\n    end\n\n    def become_fan!\n      become_fan\n      client.user.fan_of.delete(self)\n    end\n\n    def become_fan_with_friends\n      become_fan\n      client.rooms.with_friends.delete(self)\n    end\n\n    def become_fan_without_friends\n      become_fan\n      client.rooms.with_friends.delete(self)\n    end\n\n    def become_fan_with_friends!\n      become_fan\n      client.rooms.with_friends.delete(self)\n    end\n\n    def become_fan_without_friends!\n      become_fan\n      client.rooms.with_friends.delete(self)\n    end\n\n    def become_fan_with_friends!(id)\n      become_fan\n      client.rooms.with_friends.delete(id)\n    end\n\n    def become_fan_without_friends!(id)\n      become_fan\n      client.rooms.with_friends.delete(id)\n    end\n\n",
        "\n    def unboot(reason = '')\n      api('room.unboot_user', :roomid => room.id, :section => room.section, :target_userid => id, :reason => reason)\n      true\n    end\n\n    def join(reason = '')\n      api('room.join_user', :roomid => room.id, :section => room.section, :target_userid => id, :reason => reason)\n      true\n    end\n\n    def leave(reason = '')\n      api('room.leave_user', :roomid => room.id, :section => room.section, :target_userid => id, :reason => reason)\n      true\n    end\n\n    def join_room(roomid, reason = '')\n      api('room.join_room', :roomid => roomid, :section => room.section, :target_userid => id, :reason => reason)\n      true\n    end\n\n    def leave_room(roomid, reason = '')\n      api('room.leave_room', :roomid => roomid, :section => room.section, :target_userid => id, :reason => reason)\n      true\n    end\n\n    def join_room_with_user(roomid, userid, reason = '')\n      api('room.join_room_",
        "\n    def report_all(reason = '')\n      api('room.report_all_user', :roomid => room.id, :section => room.section, :reported => id, :reason => reason)\n      true\n    end\n\n    def report_all_all(reason = '')\n      api('room.report_all_all_user', :roomid => room.id, :section => room.section, :reported => id, :reason => reason)\n      true\n    end\n\n    def report_all_all_all(reason = '')\n      api('room.report_all_all_all_user', :roomid => room.id, :section => room.section, :reported => id, :reason => reason)\n      true\n    end\n\n    def report_all_all_all(reason = '')\n      api('room.report_all_all_all_user', :roomid => room.id, :section => room.section, :reported => id, :reason => reason)\n      true\n    end\n\n    def report_all_all_all_all(reason = '')\n      api('room.report_all_all_all_all_user', :roomid => room.id, :section => room.section, :reported => id, :reason => reason",
        "\n    def default_derived_characteristics_for_class(klass)\n      default_derived_characteristics\n      klass.derived_characteristics.each do |chr|\n        default_derived_characteristics(chr)\n      end\n    end\n\n    def default_derived_characteristics_for_class_with_attributes(klass, attributes)\n      default_derived_characteristics\n      klass.derived_characteristics.each do |chr|\n        default_derived_characteristics(chr, attributes)\n      end\n    end\n\n    def default_derived_characteristics_for_class_with_attributes_and_attributes(klass, attributes, attributes_and_attributes)\n      default_derived_characteristics\n      klass.derived_characteristics.each do |chr|\n        default_derived_characteristics(chr, attributes, attributes_and_attributes)\n      end\n    end\n\n    def default_derived_characteristics_for_class_with_attributes_and_attributes_and_attributes(klass, attributes, attributes_and_attributes_and_attributes)\n      default_derived_characteristics\n      klass.derived_characteristics.each do |chr|\n        default_derived_characteristics(chr, attributes, attributes_and_attributes_and_",
        "\n    def region=(args)\n      case args\n        when String\n          self.setRegion(CoordinateRegion.new(args).api, animated: false)\n        when Hash\n          self.setRegion(CoordinateRegion.new(args[:region]).api, animated: false)\n        else\n          self.setRegion(CoordinateRegion.new(args).api, animated: false)\n      end\n    end\n\n    def animated=(args)\n      case args\n        when Hash\n          self.setRegion(CoordinateRegion.new(args[:region]).api, animated: true)\n        when String\n          self.setRegion(CoordinateRegion.new(args).api, animated: true)\n        else\n          self.setRegion(CoordinateRegion.new(args).api, animated: true)\n      end\n    end\n\n    def animated=(args)\n      case args\n        when String\n          self.setRegion(CoordinateRegion.new(args).api, animated: true)\n        when Hash\n          self.setRegion(CoordinateRegion.new(args[:region]).api, animated: true)\n        else\n          self.setRegion(CoordinateRegion.new(args).api, animated: true)\n      end\n    end\n\n    def animated=(args)\n      case args\n        when String\n          self.setRegion(Coordinate",
        "\n    end\n\n    def collection_medical_identifiers\n      medical_identifiers.select { |medical_identifier| medical_identifier.site_type == Site::SiteType::COLLECTION }\n    end\n\n    def collection_medical_identifier\n      collection_medical_identifiers.first\n    end\n\n    def collection_medical_identifier_for_medical_identifier(medical_identifier)\n      collection_medical_identifiers.find { |medical_identifier| medical_identifier.medical_identifier == medical_identifier }\n    end\n\n    def collection_medical_identifier_for_medical_identifier_with_type(medical_identifier, type)\n      collection_medical_identifiers.find { |medical_identifier| medical_identifier.medical_identifier_type == type && medical_identifier.medical_identifier == medical_identifier }\n    end\n\n    def collection_medical_identifier_for_medical_identifier_with_type_and_name(medical_identifier, type, name)\n      collection_medical_identifiers.find { |medical_identifier| medical_identifier.medical_identifier_type == type && medical_identifier.medical_identifier_name == name && medical_identifier.medical_identifier == medical_",
        "\nend\n\ndef match_tissue_side(other)\n      chr = characteristics\n      ochr = other.characteristics\n      chr and ochr and chr.tissue_side == ochr.tissue_side\nend\n\ndef match_tissue_site(other)\n      chr = characteristics\n      ochr = other.characteristics\n      chr and ochr and chr.tissue_site == ochr.tissue_site\nend\n\ndef match_tissue_site_and_side(other)\n      chr = characteristics\n      ochr = other.characteristics\n      chr and ochr and chr.tissue_site == ochr.tissue_site and chr.tissue_side == ochr.tissue_side\nend\n\ndef match_tissue_site_and_side_and_site(other)\n      chr = characteristics\n      ochr = other.characteristics\n      chr and ochr and chr.tissue_site == ochr.tissue_site and chr.tissue_side == ochr.tissue_side and chr.tissue_site == ochr.tissue_site\nend\n\ndef match_tissue_site_and_side_and_site_and_side(other)\n      chr = characteristics\n      ochr = other.characteristics\n      chr and ochr",
        "\nend\n\ndef default_user_group\n      default_user.collection_protocol.collection_group\n    end\n\ndef default_user_group_id\n      default_user_group.id\n    end\n\ndef default_user_group_name\n      default_user_group.name\n    end\n\ndef default_user_group_description\n      default_user_group.description\n    end\n\ndef default_user_group_members\n      default_user_group.members\n    end\n\ndef default_user_group_members_count\n      default_user_group.members_count\n    end\n\ndef default_user_group_members_count_by_type\n      default_user_group.members_count_by_type\n    end\n\ndef default_user_group_members_count_by_type_by_name\n      default_user_group.members_count_by_type_by_name\n    end\n\ndef default_user_group_members_count_by_type_by_name_by_id\n      default_user_group.members_count_by_type_by_name_by_id\n    end\n\ndef default_user_group_members_count_by_type_by_name_by_id_by_name\n      default_user",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\n    def load(translations, file)\n      file = ::Rails.root.join(file)\n      FileUtils.rm_rf file\n\n      translations = JSON.parse(File.read(file))\n\n      translations.each do |key, value|\n        translations[key] = value.to_sym\n      end\n\n      translations\n    end\n\n    def load_translations(translations, file)\n      translations = load(translations, file)\n\n      translations.each do |key, value|\n        translations[key] = value.to_sym\n      end\n\n      translations\n    end\n\n    def load_translations_from_file(translations, file)\n      translations = load(translations, file)\n\n      translations.each do |key, value|\n        translations[key] = value.to_sym\n      end\n\n      translations\n    end\n\n    def load_translations_from_hash(translations, hash)\n      translations = load(translations, hash[:file])\n\n      translations.each do |key, value|\n        translations[key] = value.to_sym\n      end\n\n      translations\n    end\n\n    def load_translations_from_hash_with_defaults(translations, hash)\n      translations = load(translations, hash[:file], hash[:defaults])\n\n      translations.",
        "\n        def init_translations\n          ::I18n.backend.load_path = default_locales_path\n          ::I18n.backend.instance_eval do\n            init_translations unless initialized?\n            translations\n          end\n        end\n\n        def translations\n          ::I18n.backend.translations\n        end\n      end\n    end\n\n    def default_locales_path\n      File.expand_path(\"../locales\", __FILE__)\n    end\n\n    def default_locales_path=(path)\n      ::I18n.load_path = path\n    end\n\n    def initialized?\n      ::I18n.backend.instance_eval do\n        init_translations unless initialized?\n        true\n      end\n    end\n\n    def initialized?\n      ::I18n.backend.instance_eval do\n        init_translations unless initialized?\n        false\n      end\n    end\n\n    def init_translations\n      ::I18n.backend.instance_eval do\n        init_translations unless initialized?\n        translations\n      end\n    end\n\n    def translations\n      ::I18n.backend.translations\n    end\n\n    def translations=(translations)\n      ::I18n.backend.translations = translations\n    end\n\n    def translations_path\n      ::I18n.backend.translations",
        "\n    def default_properties_file\n      File.join(File.dirname(__FILE__), 'remoteService.xml')\n    end\n\n    def infer_classpath\n      # the classpath\n      classpath = File.join(File.dirname(__FILE__), 'classes')\n      # the path\n      path = File.join(File.dirname(__FILE__), 'classes')\n      # the classpath\n      classpath = classpath.gsub(/^#{path}/, '')\n      classpath\n    end\n\n    def infer_database_properties\n      # the database properties\n      database = {}\n      # the database properties\n      database[:host] = 'localhost'\n      database[:port] = '3306'\n      database\n    end\n\n    def remote_service_url\n      # the remote service url\n      url = 'http://localhost:3306'\n      # the database properties\n      database = load_properties\n      url = url.gsub(/^#{database[:host]}/, '')\n      url = url.gsub(/^#{database[:port]}/, '')\n      url\n    end\n\n    def load_properties_file(file)\n      # the properties file\n      properties = {}\n      # the properties file\n      properties_file = File.open(file, 'r')\n      properties_file.each",
        "\n    def download_files\n      Dir.glob(\"#{DATA_FILE_PATH}/*\").each { |file|\n        File.open(file, 'r:ascii-8bit').each { |line|\n          @downloads << Download.new(line)\n        }\n      }\n    end\n\n    def download_all\n      download_files\n      download_pilots\n      download_atc\n    end\n\n    def download_pilots\n      Dir.glob(\"#{DATA_FILE_PATH}/*\").each { |file|\n        File.open(file, 'r:ascii-8bit').each { |line|\n          @pilots << Pilot.new(line)\n        }\n      }\n    end\n\n    def download_atc\n      Dir.glob(\"#{DATA_FILE_PATH}/*\").each { |file|\n        File.open(file, 'r:ascii-8bit').each { |line|\n          @atc << ATC.new(line)\n        }\n      }\n    end\n\n    def download_general\n      Dir.glob(\"#{DATA_FILE_PATH}/*\").each { |file|\n        File.open(file, 'r:ascii-8bit').each { |line|\n          @general[line.split(\"=\")[",
        "\n    def download_to_file(url, file_path)\n      File.open(file_path, 'wb') do |f|\n        open(url, 'rb') do |f|\n          f.write(f.read)\n        end\n      end\n    end\n\n    def random_data_url\n      \"http://www.google.com/data/feeds/api/random?alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=json&alt=",
        "\n    end\n\n    def download_to_file url, file\n      url = URI.parse(URI.encode(url.strip))\n\n      File.new(file, File::CREAT)\n\n      Net::HTTP.start(url.host) { |http|\n        resp = http.get(url.path)\n        open(file, \"wb\") { |file|\n          file.write(resp.body)\n        }\n      }\n    end\n\n    def download_to_file url, file\n      url = URI.parse(URI.encode(url.strip))\n\n      File.new(file, File::CREAT)\n\n      Net::HTTP.start(url.host) { |http|\n        resp = http.get(url.path)\n        open(file, \"wb\") { |file|\n          file.write(resp.body)\n        }\n      }\n    end\n\n    def download_to_file url, file\n      url = URI.parse(URI.encode(url.strip))\n\n      File.new(file, File::CREAT)\n\n      Net::HTTP.start(url.host) { |http|\n        resp = http.get(url.path)\n        open(file, \"wb\") { |file|\n          file.write(",
        "\nend\n\ndef random_data_url_with_id\n      url0s = Array.new\n      file = File.open(STATUS_FILE_PATH)\n      file.each {|line|\n        if line.start_with? \"url0\"\n          url0s << line.split(\"=\").last\n        end\n      }\n      return url0s[rand(url0s.length)]\n     end\n\ndef random_data_url_with_id_and_name\n      url0s = Array.new\n      file = File.open(STATUS_FILE_PATH)\n      file.each {|line|\n        if line.start_with? \"url0\"\n          url0s << line.split(\"=\").last\n        end\n      }\n      return url0s[rand(url0s.length)]\n     end\n\ndef random_data_url_with_id_and_name_and_id\n      url0s = Array.new\n      file = File.open(STATUS_FILE_PATH)\n      file.each {|line|\n        if line.start_with? \"url0\"\n          url0s << line.split(\"=\").last\n        end\n      }\n      return url0s[rand(url0s.length)]\n     end\n\ndef",
        "\n      # => Clear the Whole Damned Cache\n      instance_variables.each { |x| remove_instance_variable(x) }\n    end\n\n    def cachier!(var = nil)\n      cachier!(var)\n      yield\n    end\n\n    def cachier!(var = nil)\n      cachier!(var) { yield }\n    end\n\n    def cachier!(var = nil)\n      cachier!(var) { yield }\n    end\n\n    def cachier!(var = nil)\n      cachier!(var) { yield }\n    end\n\n    def cachier!(var = nil)\n      cachier!(var) { yield }\n    end\n\n    def cachier!(var = nil)\n      cachier!(var) { yield }\n    end\n\n    def cachier!(var = nil)\n      cachier!(var) { yield }\n    end\n\n    def cachier!(var = nil)\n      cachier!(var) { yield }\n    end\n\n    def cachier!(var = nil)\n      cachier!(var) { yield }\n    end\n\n    def cachier!(var = nil)\n      cachier!(var) { yield }\n    end\n\n    def",
        "\n      rescue\n        puts \"Error writing to #{file}\"\n      end\n    end\n\n    def read_json(file)\n      return unless file\n      begin\n        File.open(file, 'r') { |f| JSON.parse(f.read) }\n      rescue\n        puts \"Error reading from #{file}\"\n      end\n    end\n\n    def write_json_file(file, object)\n      write_json(file, object)\n    end\n\n    def read_json_file(file)\n      read_json(file)\n    end\n\n    def write_json_file_with_hash(file, object)\n      write_json(file, object.to_json)\n    end\n\n    def read_json_file_with_hash(file)\n      read_json(file)\n    end\n\n    def write_json_file_with_hash(file, object)\n      write_json(file, object.to_json)\n    end\n\n    def read_json_file_with_hash(file)\n      read_json(file)\n    end\n\n    def write_json_file_with_hash(file, object)\n      write_json(file, object.to_json)\n    end\n\n    def read_json_file_",
        "\n    end\n\n    def file_size(file)\n      return unless file\n      return file unless file.is_a?(String) && File.file?(file)\n      File.size(file)\n    end\n\n    def file_size_in_bytes(file)\n      return unless file\n      return file unless file.is_a?(String) && File.file?(file)\n      File.size(file) * 1024\n    end\n\n    def file_size_in_kilobytes(file)\n      return unless file\n      return file unless file.is_a?(String) && File.file?(file)\n      File.size(file) * 1024 * 1024\n    end\n\n    def file_size_in_megabytes(file)\n      return unless file\n      return file unless file.is_a?(String) && File.file?(file)\n      File.size(file) * 1024 * 1024 * 1024\n    end\n\n    def file_size_in_gigabytes(file)\n      return unless file\n      return file unless file.is_a?(String) && File.file?(file)\n      File.size(file) * 1024 * 1024 * 1024 * 1024\n    end\n\n    def file_size_in_",
        "\n    end\n\n    def common_set(ary) # rubocop: disable AbcSize\n      return ary unless ary.is_a? Set\n      count = ary.count\n      return ary if count.zero?\n      return ary.flatten.uniq if count == 1\n      common = ary[0] & ary[1]\n      return common if count == 2\n      (count - 2).times { |x| common &= ary[x + 2] } if count > 2\n      common\n    end\n\n    def common_hash(ary) # rubocop: disable AbcSize\n      return ary unless ary.is_a? Hash\n      count = ary.count\n      return ary if count.zero?\n      return ary.flatten.uniq if count == 1\n      common = ary[0] & ary[1]\n      return common if count == 2\n      (count - 2).times { |x| common &= ary[x + 2] } if count > 2\n      common\n    end\n\n    def common_string(ary) # rubocop: disable AbcSize\n      return ary unless ary.is_a? String\n      count = ary.count\n      return ary if count.zero?\n      return ary.flatten.uniq if count == 1\n      common = ary[0] & ary[1]\n      return common if",
        "\n    def bind_queues\n      client.bind('localhost', 6379)\n    end\n\n    def test_env?\n      ENV['TEST'] == '1'\n    end\n\n    def count_error(e)\n      puts \"Error: #{e.message}\"\n      puts \"Stack trace: #{e.backtrace.join(\"\\n\")}\"\n    end\n\n    def start_shutdown_thread\n      Thread.new do\n        client.shutdown\n      end\n    end\n\n    def start_error_counter_thread\n      Thread.new do\n        client.on_exception do |e|\n          count_error(e)\n        end\n      end\n    end\n\n    def start_event_thread\n      Thread.new do\n        client.on_event do |e|\n          count_event(e)\n        end\n      end\n    end\n\n    def count_event(e)\n      puts \"Event: #{e.message}\"\n      puts \"Stack trace: #{e.backtrace.join(\"\\n\")}\"\n    end\n\n    def count_error(e)\n      puts \"Error: #{e.message}\"\n      puts \"Stack trace: #{e.backtrace.join(\"\\n\")}\"\n    end\nend\n\nif __FILE__ == $0\n  run\nend\n",
        "\n    def unregister_observer_class(observer_class)\n      @observer_mutex.synchronize do\n        return if @observed_models.include?(observer_class)\n        @observed_models.delete(observer_class)\n        log \"EventListener: unregistering observer class #{observer_class}\"\n        observer_queue.unbind(models_exchange, routing_key: \"#{Isimud.model_watcher_schema}.#{observer_class.base_class.name}.*\")\n      end\n    end\n\n    def observe_model(model)\n      @observer_mutex.synchronize do\n        return if @observed_models.include?(model)\n        log \"EventListener: observing model #{model}\"\n        observer_queue.publish(model, routing_key: \"#{Isimud.model_watcher_schema}.#{model.base_class.name}.*\")\n      end\n    end\n\n    def observe_all_models\n      @observer_mutex.synchronize do\n        return if @observed_models.empty?\n        log \"EventListener: observing all models\"\n        observer_queue.publish_all(models_exchange, routing_key: \"#{Isimud.model_watcher_schema}.*.*\")\n      end\n    end\n\n    def observe_all_models_with_block\n     ",
        "\n    end\n\n    def unregister_observer(observer)\n      @observer_mutex.synchronize do\n        log \"EventListener: unregistering observer #{observer.class} #{observer.id}\"\n        @observers.delete(observer_key_for(observer.class, observer.id))\n      end\n    end\n\n    def observer_key_for(observer_class, observer_id)\n      observer_class.to_s.underscore + \"_\" + observer_id.to_s\n    end\n\n    def observers\n      @observers\n    end\n\n    def client\n      @client\n    end\n\n    def log(message)\n      client.log(message)\n    end\n\n    def observer_key_for(observer_class, observer_id)\n      observer_class.to_s.underscore + \"_\" + observer_id.to_s\n    end\n\n    def observer_for(observer_class, observer_id)\n      @observers[observer_key_for(observer_class, observer_id)]\n    end\n\n    def observer_for_events(client)\n      @observers.values.select { |observer| observer.observe_events(client) }\n    end\n\n    def observer_for_events_for(client)\n      @observers.values",
        "\n    end\n\n    def register_observer(observer_class, observer_id, &block)\n      @observer_mutex.synchronize do\n        log \"EventListener: registering observer #{observer_class} #{observer_id}\"\n        @observers[observer_key_for(observer_class, observer_id)] = block\n      end\n    end\n\n    def observer_key_for(observer_class, observer_id)\n      \"#{observer_class}##{observer_id}\"\n    end\n\n    def observer_class_for(observer_key)\n      observer_key.split(\"##\")[0]\n    end\n\n    def observer_id_for(observer_key)\n      observer_key.split(\"##\")[1]\n    end\n\n    def observer_class_for_id(observer_id)\n      observer_id.split(\"#\")[0]\n    end\n\n    def observer_id_for_id(observer_id)\n      observer_id.split(\"#\")[1]\n    end\n\n    def observer_class_for_name(observer_name)\n      observer_name.split(\"#\")[0]\n    end\n\n    def observer_id_for_name(observer_name)\n      observer_name.split(\"#\")[1]\n",
        "\n    end\n\n    def models_exchange\n      @models_exchange ||= client.create_exchange([name, 'models'].join('.'),\n                                              exchange_type: :fanout,\n                                              routing_key:   name,\n                                              durable:       true,\n                                              auto_delete:   true)\n    end\n\n    def models_queue\n      @models_queue ||= client.create_queue([name, 'models'].join('.'),\n                                              models_exchange,\n                                              queue_options:     {exclusive: true},\n                                              durable:       true,\n                                              auto_delete:   true)\n    end\n\n    def models_exchange_name\n      'models'\n    end\n\n    def models_queue_name\n      'models'\n    end\n\n    def models_exchange_type\n      :fanout\n    end\n\n    def models_queue_type\n      :fanout\n    end\n\n    def models_exchange_options\n      { durable: true, auto_delete: true }\n    end\n\n    def models_queue_options\n      { durable: true, auto_delete: true }\n    end\n\n    def models_exchange_options\n      { durable: true, auto_delete: true }\n    end\n\n    def models_queue_options",
        "\n    end\n\n    def as_json_with_session_id(options = {})\n      session_id = parameters.delete(:session_id) || Thread.current[:keas_session_id]\n\n      data = {type:          type,\n              action:        action,\n              user_id:       user_id,\n              occurred_at:   occurred_at,\n              eventful_type: eventful_type,\n              eventful_id:   eventful_id,\n              session_id:    session_id}\n      unless options[:omit_parameters]\n        data[:parameters] = parameters\n        data[:attributes] = attributes\n      end\n      data\n    end\n\n    def as_json_with_session_id_and_attributes(options = {})\n      session_id = parameters.delete(:session_id) || Thread.current[:keas_session_id]\n\n      data = {type:          type,\n              action:        action,\n              user_id:       user_id,\n              occurred_at:   occurred_at,\n              eventful_type: eventful_type,\n              eventful_id:   eventful_id,\n              session_id:    session_id,\n              attributes:   attributes}\n      unless options[:omit_parameters]",
        "\n      if options.title\n        @helper.send(\"#{action}_title_usage\") unless options.title\n        fn = \"#{@src_dir}/#{options.title}.rb\"\n      else\n        fn = \"#{@src_dir}/#{action}.rb\"\n      end\n\n      @helper.send(\"#{action}_create_usage\") unless options.title\n      @commands.send(action, options)\n      puts \"#{@src_dir}/#{fn}\"\n    end\n\n    def do_create_options\n      options = {}\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @params.first\n      options[:title] ||= @",
        "\n    def do_move_options(action)\n      options = {}\n      options[:force] = true\n      options[:recursive] = true\n      options[:recursive_options] = true\n      options[:recursive_options_file] = true\n      options[:recursive_options_dir] = true\n      options[:recursive_options_file_dir] = true\n      options[:recursive_options_dir_file] = true\n      options[:recursive_options_dir_dir] = true\n      options[:recursive_options_file_dir_file] = true\n      options[:recursive_options_dir_dir_file] = true\n      options[:recursive_options_dir_dir_file] = true\n      options[:recursive_options_dir_dir_file] = true\n      options[:recursive_options_dir_dir_file] = true\n      options[:recursive_options_dir_dir_file] = true\n      options[:recursive_options_dir_dir_file] = true\n      options[:recursive_options_dir_dir_file] = true\n      options[:recursive_options_dir_dir_file] = true\n      options[:recursive_options_dir_dir_file] = true\n      options[:recursive_options_dir_dir_file] = true\n      options[:recursive_options_dir_dir_file] =",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\n    def resolve_text(text)\n      text = text.gsub(/\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\n/, \"\\n\\n\")\n      text = text.gsub(/\\n\\",
        "\n    # => Build the Faraday Connection Options\n    def conn_opts\n      {\n        url: 'https://api.newrelic.com',\n        headers: {\n          'Accept' => 'application/json',\n          'Content-Type' => 'application/json'\n        }\n      }\n    end\n\n    # => Send a request to New Relic\n    def nr_api_request(method, path, params = {})\n      # => Build the Faraday Request\n      request = conn.new(method, path, params)\n\n      # => Send the Request\n      response = request.send\n\n      # => Parse the Response\n      response.body\n    end\n\n    # => Send a request to New Relic\n    def nr_api_post(path, params = {})\n      # => Build the Faraday Request\n      request = conn.new('POST', path, params)\n\n      # => Send the Request\n      response = request.send\n\n      # => Parse the Response\n      response.body\n    end\n\n    # => Send a request to New Relic\n    def nr_api_put(path, params = {})\n      # => Build the Faraday Request\n      request = conn.new('PUT', path, params)\n\n      # =>",
        "\n    end\n\n    def alert_remove_entity(entity_id, condition_id)\n      nr_api.delete do |req|\n        req.url url('alerts_entity_conditions', entity_id)\n        req.params['condition_id'] = condition_id\n      end\n    end\n\n    def alert_get_entity(entity_id)\n      nr_api.get do |req|\n        req.url url('alerts_entity_conditions', entity_id)\n      end\n    end\n\n    def alert_get_entity_conditions(entity_id)\n      nr_api.get do |req|\n        req.url url('alerts_entity_conditions', entity_id)\n      end\n    end\n\n    def alert_get_entity_conditions_by_type(entity_type)\n      nr_api.get do |req|\n        req.url url('alerts_entity_conditions', entity_type)\n      end\n    end\n\n    def alert_get_entity_conditions_by_type_and_id(entity_type, condition_id)\n      nr_api.get do |req|\n        req.url url('alerts_entity_conditions', entity_type, condition_id)\n      end\n    end\n\n    def alert_get",
        "\n    end\n\n    def alert_delete_entity_condition(entity_id, condition_id, entity_type = 'Server')\n      nr_api.delete do |req|\n        req.url url('alerts_entity_conditions', entity_id)\n        req.params['entity_type'] = entity_type\n        req.params['condition_id'] = condition_id\n      end\n    end\n\n    def alert_delete_entity_condition_by_id(entity_id, condition_id, entity_type = 'Server')\n      nr_api.delete do |req|\n        req.url url('alerts_entity_conditions', entity_id)\n        req.params['entity_type'] = entity_type\n        req.params['condition_id'] = condition_id\n      end\n    end\n\n    def alert_delete_entity_conditions(entity_id, entity_type = 'Server')\n      nr_api.delete do |req|\n        req.url url('alerts_entity_conditions', entity_id)\n      end\n    end\n\n    def alert_delete_entity_conditions_by_id(entity_id, entity_type = 'Server')\n      nr_api.delete do |req|\n        req.url url('alerts_entity_conditions', entity_",
        "\n    end\n\n    def get_server_name(server_id)\n      return nil unless server_id =~ /^[0-9]+$/\n      ret = nr_api.get(url('servers', server_id)).body\n      ret['server']['name']\n    rescue Faraday::ResourceNotFound, NoMethodError\n      nil\n    end\n\n    def get_server_ip(server_id)\n      return nil unless server_id =~ /^[0-9]+$/\n      ret = nr_api.get(url('servers', server_id)).body\n      ret['server']['ip']\n    rescue Faraday::ResourceNotFound, NoMethodError\n      nil\n    end\n\n    def get_server_ip_by_name(server_name)\n      return nil unless server_name =~ /^[0-9]+$/\n      ret = nr_api.get(url('servers', server_name)).body\n      ret['server']['ip']\n    rescue Faraday::ResourceNotFound, NoMethodError\n      nil\n    end\n\n    def get_server_ip_by_id(server_id)\n      return nil unless server_id =~ /^[0-9]+$/\n      ret = nr_api.get(url('servers', server_id)).body",
        "\n    end\n\n    def get_server_id(server)\n      ret = nr_api.get(url('servers'), 'filter[name]' => server).body\n      return ret['servers'] unless server.nil?\n      ret['servers'].find { |x| x['name'].casecmp(server).zero? }\n    rescue NoMethodError\n      nil\n    end\n\n    def get_server_ip(server)\n      ret = nr_api.get(url('servers'), 'filter[name]' => server).body\n      return ret['servers'] unless server.nil?\n      ret['servers'].find { |x| x['ip'].casecmp(server).zero? }\n    rescue NoMethodError\n      nil\n    end\n\n    def get_server_ip_by_name(server)\n      ret = nr_api.get(url('servers'), 'filter[name]' => server).body\n      return ret['servers'] unless server.nil?\n      ret['servers'].find { |x| x['ip'].casecmp(server).zero? }\n    rescue NoMethodError\n      nil\n    end\n\n    def get_server_ip_by_id(server)\n      ret = nr_api.get(url('servers'), 'filter[id]' => server).body\n      return ret['servers'] unless server.",
        "\n    def get_servers_labeled_by_name(name)\n      label_query = Array(name).reject { |x| !x.include?(':') }.join(';')\n      return [] unless label_query\n      nr_api.get(url('servers'), 'filter[labels]' => label_query).body\n    end\n\n    def get_servers_labeled_by_name_and_type(name, type)\n      label_query = Array(name).reject { |x| !x.include?(':') }.join(';')\n      return [] unless label_query\n      nr_api.get(url('servers'), 'filter[labels]' => label_query, 'filter[type]' => type).body\n    end\n\n    def get_servers_labeled_by_name_and_type_and_id(name, type, id)\n      label_query = Array(name).reject { |x| !x.include?(':') }.join(';')\n      return [] unless label_query\n      nr_api.get(url('servers'), 'filter[labels]' => label_query, 'filter[type]' => type, 'filter[id]' => id).body\n    end\n\n    def get_servers_labeled_by_name_and_type",
        "\n      client.subscribe(queue) do |message|\n        event = Event.parse(message)\n        handle_event(event)\n      end\n    end\n\n    def handle_event(event)\n      if event.type == :message\n        handle_message(event)\n      elsif event.type == :error\n        handle_error(event)\n      end\n    end\n\n    def handle_message(event)\n      if event.type == :message\n        handle_message(event.message)\n      elsif event.type == :error\n        handle_error(event.error)\n      end\n    end\n\n    def handle_error(event)\n      if event.type == :error\n        handle_error(event.error)\n      end\n    end\n\n    def handle_message(message)\n      if message.type == :message\n        handle_message(message.message)\n      elsif message.type == :error\n        handle_error(message.error)\n      end\n    end\n\n    def create_queue(client)\n      queue = client.create_queue(queue_name)\n      queue.bind(queue_name)\n      queue\n    end\n\n    def queue_name\n      \"event_queue\"\n    end\n\n    def enable_listener?\n      @enable_",
        "\n  def unbind(queue_name, exchange_name, *routing_keys, &block)\n      queue = create_queue(queue_name, exchange_name,\n                           queue_options: {durable: true},\n                           routing_keys:  routing_keys)\n      unsubscribe(queue, &block) if block_given?\n    end\n\n  def delete(queue_name, exchange_name, *routing_keys, &block)\n      queue = create_queue(queue_name, exchange_name,\n                           queue_options: {durable: true},\n                           routing_keys:  routing_keys)\n      unsubscribe(queue, &block) if block_given?\n    end\n\n  def delete_all(queue_name, exchange_name, *routing_keys, &block)\n      queue = create_queue(queue_name, exchange_name,\n                           queue_options: {durable: true},\n                           routing_keys:  routing_keys)\n      unsubscribe(queue, &block) if block_given?\n    end\n\n  def delete_all_with_block(queue_name, exchange_name, *routing_keys, &block)\n      queue = create_queue(queue_name, exchange_name,\n                           queue_options: {durable: true},\n                           routing_keys:  routing",
        "\n    def find_queue(queue_name, options = {})\n      log \"Isimud::BunnyClient: find_queue #{queue_name}\"\n      queue = @client.queues.find_by_name(queue_name)\n      if queue.nil?\n        raise \"Queue #{queue_name} not found\"\n      end\n      queue\n    end\n\n    def bind_routing_keys(queue, exchange_name, routing_keys)\n      log \"Isimud::BunnyClient: bind_routing_keys #{queue.inspect} exchange_name=#{exchange_name.inspect} routing_keys=#{routing_keys.inspect}\"\n      queue.bind_routing_keys(exchange_name, routing_keys)\n    end\n\n    def delete_queue(queue_name)\n      log \"Isimud::BunnyClient: delete_queue #{queue_name}\"\n      queue = @client.queues.find_by_name(queue_name)\n      if queue.nil?\n        raise \"Queue #{queue_name} not found\"\n      end\n      queue.delete\n    end\n\n    def delete_exchange(exchange_name)\n      log \"Isimud::BunnyClient: delete_exchange #{exchange_name}\"\n      exchange = @client.exchanges.find_by_name",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapRemoveCodec;\nimport com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.Action",
        "\n    def channel_key\n      @channel_key ||= begin\n        channel.try(:key)\n      end\n    end\n\n    def channel_key=(key)\n      @channel_key = key\n    end\n\n    def channel_key\n      @channel_key ||= begin\n        channel.try(:key)\n      end\n    end\n\n    def channel_key=(key)\n      @channel_key = key\n    end\n\n    def channel_key\n      @channel_key ||= begin\n        channel.try(:key)\n      end\n    end\n\n    def channel_key=(key)\n      @channel_key = key\n    end\n\n    def channel_key\n      @channel_key ||= begin\n        channel.try(:key)\n      end\n    end\n\n    def channel_key=(key)\n      @channel_key = key\n    end\n\n    def channel_key\n      @channel_key ||= begin\n        channel.try(:key)\n      end\n    end\n\n    def channel_key=(key)\n      @channel_key = key\n    end\n\n    def channel_key\n      @channel_key ||= begin\n        channel.try(:key)\n      end\n    end\n\n    def channel_key=(key)\n      @channel_key = key\n    end",
        "\n    def subscribe(exchange, routing_key, payload, options = {})\n      log \"Isimud::BunnyClient#subscribe: exchange=#{exchange} routing_key=#{routing_key}\", :debug\n      channel.subscribe(exchange, routing_key, payload, options.merge(routing_key: routing_key, persistent: true))\n    end\n\n    def unsubscribe(exchange, routing_key, payload, options = {})\n      log \"Isimud::BunnyClient#unsubscribe: exchange=#{exchange} routing_key=#{routing_key}\", :debug\n      channel.unsubscribe(exchange, routing_key, payload, options.merge(routing_key: routing_key, persistent: true))\n    end\n\n    def channel\n      @channel ||= Isimud::BunnyClient.new(host: host, port: port, username: username, password: password)\n    end\n\n    def log(message, level = :debug)\n      log_message(message, level)\n    end\n\n    def log_message(message, level = :debug)\n      log \"#{level} #{message}\"\n    end\n\n    def host\n      @host ||= \"localhost\"\n    end\n\n    def port\n      @port ||= 61616\n    end\n\n    def username\n      @username ||= \"",
        "\n    def post_with_ext(opts)\n      opts = @helper.ensure_open_struct(opts)\n      date = @helper.get_date_stamp\n\n      # still want to escape any garbage in the slug\n      slug = if opts.slug.nil? || opts.slug.empty?\n               opts.title\n             else\n               opts.slug\n             end\n      slug = @helper.get_slug_for(slug)\n\n      # put the metadata into the layout header\n      head, ext = @helper.get_layout(opts.layout)\n      head.sub!(/^title:\\s*$/, \"title: #{opts.title}\")\n      head.sub!(/^date:\\s*$/, \"date: #{date}\")\n      ext ||= @ext\n\n      path = File.join(POSTS_FOLDER, \"#{date}-#{slug}.#{ext}\")\n      f = File.open(path, \"w\")\n      f.write(head)\n      f.close\n      @helper.open_in_editor(path) # open file if config key set\n      path    # return the path, in case we want to do anything useful\n    end\n\n    def post_with_ext_and_title(opts)\n      opts = @helper.ensure_open_struct(opts)",
        "\n    def draft_with_title(opts)\n      opts = @helper.ensure_open_struct(opts)\n\n      # the drafts folder might not exist yet...create it just in case\n      FileUtils.mkdir_p(DRAFTS_FOLDER)\n\n      slug = if opts.slug.nil? || opts.slug.empty?\n               opts.title\n             else\n               opts.slug\n             end\n      slug = @helper.get_slug_for(slug)\n\n      # put the metadata into the layout header\n      head, ext = @helper.get_layout(opts.layout)\n      head.sub!(/^title:\\s*$/, \"title: #{opts.title}\")\n      head.sub!(/^date:\\s*$/, \"date: #{@helper.get_date_stamp}\")\n      ext ||= @ext\n\n      path = File.join(DRAFTS_FOLDER, \"#{slug}.#{ext}\")\n      f = File.open(path, \"w\")\n      f.write(head)\n      f.close\n      @helper.open_in_editor(path) # open file if config key set\n      path    # return the path, in case we want to do anything useful\n    end\n\n    def draft_with_title_and_ext(opts)\n      opts",
        "\n    def publish_all(draftpath, opts={})\n      opts = @helper.ensure_open_struct(opts)\n      tail = File.basename(draftpath)\n\n      begin\n        infile = File.open(draftpath, \"r\")\n      rescue Errno::ENOENT\n        @helper.bad_path(draftpath)\n      end\n\n      date = @helper.get_date_stamp\n      time = @helper.get_time_stamp\n\n      outpath = File.join(POSTS_FOLDER, \"#{date}-#{tail}\")\n      outfile = File.open(outpath, \"w\")\n\n      infile.each_line do |line|\n        line.sub!(/^date:.*$/, \"date: #{date} #{time}\\n\") unless opts.keep_timestamp\n        outfile.write(line)\n      end\n\n      infile.close\n      outfile.close\n      FileUtils.rm(draftpath) unless opts.keep_draft\n\n      outpath\n    end\n\n    def publish_all_drafts(draftpath, opts={})\n      opts = @helper.ensure_open_struct(opts)\n      tail = File.basename(draftpath)\n\n      begin\n        infile = File.open(draftpath, \"r\")\n      rescue Errno::ENOENT\n       ",
        "\n  end\n\n  def terminal_size=(rows, cols)\n    rows, cols = rows.to_i, cols.to_i\n    buf = [0, 0, 0, 0].pack(\"SSSS\")\n    if $stdout.ioctl(TIOCGWINSZ, buf) >= 0 then\n      rows, cols, row_pixels, col_pixels = buf.unpack(\"SSSS\")\n    end\n  end\n\n  def terminal_size_with_cursor\n    rows, cols = 25, 80\n    buf = [0, 0, 0, 0].pack(\"SSSS\")\n    if $stdout.ioctl(TIOCGWINSZ, buf) >= 0 then\n      rows, cols, row_pixels, col_pixels = buf.unpack(\"SSSS\")\n    end\n    rows, cols = rows.to_i, cols.to_i\n    buf = [0, 0, 0, 0].pack(\"SSSS\")\n    if $stdout.ioctl(TIOCGWINSZ, buf) >= 0 then\n      rows, cols, row_pixels, col_pixels = buf.unpack(\"SSSS\")\n    end\n    rows, cols = rows.to_i, cols.to_i\n    buf = [0, 0, 0, 0].pack(\"SSSS\")\n    if $stdout.",
        "\n  def reset_modes\n    buf = [0, 0, 0, 0, 0, 0, 0, ''].pack(\"IIIICCA*\")\n    $stdout.ioctl(TCSETS, buf)\n    @old_modes = buf.unpack(\"IIIICCA*\")\n    new_modes = @old_modes.clone\n    new_modes[3] &= ~ECHO # echo off\n    new_modes[3] &= ~ICANON # one char @ a time\n    $stdout.ioctl(TCSETS, new_modes.pack(\"IIIICCA*\"))\n    print \"\\e[2J\" # clear screen\n    print \"\\e[H\" # go home\n    print \"\\e[?47h\" # kick xterm into the alt screen\n    print \"\\e[?1000h\" # kindly ask for mouse positions to make up for it\n    self.cursor = false\n    flush\n  end\n\n  def set_cursor(x, y)\n    self.cursor = true\n    self.x = x\n    self.y = y\n    flush\n  end\n\n  def set_cursor_position(x, y)\n    self.cursor = true\n    self.x = x\n    self.y = y\n    flush\n  end\n\n  def set_cursor_",
        "\n    end\n\n    def extract_permissions(subject)\n      return extract_permissions(subject.to_permission_instance) if subject.respond_to? :to_permission_instance\n\n      return subject[:any] if subject.is_a? Hash and subject.key? :any\n\n      [subject]\n    end\n\n    def extract_permissions(subject)\n      return subject[:any] if subject.is_a? Hash and subject.key? :any\n\n      [subject]\n    end\n\n    def extract_permissions_for_user(user)\n      return extract_permissions_for_user(user.to_permission_instance) if user.respond_to? :to_permission_instance\n\n      return user[:any] if user.is_a? Hash and user.key? :any\n\n      [user]\n    end\n\n    def extract_permissions_for_user(user)\n      return user[:any] if user.is_a? Hash and user.key? :any\n\n      [user]\n    end\n\n    def extract_permissions_for_group(group)\n      return extract_permissions_for_group(group.to_permission_instance) if group.respond_to? :to_permission_instance\n\n      return group[:any] if group.is_a? Hash",
        "\n    def restart # rubocop: disable AbcSize, MethodLength\n      # => Windows Workaround (https://github.com/bdwyertech/newrelic-management/issues/1)\n      ENV['TZ'] = 'UTC' if OS.windows? && !ENV['TZ']\n\n      scheduler = Rufus::Scheduler.new\n      Notifier.msg('Restarting Process')\n\n      # => Alerts Management\n      alerts_interval = Config.alert_management_interval\n      scheduler.every alerts_interval, overlap: false do\n        Manager.manage_alerts\n      end\n\n      # => Cleanup Stale Servers\n      if Config.cleanup\n        cleanup_interval = Config.cleanup_interval\n        cleanup_age = Config.cleanup_age\n\n        scheduler.every cleanup_interval, overlap: false do\n          Manager.remove_nonreporting_servers(cleanup_age)\n        end\n      end\n\n      # => Join the Current Thread to the Scheduler Thread\n      scheduler.join\n    end\n\n    def stop # rubocop: disable AbcSize, MethodLength\n      # => Windows Workaround (https://github.com/bdwyertech/newrelic-management/issues/1)\n      ENV['TZ'] = 'UTC' if OS.windows? && !ENV['TZ']\n\n      scheduler =",
        "\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.manage_alerts\n\n      # => Manage",
        "\n    def check_custom_src_dir!\n      if File.exists?('./_config.yml')\n        @custom_src_dir = File.expand_path('./_config.yml')\n      else\n        puts 'ERROR: Cannot locate _config.yml. Double check to make sure'\n        puts '       that you are in a jekyll directory.'\n        exit\n      end\n    end\n\n    def ensure_jekyll_dir\n      @orig_dir = Dir.pwd\n      start_path = Pathname.new(@orig_dir)\n\n      ok = File.exists?('./_posts')\n      new_path = nil\n\n      # if it doesn't exist, check for a custom source dir in _config.yml\n      if !ok\n        check_custom_src_dir!\n        ok = File.exists?('./_posts')\n        new_path = Pathname.new(Dir.pwd)\n      end\n\n      if ok\n        return (new_path ? new_path.relative_path_from(start_path) : '.')\n      else\n        puts 'ERROR: Cannot locate _posts directory. Double check to make sure'\n        puts '       that you are in a jekyll directory.'\n        exit\n      end\n    end\n\n    def ensure",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n",
        "\n    end\n\n    def main\n      gen_usage\n      puts ''\n      puts 'Create a new draft in _drafts with title SLUG'\n      puts ''\n      puts 'Create a new timestamped post in _posts with title SLUG'\n      puts ''\n      puts 'Publish the draft with SLUG, timestamping appropriately'\n      puts ''\n      puts 'Move a post to _drafts, untimestamping appropriately'\n      exit\n    end\n\n    def draft\n      draft_title = ARGV[0]\n      draft_title = draft_title.downcase\n      draft_title = draft_title.gsub(/\\s+/, '-')\n      draft_title = draft_title.gsub(/\\W+/, '-')\n      draft_title = draft_title.gsub(/\\W+/, '-')\n      draft_title = draft_title.gsub(/\\W+/, '-')\n      draft_title = draft_title.gsub(/\\W+/, '-')\n      draft_title = draft_title.gsub(/\\W+/, '-')\n      draft_title = draft_title.gsub(/\\W+/, '-')\n      draft_title = draft_title.gsub(/\\W+/, '-')\n      draft_title = draft_title.gsub(/\\",
        "\n    def terminal_notification(message, subtitle = message)\n      # => Terminal Messages\n      terminal_notification(message, subtitle)\n    end\n\n    def osx_notification(message, subtitle = message, title = 'NewRelic Management')\n      # => OSX Messages\n      osx_notification(message, subtitle, title)\n    end\n\n    def osx_notification(message, subtitle = message, title = 'NewRelic Management')\n      # => OSX Messages\n      osx_notification(message, subtitle, title)\n    end\n\n    def osx_notification(message, subtitle = message, title = 'NewRelic Management')\n      # => OSX Messages\n      osx_notification(message, subtitle, title)\n    end\n\n    def osx_notification(message, subtitle = message, title = 'NewRelic Management')\n      # => OSX Messages\n      osx_notification(message, subtitle, title)\n    end\n\n    def osx_notification(message, subtitle = message, title = 'NewRelic Management')\n      # => OSX Messages\n      osx_notification(message, subtitle, title)\n    end\n\n    def osx_notification(message, subtitle = message, title = 'NewRelic Management')\n      # => OSX Messages\n      osx_notification(",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\",
        "\n        end\n      end\n      x\n    end\n\ndef analyze_all(string, options = {})\n      x = []\n      @fst._analyze_all(string) do |a| \n        if options[:symbol_sequence]\n          x << a.map { |s| s.match(/^<(.*)>$/) ? $1.to_sym : s }\n        else\n          x << a.join\n        end\n      end\n      x\n    end\n\ndef analyze_all_with_options(string, options = {})\n      x = []\n      @fst._analyze_all_with_options(string) do |a| \n        if options[:symbol_sequence]\n          x << a.map { |s| s.match(/^<(.*)>$/) ? $1.to_sym : s }\n        else\n          x << a.join\n        end\n      end\n      x\n    end\n\ndef analyze_all_with_options_with_symbol_sequence(string, options = {})\n      x = []\n      @fst._analyze_all_with_options_with_symbol_sequence(string) do |a| \n        if options[:symbol_sequence]\n          x << a.map { |s| s.match(/^<(.*)>$/)",
        "\nend\n\ndef test\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test2\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test3\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test4\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test5\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test6\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test7\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test8\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test9\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test10\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test11\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test12\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test13\n  generate(\"abcdefghijklmnopqrstuvwxyz\")\nend\n\ndef test14\n  generate(\"abcdefghij",
        "\n    # => Load Configuration\n    Config.load\n\n    # => Load Plugins\n    Plugins.load\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins.load_plugins\n\n    # => Load Plugins\n    Plugins",
        "\n    def missing_specs_from_directory(path)\n      Dir.entries(path).select do |file|\n        file =~ /\\.spec$/\n      end\n    end\n\n    def missing_specs_from_file_and_directory(path)\n      missing_specs_from_file(path) + missing_specs_from_directory(path)\n    end\n\n    def missing_specs_from_file_and_directory_and_file(path)\n      missing_specs_from_file(path) + missing_specs_from_directory(path) + File.join(path, 'spec')\n    end\n\n    def missing_specs_from_file_and_directory_and_file_and_directory(path)\n      missing_specs_from_file(path) + missing_specs_from_directory(path) + File.join(path, 'spec', 'spec') + File.join(path, 'spec', 'spec', 'spec')\n    end\n\n    def missing_specs_from_file_and_directory_and_file_and_directory(path)\n      missing_specs_from_file(path) + missing_specs_from_directory(path) + File.join(path, 'spec', 'spec', 'spec', 'spec') + File.join(path, '",
        "\n      list_nonreporting_servers.each do |server|\n        Notifier.msg(server[:name], 'Removing Stale, Non-Reporting Server')\n        Client.delete_server(server[:id])\n      end\n    end\n\n    def list_nonreporting_servers\n      Client.list_nonreporting_servers\n    end\n\n    def list_nonreporting_servers_by_name(name)\n      Client.list_nonreporting_servers_by_name(name)\n    end\n\n    def list_nonreporting_servers_by_id(id)\n      Client.list_nonreporting_servers_by_id(id)\n    end\n\n    def list_nonreporting_servers_by_name_and_id(name, id)\n      Client.list_nonreporting_servers_by_name_and_id(name, id)\n    end\n\n    def list_nonreporting_servers_by_name_and_id_and_status(name, id, status)\n      Client.list_nonreporting_servers_by_name_and_id_and_status(name, id, status)\n    end\n\n    def list_nonreporting_servers_by_name_and_id_and_status_and_last_reported_at(name, id, status, last",
        "\n      end\n      result\n    end\n\ndef find_labeled(exclude)\n      result = []\n      Array(exclude).each do |exclude|\n        if exclude.include?(':')\n          find_excluded(exclude).each { |x| result << x }\n          next\n        end\n        res = Client.get_server(exclude)\n        result << res['id'] if res\n      end\n      result\n    end\n\ndef find_excluded_by_label(label)\n      result = []\n      Array(label).each do |label|\n        if label.include?(':')\n          find_excluded(label).each { |x| result << x }\n          next\n        end\n        res = Client.get_server(label)\n        result << res['id'] if res\n      end\n      result\n    end\n\ndef find_labeled_by_label(label)\n      result = []\n      Array(label).each do |label|\n        if label.include?(':')\n          find_excluded_by_label(label).each { |x| result << x }\n          next\n        end\n        res = Client.get_server(label)\n        result << res['id'] if res\n      end\n      result\n    end\n\ndef find_labeled_by",
        "\n    def sms_confirmed?\n      !_TC_sms_blocked\n    end\n\n    def sms_blocked?\n      _TC_sms_blocked\n    end\n\n    def sms_blocked_reason\n      _TC_sms_blocked_reason\n    end\n\n    def sms_blocked_reason_text\n      _TC_sms_blocked_reason_text\n    end\n\n    def sms_blocked_reason_url\n      _TC_sms_blocked_reason_url\n    end\n\n    def sms_blocked_reason_url_text\n      _TC_sms_blocked_reason_url_text\n    end\n\n    def sms_blocked_reason_url_url\n      _TC_sms_blocked_reason_url_url\n    end\n\n    def sms_blocked_reason_url_url_text\n      _TC_sms_blocked_reason_url_url_text\n    end\n\n    def sms_blocked_reason_url_url_url\n      _TC_sms_blocked_reason_url_url_url\n    end\n\n    def sms_blocked_reason_url_url_text\n      _TC_sms_blocked_reason_url_url_text\n    end\n\n    def sms_blocked_reason_url_url_url\n      _TC_sms_blocked_reason",
        "\n    end\n\n    def voice_confirmed?\n      !!_TC_voice_confirmed\n    end\n\n    def voice_blocked?\n      !!_TC_voice_blocked\n    end\n\n    def voice_confirmed_by?(user)\n      !!_TC_voice_confirmed_by && _TC_voice_confirmed_by.id == user.id\n    end\n\n    def voice_blocked_by?(user)\n      !!_TC_voice_blocked_by && _TC_voice_blocked_by.id == user.id\n    end\n\n    def voice_confirmed_by_phone_number(phone_number)\n      !!_TC_voice_confirmed_by_phone_number && _TC_voice_confirmed_by_phone_number.phone_number == phone_number\n    end\n\n    def voice_blocked_by_phone_number(phone_number)\n      !!_TC_voice_blocked_by_phone_number && _TC_voice_blocked_by_phone_number.phone_number == phone_number\n    end\n\n    def voice_confirmed_by_phone_number_with_confirmation_code(phone_number, confirmation_code)\n      !!_TC_voice_confirmed_by_phone_number_with_confirmation_code && _",
        "\n    def format(value, format, raise_error=false)\n      unless FORMATS.key?(format)\n        raise FormatError, \"Invalid data format: #{format}\"\n      end\n      result = value =~ FORMATS[format] ? true : false\n      if raise_error && !result\n        raise ValidationError, \"Invalid value \\\"#{value}\\\" for #{format}\"\n      end\n      result\n    end\n\n    def validate_date(value, format, raise_error=false)\n      unless VALID_DATE_FORMATS.key?(format)\n        raise FormatError, \"Invalid data format: #{format}\"\n      end\n      result = value =~ VALID_DATE_FORMATS[format] ? true : false\n      if raise_error && !result\n        raise ValidationError, \"Invalid value \\\"#{value}\\\" for #{format}\"\n      end\n      result\n    end\n\n    def validate_time(value, format, raise_error=false)\n      unless VALID_TIME_FORMATS.key?(format)\n        raise FormatError, \"Invalid data format: #{format}\"\n      end\n      result = value =~ VALID_TIME_FORMATS[format] ? true : false\n      if raise_error && !result\n        raise ValidationError, \"Invalid value \\\"#{value}\\\" for #{format}\"\n      end\n      result\n    end\n",
        "\n    def adapter_class(scheme)\n      case scheme\n      when 'http'\n        HTTPAdapter\n      when 'https'\n        HTTPSAdapter\n      else\n        raise ArgumentError, \"Unknown scheme: #{scheme}\"\n      end\n    end\n\n    class HTTPAdapter < BaseAdapter\n      def initialize(uri, settings)\n        super(uri, settings)\n        @headers = {}\n      end\n\n      def start(&block)\n        @headers = {}\n        super\n      end\n\n      def write(data)\n        @headers[data.to_s] = data\n        super\n      end\n\n      def close\n        super\n      end\n\n      def read(size)\n        @headers.each_pair do |key, value|\n          yield key, value\n        end\n        super\n      end\n    end\n\n    class HTTPSAdapter < BaseAdapter\n      def initialize(uri, settings)\n        super(uri, settings)\n        @headers = {}\n      end\n\n      def start(&block)\n        @headers = {}\n        super\n      end\n\n      def write(data)\n        @headers[data.to_s] = data\n        super\n      end\n\n      def close\n        super\n      end\n\n      def read(size)\n        @headers.each_pair do",
        "\n      poly\n    end\n\n    def all_fields_with_value(table, field_name, value)\n      all_fields(table, field_name, value).map { |poly| poly[:diffgram][:document_element][:municipality_poly] }\n    end\n\n    def all_fields_with_value_and_polys(table, field_name, value, polys)\n      all_fields(table, field_name, value).map { |poly| poly[:diffgram][:document_element][:municipality_poly] }.\n        merge(polys)\n    end\n\n    def all_fields_with_value_and_polys_and_values(table, field_name, value, polys, values)\n      all_fields(table, field_name, value).map { |poly| poly[:diffgram][:document_element][:municipality_poly] }.\n        merge(polys).\n        merge(values)\n    end\n\n    def all_fields_with_value_and_polys_and_values_and_polys(table, field_name, value, polys, values, polys_and_values)\n      all_fields(table, field_name, value).map { |",
        "\n    def THEN(condition, adjuster)\n      unless Validation.conditionable? condition\n        raise TypeError, 'wrong object for condition'\n      end\n\n      unless Validation.adjustable? adjuster\n        raise TypeError, 'wrong object for adjuster'\n      end\n\n      ->v{_valid?(condition, v) ? adjuster.call(v) : v}\n    end\n\n    def _valid?(condition, v)\n      condition.call(v)\n    end\nend\n",
        "\n    def INJECT_ARRAY(adjuster1, adjuster2, *adjusters)\n      adjusters = [adjuster1, adjuster2, *adjusters]\n\n      unless adjusters.all?{|f|adjustable? f}\n        raise TypeError, 'wrong object for adjuster'\n      end\n\n      ->v{\n        adjusters.reduce(v){|ret, adjuster|adjuster.call ret}\n      }\n    end\n\n    def INJECT_MAP(adjuster1, adjuster2, *adjusters)\n      adjusters = [adjuster1, adjuster2, *adjusters]\n\n      unless adjusters.all?{|f|adjustable? f}\n        raise TypeError, 'wrong object for adjuster'\n      end\n\n      ->v{\n        adjusters.reduce(v){|ret, adjuster|adjuster.call ret}\n      }\n    end\n\n    def INJECT_SET(adjuster1, adjuster2, *adjusters)\n      adjusters = [adjuster1, adjuster2, *adjusters]\n\n      unless adjusters.all?{|f|adjustable? f}\n        raise TypeError, 'wrong object for adjuster'\n      end\n\n      ->v{\n        adjusters.reduce(v){|ret,",
        "\n    def PARSE_STRING(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_INTEGER(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_FLOAT(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_BOOLEAN(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_DATE(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_TIME(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_DATETIME(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_DATETIME_WITH_TIME(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_DATETIME_WITH_TIME_ZONE(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_DATETIME_WITH_TIME_ZONE_OFFSET(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_DATETIME_WITH_TIME_ZONE_OFFSET_WITH_TIME(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_DATETIME_WITH_TIME_ZONE_OFFSET_WITH_TIME_ZONE(parser)\n      PARSE(parser)\n    end\n\n    def PARSE_DATETIME_WITH_TIME_ZONE_OFFSET_WITH_TIME_ZONE_OFFSET(parser)\n     ",
        "\n  end\n\n  def get_class_list\n    @class_list ||= []\n    @class_list.each do |x|\n      if x.include?(name)\n        puts x\n      end\n    end\n  end\n\n  def get_class_name(name)\n    @class_name ||= []\n    @class_name.each do |x|\n      if x.include?(name)\n        puts x\n      end\n    end\n  end\n\n  def get_class_description(name)\n    @class_description ||= []\n    @class_description.each do |x|\n      if x.include?(name)\n        puts x\n      end\n    end\n  end\n\n  def get_class_description_by_name(name)\n    @class_description_by_name ||= []\n    @class_description_by_name.each do |x|\n      if x.include?(name)\n        puts x\n      end\n    end\n  end\n\n  def get_class_description_by_description(description)\n    @class_description_by_description ||= []\n    @class_description_by_description.each do |x|\n      if x.include?(description)\n        puts x\n      end\n    end\n  end",
        "\n    def post(path, data)\n      connection.post(path, data)\n    end\n\n    def get(path)\n      connection.get(path)\n    end\n\n    def delete(path)\n      connection.delete(path)\n    end\n\n    def put(path, data)\n      connection.put(path, data)\n    end\n\n    def patch(path, data)\n      connection.patch(path, data)\n    end\n\n    def options\n      @options\n    end\n\n    def text\n      @text\n    end\n\n    def text=(text)\n      @text = text\n    end\n\n    def options=(options)\n      @options = options\n    end\n\n    def text=(text)\n      @text = text\n    end\n\n    def options=(options)\n      @options = options\n    end\n\n    def options=(options)\n      @options = options\n    end\n\n    def options=(options)\n      @options = options\n    end\n\n    def options=(options)\n      @options = options\n    end\n\n    def options=(options)\n      @options = options\n    end\n\n    def options=(options)\n      @options = options\n    end\n\n    def options=(options)\n      @options = options\n   ",
        "\n      if deadline > start_time\n        sleep(deadline - start_time)\n      end\n    end\n\n    def process_timeout(timeout)\n      if timeout.is_a?(Integer)\n        timeout\n      elsif timeout.is_a?(String)\n        timeout.to_i\n      else\n        timeout\n      end\n    end\n\n    def process_timeout_in_seconds(timeout)\n      if timeout.is_a?(Integer)\n        timeout\n      elsif timeout.is_a?(String)\n        timeout.to_i\n      else\n        timeout\n      end\n    end\n\n    def process_timeout_in_minutes(timeout)\n      if timeout.is_a?(Integer)\n        timeout\n      elsif timeout.is_a?(String)\n        timeout.to_i\n      else\n        timeout\n      end\n    end\n\n    def process_timeout_in_hours(timeout)\n      if timeout.is_a?(Integer)\n        timeout\n      elsif timeout.is_a?(String)\n        timeout.to_i\n      else\n        timeout\n      end\n    end\n\n    def process_timeout_in_days(timeout)\n      if timeout.is_a?(Integer)\n        timeout\n      elsif timeout.is_a?",
        "\n\n    def crud_icon(model, instance_name, actions, args={})\n      _html = \"\"\n      _options = args.keys.empty? ? '' : \", #{args.map{|k,v| \":#{k} => #{v}\"}}\"\n  \n      if use_crud_icons\n        if actions.include?(:show)\n          _html << eval(\"link_to image_tag('/images/icons/view.png', :class => 'crud_icon'), model, :title => 'View'#{_options}\")\n        end\n        if actions.include?(:edit)\n          _html << eval(\"link_to image_tag('/images/icons/edit.png', :class => 'crud_icon'), edit_#{instance_name}_path(model), :title => 'Edit'#{_options}\")\n        end\n        if actions.include?(:delete)\n          _html << eval(\"link_to image_tag('/images/icons/delete.png', :class => 'crud_icon'), model, :confirm => 'Are you sure? This action cannot be undone.', :method => :delete, :title => 'Delete'#{_options}\")\n        end\n      else\n        if actions.include?(:show)\n          _html << eval(\"link_to 'View', model, :title",
        "\n    def obfuscated_link_to_with_args(path, image, label, args={})\n      _html = %{<form action=\"#{path}\" method=\"get\" class=\"obfuscated_link\">}\n      _html << %{ <fieldset><input alt=\"#{label}\" src=\"#{image}\" type=\"image\" /></fieldset>}\n      args.each{ |k,v| _html << %{  <div><input id=\"#{k.to_s}\" name=\"#{k}\" type=\"hidden\" value=\"#{v}\" /></div>} }\n      _html << %{</form>}\n      _html\n    end\n\n    def obfuscated_link_to_with_args_with_html(path, image, label, args={})\n      _html = %{<form action=\"#{path}\" method=\"get\" class=\"obfuscated_link\">}\n      _html << %{ <fieldset><input alt=\"#{label}\" src=\"#{image}\" type=\"image\" /></fieldset>}\n      args.each{ |k,v| _html << %{  <div><input id=\"#{k.to_s}\" name=\"#{k}\" type=\"hidden\" value=\"#{v}\" /></div>} }\n      _html << %{<div><input id=\"#{k.to_s}\" name",
        "\n    end\n\n    def required_field_helper_with_errors( model, element, html )\n      if model && ! model.errors.empty? && element.is_required\n        return content_tag( :div, html, :class => 'fieldWithErrors' )\n      else\n        return html\n      end\n    end\n\n    def required_field_helper_with_errors_with_errors( model, element, html )\n      if model && ! model.errors.empty? && element.is_required\n        return content_tag( :div, html, :class => 'fieldWithErrors' )\n      else\n        return html\n      end\n    end\n\n    def required_field_helper_with_errors_with_errors_with_errors( model, element, html )\n      if model && ! model.errors.empty? && element.is_required\n        return content_tag( :div, html, :class => 'fieldWithErrors' )\n      else\n        return html\n      end\n    end\n\n    def required_field_helper_with_errors_with_errors_with_errors( model, element, html )\n      if model && ! model.errors.empty? && element.is_required\n        return content_tag( :div, html, :class => 'fieldWithErrors' )\n",
        "\n    def select_tag_for_filter_with_scope(model, nvpairs, params)\n      return unless model && nvpairs && ! nvpairs.empty?\n      options = { :query => params[:query] }\n      _url = url_for(eval(\"#{model}_url(options)\"))\n      _html = %{<label for=\"show\">Show:</label><br />}\n      _html << %{<select name=\"show\" id=\"show\" onchange=\"window.location='#{_url}' + '?show=' + this.value\">}\n      nvpairs.each do |pair|\n        _html << %{<option value=\"#{pair[:scope]}\"}\n        if params[:show] == pair[:scope] || ((params[:show].nil? || params[:show].empty?) && pair[:scope] == \"all\")\n          _html << %{ selected=\"selected\"}\n        end\n        _html << %{>#{pair[:label]}}\n        _html << %{</option>}\n      end\n      _html << %{</select>}\n    end\n\n    def select_tag_for_filter_with_scope_and_label(model, nvpairs, params)\n      return unless model && nvpairs && ! nvpairs.empty?\n      options = { :query => params[:query]",
        "\n    def sort_link_with_query(model, field, params, html_options={})\n      if (field.to_sym == params[:by] || field == params[:by]) && params[:dir] == \"ASC\"\n        classname = \"arrow-asc\"\n        dir = \"DESC\"\n      elsif (field.to_sym == params[:by] || field == params[:by])\n        classname = \"arrow-desc\"\n        dir = \"ASC\"\n      else\n        dir = \"ASC\"\n      end\n  \n      options = {\n        :anchor => html_options[:anchor] || nil,\n        :by => field,\n        :dir => dir,\n        :query => params[:query],\n        :show => params[:show]\n      }\n  \n      options[:show] = params[:show] unless params[:show].blank? || params[:show] == 'all'\n  \n      html_options = {\n        :class => \"#{classname} #{html_options[:class]}\",\n        :style => \"color: white; font-weight: #{params[:by] == field ? \"bold\" : \"normal\"}; #{html_options[:style]}\",\n        :title => \"Sort by this field\"\n      }\n  \n      field_name = params[:labels] && params[:labels][field] ? params[:labels",
        "\n    def tag_for_label_with_inline_help_with_icon( label_text, field_id, help_text, icon_name )\n      _html = \"\"\n      _html << %{<label for=\"#{field_id}\">#{label_text}}\n      _html << %{<img src=\"/images/icons/#{icon_name}.png\" onclick=\"$('#{field_id}_help').toggle();\" class='inline_icon' />}\n      _html << %{</label><br />}\n      _html << %{<div class=\"inline_help\" id=\"#{field_id}_help\" style=\"display: none;\">}\n      _html << %{<p>#{help_text}</p>}\n      _html << %{<img src=\"/images/icons/help_icon.png\" onclick=\"$('#{field_id}_help').toggle();\" class='inline_icon' />}\n      _html << %{</div>}\n      _html\n    end\n\n    def tag_for_label_with_inline_help_with_icon_with_text( label_text, field_id, help_text, icon_name, text )\n      _html = \"\"\n      _html << %{<label for=\"#{field_id}\">#{label_text}}\n     ",
        "\n    def key_release(keys)\n      dump_caller_stack\n      \n      if keys =~ /^Ctrl\\+([A-Z])$/\n        filtered_keys = \"^+#{$1}\"\n      elsif keys =~ /^Ctrl\\+Shift\\+([A-Z])$/\n        filtered_keys = \"^+#{$1.downcase}\"\n      elsif keys =~ /^Alt+([A-Z])$/\n        filtered_keys = \"!+#{$1}\"\n      elsif keys =~ /^Alt\\+Shift\\+([a-z])$/\n        filtered_keys = \"!+#{$1.downcase}\"\n      else\n        filtered_keys = keys\n      end\n      filtered_keys = keys.gsub(\"Alt+\", \"!+\").gsub(\"Ctrl+\", \"^+\")\n      RFormSpec::Keyboard.release(filtered_keys)\n      sleep 0.5\n    end\n\n    def key_press_with_delay(keys)\n      dump_caller_stack\n      \n      if keys =~ /^Ctrl\\+([A-Z])$/\n        filtered_keys = \"^+#{$1}\"\n      elsif keys =~ /^Ctrl\\+Shift\\+([A-Z])$/\n        filtered_keys = \"^+#{$1.downcase}\"\n      elsif keys =~ /^Alt+([A",
        "\nend\n\ndef open_file_dialog_with_text(title, filepath, text=\"\")\n      wait_and_focus_window(title)\n      dialog = RFormSpec::OpenFileDialog.new(title, text)\n      dialog.enter_filepath(filepath)\n      sleep 1\n      dialog.click_open\n    end\n\ndef open_file_dialog_with_text_and_file_name(title, filepath, text=\"\", file_name=\"\")\n      wait_and_focus_window(title)\n      dialog = RFormSpec::OpenFileDialog.new(title, text)\n      dialog.enter_filepath(filepath)\n      dialog.enter_file_name(file_name)\n      sleep 1\n      dialog.click_open\n    end\n\ndef open_file_dialog_with_text_and_file_name_and_extension(title, filepath, text=\"\", file_name=\"\", extension=\"\")\n      wait_and_focus_window(title)\n      dialog = RFormSpec::OpenFileDialog.new(title, text)\n      dialog.enter_filepath(filepath)\n      dialog.enter_file_name(file_name)\n      dialog.enter_extension(extension)\n      sleep 1\n      dialog.click_open\n    end\n\ndef open_file_dialog",
        "\n      # The options specified on the command line will be collected in *options*.\n      @options\n    end\n\n    def options\n      @options\n    end\n\n    def options=(options)\n      @options = options\n    end\n\n    def options_hash\n      @options.options_hash\n    end\n\n    def options_hash=(options_hash)\n      @options = options_hash\n    end\n\n    def options_hash_with_defaults\n      @options.options_hash_with_defaults\n    end\n\n    def options_hash_with_defaults=(options_hash_with_defaults)\n      @options = options_hash_with_defaults\n    end\n\n    def options_hash_with_defaults_with_defaults\n      @options.options_hash_with_defaults_with_defaults\n    end\n\n    def options_hash_with_defaults_with_defaults=(options_hash_with_defaults_with_defaults)\n      @options = options_hash_with_defaults_with_defaults\n    end\n\n    def options_hash_with_defaults_with_defaults_with_defaults\n      @options.options_hash_with_defaults_with_defaults_with_defaults\n    end\n\n    def options_hash_with_defaults_with_defaults_with_defaults\n     ",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\n    def run_normal\n      logger.info(\"#{self.class.to_s} is starting.\")\n      count_options = self.class.legacy_find_options.dup\n      count_options.delete(:order)\n      count_options.delete(:group)\n      count_options.delete(:limit)\n      count_options.delete(:offset)\n      @num_of_records = self.class.legacy_model.count(count_options)\n      if self.class.legacy_find_options[:limit] && (@num_of_records > self.class.legacy_find_options[:limit])\n        run_in_batches @num_of_records\n      else\n        run_normal\n      end\n      logger.info(\"#{self.class.to_s} migrated all #{@num_of_records} records successfully.\")\n    end\n\n    def run_in_batches(num_of_records)\n      logger.info(\"#{self.class.to_s} is starting.\")\n      count_options = self.class.legacy_find_options.dup\n      count_options.delete(:order)\n      count_options.delete(:group)\n      count_options.delete(:limit)\n      count_options.delete(:offset)\n      @num_of_records = self.",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support",
        "\n    def extract_search_text_with_tags(attributes)\n      Array(attributes).map { |meth|\n        Nokogiri::HTML(self.send(meth)).xpath(\"//text()\").\n          map {|node| node.text.try(:strip!); node.text}.join(\" \")\n      }.reject {|&:blank?}.join(\"\\n\")\n    end\n\n    def extract_search_text_with_tags_and_tags(attributes)\n      Array(attributes).map { |meth|\n        Nokogiri::HTML(self.send(meth)).xpath(\"//text()\").\n          map {|node| node.text.try(:strip!); node.text.try(:strip!); node.text}.join(\" \")\n      }.reject {|&:blank?}.join(\"\\n\")\n    end\n\n    def extract_search_text_with_tags_and_tags_and_tags(attributes)\n      Array(attributes).map { |meth|\n        Nokogiri::HTML(self.send(meth)).xpath(\"//text()\").\n          map {|node| node.text.try(:strip!); node.text.try(:strip!); node.text.try(:strip!); node.text}.join(\" \")\n      }.reject {|",
        "\n    end\n\n    def set_query_values!\n      self.class.search_query_values.each do |value|\n        self.send(\"#{value}=\", value)\n      end\n    end\n\n    def set_query_values!\n      self.class.search_query_values.each do |value|\n        self.send(\"#{value}=\", value)\n      end\n    end\n\n    def set_query_values!\n      self.class.search_query_values.each do |value|\n        self.send(\"#{value}=\", value)\n      end\n    end\n\n    def set_query_values!\n      self.class.search_query_values.each do |value|\n        self.send(\"#{value}=\", value)\n      end\n    end\n\n    def set_query_values!\n      self.class.search_query_values.each do |value|\n        self.send(\"#{value}=\", value)\n      end\n    end\n\n    def set_query_values!\n      self.class.search_query_values.each do |value|\n        self.send(\"#{value}=\", value)\n      end\n    end\n\n    def set_query_values!\n      self.class.search_query_",
        "\nend\n\ndef manager_ws_uri\n    manager_ws_uri.to_s\nend\n\ndef manager_ws_uri_with_port\n    manager_ws_uri.to_s + \":\" + manager_port\nend\n\ndef manager_ws_uri_without_port\n    manager_ws_uri.to_s\nend\n\ndef manager_ws_uri_with_path\n    manager_ws_uri.to_s + \"/\"\nend\n\ndef manager_ws_uri_without_path\n    manager_ws_uri.to_s\nend\n\ndef manager_ws_uri_with_query\n    manager_ws_uri.to_s + \"?\"\nend\n\ndef manager_ws_uri_without_query\n    manager_ws_uri.to_s\nend\n\ndef manager_ws_uri_with_fragment\n    manager_ws_uri.to_s + \"#\"\nend\n\ndef manager_ws_uri_without_fragment\n    manager_ws_uri.to_s\nend\n\ndef manager_ws_uri_with_query_and_fragment\n    manager_ws_uri.to_s + \"?\" + manager_query + \"#\" + manager_fragment\nend\n\ndef manager_ws_uri_without_query_and_fragment\n    manager_ws_uri",
        "\n    def check_script(command)\n      if File.exists?(command)\n        puts \"WARNING: The following script was found in #{command}:\"\n        for e in File.open(command)\n          puts \"[#{e.path}] #{e.message}\"\n        end\n        raise \"Errors in the script\"\n      end\n    end\n\n    def confdir\n      File.expand_path(\"../conf\", __FILE__)\n    end\n\n    def conffile\n      File.expand_path(\"../settings.yaml\", __FILE__)\n    end\n\n    def hook_user\n      @hook_user ||= ENV['HOOK_USER']\n    end\n\n    def database_path\n      @database_path ||= ENV['DATABASE_PATH']\n    end\n\n    def log_path\n      @log_path ||= ENV['LOG_PATH']\n    end\n\n    def log_level\n      @log_level ||= ENV['LOG_LEVEL']\n    end\n\n    def rename_hook_command\n      @rename_hook_command ||= ENV['RENAME_HOOK_COMMAND']\n    end\n\n    def rename_hook_command=(command)\n      @rename_hook_command = command\n    end\n\n    def rename_hook_command\n      @rename_hook_command ||= '/bin/true",
        "\n    end\n\n    def check_script_dir(path)\n      path.split(' ')[0].split('/').each do |dir|\n        check_script(dir)\n      end\n    end\n\n    def check_script_file(path)\n      check_script(path)\n    end\n\n    def check_script_dir_file(path)\n      check_script_dir(path)\n    end\n\n    def check_script_file_dir(path)\n      check_script_file(path)\n    end\n\n    def check_script_dir_file_dir(path)\n      check_script_dir_file(path)\n    end\n\n    def check_script_file_dir_file(path)\n      check_script_file_dir(path)\n    end\n\n    def check_script_file_dir_file_dir(path)\n      check_script_file_dir_file(path)\n    end\n\n    def check_script_file_dir_file_dir(path)\n      check_script_file_dir_file(path)\n    end\n\n    def check_script_file_dir_file_dir(path)\n      check_script_file_dir_file(path)\n    end\n\n    def check_script",
        "\n    end\n\n    def sync_host_table_with_new_hosts\n      uri = foreman_uri('/hosts?per_page=9999999')\n      debug \"Loading hosts from #{uri}\"\n      json = RestClient.get uri\n      debug \"Got JSON: #{json}\"\n      JSON.parse(json)['results'].each do |rec|\n        @db.execute \"insert into host (id,name) values ( ?, ? )\",\n                   rec['id'], rec['name']\n      end\n    end\n\n    def sync_host_table_with_new_hosts_with_new_hosts\n      uri = foreman_uri('/hosts?per_page=9999999')\n      debug \"Loading hosts from #{uri}\"\n      json = RestClient.get uri\n      debug \"Got JSON: #{json}\"\n      JSON.parse(json)['results'].each do |rec|\n        @db.execute \"insert into host (id,name) values ( ?, ? )\",\n                   rec['id'], rec['name']\n      end\n    end\n\n    def sync_host_table_with_new_hosts_with_new_hosts_with_new_hosts\n      uri = foreman_uri('/hosts?per_page=9999999')\n      debug \"Loading hosts from #{uri}\"\n     ",
        "\n    def sync_host_table\n      @db.execute <<-SQL\n        update host set name = 'localhost' where id = 1;\n      SQL\n    end\n\n    def sync_database\n      @db.execute <<-SQL\n        update host set name = 'localhost' where id = 1;\n      SQL\n    end\n\n    def sync_database_with_new_host\n      @db.execute <<-SQL\n        update host set name = 'localhost' where id = 1;\n      SQL\n    end\n\n    def sync_database_with_new_host_with_new_name\n      @db.execute <<-SQL\n        update host set name = 'localhost' where id = 1;\n      SQL\n    end\n\n    def sync_database_with_new_host_with_new_name_with_new_id\n      @db.execute <<-SQL\n        update host set name = 'localhost' where id = 1;\n      SQL\n    end\n\n    def sync_database_with_new_host_with_new_name_with_new_id_with_new_name\n      @db.execute <<-SQL\n        update host set name = 'localhost' where id = 1;\n      SQL\n    end\n\n    def sync_database_with_new_host_with_",
        "\n    def execute_hook_action_with_id(id)\n      @rename = false\n      name = @rec['host']['name']\n      id = id.to_i\n    \n      case @action\n      when 'create'\n        sql = \"insert into host (id, name) values (?, ?)\"\n        params = [id, name]\n      when 'update'\n        # Check if we are renaming the host\n        @old_name = @db.get_first_row('select name from host where id = ?', id)\n        @old_name = @old_name[0] unless @old_name.nil?\n        if @old_name.nil?\n          warn 'received an update for a non-existent host'\n        else\n          @rename = @old_name != name\n        end\n        debug \"checking for a rename: old=#{@old_name} new=#{name} rename?=#{@rename}\"\n    \n        sql = 'update host set name = ? where id = ?'\n        params = [name, id]\n      when 'destroy'\n        sql = 'delete from host where id = ?'\n        params = [id]\n      else\n        raise ArgumentError, \"unsupported action: #{ARGV[0]}\"\n      end\n      debug \"updating database; id=#{id} name=#{",
        "\n      lists[name]\n    end\n\n    def write_list(name, value)\n      opts = self.class.persisted_attrs[name]\n\n      if !lists[name] && opts[:default]\n        opts[:default]\n      else\n        send(\"#{name}=\", value) if lists[name].is_a?(Redis::Future)\n        lists[name] = value\n      end\n    end\n\n    def read_set(name)\n      opts = self.class.persisted_attrs[name]\n\n      if !sets[name] && opts[:default]\n        opts[:default]\n      else\n        send(\"#{name}=\", sets[name].value) if sets[name].is_a?(Redis::Future)\n        sets[name]\n      end\n    end\n\n    def write_set(name, value)\n      opts = self.class.persisted_attrs[name]\n\n      if !sets[name] && opts[:default]\n        opts[:default]\n      else\n        send(\"#{name}=\", value) if sets[name].is_a?(Redis::Future)\n        sets[name] = value\n      end\n    end\n\n    def read_map(name)\n      opts = self.class.persisted_attrs[",
        "\n      hashes[name]\n    end\n\n    def write_hash(name, value)\n      opts = self.class.persisted_attrs[name]\n\n      if !hashes[name] && opts[:default]\n        opts[:default]\n      else\n        self.send(\"#{name}=\", value) if hashes[name].is_a?(Redis::Future)\n        hashes[name] = value\n      end\n    end\n\n    def read_hash_with_timeout(name, timeout)\n      opts = self.class.persisted_attrs[name]\n\n      if !hashes[name] && opts[:default]\n        opts[:default]\n      else\n        self.send(\"#{name}=\", hashes[name].value, timeout) if hashes[name].is_a?(Redis::Future)\n        hashes[name]\n      end\n    end\n\n    def write_hash_with_timeout(name, value, timeout)\n      opts = self.class.persisted_attrs[name]\n\n      if !hashes[name] && opts[:default]\n        opts[:default]\n      else\n        self.send(\"#{name}=\", value, timeout) if hashes[name].is_a?(Redis::Future)\n        hashes[name]\n      end\n    end\n\n   ",
        "\n    def write_attribute_with_block(name, val, &block)\n      write_attribute(name, val) { yield }\n    end\n\n    def write_attribute_with_block_with_block(name, val, &block)\n      write_attribute(name, val) { yield }\n    end\n\n    def write_attribute_with_block_with_block_with_block(name, val, &block)\n      write_attribute(name, val) { yield }\n    end\n\n    def write_attribute_with_block_with_block_with_block(name, val, &block)\n      write_attribute(name, val) { yield }\n    end\n\n    def write_attribute_with_block_with_block_with_block(name, val, &block)\n      write_attribute(name, val) { yield }\n    end\n\n    def write_attribute_with_block_with_block_with_block(name, val, &block)\n      write_attribute(name, val) { yield }\n    end\n\n    def write_attribute_with_block_with_block_with_block(name, val, &block)\n      write_attribute(name, val) { yield }\n    end\n\n    def write_attribute_with_block",
        "\n    def read_list(name)\n      lists[name]\n    end\n\n    def delete_list(name)\n      lists.delete(name)\n    end\n\n    def lists\n      @lists ||= {}\n    end\n\n    def keys\n      @keys ||= {}\n    end\n\n    def keys_with_prefix(prefix)\n      @keys_with_prefix ||= {}\n    end\n\n    def keys_with_prefix_and_suffix(prefix, suffix)\n      @keys_with_prefix_and_suffix ||= {}\n    end\n\n    def keys_with_prefix_and_suffix_and_prefix(prefix, suffix, prefix)\n      @keys_with_prefix_and_suffix_and_prefix_and_suffix ||= {}\n    end\n\n    def keys_with_prefix_and_suffix_and_prefix_and_suffix(prefix, suffix, prefix, suffix)\n      @keys_with_prefix_and_suffix_and_prefix_and_suffix ||= {}\n    end\n\n    def keys_with_prefix_and_suffix_and_prefix_and_suffix(prefix, suffix, prefix, suffix)\n      @keys_with_prefix_and_suffix_and_prefix_and_suffix ||= {}\n    end\n\n    def keys_with_prefix_and_suffix",
        "\n    def hashes\n      @hashes ||= {}\n    end\n\n    def delete(name)\n      hashes.delete(name)\n    end\n\n    def delete_all\n      hashes.clear\n    end\n\n    def delete_all_keys\n      hashes.keys.each { |name| delete(name) }\n    end\n\n    def delete_all_values\n      hashes.values.each { |val| delete(val) }\n    end\n\n    def delete_all_values_keys\n      hashes.values.keys.each { |name| delete(name) }\n    end\n\n    def delete_all_values_values\n      hashes.values.each { |val| delete(val) }\n    end\n\n    def delete_all_values_values_keys\n      hashes.values.keys.each { |name| delete(name) }\n    end\n\n    def delete_all_values_values_values\n      hashes.values.each { |val| delete(val) }\n    end\n\n    def delete_all_values_values_values_keys\n      hashes.values.keys.each { |name| delete(name) }\n    end\n\n    def delete_all_values_values_values_values\n      hashes.values.each { |val| delete(val) }\n",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input",
        "\n    end\n\n    def filter_authorized_by_role(role, objects, user = current_user)\n      object_array = Array(objects)\n\n      object_array.select do |object|\n        policy = policy_for(object)\n        policy.role == role\n      end\n    end\n\n    def filter_authorized_by_role_and_user(role, objects, user = current_user)\n      object_array = Array(objects)\n\n      object_array.select do |object|\n        policy = policy_for(object)\n        policy.role == role && policy.user == user\n      end\n    end\n\n    def filter_authorized_by_role_and_user_and_role(role, objects, user = current_user)\n      object_array = Array(objects)\n\n      object_array.select do |object|\n        policy = policy_for(object)\n        policy.role == role && policy.user == user && policy.role == role\n      end\n    end\n\n    def filter_authorized_by_role_and_user_and_user_and_role(role, objects, user = current_user)\n      object_array = Array(objects)\n\n      object_array.select do |object|\n        policy = policy_for(object",
        "\n    # If the user is not an admin, then the object can be accessed\n    # by anyone.\n    if !user.admin?\n      return true\n    end\n\n    # If the object is a class, then the user can access it.\n    if object.is_a?(Class)\n      return can?(method, object, user)\n    end\n\n    # If the object is a module, then the user can access it.\n    if object.is_a?(Module)\n      return can?(method, object, user)\n    end\n\n    # If the object is a module, then the user can access it.\n    if object.is_a?(Module)\n      return can?(method, object, user)\n    end\n\n    # If the object is a class, then the user can access it.\n    if object.is_a?(Class)\n      return can?(method, object, user)\n    end\n\n    # If the object is a class, then the user can access it.\n    if object.is_a?(Class)\n      return can?(method, object, user)\n    end\n\n    # If the object is a module, then the user can access it.\n    if object.is_a?(Module)\n      return can?",
        "\n    def nethash_with_blockchain_api blockchain_api\n      nethash interval: interval, start: start, stop: true\n    end\n\n    def nethash_with_blockchain_api_with_blockchain_api blockchain_api, blockchain_api\n      nethash interval: interval, start: start, stop: true, blockchain_api: blockchain_api\n    end\n\n    def nethash_with_blockchain_api_with_blockchain_api_with_blockchain_api blockchain_api, blockchain_api, blockchain_api\n      nethash interval: interval, start: start, stop: true, blockchain_api: blockchain_api, blockchain_api: blockchain_api\n    end\n\n    def nethash_with_blockchain_api_with_blockchain_api_with_blockchain_api blockchain_api, blockchain_api, blockchain_api\n      nethash interval: interval, start: start, stop: true, blockchain_api: blockchain_api, blockchain_api: blockchain_api\n    end\n\n    def nethash_with_blockchain_api_with_blockchain_api_with_blockchain_api blockchain_api, blockchain_api, blockchain_api\n      nethash interval: interval, start: start, stop: true,",
        "\n    def first(limit=1, offset=0)\n      from    = offset\n      to      = from + limit - 1\n      members = redis.zrange(index_key_for(:id), (from * -1) + 1, (to * -1) + 1).reverse\n\n      find(limit > 1 ? members : members.first)\n    end\n\n    def count(limit=1, offset=0)\n      from    = offset\n      to      = from + limit - 1\n      members = redis.zrange(index_key_for(:id), (from * -1) + 1, (to * -1) + 1).reverse\n\n      redis.zcard(index_key_for(:id), (from * -1) + 1, (to * -1) + 1)\n    end\n\n    def count_by_id(ids)\n      count(ids, offset: 0)\n    end\n\n    def count_by_id_and_limit(ids, limit)\n      count(ids, offset: 0, limit: limit)\n    end\n\n    def count_by_id_and_offset(ids, offset)\n      count(ids, offset: offset, limit: limit)\n    end\n\n    def count_by_id_and_offset_and_limit(",
        "\n    end\n\n    def find_by_ids(ids, opts={})\n      ids.is_a?(Array) ? find_by_ids_and_opts(ids, opts) : find_by_id_and_opts(ids, opts)\n    end\n\n    def find_by_id(ids, opts={})\n      ids.is_a?(Array) ? find_by_id_and_opts(ids, opts) : find_by_id_and_opts(ids, opts)\n    end\n\n    def find_by_id_and_opts(ids, opts={})\n      ids.is_a?(Array) ? find_by_id_and_opts_and_ids(ids, opts) : find_by_id_and_opts_and_id(ids, opts)\n    end\n\n    def find_by_id_and_opts_and_ids(ids, opts={})\n      ids.is_a?(Array) ? find_by_id_and_opts_and_ids_and_opts(ids, opts) : find_by_id_and_opts_and_id(ids, opts)\n    end\n\n    def find_by_id_and_opts_and_ids_and_opts(ids, opts={})\n",
        "\n    def find_in_batches_with_options(options={})\n      find_in_batches(options).map { |record| record.first }\n    end\n\n    def find_in_batches_with_options_with_block(options={})\n      find_in_batches(options).map { |record| record.first }.with_block { |record| yield record }\n    end\n\n    def find_in_batches_with_options_with_block_with_block(options={})\n      find_in_batches(options).map { |record| record.first }.with_block { |record| yield record }.with_block { |record| yield record }\n    end\n\n    def find_in_batches_with_options_with_block_with_block_with_block(options={})\n      find_in_batches(options).map { |record| record.first }.with_block { |record| yield record }.with_block { |record| yield record }.with_block { |record| yield record }\n    end\n\n    def find_in_batches_with_options_with_block_with_block_with_block(options={})\n      find_in_batches(options).map { |record| record.first }.with_block { |",
        "\n    def load_keymap_from_file(map) #:nodoc:\n      @maps ||= Hash.new\n      if File.file?(File.join(self.storage_path, map.to_s + \"_map.yml\"))\n        @maps[map] = YAML.load(File.open(File.join(self.storage_path, map.to_s + \"_map.yml\")))\n        logger.debug(\"#{self.class.to_s} lazy loaded #{map} successfully.\")\n      end\n    end\n\n    def load_keymap_from_hash(hash) #:nodoc:\n      @maps ||= Hash.new\n      if hash.is_a?(Hash)\n        hash.each do |k, v|\n          load_keymap_from_hash(v)\n        end\n      end\n    end\n\n    def load_keymap_from_hash_with_defaults(hash) #:nodoc:\n      @maps ||= Hash.new\n      if hash.is_a?(Hash)\n        hash.each do |k, v|\n          load_keymap_from_hash(v)\n        end\n      end\n    end\n\n    def load_keymap_from_hash_with_defaults_and_defaults(hash) #:nodoc:\n      @maps ||=",
        "\n  def load_keymap(map)\n    @maps[map.to_s] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s][handle_composite(map)] = {}\n    @maps[map.to_s",
        "\n    def processor_count=(value)\n      @processor_count = value\n    end\n\n    def processor_count_in_bytes\n      @processor_count_in_bytes ||= begin\n        if File.readable?(\"/proc/cpuinfo\")\n          IO.read(\"/proc/cpuinfo\").scan(/^processor/).size\n        elsif File.executable?(\"/usr/bin/hwprefs\")\n          IO.popen(\"/usr/bin/hwprefs thread_count\").read.to_i\n        elsif File.executable?(\"/usr/sbin/psrinfo\")\n          IO.popen(\"/usr/sbin/psrinfo\").read.scan(/^.*on-*line/).size\n        elsif File.executable?(\"/usr/sbin/ioscan\")\n          IO.popen(\"/usr/sbin/ioscan -kC processor\") do |out|\n            out.read.scan(/^.*processor/).size\n          end\n        elsif File.executable?(\"/usr/sbin/pmcycles\")\n          IO.popen(\"/usr/sbin/pmcycles -m\").read.count(\"\\n\")\n        elsif File.executable?(\"/usr/sbin/lsdev\")\n          IO.popen(\"/usr/sbin/lsdev -Cc",
        "\n    def processor_count\n      @processor_count ||= begin\n        if RbConfig::CONFIG[\"target_os\"] == /darwin1/\n          IO.popen(\"/usr/sbin/sysctl -n hw.nprocessor\").read.to_i\n        else\n          IO.read(\"/proc/cpuinfo\").scan(/^processor id.*/).map { |ln| ln[/\\d+/] }.reduce(:+)\n        end\n      end\n    end\n\n    def processor_count_with_cores\n      @processor_count_with_cores ||= begin\n        if RbConfig::CONFIG[\"target_os\"] == /darwin1/\n          IO.popen(\"/usr/sbin/sysctl -n hw.nprocessor\").read.to_i\n        else\n          IO.read(\"/proc/cpuinfo\").scan(/^processor id.*|^core id.*/).map { |ln| ln[/\\d+/] }.reduce(:+)\n        end\n      end\n    end\n\n    def processor_count_with_cores_and_cores\n      @processor_count_with_cores_and_cores ||= begin\n        if RbConfig::CONFIG[\"target_os\"] == /darwin1/\n          IO.popen(\"/usr/sbin/sysctl -n hw.nprocessor\").read.to",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputFilter;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate",
        "\n    def clear()\n      self.clear\n      self.concat []\n    end\n\n    def append(event)\n      self.concat event\n    end\n\n    def event_file\n      File.join(File.dirname(__FILE__), 'events.txt')\n    end\n\n    def event_file=(file)\n      @event_file = file\n    end\n\n    def event_file_path\n      File.join(File.dirname(__FILE__), 'events.txt')\n    end\n\n    def event_file_path=(file)\n      @event_file = file\n    end\n\n    def event_file_path_with_extension\n      File.join(File.dirname(__FILE__), 'events.txt.ext')\n    end\n\n    def event_file_path_with_extension=(file)\n      @event_file = file\n    end\n\n    def event_file_path_with_extension_with_extension\n      File.join(File.dirname(__FILE__), 'events.txt.ext.ext')\n    end\n\n    def event_file_path_with_extension_with_extension_with_extension\n      File.join(File.dirname(__FILE__), 'events.txt.ext.ext.ext')\n    end\n\n   ",
        "\n    def follower_of?(model)\n      0 < self.followers.by_model(model).limit(1).count * model.followees.by_model(self).limit(1).count\n    end\n\n    def follower_of?(model)\n      0 < self.followers.by_model(model).limit(1).count * model.followers.by_model(self).limit(1).count\n    end\n\n    def follower_of?(model)\n      0 < self.followers.by_model(model).limit(1).count * model.followers.by_model(self).limit(1).count\n    end\n\n    def follower_of?(model)\n      0 < self.followers.by_model(model).limit(1).count * model.followers.by_model(self).limit(1).count\n    end\n\n    def follower_of?(model)\n      0 < self.followers.by_model(model).limit(1).count * model.followers.by_model(self).limit(1).count\n    end\n\n    def follower_of?(model)\n      0 < self.followers.by_model(model).limit(1).count * model.followers.by_",
        "\nend\n\ndef ever_followed_by_user(user)\n      follow = []\n      self.followed_history.each do |h|\n        follow << h.split('_')[0].constantize.find(h.split('_')[1])\n      end\n      follow.select {|f| f.user == user}\n    end\n\ndef ever_followed_by_user_and_name(user, name)\n      follow = []\n      self.followed_history.each do |h|\n        follow << h.split('_')[0].constantize.find(h.split('_')[1])\n      end\n      follow.select {|f| f.user == user && f.name == name}\n    end\n\ndef ever_followed_by_user_and_name_and_id(user, name, id)\n      follow = []\n      self.followed_history.each do |h|\n        follow << h.split('_')[0].constantize.find(h.split('_')[1])\n      end\n      follow.select {|f| f.user == user && f.name == name && f.id == id}\n    end\n\ndef ever_followed_by_user_and_name_and_id_and_type(",
        "\n    end\n\n    def waitable_for_current_thread\n      @waitables_to_resume.pop\n    end\n\n    def waitable_for_current_thread_with_timeout(timeout)\n      @waitables_to_resume.pop(timeout)\n    end\n\n    def waitable_for_current_thread_with_timeout_and_mutex(timeout, mutex)\n      @waitables_to_resume.pop(timeout, mutex)\n    end\n\n    def waitable_for_current_thread_with_timeout_and_mutex_and_timeout(timeout, mutex, timeout)\n      @waitables_to_resume.pop(timeout, mutex, timeout)\n    end\n\n    def waitable_for_current_thread_with_timeout_and_mutex_and_timeout_and_mutex(timeout, mutex, timeout, mutex)\n      @waitables_to_resume.pop(timeout, mutex, timeout, mutex)\n    end\n\n    def waitable_for_current_thread_with_timeout_and_mutex_and_timeout_and_mutex(timeout, mutex, timeout, mutex, timeout)\n      @waitables_to_resume.pop(timeout, mutex, timeout, mutex, timeout)\n    end\n\n    def waitable_for_current_thread_with",
        "\n      unless timeout.is_a?(Numeric)\n        raise TypeError, \"'timeout' must be a Numeric\" unless timeout.is_a?(Numeric)\n      end\n    end\n\n    def validate_timeout_interval(interval)\n      unless interval == nil\n        raise TypeError, \"'interval' must be nil or a Numeric\" unless interval.is_a?(Numeric)\n      end\n    end\n\n    def validate_timeout_interval_interval(interval, interval_interval)\n      unless interval == nil\n        raise TypeError, \"'interval' must be nil or a Numeric\" unless interval.is_a?(Numeric)\n      end\n      unless interval_interval == nil\n        raise TypeError, \"'interval_interval' must be nil or a Numeric\" unless interval_interval.is_a?(Numeric)\n      end\n    end\n\n    def validate_timeout_interval_interval_interval(interval, interval_interval, interval_interval_interval)\n      unless interval == nil\n        raise TypeError, \"'interval' must be nil or a Numeric\" unless interval.is_a?(Numeric)\n      end\n      unless interval_interval == nil\n        raise TypeError, \"'interval_interval' must be nil or a Numeric\" unless interval_interval.is_a?(Numeric)\n      end\n      unless interval_interval_interval == nil\n        raise TypeError",
        "\n    def render_locals(view_handler, locals)\n      locals.merge!(view_handler.locals)\n    end\n\n    def render_template(template_name, view_handler, locals, &content)\n      render(template_name, view_handler, locals, &content)\n    end\n\n    def render_template_with_locals(template_name, view_handler, locals, &content)\n      render(template_name, view_handler, locals, &content)\n    end\n\n    def render_template_with_locals_and_locals(template_name, view_handler, locals, &content)\n      render(template_name, view_handler, locals, &content)\n    end\n\n    def render_template_with_locals_and_locals_and_locals(template_name, view_handler, locals, &content)\n      render(template_name, view_handler, locals, &content)\n    end\n\n    def render_template_with_locals_and_locals_and_locals(template_name, view_handler, locals, &content)\n      render(template_name, view_handler, locals, &content)\n    end\n\n    def render_template_with_locals_and_locals_and_locals(template_name, view_handler, locals",
        "\n\ndef get_entry()\n      entry = @worksheet.get_entry(@page_name)\n      if entry\n        return entry\n      end\n      return nil\n    end\n\ndef get_agent_name()\n      agent_name = @agent_name\n      if agent_name\n        return agent_name\n      end\n      return nil\n    end\n\ndef get_page_name()\n      page_name = @page_name\n      if page_name\n        return page_name\n      end\n      return nil\n    end\n\ndef get_config()\n      config = @config\n      if config\n        return config\n      end\n      return nil\n    end\n\ndef get_keys()\n      keys = @keys\n      if keys\n        return keys\n      end\n      return nil\n    end\n\ndef get_prerequisites()\n      prerequisites = @prerequisites\n      if prerequisites\n        return prerequisites\n      end\n      return nil\n    end\n\ndef get_debug()\n      debug = @debug\n      if debug\n        return debug\n      end\n      return nil\n    end\n\ndef get_debug_mode()\n      debug_mode = @debug_mode\n      if debug_mode\n        return debug_mode\n      end\n      return nil\n   ",
        "\n    def first(number)\n      cards = []\n      cards << cards.first(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last(number)\n      cards << cards.last",
        "\n    def discard_all\n      ordered = player.hand.map do |card|\n        i = card_preference.map { |preference| card.type == preference }.index(true)\n        {card: card, index: i}\n      end\n      ordered.sort_by { |h| h[:index] || 99 }.last.try(:fetch, :card)\n    end\n\n    def discard_all_by_type\n      ordered = player.hand.map do |card|\n        i = card_preference.map { |preference| card.type == preference }.index(true)\n        {card: card, index: i}\n      end\n      ordered.sort_by { |h| h[:index] || 99 }.last.try(:fetch, :card)\n    end\n\n    def discard_all_by_type_and_index\n      ordered = player.hand.map do |card|\n        i = card_preference.map { |preference| card.type == preference }.index(true)\n        {card: card, index: i}\n      end\n      ordered.sort_by { |h| h[:index] || 99 }.last.try(:fetch, :card)\n    end\n\n    def discard_all_by_type_and_index_and_type\n     ",
        "\n    def skippable?(card, target, bangs_played)\n      bangs_played == 0 if card.type == Card.bang_card\n      bangs_played == 1 if card.type == Card.king_card\n      bangs_played == 2 if card.type == Card.heart_card\n      bangs_played == 3 if card.type == Card.diamond_card\n      bangs_played == 4 if card.type == Card.club_card\n      bangs_played == 5 if card.type == Card.heart_card\n      bangs_played == 6 if card.type == Card.diamond_card\n      bangs_played == 7 if card.type == Card.club_card\n      bangs_played == 8 if card.type == Card.heart_card\n      bangs_played == 9 if card.type == Card.diamond_card\n      bangs_played == 10 if card.type == Card.club_card\n      bangs_played == 11 if card.type == Card.heart_card\n      bangs_played == 12 if card.type == Card.diamond_card\n      bang",
        "\n        if elapsed_time > timeout\n          raise Timeout::Error, \"sleep timed out\"\n        end\n        elapsed_time\n      end\n    end\n\n    def timer\n      @timer ||= begin\n        begin\n          Thread.start\n        rescue\n          nil\n        end\n      end\n    end\n\n    def unlock\n      @lock ||= begin\n        begin\n          Thread.pass\n        rescue\n          nil\n        end\n      end\n    end\n\n    def validate_timeout(timeout)\n      raise ArgumentError, \"timeout must be a Float\" unless timeout.is_a? Float\n    end\n\n    def timer_lock\n      @lock ||= begin\n        begin\n          Thread.pass\n        rescue\n          nil\n        end\n      end\n    end\n\n    def timer_unlock\n      @lock ||= begin\n        begin\n          Thread.pass\n        rescue\n          nil\n        end\n      end\n    end\n\n    def timer_lock_unlock\n      @lock ||= begin\n        begin\n          Thread.pass\n        rescue\n          nil\n        end\n      end\n    end\n\n    def timer_lock_unlock_with_timeout(timeout)\n      @lock ||= begin\n        begin\n          Thread.pass\n        rescue\n          nil\n        end\n      end\n    end\n\n    def timer_unlock_with",
        "\n    end\n\n    def temporarily_release_immediately(&block)\n      temporarily_release(&block)\n    end\n\n    def temporarily_release_immediately_with_timeout(&block)\n      temporarily_release_immediately(&block)\n    end\n\n    def temporarily_release_immediately_with_timeout_with_block(&block)\n      temporarily_release_immediately(&block)\n    end\n\n    def temporarily_release_immediately_with_timeout_with_block_with_timeout(&block)\n      temporarily_release_immediately(&block)\n    end\n\n    def temporarily_release_immediately_with_timeout_with_block_with_timeout_with_block(&block)\n      temporarily_release_immediately(&block)\n    end\n\n    def temporarily_release_immediately_with_timeout_with_block_with_timeout_with_block(&block)\n      temporarily_release_immediately(&block)\n    end\n\n    def temporarily_release_immediately_with_timeout_with_block_with_timeout_with_block(&block)\n      temporarily_release_immediately(&block)\n    end\n\n    def temporarily_release_immediately_with_timeout_with_block_with_timeout_with",
        "\n    puts \"Elapsed time: #{time_elapsed}\"\nend\n\ndef timer_with_block(&block)\n      start_time = Time.now\n      yield(start_time)\n      time_elapsed = Time.now - start_time\n\n    puts \"Elapsed time: #{time_elapsed}\"\nend\n\ndef timer_with_block_with_block(&block)\n      start_time = Time.now\n      yield(start_time)\n      time_elapsed = Time.now - start_time\n\n    puts \"Elapsed time: #{time_elapsed}\"\nend\n\ndef timer_with_block_with_block_with_block(&block)\n      start_time = Time.now\n      yield(start_time)\n      time_elapsed = Time.now - start_time\n\n    puts \"Elapsed time: #{time_elapsed}\"\nend\n\ndef timer_with_block_with_block_with_block(&block)\n      start_time = Time.now\n      yield(start_time)\n      time_elapsed = Time.now - start_time\n\n    puts \"Elapsed time: #{time_elapsed}\"\nend\n\ndef timer_with_block_with_block_with_block(&block)\n      start_time = Time.now\n      yield(start_time)",
        "\n    def wait_until(time)\n      loop do\n        break if continue\n        sleep time\n      end\n    end\n\n    def sleep_until(time)\n      loop do\n        break if continue\n        sleep time\n      end\n    end\n\n    def sleep_until_exit(time)\n      loop do\n        break if continue\n        sleep time\n        exit\n      end\n    end\n\n    def sleep_until_exit_with_message(time, message)\n      loop do\n        break if continue\n        sleep time\n        exit message\n      end\n    end\n\n    def sleep_until_exit_with_message_and_exit(time, message, exit)\n      loop do\n        break if continue\n        sleep time\n        exit message\n      end\n    end\n\n    def sleep_until_exit_with_message_and_exit_with_message(time, message, exit, message2)\n      loop do\n        break if continue\n        sleep time\n        exit message\n      end\n    end\n\n    def sleep_until_exit_with_message_and_exit_with_message_and_exit(time, message, exit, message2, message3)\n      loop do\n        break if continue\n        sleep time\n        exit message\n      end\n    end\n\n    def sleep",
        "\n        if block.arity == 0\n          block.call(*args)\n        else\n          block.call(*args, &block.block)\n        end\n      end\n    end\n\ndef optional_args_block_call_with_block(block, args)\n      optional_args_block_call(block, args)\n    end\n\ndef optional_args_block_call_with_block_with_block(block, args, &block)\n      optional_args_block_call(block, args)\n    end\n\ndef optional_args_block_call_with_block_with_block_with_block(block, args, &block)\n      optional_args_block_call(block, args)\n    end\n\ndef optional_args_block_call_with_block_with_block_with_block(block, args, &block)\n      optional_args_block_call(block, args)\n    end\n\ndef optional_args_block_call_with_block_with_block_with_block(block, args, &block)\n      optional_args_block_call(block, args)\n    end\n\ndef optional_args_block_call_with_block_with_block_with_block(block, args, &block)\n      optional_args_block_",
        "\n    def extract_file_rdoc_with_comments(file, from = nil, reverse = false)\n      lines = File.readlines(file)\n      if from.nil? and reverse\n        lines = lines.reverse\n      elsif !reverse\n        lines = lines[(from || 0)..-1]\n      else\n        lines = lines[0...(from || -1)].reverse\n      end\n      \n      doc, started = [], false\n      lines.each{|line|\n        if /^\\s*[#]/ =~ line\n          doc << line\n          started = true\n        elsif started\n          break\n        end \n      }\n      \n      doc = reverse ? doc.reverse[0..-1] : doc[0..-1]\n      doc = doc.join(\"\\n\")\n      doc.gsub(/^\\s*[#] ?/, \"\")\n    end\n\n    def extract_file_rdoc_with_comments_and_comments_and_comments(file, from = nil, reverse = false)\n      lines = File.readlines(file)\n      if from.nil? and reverse\n        lines = lines.reverse\n      elsif !reverse\n        lines = lines[(from || 0)..-1]\n      else\n        lines = lines[0...(from || -1)",
        "\n    def order(order)\n      if (order == :asc) || (order == :desc)\n        order = :asc\n      end\n      clone.tap {|q| q.options[:order] = order}\n    end\n\n    def limit(limit)\n      if (limit == 0)\n        limit = nil\n      end\n      clone.tap {|q| q.options[:limit] = limit}\n    end\n\n    def offset(offset)\n      if (offset == 0)\n        offset = nil\n      end\n      clone.tap {|q| q.options[:offset] = offset}\n    end\n\n    def where(conditions)\n      if (conditions == []) || (conditions.nil?)\n        conditions = []\n      end\n      clone.tap {|q| q.options[:conditions] = conditions}\n    end\n\n    def where!(conditions)\n      if (conditions == []) || (conditions.nil?)\n        conditions = []\n      end\n      clone.tap {|q| q.options[:conditions] = conditions}\n    end\n\n    def where_not(conditions)\n      if (conditions == []) || (conditions.nil?)\n        conditions = []\n      end\n      clone.tap {|q| q.options[:conditions] = conditions}\n    end",
        "\n    end\n\n    def set_pagination_info(page_no, page_size, record_count)\n      @current_page = page_no\n      @per_page = page_size\n      @total_count = record_count\n      @total_pages = (record_count / page_size.to_f).ceil\n    \n      extend PaginationMethods\n\n      self\n    end\n\n    def set_pagination_info(page_no, page_size, record_count)\n      @current_page = page_no\n      @per_page = page_size\n      @total_count = record_count\n      @total_pages = (record_count / page_size.to_f).ceil\n    \n      extend PaginationMethods\n\n      self\n    end\n\n    def set_pagination_info(page_no, page_size, record_count)\n      @current_page = page_no\n      @per_page = page_size\n      @total_count = record_count\n      @total_pages = (record_count / page_size.to_f).ceil\n    \n      extend PaginationMethods\n\n      self\n    end\n\n    def set_pagination_info(page_no, page_size, record_count)\n      @current_page = page_no",
        "\n    def echo_uploads_data\n      @echo_uploads_data ||= begin\n        if send(\"#{self.class.name}_tmp_metadata\").nil?\n          send \"#{self.class.name}_tmp_metadata=\", []\n        end\n        send(\"#{self.class.name}_tmp_metadata\")\n      end\n    end\n\n    def echo_uploads_data=(data)\n      @echo_uploads_data = data\n    end\n\n    def echo_uploads_data\n      @echo_uploads_data ||= begin\n        if send(\"#{self.class.name}_tmp_metadata\").nil?\n          send \"#{self.class.name}_tmp_metadata=\", []\n        end\n        send(\"#{self.class.name}_tmp_metadata\")\n      end\n    end\n\n    def echo_uploads_data=(data)\n      @echo_uploads_data = data\n    end\n\n    def echo_uploads_data\n      @echo_uploads_data ||= begin\n        if send(\"#{self.class.name}_tmp_metadata\").nil?\n          send \"#{self.class.name}_tmp_metadata=\", []\n        end\n        send(\"#{self.class.name}_tmp_metadata\")\n      end\n    end\n\n    def echo_uploads_data=(data)\n      @echo_uploads_",
        "\n    def follower_of?(model)\n      0 < self.followees.by_model(model).limit(1).count * model.followers.by_model(self).limit(1).count\n    end\n\n    def follower_of?(model)\n      0 < self.followees.by_model(model).limit(1).count * model.followers.by_model(self).limit(1).count\n    end\n\n    def follower_of?(model)\n      0 < self.followees.by_model(model).limit(1).count * model.followers.by_model(self).limit(1).count\n    end\n\n    def follower_of?(model)\n      0 < self.followees.by_model(model).limit(1).count * model.followers.by_model(self).limit(1).count\n    end\n\n    def follower_of?(model)\n      0 < self.followees.by_model(model).limit(1).count * model.followers.by_model(self).limit(1).count\n    end\n\n    def follower_of?(model)\n      0 < self.followees.by_model(model).limit(1).count * model.followers.by_",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\n    end\n\n    def follow_history\n      self.follow_history.map { |h| h.split('_')[0].constantize.find(h.split('_')[1]) }\n    end\n\n    def follow_history=(history)\n      self.follow_history = history\n    end\n\n    def follow_history_count\n      self.follow_history.count\n    end\n\n    def follow_history_size\n      self.follow_history.size\n    end\n\n    def follow_history_last\n      self.follow_history.last\n    end\n\n    def follow_history_last_id\n      self.follow_history.last.id\n    end\n\n    def follow_history_last_name\n      self.follow_history.last.name\n    end\n\n    def follow_history_last_email\n      self.follow_history.last.email\n    end\n\n    def follow_history_last_created_at\n      self.follow_history.last.created_at\n    end\n\n    def follow_history_last_updated_at\n      self.follow_history.last.updated_at\n    end\n\n    def follow_history_last_followed_at\n      self.follow_history.last.followed_at\n    end\n\n",
        "\n          @pop_mutex.unlock\n          @mutex.unlock\n          @pop_mutex.lock\n        end\n      end\n    end\n\n    def push(item)\n      @push_mutex.lock do\n        @mutex.synchronize do\n          if empty?\n            return if closed?\n            raise ThreadError if non_block\n            @mutex.unlock\n            @waiter.wait\n            @mutex.lock\n            return if closed?\n          end\n          @items << item\n        end\n      end\n    end\n\n    def empty?\n      @items.empty?\n    end\n\n    def closed?\n      @closed\n    end\n\n    def size\n      @items.size\n    end\n\n    def each\n      @items.each do |item|\n        yield item\n      end\n    end\n\n    def each_with_index\n      @items.each_with_index do |item, index|\n        yield item, index\n      end\n    end\n\n    def each_with_index_with_block\n      @items.each_with_index_with_block do |item, index, block|\n        yield item, index, block\n      end\n    end\n\n    def each_with_index_with_block_with_block\n      @items.each_with",
        "\n    end\n\n    def cache\n      @cache ||= {}\n    end\n\n    def link\n      @link ||= link_class.new(self)\n    end\n\n    def link_class\n      @link_class ||= begin\n        link_class = link.send(:link_class)\n        link_class.new(self)\n      end\n    end\n\n    def link_class=(link_class)\n      @link_class = link_class\n    end\n\n    def cache=(cache)\n      @cache = cache\n    end\n\n    def cache\n      @cache ||= {}\n    end\n\n    def cache_key(key)\n      @cache_key ||= key\n    end\n\n    def cache_key=(key)\n      @cache_key = key\n    end\n\n    def cache_key_prefix\n      @cache_key_prefix ||= key_prefix\n    end\n\n    def cache_key_prefix=(prefix)\n      @cache_key_prefix = prefix\n    end\n\n    def cache_key_suffix\n      @cache_key_suffix ||= key_suffix\n    end\n\n    def cache_key_suffix=(suffix)\n      @cache_key_suffix = suffix\n    end\n\n    def cache_key_prefix_suffix\n      @cache_key_prefix_",
        "\n        end\n      end\n    end\n\n    def announce_all(key, port, opts={}, &block)\n      announce(key, port, opts, &block)\n      announce(key, port, opts, &block)\n      announce(key, port, opts, &block)\n    end\n\n    def announce_all_with_opts(key, port, opts={}, &block)\n      announce(key, port, opts, &block)\n      announce(key, port, opts, &block)\n      announce(key, port, opts, &block)\n    end\n\n    def announce_all_with_opts_and_block(key, port, opts={}, &block)\n      announce(key, port, opts, &block)\n      announce(key, port, opts, &block)\n    end\n\n    def announce_all_with_opts_and_block_with_opts(key, port, opts={}, &block)\n      announce(key, port, opts, &block)\n      announce(key, port, opts, &block)\n    end\n\n    def announce_all_with_opts_and_block_with_opts_and_block(key, port, opts={}, &block)\n      announce(key, port, opts, &block)\n      announce(key, port, opts,",
        "\n    end\n\n    def _logical_or(delegated, *conditions)\n      _logical_operator(delegated, *conditions) | _logical_operator(delegated, *conditions)\n    end\n\n    def _logical_and(delegated, *conditions)\n      _logical_operator(delegated, *conditions) & _logical_operator(delegated, *conditions)\n    end\n\n    def _logical_not(delegated, *conditions)\n      _logical_operator(delegated, *conditions) ^ _logical_operator(delegated, *conditions)\n    end\n\n    def _logical_and_not(delegated, *conditions)\n      _logical_operator(delegated, *conditions) & _logical_operator(delegated, *conditions) ^ _logical_operator(delegated, *conditions)\n    end\n\n    def _logical_or_not(delegated, *conditions)\n      _logical_operator(delegated, *conditions) | _logical_operator(delegated, *conditions) ^ _logical_operator(delegated, *conditions)\n    end\n\n    def _logical_and_or_not(delegated, *conditions)\n      _logical_operator(delegated, *conditions) & _",
        "\n    def post_with_signature_with_headers(opts)\n      path = opts.fetch(:path)\n      payload = opts.fetch(:payload)\n      secret = opts.fetch(:secret)\n\n      post path, {payload: payload}, generate_secret_header(secret, URI.encode_www_form(payload: payload))\n    end\n\n    def generate_secret_header(secret, payload)\n      \"X-Auth-Token: #{secret}\"\n    end\n\n    def generate_signature(opts)\n      path = opts.fetch(:path)\n      payload = opts.fetch(:payload)\n      secret = opts.fetch(:secret)\n\n      signature = Digest::SHA1.hexdigest(URI.encode_www_form(payload: payload))\n\n      post path, {payload: payload}, generate_signature_header(secret, signature)\n    end\n\n    def generate_signature_header(secret, signature)\n      \"X-Auth-Signature: #{signature}\"\n    end\n\n    def generate_signature_header_with_headers(opts)\n      path = opts.fetch(:path)\n      payload = opts.fetch(:payload)\n      secret = opts.fetch(:secret)\n\n      signature = Digest::SHA1.hexdigest(URI.encode_www_form(payload: payload))\n\n",
        "\n    return new_height\nend\n\ndef get_width(img)\n      new_width = (img.width / (img.height.to_f / self.height.to_f)).ceil\n    end\n\ndef get_width_ratio(img)\n      new_width = (img.width.to_f / self.width.to_f)\n    end\n\ndef get_height_ratio(img)\n      new_height = (img.height.to_f / self.height.to_f)\n    end\n\ndef get_width_ratio(img)\n      new_width = (img.width.to_f / self.width.to_f)\n    end\n\ndef get_height_ratio(img)\n      new_height = (img.height.to_f / self.height.to_f)\n    end\n\ndef get_width_ratio(img)\n      new_width = (img.width.to_f / self.width.to_f)\n    end\n\ndef get_height_ratio(img)\n      new_height = (img.height.to_f / self.height.to_f)\n    end\n\ndef get_width_ratio(img)\n      new_width = (img.width.to_f /",
        "\n        end\n      end.join\n    end\n\n    def find_closest_term_color(pix_vals)\n      pix_vals.sort! {|a,b| a[0] <=> b[0]}\n      pix_vals.map! {|a| a[1]}\n      pix_vals.map! {|a| a[2]}\n      pix_vals.map! {|a| a[3]}\n      pix_vals.map! {|a| a[4]}\n      pix_vals.map! {|a| a[5]}\n      pix_vals.map! {|a| a[6]}\n      pix_vals.map! {|a| a[7]}\n      pix_vals.map! {|a| a[8]}\n      pix_vals.map! {|a| a[9]}\n      pix_vals.map! {|a| a[10]}\n      pix_vals.map! {|a| a[11]}\n      pix_vals.map! {|a| a[12]}\n      pix_vals.map! {|a| a[13]}\n      pix_vals.map! {|a| a[14]}\n      pix_vals.map! {|a| a[15]}\n      pix_vals.map",
        "\n      @@palette[color] = lil_dist\n      color\n    end\n\ndef find_closest_term_color_by_name(name)\n      color = \"\"\n      lil_dist = 195075\n      @@palette.each do |col_name, col_values|\n        dist = find_distance(col_values, name)\n        if dist < lil_dist\n          lil_dist = dist\n          color = col_name\n        end\n      end\n      color\n    end\n\ndef find_closest_term_color_by_name_and_value(name, value)\n      color = \"\"\n      lil_dist = 195075\n      @@palette.each do |col_name, col_values|\n        dist = find_distance(col_values, name, value)\n        if dist < lil_dist\n          lil_dist = dist\n          color = col_name\n        end\n      end\n      color\n    end\n\ndef find_closest_term_color_by_name_and_value_and_color(name, value, color)\n      color = \"\"\n      lil_dist = 195075\n      @@palette.each do |col_name, col_values|\n        dist = find_distance(col_values, name,",
        "\nend\n\ndef find_color(pixel)\n  pixels = pixel.to_a\n  pixels.each do |pixel|\n    if pixel.to_s.length == 1\n      return \"black\"\n    end\n  end\n  return \"white\"\nend\n\ndef draw_line_with_color(pixels)\n  pixels = pixels.to_a\n  pixels.each do |pixel|\n    if pixel.to_s.length == 1\n      return \"black\"\n    end\n  end\n  return \"white\"\nend\n\ndef draw_line_with_color_and_alpha(pixels)\n  pixels = pixels.to_a\n  pixels.each do |pixel|\n    if pixel.to_s.length == 1\n      return \"black\"\n    end\n  end\n  return \"white\"\nend\n\ndef draw_line_with_color_and_alpha_and_alpha(pixels)\n  pixels = pixels.to_a\n  pixels.each do |pixel|\n    if pixel.to_s.length == 1\n      return \"black\"\n    end\n  end\n  return \"white\"\nend\n\ndef draw_line_with_color_and_alpha_and_alpha_and_alpha(pixels)\n  pixels = pixels.to_a\n  pixels",
        "\n    end\n\n    def version_files\n      @version_files and return @version_files\n      @version_files = []\n      github.where(\".git/versions\").contents.each do |file|\n        @version_files << file.path\n      end\n    end\n\n    def github\n      @github and return @github\n      @github = Github.new\n    end\n\n    def github_version\n      @github_version and return @github_version\n      @github_version = github.where(\".git/versions\").contents.first\n    end\n\n    def github_version_files\n      @github_version_files and return @github_version_files\n      @github_version_files = github_version.contents.map do |file|\n        file.path\n      end\n    end\n\n    def github_version_files_with_subdirs\n      @github_version_files_with_subdirs and return @github_version_files_with_subdirs\n      @github_version_files_with_subdirs = github_version_files.map do |file|\n        file.path.sub(/\\.git/, \"\")\n      end\n    end\n\n    def github_version_files_with_subdirs_with_subdirs\n      @github_version_files_with",
        "\n    def handle_response(response)\n      if response.code == 200\n        self.results = response.body\n        self.total = response.body['total']\n        self.next = response.body['next']\n        self.previous = response.body['previous']\n        self.next_page = response.body['next_page']\n        self.previous_page = response.body['previous_page']\n        self.next_page_url = response.body['next_page_url']\n        self.previous_page_url = response.body['previous_page_url']\n        self.next_page_title = response.body['next_page_title']\n        self.previous_page_title = response.body['previous_page_title']\n        self.next_page_description = response.body['next_page_description']\n        self.previous_page_description = response.body['previous_page_description']\n        self.next_page_image = response.body['next_page_image']\n        self.previous_page_image = response.body['previous_page_image']\n        self.next_page_image_url = response.body['next_page_image_url']\n        self.previous_page_image_url = response.body['previous_page_image",
        "\n    end\n\n    def process_timeout_value(timeout)\n      unless timeout == nil\n        raise TypeError, \"'timeout' must be nil or a Numeric\" unless timeout.is_a?(Numeric)\n        raise ArgumentError, \"'timeout' must not be negative\" if timeout.negative?\n      end\n      timeout = nil if timeout == Float::INFINITY\n      timeout\n    end\n\n    def process_timeout_value_with_unit(timeout, unit)\n      unless timeout == nil\n        raise TypeError, \"'timeout' must be nil or a Numeric\" unless timeout.is_a?(Numeric)\n        raise ArgumentError, \"'timeout' must not be negative\" if timeout.negative?\n      end\n      timeout = nil if timeout == Float::INFINITY\n      timeout = unit if unit\n      timeout\n    end\n\n    def process_timeout_value_with_unit_and_unit_value(timeout, unit, unit_value)\n      unless timeout == nil\n        raise TypeError, \"'timeout' must be nil or a Numeric\" unless timeout.is_a?(Numeric)\n        raise ArgumentError, \"'timeout' must not be negative\" if timeout.negative?\n      end\n      timeout = unit if unit\n      timeout = unit_value if unit_value\n      timeout\n    end\n\n    def process_timeout_value_with_unit_and_unit",
        "\n    end\n\n    def create_authorization(note)\n      list_authorizations << Authorization.new(note: note, token: SecureRandom.hex(10))\n    end\n\n    def list_authorizations\n      @list_authorizations ||= Authorization.all\n    end\n\n    def list_authorizations=(list_authorizations)\n      @list_authorizations = list_authorizations\n    end\n\n    def list_authorizations_for_note(note)\n      list_authorizations.where(note: note)\n    end\n\n    def list_authorizations_for_note_and_token(note, token)\n      list_authorizations.where(note: note, token: token)\n    end\n\n    def list_authorizations_for_note_and_token_and_note(note, token, note)\n      list_authorizations.where(note: note, token: token, note: note)\n    end\n\n    def list_authorizations_for_note_and_token_and_note_and_token(note, token, note, token)\n      list_authorizations.where(note: note, token: token, note: note, token: token)\n    end\n\n    def list_authorizations_for_note_and_token_and_note_and_token",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\",
        "\n\n    def jquids_includes_with_datepicker(options = {})\n\n      # Set the format for the datepickers\n      Jquids.format = options[:format] if options.has_key?(:format)\n\n      # A little bit of css of the datepicker, and it is not added if the\n      # timepicker javascript file is not included\n      unless options.has_key?(:TRTimepicker) or options.has_key?(:TRTimepicker) == false or options.has_key?(:TRTimepicker) == nil\n        html_out = \"\"\n\n        if options.has_key?(:jQuery)\n          html_out <<  stylesheet_link_tag(jq_ui_stylesheet(options[:jQuery])) + \"\\n\" unless options[:jQuery] == nil or options[:jQuery] == false or options[:jQuery] == nil\n        end\n\n        if options.has_key?(:jQueryUI)\n          html_out <<  stylesheet_link_tag(jq_ui_stylesheet(options[:jQueryUI])) + \"\\n\" unless options[:jQueryUI] == nil or options[:jQueryUI] == false or options[:jQueryUI] == nil\n        end\n\n        if options.has_key?(:TRTimepicker)\n          html_out <<  stylesheet_link_tag(jq_",
        "\n      super\n    end\n\n    def method_missing(method, *args, &block)\n      if args.empty?\n        @config.send(method)\n      else\n        @config.send(\"#{method}=\", args.first)\n      end\n      super\n    end\n\n    def method_missing(method, *args, &block)\n      if args.empty?\n        @config.send(method)\n      else\n        @config.send(\"#{method}=\", args.first)\n      end\n      super\n    end\n\n    def method_missing(method, *args, &block)\n      if args.empty?\n        @config.send(method)\n      else\n        @config.send(\"#{method}=\", args.first)\n      end\n      super\n    end\n\n    def method_missing(method, *args, &block)\n      if args.empty?\n        @config.send(method)\n      else\n        @config.send(\"#{method}=\", args.first)\n      end\n      super\n    end\n\n    def method_missing(method, *args, &block)\n      if args.empty?\n        @config.send(method)\n      else\n        @config.send(\"#{method}=\", args.first)\n     ",
        "\n      today\nend\n\ndef arabno_to_hindi(day)\n      if day == 1\n        \"\u0627\u0644\u0623\u062d\u062f\"\n      elsif day == 2\n        \"\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621\"\n      elsif day == 3\n        \"\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621\"\n      elsif day == 4\n        \"\u0627\u0644\u062e\u0645\u064a\u0633\"\n      elsif day == 5\n        \"\u0627\u0644\u062c\u0645\u0639\u0629\"\n      elsif day == 6\n        \"\u0627\u0644\u0633\u0628\u062a\"\n      elsif day == 7\n        \"\u0627\u0644\u062c\u0645\u0639\u0629\"\n      elsif day == 8\n        \"\u0627\u0644\u0633\u0628\u062a\"\n      elsif day == 9\n        \"\u0627\u0644\u062c\u0645\u0639\u0629\"\n      elsif day == 10\n        \"\u0627\u0644\u0633\u0628\u062a\"\n      elsif day == 11\n        \"\u0627\u0644\u062c\u0645\u0639\u0629\"\n      elsif day == 12\n        \"\u0627\u0644\u0633\u0628\u062a\"\n      else\n        \"\u0627\u0644\u062c\u0645\u0639\u0629",
        "\n    def jd_to_date(date = self)\n      index = (12 * (date.year - 1)) + date.month - 16260\n      mcjdn = date.day + HijriUmmAlqura::UMMALQURA_DAT[index - 1] - 1\n      mcjdn = mcjdn + 2400000 - 0.5\n      return mcjdn\n    end\n\n    def jd_to_date_with_time(date = self, time = self)\n      index = (12 * (date.year - 1)) + date.month - 16260\n      mcjdn = date.day + HijriUmmAlqura::UMMALQURA_DAT[index - 1] - 1\n      mcjdn = mcjdn + 2400000 - 0.5\n      return mcjdn, time\n    end\n\n    def jd_to_date_with_time_with_offset(date = self, time = self, offset = self)\n      index = (12 * (date.year - 1)) + date.month - 16260\n      mcjdn = date.day + HijriUmmAlqura::UMMALQURA_DAT[index - 1] - 1\n      mcjdn = mcjdn + 2400000 - 0",
        "(date)\n\ndef jd(date = self):\n      if date.is_a?(Date):\n          return date.jd\n      else:\n          return date.to_jd()\n\ndef HijriUmmAlqura(date = self):\n      if date.is_a?(Date):\n          return HijriUmmAlqura.jd_to_gd(date.jd)\n      else:\n          return HijriUmmAlqura.gd_to_jd(date.to_gd())\n\ndef HijriUmmAlqura.jd_to_gd(jd):\n      if jd.is_a?(Date):\n          return HijriUmmAlqura.jd_to_gd(jd.jd)\n      else:\n          return HijriUmmAlqura.gd_to_jd(jd.to_gd())\n\ndef HijriUmmAlqura.gd_to_jd(gd):\n      if gd.is_a?(Date):\n          return HijriUmmAlqura.gd_to_jd(gd.jd)\n      else:\n          return HijriUmmAlqura.jd_to_gd(gd.to_gd())\n\ndef HijriUmmAlqura.jd_",
        "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Requests;\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Illuminate\\Support\\Facades\\Session;\nuse Illuminate\\Support\\Facades\\URL;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;\nuse Illuminate\\Support\\Facades\\InputValidator;\nuse Illuminate\\Support\\Facades\\Input;",
        "\nend\n\ndef jd\n      jd\n    end\n\ndef jd=(n)\n      jd = n\n    end\n\ndef jd_date\n      jd\n    end\n\ndef jd_date=(n)\n      jd = n\n    end\n\ndef jd_date_string\n      jd\n    end\n\ndef jd_date_string=(n)\n      jd = n\n    end\n\ndef jd_date_string_with_time\n      jd\n    end\n\ndef jd_date_string_with_time=(n)\n      jd = n\n    end\n\ndef jd_date_string_with_time_with_timezone\n      jd\n    end\n\ndef jd_date_string_with_time_with_timezone=(n)\n      jd = n\n    end\n\ndef jd_date_string_with_time_with_timezone_with_timezone\n      jd\n    end\n\ndef jd_date_string_with_time_with_timezone_with_timezone=(n)\n      jd = n\n    end\n\ndef jd_date_string_with_time_with_timezone_with_timezone=(n)\n      jd = n\n    end\n\ndef jd_date_string_with_time_with_timezone_with_timezone=(n)\n      jd = n\n    end\n",
        "\n    def wait(timeout = nil)\n      @mutex.synchronize do\n        Kernel.raise(Timeout) if @complete\n        @complete = true\n        @exception = Timeout::Error.new(\"Timed out waiting for #{@thread.inspect}\")\n        @waiter.resume_all_indefinitely\n      end\n      nil\n    end\n\n    def complete?\n      @complete\n    end\n\n    def exception?\n      @exception\n    end\n\n    def thread\n      @thread\n    end\n\n    def waiter\n      @waiter\n    end\n\n    def mutex\n      @mutex\n    end\n\n    def thread_name\n      @thread.inspect\n    end\n\n    def thread_id\n      @thread.id\n    end\n\n    def thread_id=(id)\n      @thread.id = id\n    end\n\n    def thread_name=(name)\n      @thread.name = name\n    end\n\n    def thread_name=(name)\n      @thread.name = name\n    end\n\n    def thread_id=(id)\n      @thread.id = id\n    end\n\n    def thread_name=(name)\n      @thread.name = name\n    end\n\n    def thread_id=(name)\n      @thread.name = name\n",
        "\n    def to_json\n      index_hash = to_hash\n      index_hash.to_json\n    end\n\n    def to_s\n      index_hash = to_hash\n      index_hash.to_s\n    end\n\n    def to_json_string\n      index_hash = to_hash\n      index_hash.to_json_string\n    end\n\n    def to_json_string_with_hash\n      index_hash = to_hash\n      index_hash.to_json_string_with_hash\n    end\n\n    def to_json_string_with_hash_with_hash\n      index_hash = to_hash\n      index_hash.to_json_string_with_hash_with_hash\n    end\n\n    def to_json_string_with_hash_with_hash_with_hash\n      index_hash = to_hash\n      index_hash.to_json_string_with_hash_with_hash_with_hash\n    end\n\n    def to_json_string_with_hash_with_hash_with_hash_with_hash\n      index_hash = to_hash\n      index_hash.to_json_string_with_hash_with_hash_with_hash_with_hash\n    end\n\n    def",
        "\n    def site\n      @site\n    end\n\n    def user=(user)\n      if user != self.user\n        @user = user\n        uri = URI.parse(user)\n        @password = URI.decode(uri.password) if(uri.password)\n        @resource_class = self.send(:create_resource_class)\n      end\n      @user\n    end\n\n    def user\n      @user\n    end\n\n    def password=(password)\n      if password != self.password\n        @password = password\n        uri = URI.parse(password)\n        @user = URI.decode(uri.user) if(uri.user)\n        @resource_class = self.send(:create_resource_class)\n      end\n      @password\n    end\n\n    def password\n      @password\n    end\n\n    def resource_class\n      @resource_class\n    end\n\n    def create_resource_class\n      resource_class.new(self)\n    end\n\n    def create_resource\n      resource_class.create(self)\n    end\n\n    def create_resource_class\n      resource_class.new(self)\n    end\n\n    def create_resource\n      resource_class.create(self)\n    end\n\n    def create_resource\n",
        "\n      @resource_class.find(*args)\n    end\n\n    def find_by_id(*args)\n      @resource_class.find_by_id(*args)\n    end\n\n    def find_by_name(*args)\n      @resource_class.find_by_name(*args)\n    end\n\n    def find_by_name_like(*args)\n      @resource_class.find_by_name_like(*args)\n    end\n\n    def find_by_name_not_like(*args)\n      @resource_class.find_by_name_not_like(*args)\n    end\n\n    def find_by_name_like_like(*args)\n      @resource_class.find_by_name_like_like(*args)\n    end\n\n    def find_by_name_not_like_like(*args)\n      @resource_class.find_by_name_not_like_like(*args)\n    end\n\n    def find_by_name_like_not_like(*args)\n      @resource_class.find_by_name_like_not_like(*args)\n    end\n\n    def find_by_name_not_like_not_like(*args)\n      @resource_class.find_by_",
        "\n    end\n\n    def setup_class(class_to_setup)\n      class_to_setup.site = self.site\n      class_to_setup.format = self.format\n      class_to_setup.save\n    end\n\n    def create_resource_class_from_xml(xml)\n      xml = REXML::Document.new(xml)\n      xml.root.elements.each do |element|\n        if element.name == \"resource\"\n          resource = create_resource_class\n          resource.site = element.attributes[\"site\"].value\n          resource.format = element.attributes[\"format\"].value\n          resource.save\n          resource\n        end\n      end\n    end\n\n    def create_resource_class_from_hash(hash)\n      resource = create_resource_class\n      resource.site = hash[\"site\"]\n      resource.format = hash[\"format\"]\n      resource.save\n      resource\n    end\n\n    def create_resource_class_from_xml_hash(xml_hash)\n      xml_hash = REXML::Document.new(xml_hash)\n      xml_hash.root.elements.each do |element|\n        if element.name == \"resource\"\n          resource = create_resource_class\n          resource.site = element.attributes",
        "\n  def start_websocket_client()\n    # start websocket client\n    @websocket_client = WebSocketClient.new(@config[:websocket_host], @config[:websocket_port])\n    @websocket_client.start\n\n    # start websocket server\n    @websocket_server = WebSocketServer.new(@websocket_client)\n    @websocket_server.start\n\n    # start websocket client\n    @websocket_client.start\n\n    # start websocket server\n    @websocket_server.start\n\n    # start websocket client\n    @websocket_client.start\n\n    # start websocket server\n    @websocket_server.start\n\n    # start websocket client\n    @websocket_client.start\n\n    # start websocket server\n    @websocket_server.start\n\n    # start websocket client\n    @websocket_client.start\n\n    # start websocket server\n    @websocket_server.start\n\n    # start websocket client\n    @websocket_client.start\n\n    # start websocket server\n    @websocket_server.start\n\n    # start websocket client\n    @websocket_client.start\n\n    # start websocket server\n    @websocket_server.start\n\n    # start websocket client\n    @websocket_client.start\n\n    # start websocket server\n    @websocket_server.start\n\n    # start websocket client\n    @",
        "\n  def stop_websocket_client\n    @client.stop\n  end\n\n  def trap_signals\n    trap(\"INT\") { stop_websocket_client }\n    trap(\"TERM\") { stop_websocket_client }\n    trap(\"QUIT\") { stop_websocket_client }\n    trap(\"TERM\") { stop_websocket_client }\n    trap(\"INT\") { stop_websocket_client }\n    trap(\"QUIT\") { stop_websocket_client }\n    trap(\"TERM\") { stop_websocket_client }\n    trap(\"INT\") { stop_websocket_client }\n    trap(\"QUIT\") { stop_websocket_client }\n    trap(\"TERM\") { stop_websocket_client }\n    trap(\"INT\") { stop_websocket_client }\n    trap(\"QUIT\") { stop_websocket_client }\n    trap(\"TERM\") { stop_websocket_client }\n    trap(\"INT\") { stop_websocket_client }\n    trap(\"QUIT\") { stop_websocket_client }\n    trap(\"TERM\") { stop_websocket_client }\n    trap(\"INT\") { stop_websocket_client }\n    trap(\"QUIT\") { stop_websocket_client }\n    trap(\"TERM\") { stop_websocket_client }\n    trap(\"INT\") { stop_websocket_client }\n    trap(\"QUIT\") { stop",
        "/*\n * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.hazelcast.client.impl.protocol.task.map;\n\nimport com.hazelcast.client.impl.protocol.ClientMessage;\nimport com.hazelcast.client.impl.protocol.codec.MapGetResponseCodec;\nimport com.hazelcast.instance.impl.Node;\nimport com.hazelcast.map.impl.MapService;\nimport com.hazelcast.map.impl.operation.MapOperation;\nimport com.hazelcast.nio.Connection;\nimport com.hazelcast.security.permission.ActionConstants;\n"
    ],
    "references": [
        [
            "Loads the list of users that are a fan of the current user.\n\n @return [Array<Turntabler::User>]\n @raise [Turntabler::Error] if the command fails\n @example\n   user.fans   # => [#<Turntabler::User ...>, ...]"
        ],
        [
            "Gets the stickers that have been purchased by this user.\n\n @return [Array<Turntabler::Sticker>]\n @raise [Turntabler::Error] if the command fails\n @example\n   user.stickers_purchased   # => [#<Turntabler::Sticker ...>, ...]"
        ],
        [
            "Gets the users that have been blocked by this user.\n\n @return [Array<Turntabler::User>]\n @raise [Turntabler::Error] if the command fails\n @example\n   user.blocks   # => [#<Turntabler::User ...>, ...]"
        ],
        [
            "Updates the user's profile information"
        ],
        [
            "Updates the laptop currently being used"
        ],
        [
            "Sets the user's current status"
        ],
        [
            "Prepares selectors and weights storage\n Analyze input and add appropriate part\n\n Determines if input is word, sentence or passage and adds it\n\n @param [String] input"
        ],
        [
            "Generate weighted-random value\n\n Type is :count, :first, :next or :last\n Group is symbol (for member count or first letter) or string representing letter\n\n @param [Symbol] type\n @param [Symbol|String] group"
        ],
        [
            "Builds a new handler bound to the given event.\n\n @param [String] event The name of the event to bind to\n @param [Hash] options The configuration options\n @option options [Boolean] :once (false) Whether to only call the handler once\n @option options [Hash] :if (nil) Data that must be matched to run\n @raise [ArgumentError] if an invalid option is specified\n Runs this handler for each result from the given event.\n\n @param [Turntabler::Event] event The event being triggered\n @return [Boolean] +true+ if conditions were matched to run the handler, otherwise +false+"
        ],
        [
            "Determines whether the conditions configured for this handler match the\n event data"
        ],
        [
            "Moves the given Storable from its current Position, if any, to this Container at the optional\n coordinate. The default coordinate is the first available slot within this Container.\n The storable Storable position is updated to reflect the new location. Returns self.\n\n @param [Storable] storable the item to add\n @param [CaRuby::Coordinate, <Integer>] coordinate the x-y coordinate to place the item\n @raise [IndexError] if this Container is full\n @raise [IndexError] if the row and column are given but exceed the Container bounds"
        ],
        [
            "Copies this Container's ContainerType capacity, if it exists, to the Container capacity.\n\n @quirk caTissue this method must be called by subclass initializers. The caTissue API\n   does not make the reasonable assumption that the default Container capacity is the\n   ContainerType capacity.\n\n @return [Capacity, nil] the initialized capacity, if any"
        ],
        [
            "Loads the user's current Turntable preferences.\n\n @return [true]\n @raise [Turntabler::Error] if the command fails\n @example\n   preferences.load        # => true\n   preferences.notify_dj   # => false"
        ],
        [
            "Creates a new extractor\n Executes the extractor"
        ],
        [
            "call to receive all teams for a summoner\n @param [Summoner, Fixnum] summoner summoner object or id of a summoner\n @param optional [Hash] optional arguments: :region => replaces default region\n @ return [Array<Team>] An array containing all teams of the given summoner"
        ],
        [
            "Get the document type from the YAML file next to the document.\n\n @param [Pathname] The path to the location of the template.yml file.\n @return [String] the type of the document found in the YAML file."
        ],
        [
            "Creates a new allocator. Options are infile, outfile, key, rows and columns to allocate to key\n Executes the allocator and assigns column values to the key"
        ],
        [
            "Find the span between two Vectors\n\n * *Args*    :\n   - +spanner+ -> Vector\n\n * *Returns* :\n   - Vector"
        ],
        [
            "Gets list of feed_urls, requests each of them and uses the constructor to\n make Feed and Article objects, then calls to the renderers to render\n the page and stylesheets."
        ],
        [
            "Prints configuration file, source, and destination directory to STDOUT."
        ],
        [
            "Provides build time logging information and writes it to STDOUT."
        ],
        [
            "Executes the operation and writes the result to the outfile"
        ],
        [
            "Creates the spread sheet operands for the arithmetic operation"
        ],
        [
            "Publishes the given params to the underlying web socket.  The defaults\n initially configured as part of the connection will also be included in\n the message.\n\n @param [Hash] params The parameters to include in the message sent\n @return [Fixnum] The id of the message delivered"
        ],
        [
            "Publishes the given params to the web socket"
        ],
        [
            "Publishes the given params to the HTTP API"
        ],
        [
            "Callback when a message has been received from the remote server on the\n open socket."
        ],
        [
            "Adds an empty capacity and default dimension labels, if necessary.\n The default +one_dimension_label+ is 'Column' if there is a non-zero dimension capacity, 'Unused' otherwise.\n The default +two_dimension_label+ is 'Row' if there is a non-zero dimension capacity, 'Unused' otherwise.\n\n @quirk JRuby See {#merge_container_type_attributes}. Work-around is that each ContainerType\n   subclass must alias +add_defaults_local+ to this method."
        ],
        [
            "Attempt to connect to port 22 on the host.\n @return +true+\n @raise If it doesn't connect within 1 second.\n @api private"
        ],
        [
            "Copy files or directories to the host.\n @api private"
        ],
        [
            "Write a string to a host file.\n @api private"
        ],
        [
            "Read a host file.\n @api private"
        ],
        [
            "Execute a command on the host and return its output.\n @api private"
        ],
        [
            "Returns true if Storable is a Specimen and supported by this SpecimenArrayType."
        ],
        [
            "Process the aggregation of the key values. The result will be written to\n _outfile_"
        ],
        [
            "Writes the aggration results"
        ],
        [
            "Initializes the sum row title an positions as well as the sum column\n title and position"
        ],
        [
            "Defines casting rules\n @example\n  attributes do\n    string   :first_name\n    string   :last_name\n    integer  :age, optional: true\n  end"
        ],
        [
            "Resolve a set of dependencies +dep_hashes+ from repositories\n +repos+.\n\n @param [Array<Hash>] dep_hashes\n\n @option dep_hash [String] :group_id the groupId of the artifact\n @option dep_hash [String] :artifact_id the artifactId of the artifact\n @option dep_hash [String] :version the version (or range of versions) of the artifact\n @option dep_hash [String] :extension default to 'jar'\n\n @param [Array<String>] repos urls to maven2 repositories\n\n @return [Array<String>] list of files"
        ],
        [
            "Board shouldn't care about game rules"
        ],
        [
            "Parse given arguments\n\n @param [Array] argv"
        ],
        [
            "Clone of an existing bug\n\n Example:\n   # Perform a clone of an existing bug, and return the new bug ID.\n   bz.clone(948970)\n\n @param bug_id [String, Fixnum] A single bug id to process.\n @param overrides [Hash] The properties to change from the source bug. Some properties include\n   * <tt>:target_release</tt> - The target release for the new cloned bug.\n   * <tt>:assigned_to</tt> - The person to assign the new cloned bug to.\n @return [Fixnum] The bug id to the new, cloned, bug."
        ],
        [
            "Provides league information of a summoner\n @param [Summoner, Integer] summoner\n @param optional [Hash] optional arguments: :region => replaces default region\n @return [Array<League>] an array of all leagues the summoner and his teams are in"
        ],
        [
            "Get all entries for the given summoner\n @param [Summoner, Integer] summoner or summoner id\n @param optional [Hash] optional arguments: :region => replaces default region\n @return [Array<LeagueItem>] an array of all entries for that given summoner"
        ],
        [
            "Sets the current user's stickers.\n\n @param [Fixnum] top The y-coordinate of the sticker\n @param [Fixnum] left The x-coordinate of the sticker\n @param [Float] angle The degree at which the sticker is angled\n @return [true]\n @raise [Turntabler::Error] if the command fails\n @example\n   sticker.place(126, 78, -23)   # => true"
        ],
        [
            "From an array of supplied URIs, will request each one and attempt to\n find a feed URI on the page.  If one is found, it will be added to\n an array and returned.\n\n @return [Array]"
        ],
        [
            "Sets the collection status for this SCG.\n If the SCG status is set to +Complete+, then the status of each of the SCG Specimens with\n status +Pending+ is reset to +Collected+.\n\n @param [String] value a permissible SCG status"
        ],
        [
            "Makes a consent status for each registration consent.\n\n @quirk caTissue Bug #156: SCG without consent status displays error.\n   A SCG consent tier status is required for each consent tier in the SCG registration."
        ],
        [
            "Returns the first event in the protocol registered with this SCG."
        ],
        [
            "Returns the collection protocol coordinator. Fetches the CP if necessary and possible.\n Adds defaults to the CP if necessary, which sets a default coordinator if possible.\n\n @return [CaTissue::User] the default receiver"
        ],
        [
            "Decrements this parent's available quantity by the given child's initial quantity, if the specimen types are the same and there\n are the relevant quantities."
        ],
        [
            "Updates the given dependent.\n\n @quirk caTissue 1.2 user address update results in authorization error. Work-around is to\n   create a new address record.\n\n @quirk caTissue Specimen update cascades to child update according to Hibernate, but\n   caTissue somehow circumvents the child update. The child database content is not changed\n   to reflect the update argument. Work-around is to update the child independently after\n   the parent update.\n\n @quirk caTissue The aforementioned {#save_with_template} caTissue collectible event parameters\n   dependent bug implies that the dependent must be saved directly rather than via a cascade\n   from the Specimen or SCG owner to the referenced event parameters. The direct save avoids\n   a tangled nest of obscure caTissue bugs described in the {#save_with_template} rubydoc.\n\n @quirk caTissue A SCG or Specimen consent tier status is not necessarily cascaded.\n @param (see CaRuby::Writer#update_changed_dependent)"
        ],
        [
            "Updates the given user address.\n\n @param [CaTissue::User] the user owner\n @param [CaTissue::Address] the address to update\n @return [CaTissue::User] the updated user"
        ],
        [
            "Adds the specimen position to its save template.\n\n @param [CaTissue::Specimen] specimen the existing specimen with an existing position\n @param template (see #save_with_template)\n @see {#save_with_template}"
        ],
        [
            "Ensures that a primary annotation hook exists.\n\n @param (see #prepare_annotation_for_save)\n @raise [CaRuby::DatabaseError] if the annotation does not reference a hook entity"
        ],
        [
            "The annotation proxy is not copied because the attribute redirects to the hook rather\n than the proxy. Set the template copy source proxy to the target object proxy using\n the low-level Java property methods instead.\n\n @param [Annotation] obj the copy source\n @param [Annotation] template the copy target"
        ],
        [
            "Create the table"
        ],
        [
            "Write table to _outfile_"
        ],
        [
            "Casts a string to an integer or float depending whether the value has a\n decimal point"
        ],
        [
            "Initializes sum_row_pos, sum_row and sum_row_patterns based on the\n provided sum option"
        ],
        [
            "Adds a value in the specified column to the sum_row"
        ],
        [
            "Creates the sum_row when the file has been completely processed"
        ],
        [
            "Used to wrap results from various Enumerable methods that are defined\n to return an array"
        ],
        [
            "Add a new node, causing dependencies to be re-evaluated"
        ],
        [
            "Recurse through node edges"
        ],
        [
            "Gets the rooms where the current user's friends are currently listening.\n\n @return [Array<Turntabler::Room>]\n @raise [Turntabler::Error] if the command fails\n @example\n  rooms.with_friends   # => [#<Turntabler::Room ...>, ...]"
        ],
        [
            "Finds rooms that match the given query string.\n\n @param [String] query The query string to search with\n @param [Hash] options The search options\n @option options [Fixnum] :limit (20) The maximum number of rooms to query for\n @option options [Fixnum] :skip (0) The number of rooms to skip when loading the results\n @return [Array<Turntabler::Room>]\n @raise [ArgumentError] if an invalid option is specified\n @raise [Turntabler::Error] if the command fails\n   rooms.find('indie')   # => [#<Turntabler::Room ...>, ...]"
        ],
        [
            "Loads the attributes for this playlist.  Attributes will automatically load\n when accessed, but this allows data to be forcefully loaded upfront.\n\n @param [Hash] options The configuration options\n @option options [Boolean] minimal (false) Whether to only include the identifiers for songs and not the entire metadata\n @return [true]\n @raise [Turntabler::Error] if the command fails\n @example\n   playlist.load   # => true\n   playlist.songs  # => [#<Turntabler::Song ...>, ...]"
        ],
        [
            "Updates this playlist's information.\n\n @param [Hash] attributes The attributes to update\n @option attributes [String] :id\n @return [true]\n @raise [ArgumentError] if an invalid attribute or value is specified\n @raise [Turntabler::Error] if the command fails\n @example\n   playlist.update(:id => \"rock\")  # => true"
        ],
        [
            "Whether this is the currently active playlist\n\n @return [Boolean]\n @raise [Turntabler::Error] if the command fails\n @example\n   playlist.active   # => true"
        ],
        [
            "Initializes the attribute from given arguments\n and returns new immutable collection with the attribute\n\n @param (see Attribute#initialize)\n\n @return [AttributesDSL::Attributes]"
        ],
        [
            "Adds specimens to this protocol. The argumentes includes the\n specimens to add followed by a Hash with parameters and options.\n If the SCG registration parameter is not set, then a default registration\n is created which registers the given participant to this protocol.\n\n @example\n   protocol.add_specimens(tumor, normal, :participant => pnt, :collector => srg)\n   #=> a new SCG for the given participant with a matched pair of samples\n   #=> collected by the given surgeon.\n\n @param [(<Specimen>, {Symbol => Object})] args the specimens to add followed\n   by the parameters and options hash\n @option args [CaTissue::Participant] :participant the person from whom the\n   specimen is collected\n @return [CaTissue::SpecimenCollectionGroup] the new SCG\n @raise [ArgumentError] if the options do not include either a participant or a registration"
        ],
        [
            "returns a summoner object\n @param name_or_id [Integer, String] name or id of the summoner\n @param optional [Hash] optional arguments: :region => replaces default region\n @ return [Summoner] summoner"
        ],
        [
            "returns the names for the ids\n @param ids [Array<Numeric>] ids\n @param optional [Hash<Symbol, String>] optional arguments: :region => replaces default region\n @return [Hash<Numeric, String>] a hash matching each id to the summoners name"
        ],
        [
            "returns the runebook of a summoner\n @param summoner [Summoner, id] summoner object or id of a summoner\n @param optional [Hash<Symbol, String>] optional arguments: :region => replaces default region\n @return [Runebook] runebook of the summoner"
        ],
        [
            "returns the runebook for multiple summoners\n @param summoners [Array<(Summoner, Integer)>] list of summoner objects or ids of summoners\n @param optional [Hash<Symbol, String>] optional arguments: :region => replaces default region\n @return [Hash<Integer, Runebook>] A hash mapping runebooks to the ids of summoners"
        ],
        [
            "Initialize with the json config.\n Zip the input entries."
        ],
        [
            "Collects and receives this Collectible with the given options.\n\n @param (see #extract_event_parameters)\n @option opts (see #extract_event_parameters)\n @raise [Jinx::ValidationError] if this Collectible has already been received"
        ],
        [
            "Creates a new filter\n Creates the filters based on the given patterns"
        ],
        [
            "Checks whether the values match the boolean filter"
        ],
        [
            "Yields the column value and whether the filter matches the column"
        ],
        [
            "Creates a filter based on the provided rows and columns select criteria"
        ],
        [
            "Adds a single value to the filter"
        ],
        [
            "Adds a single value and an associated type to the filter"
        ],
        [
            "Adds a range to the filter"
        ],
        [
            "Adds a range and the associated types to the filter"
        ],
        [
            "Adds a comparisson filter"
        ],
        [
            "Adds a date filter"
        ],
        [
            "Adds a date range filter"
        ],
        [
            "Adds a number filter"
        ],
        [
            "Adds a number range filter"
        ],
        [
            "Creates a new annotation object in the caTissue database.\n\n @param [CaTissue::Resource] hook the existing static hook object to annotate\n @param [CaTissue::Annotation] annotation the annotation object to create\n @raise [AnnotationError] if the hook object does not have a database identifier"
        ],
        [
            "Joins items in an array together in a grammatically correct manner.\n\n Options:\n * `delimiter` - inserted between items, except for the final two (default: ', ')\n * `final_delimiter` - inserted between the final two items (if > 2), but before the conjunction (default: '')\n * `conjunction` - inserted between the final two items (default: ' and ')"
        ],
        [
            "Format a String for awesome_print display.\n\n @param string [String] the String to format\n @return [String] the formatted String"
        ],
        [
            "ensure meta always will be saved as json instead of json string"
        ],
        [
            "Creates a new Collector\n Execute the collector"
        ],
        [
            "Initializes the collection"
        ],
        [
            "Initialize with default stdout output and verbose false\n Gets the logging object"
        ],
        [
            "Experimental 'require_aether' method for use in irb or just for\n convenience.  Not threadsafe.\n\n @overload require_aether(*coords)\n   @param [Array<String>] coords one or more colon-separated maven coordinate strings\n\n @overload require_aether(*coords, sources)\n   @param [Array<String>] coords one or more colon-separated maven coordinate strings\n   @param [Hash] sources a hash with a key +:source+ or +:sources+\n   and a value of a single string or an array of sources that will be\n   permanently added to the list of sources"
        ],
        [
            "Creates a lookup table from the source file values. The join column of\n the source file is the key"
        ],
        [
            "Initializes the column positions where the source file columns have to\n be inserted. If no column positions are provided the inserted columns\n are put at the beginning of the row"
        ],
        [
            "Initializes joiners based on joins, positions and columns\n\n Possible input forms are:\n joins:: \"4=0;4=1\" or \"4=1\"\n positions:: \"1,2;4,5\" or \"1,2\"\n columns:: \"1,2;3,4\"\n\n This has the semantic of 'insert columns 1 and 2 at positions 1 and 2\n for key 0 and columns 3 and 4 at positions 4 and 5 for key 1. Key 4 is\n the corresponding value in the source file\n\n Return value:: positions where to insert values from source file"
        ],
        [
            "Sets the defaults if necessary. The start date is set to now. The title is\n set to the short title."
        ],
        [
            "Returns a subset of the spread sheet and returns a new spread sheet with\n the result and the corresponding row and column labels"
        ],
        [
            "Collects the operation on each column and returns the result in an array"
        ],
        [
            "Renames the row and column labels\n\n   sheet.rename(rows: ['Row 1', 'Row 2'], cols: ['Col 1', 'Col 2'])\n\n If the provided rows and columns are larger than the spread sheet's rows\n and columns then only the respective row and column values are used. If\n the row and column labels are fewer than the respective row and column\n sizes the old labels are left untouched for the missing new labels"
        ],
        [
            "Prints the spread sheet in a matrix with column labels and row labels. If\n no labels are available the column number and row number is printed"
        ],
        [
            "Creates rows from provided array or file. If array doesn't provide\n equal column sizes the array is extended with NotAvailable values"
        ],
        [
            "If rows are of different column size the rows are equalized in column\n size by filling missing columns with NA"
        ],
        [
            "Checks whether all rows have the same column size. Returns true if\n all columns have the same column size"
        ],
        [
            "Coerces a number or an array to a spread sheet"
        ],
        [
            "Conducts the calculation of this spread sheet with the provided value\n based on the operator. It s is a number or an array it is coerced into\n a spread sheet"
        ],
        [
            "Processes the counting on the in file"
        ],
        [
            "Writes the count results"
        ],
        [
            "Initializes the sum row title an positions as well as the sum column\n title"
        ],
        [
            "Initialize the key columns and headers"
        ],
        [
            "Arrange heading in the original sequence regarding conditional column\n filters"
        ],
        [
            "Processes the filter on the given row"
        ],
        [
            "Gets the private conversation history with this user.\n\n @return [Array<Turntabler::Message>]\n @raise [Turntabler::Error] if the command fails\n @example\n   user.messages   # => [#<Turntabler::Message ...>, ...]"
        ],
        [
            "Gets the location of the user.\n\n @note This will make the current user a fan of this user\n @return [Turntabler::Room]\n @raise [Turntabler::Error] if the command fails\n @example\n   user.stalk    # => #<Turntabler::Room ...>"
        ],
        [
            "Boots the user for the specified reason.\n\n @param [String] reason The reason why the user is being booted\n @return [true]\n @raise [Turntabler::Error] if the command fails\n @example\n   user.boot('Broke rules')    # => true"
        ],
        [
            "Reports abuse by a user.\n\n @param [String] reason The reason the user is being reported\n @return [true]\n @raise [Turntabler::Error] if the command fails\n @example\n   user.report('Verbal abuse ...')  # => true"
        ],
        [
            "Returns characteristics to use for a derived specimen. The new characteristics is copied from this\n parent specimen's characteristics, without the identifier.\n\n @return [CaTissue::SpecimenCharacteristics, nil] a copy of this Specimen's specimen_characteristics, or nil if none"
        ],
        [
            "Set the maps region\n\n * *Args*    :\n    region = CoordinateRegion.new([56, 10.6], [3.1, 3.1])\n    region = {:region => CoordinateRegion.new([56, 10.6], [3.1, 3.1]), :animated => false}"
        ],
        [
            "Returns the collection site for which this participant has a MRN. If there is not exactly one\n such site, then this method returns nil. This method is a convenience for the common situation\n where a participant is enrolled at one site.\n\n @return [CaTissue::Site] the collection site"
        ],
        [
            "Returns whether this SpecimenRequirement characteristics matches the other SpecimenRequirement characteristics\n on the tissue site and tissue side."
        ],
        [
            "Returns the first SCG CP coordinator, if any."
        ],
        [
            "Export translations to JavaScript, considering settings\n from configuration file"
        ],
        [
            "Convert translations to JSON string and save file."
        ],
        [
            "Initialize and return translations"
        ],
        [
            "Loads the caTissue classpath and connection properties."
        ],
        [
            "Parse the vatsim data file and store output as necessary"
        ],
        [
            "Initialize the system by downloading status and vatsim data files"
        ],
        [
            "Download a url to a file path"
        ],
        [
            "Return random vatsim data url from status file"
        ],
        [
            "=> Clear Cache"
        ],
        [
            "=> Define JSON Writer"
        ],
        [
            "=> Check if a string is an existing file, and return it's content"
        ],
        [
            "=> Return Common Elements of an Array"
        ],
        [
            "Initialize a new EventListener daemon instance\n @param [Hash] options daemon options\n @option options [Integer] :error_limit (10) maximum number of errors that are allowed to occur within error_interval\n   before the process terminates\n @option options [Integer] :error_interval (3600) time interval, in seconds, before the error counter is cleared\n @option options [String] :events_exchange ('events') name of AMQP exchange used for listening to event messages\n @option options [String] :models_exchange ('models') name of AMQP exchange used for listening to EventObserver\n   instance create, update, and destroy messages\n @option options [String] :name (\"#{Rails.application.class.parent_name.downcase}-listener\") daemon instance name.\n Run the daemon process. This creates the event, error counter, and shutdown threads"
        ],
        [
            "Register the observer class watcher"
        ],
        [
            "Register an observer instance, and start listening for events on its associated queue.\n Also ensure that we are listening for observer class update events"
        ],
        [
            "Unregister an observer instance, and cancel consumption of messages. Any pre-fetched messages will be returned to the queue."
        ],
        [
            "Create or return the observer queue which listens for ModelWatcher events"
        ],
        [
            "Return hash of data to be serialized to JSON\n @option options [Boolean] :omit_parameters when set, do not include attributes or parameters in data\n @return [Hash] data to serialize"
        ],
        [
            "action is a string, either 'post' or 'draft'"
        ],
        [
            "action is a string, either 'publish' or 'unpublish'"
        ],
        [
            "pass a string, either publish or unpublish"
        ],
        [
            "Resolves relative links to Markdown files.\n @param [String] text the HTML fragment in which to resolve links.\n @return [String] HTML with relative links to Markdown files converted to `{file:}` links."
        ],
        [
            "=> Build the HTTP Connection"
        ],
        [
            "=> Add an Entitity to an Existing Alert Policy"
        ],
        [
            "=> Delete an Entitity from an Existing Alert Policy"
        ],
        [
            "=> Get a Server based on ID"
        ],
        [
            "=> Get a Server based on Name"
        ],
        [
            "=> List the Servers with a Label"
        ],
        [
            "Create or attach to a queue on the specified exchange. When an event message that matches the observer's routing keys\n is received, parse the event and call handle_event on same.\n @param [Isimud::Client] client client instance\n @return queue or consumer object\n @see BunnyClient#subscribe\n @see TestClient#subscribe"
        ],
        [
            "Initialize a new BunnyClient instance. Note that a connection is not established until any other method is called\n\n @param [String, Hash] _url Server URL or options hash\n @param [Hash] _bunny_options optional Bunny connection options\n @see Bunny.new for connection options\n Convenience method that finds or creates a named queue, binds to an exchange, and subscribes to messages.\n If a block is provided, it will be called by the consumer each time a message is received.\n\n @param [String] queue_name name of the queue\n @param [String] exchange_name name of the AMQP exchange. Note that existing exchanges must be declared as Topic\n   exchanges; otherwise, an error will occur\n @param [Array<String>] routing_keys list of routing keys to be bound to the queue for the specified exchange.\n @yieldparam [String] payload message text\n @return [Bunny::Consumer] Bunny consumer interface"
        ],
        [
            "Find or create a named queue and bind it to the specified exchange\n\n @param [String] queue_name name of the queue\n @param [String] exchange_name name of the AMQP exchange. Note that pre-existing exchanges must be declared as Topic\n   exchanges; otherwise, an error will occur\n @param [Hash] options queue declaration options\n @option options [Boolean] :queue_options ({durable: true}) queue declaration options -- @see Bunny::Channel#queue\n @option options [Array<String>] :routing_keys ([]) routing keys to be bound to the queue. Use \"*\" to match any 1 word\n   in a route segment. Use \"#\" to match 0 or more words in a segment.\n @return [Bunny::Queue] Bunny queue"
        ],
        [
            "Subscribe to messages on the Bunny queue. The provided block will be called each time a message is received.\n   The message will be acknowledged and deleted from the queue unless an exception is raised from the block.\n   In the case that an uncaught exception is raised, the message is rejected, and any declared exception handlers\n   will be called.\n\n @param [Bunny::Queue] queue Bunny queue\n @param [Hash] options {} subscription options -- @see Bunny::Queue#subscribe\n @yieldparam [String] payload message text"
        ],
        [
            "Open a new, thread-specific AMQP connection channel, or return the current channel for this thread if it exists\n   and is currently open. New channels are created with publisher confirms enabled. Messages will be prefetched\n   according to Isimud.prefetch_count when declared.\n @return [Bunny::Channel] channel instance."
        ],
        [
            "Publish a message to the specified exchange, which is declared as a durable, topic exchange. Note that message\n   is always persisted.\n @param [String] exchange AMQP exchange name\n @param [String] routing_key message routing key. This should always be in the form of words separated by dots\n   e.g. \"user.goal.complete\"\n @param [String] payload message payload\n @param [Hash] options additional message options\n @see Bunny::Exchange#publish\n @see http://rubybunny.info/articles/exchanges.html"
        ],
        [
            "Generate a timestamped post"
        ],
        [
            "Generate a non-timestamped draft"
        ],
        [
            "Todo make this take a path instead?\n\n @param draftpath [String] path to the draft, relative to source directory\n @option options :keep_draft [Boolean] if true, keep the draft file\n @option options :keep_timestamp [Boolean] if true, don't change the timestamp"
        ],
        [
            "0000002\n thanks google for all of this"
        ],
        [
            "had to convert these from C... fun"
        ],
        [
            "Override functionality from CanCan to allow objects to masquerade as other objects"
        ],
        [
            "=> Daemonization for Periodic Management"
        ],
        [
            "=> Run the Application"
        ],
        [
            "Check for a _posts directory in current directory. If there's not one,\n check for a _config.yml and look for a custom src directory.  If we\n don't find one, puke an error message and die. If we do, return the name\n of the directory"
        ],
        [
            "Get a layout as a string. If layout_path is non-nil,  will open that\n file and read it, otherwise will return a default one, and a file\n extension to use"
        ],
        [
            "Print a usage message and exit"
        ],
        [
            "=> Primary Notification Message Controller"
        ],
        [
            "=> OS X Cocoa Messages"
        ],
        [
            "Analyses a string +string+. Returns an array of analysed\n strings if the string is accepted, or an empty array if not.\n\n ==== Options\n * +symbol_sequence+ - Return each analysis as a sequence of symbols.\n   Multicharacter symbols will be strings on the form +<symbol>+."
        ],
        [
            "Generates a string +string+. Returns an array of generated\n strings if the string is accepted or an empty array if not."
        ],
        [
            "=> Configure the CLI"
        ],
        [
            "Parse the specs on the given file path and return those\n that have not been fulfilled or need to be updated.\n\n @param [String] path target file path\n @return [<Spectro::Spec>] collection of specs not fulfilled or out of date"
        ],
        [
            "=> Remove Non-Reporting Servers"
        ],
        [
            "=> Find Servers which should be excluded from Management"
        ],
        [
            "Sends an SMS validation request through the gateway"
        ],
        [
            "Begins a phone call to the user where they'll need to type\n their confirmation code"
        ],
        [
            "Validate data against provided format"
        ],
        [
            "Initiates a new session\n @see XFTP::Validator::Settings"
        ],
        [
            "Performs a search for geo-attributes.\n\n @param [String] table the table to search\n @param [String] field_name the field/column to search in the given table\n @param [String] value string value to search in the given field and table\n @return [Hash] search results"
        ],
        [
            "Adjuster Builders\n Apply adjuster when passed condition.\n @param condition [Proc, Method, #===]\n @param adjuster [Proc, #to_proc]\n @return [lambda]"
        ],
        [
            "Sequencial apply all adjusters.\n @param adjuster1 [Proc, #to_proc]\n @param adjuster2 [Proc, #to_proc]\n @param adjusters [Proc, #to_proc]\n @return [lambda]"
        ],
        [
            "Accept any parser when that resopond to parse method.\n @param parser [#parse]\n @return [lambda]"
        ],
        [
            "return the class match by name"
        ],
        [
            "Make a lazy connection."
        ],
        [
            "Calculate the desired time to wake up.\n @api private\n @param start_time [nil,Time] time when the thread is put to sleep\n @param timeout [Numeric] desired time to sleep in seconds, +nil+ for forever\n @raise [TypeError] if +start_time+ is not +nil+ or a +Numeric+\n @raise [ArgumentError] if +start_time+ is negative\n @return [Time]"
        ],
        [
            "Display CRUD icons or links, according to setting in use_crud_icons method.\n\n In application_helper.rb:\n\n   def use_crud_icons\n     true\n   end\n\n Then use in index views like this:\n\n <td class=\"crud_links\"><%= crud_links(my_model, 'my_model', [:show, :edit, :delete]) -%></td>"
        ],
        [
            "Create a link that is opaque to search engine spiders."
        ],
        [
            "Wraps the given HTML in Rails' default style to highlight validation errors, if any."
        ],
        [
            "Use on index pages to create dropdown list of filtering criteria.\n Populate the filter list using a constant in the model corresponding to named scopes.\n\n Usage:\n\n - item.rb:\n\n     scope :active,   :conditions => { :is_active => true }\n     scope :inactive, :conditions => { :is_active => false }\n\n     FILTERS = [\n       {:scope => \"all\",       :label => \"All\"},\n       {:scope => \"active\",    :label => \"Active Only\"},\n       {:scope => \"inactive\",  :label => \"Inactive Only\"}\n     ]\n\n - items/index.html.erb:\n\n     <%= select_tag_for_filter(\"items\", @filters, params) -%>\n\n - items_controller.rb:\n\n     def index\n       @filters = Item::FILTERS\n       if params[:show] && params[:show] != \"all\" && @filters.collect{|f| f[:scope]}.include?(params[:show])\n         @items = eval(\"@items.#{params[:show]}.order_by(params[:by], params[:dir])\")\n       else\n         @items = @items.order_by(params[:by], params[:dir])\n       end\n       ...\n     end"
        ],
        [
            "Returns a link_to tag with sorting parameters that can be used with ActiveRecord.order_by.\n\n To use standard resources, specify the resources as a plural symbol:\n   sort_link(:users, 'email', params)\n\n To use resources aliased with :as (in routes.rb), specify the aliased route as a string.\n   sort_link('users_admin', 'email', params)\n\n You can override the link's label by adding a labels hash to your params in the controller:\n   params[:labels] = {'user_id' => 'User'}"
        ],
        [
            "Create a set of tags for displaying a field label with inline help.\n Field label text is appended with a ? icon, which responds to a click\n by showing or hiding the provided help text.\n\n Sample usage:\n\n   <%= tag_for_label_with_inline_help 'Relative Frequency', 'rel_frequency', 'Relative frequency of search traffic for this keyword across multiple search engines, as measured by WordTracker.' %>\n\n Yields:\n\n   <label for=\"rel_frequency\">Relative Frequency: <%= image_tag \"/images/help_icon.png\", :onclick => \"$('rel_frequency_help').toggle();\", :class => 'inline_icon' %></label><br />\n   <div class=\"inline_help\" id=\"rel_frequency_help\" style=\"display: none;\">\n     <p>Relative frequency of search traffic for this keyword across multiple search engines, as measured by WordTracker.</p>\n   </div>"
        ],
        [
            "wrapper of keyboard operations"
        ],
        [
            "standard open file dialog"
        ],
        [
            "Return a structure describing the options."
        ],
        [
            "Add new path to the gitattributes file"
        ],
        [
            "Runs the migration.\n\n   MyMigration.new.run"
        ],
        [
            "List parents, closest to furthest.\n\n This is a recursive, expensive call."
        ],
        [
            "Extract text out of HTML or plain strings. Basically removes html\n formatting.\n\n @param attributes [Symbol, String]\n   variable list of attributes or methods to be extracted for search\n\n @return [String] content of each attribute separated by new lines"
        ],
        [
            "Build query attribute hash.\n\n Internally stored as JSONB.\n\n @return [Hash] to be set for query attribute"
        ],
        [
            "Get the WebSocket API URI\n\n @return [String] uri"
        ],
        [
            "Parse the configuration file"
        ],
        [
            "Do additional sanity checking on a hook script"
        ],
        [
            "Get all the host IDs and FQDNs and populate the host table"
        ],
        [
            "Initialize an empty database"
        ],
        [
            "Update the database based on the foreman_hook"
        ],
        [
            "Transform and read a list attribute"
        ],
        [
            "Transform and read a hash attribute"
        ],
        [
            "Transform and write a standard attribute value"
        ],
        [
            "Transform and write a list value"
        ],
        [
            "Transform and write a hash attribute"
        ],
        [
            "Update fields without hitting the callbacks"
        ],
        [
            "Controller helper method to filter out non-authorized\n objects from the passed in array\n\n @param method [Symbol] method to be called on each policy\n @param objects [Array] array of objects to filter\n @param user [User] The current user object to pass\n @return (Array)\n\n @visibility public"
        ],
        [
            "Helper method available in controllers and views\n that returns the value of the policy method\n\n @param (see #authorize!)\n @return (Boolean)\n\n @visibility public"
        ],
        [
            "shows statistics about difficulty and network power\n\n /nethash/INTERVAL/START/STOP\n Default INTERVAL=500, START=0, STOP=infinity.\n\n See http://dogechain.info/chain/Dogecoin/q/nethash"
        ],
        [
            "Find the first saved record\n @note `last` uses a sorted set as an index of `ids` and finds the highest id.\n @param limit [Integer] returns one or many\n @param offset [Integer] from the end of the index, back\n @return [Base, Array]"
        ],
        [
            "Find a record by `id`\n @param ids [Integer, Array<Integer>] of the record(s) to lookup.\n @return [Base, Array] matching records"
        ],
        [
            "Iterate over all records in batches\n @param options [Hash] accepts options\n   `:start` to offset from the beginning of index,\n   `:batch_size` the size of the batch, default is 500.\n @param &block [Proc] passes each batch of articles to the Proc."
        ],
        [
            "Lazy loader..."
        ],
        [
            "Returns the deserialized mapped key when provided with the former key.\n\n  mapped_key(:products, 2)"
        ],
        [
            "Number of processors seen by the OS and used for process scheduling.\n\n * AIX: /usr/sbin/pmcycles (AIX 5+), /usr/sbin/lsdev\n * BSD: /sbin/sysctl\n * Cygwin: /proc/cpuinfo\n * Darwin: /usr/bin/hwprefs, /usr/sbin/sysctl\n * HP-UX: /usr/sbin/ioscan\n * IRIX: /usr/sbin/sysconf\n * Linux: /proc/cpuinfo\n * Minix 3+: /proc/cpuinfo\n * Solaris: /usr/sbin/psrinfo\n * Tru64 UNIX: /usr/sbin/psrinfo\n * UnixWare: /usr/sbin/psrinfo"
        ],
        [
            "Number of physical processor cores on the current system."
        ],
        [
            "end def run"
        ],
        [
            "Reload the events from the event file. Existing events are\n deleted first."
        ],
        [
            "see if this model is followee of some model\n\n Example:\n   >> @ruby.followee_of?(@jim)\n   => true"
        ],
        [
            "see model's followed history\n\n Example:\n   >> @ruby.ever_followed\n   => [@jim]"
        ],
        [
            "Puts this thread to sleep until another thread resumes it.\n Threads will be woken in the chronological order that this was called.\n @note Will block until resumed\n @param mutex [Mutex] mutex to be unlocked while this thread is sleeping\n @param timeout [nil,Numeric] maximum time to sleep in seconds, +nil+ for forever\n @raise [TypeError] if +timeout+ is not +nil+ or +Numeric+\n @raise [ArgumentError] if +timeout+ is negative\n @raise [Exception] any exception raised by +::ConditionVariable#wait+ (eg. interrupts, +ThreadError+)\n @return [self]"
        ],
        [
            "Validates a timeout value\n @api private\n @param timeout [nil,Numeric]\n @raise [TypeError] if +timeout+ is not +nil+ or +Numeric+\n @raise [ArgumentError] if +timeout+ is negative\n @return [void]"
        ],
        [
            "render the template including the handler as a local"
        ],
        [
            "this call initiates a race resistant attempt to make sure that there is only 1\n clear 'winner' among N potential agents attempting to run the same goal on the\n same spreadsheet agent's cell"
        ],
        [
            "you have the option of picking from many cards, pick the best one."
        ],
        [
            "This method is called if your hand is over the hand limit, it returns the card that you would like to discard.\n Returning nil or a card you don't have is a very bad idea. Bad things will happen to you."
        ],
        [
            "This is the method that is called on your turn."
        ],
        [
            "Releases the lock and puts this thread to sleep.\n @param timeout [nil, Numeric] time to sleep in seconds or +nil+ to sleep forever\n @raise [TypeError] if +timeout+ is not +nil+ or +Numeric+\n @raise [ArgumentError] if +timeout+ is not positive\n @return [Integer] elapsed time sleeping"
        ],
        [
            "Temporarily unlocks it while a block is run.\n If an error is raised in the block the it will try to be immediately relocked\n   before passing the error up. If unsuccessful, a +ThreadError+ will be raised to\n   imitate the core's behavior.\n @api private\n @raise [ThreadError] if relock unsuccessful after an error\n @raise [ArgumentError] if no block given\n @return [void]"
        ],
        [
            "Calculate time elapsed when running block.\n @api private\n @yield called while running timer\n @yieldparam start_time [Time]\n @raise [Exception] any exception raised in block\n @return [Float] time elapsed while running block"
        ],
        [
            "stalls test until ^C is hit\n useful for inspecting page state via firebug"
        ],
        [
            "Makes a call to a block that accepts optional arguments"
        ],
        [
            "Extracts the rdoc of a given ruby file source."
        ],
        [
            "Add select method to select the fields to return"
        ],
        [
            "Sets the pagination info"
        ],
        [
            "Pass in a hash that's been encoded as JSON and then Base64."
        ],
        [
            "see if this model is follower of some model\n\n Example:\n   >> @jim.follower_of?(@ruby)\n   => true"
        ],
        [
            "follow some model"
        ],
        [
            "unfollow some model"
        ],
        [
            "see user's follow history\n\n Example:\n   >> @jim.ever_follow\n   => [@ruby]"
        ],
        [
            "Retrieves an item from it.\n @note If it is empty, the method will block until an item is available.\n If +non_block+ is +true+, a +ThreadError+ will be raised.\n @raise [ThreadError] if it is empty and +non_block+ is +true+\n @param non_block [Boolean]\n @return [Object]"
        ],
        [
            "Initialize can accept custom configuration parameters\n Lookup for a specific service `key`\n passed block is called with the result values\n in case of `http` backend it return the result directly\n @param key [string] identifier of the service"
        ],
        [
            "Announce a specific service `key` available on specific `port`\n passed block is called when the announce is sent\n @param key [string] service identifier\n @param port [int] service port number\n @block callback"
        ],
        [
            "Condition Builders\n A innner method for some condition builders.\n For build conditions AND, NAND, OR, NOR, XOR, XNOR.\n @param delegated [Symbol]\n @return [lambda]"
        ],
        [
            "Post to the given path, including the correct signature header based on the payload and secret.\n @param [Hash] opts The options to use when crafting the request.\n @option opts [String] :path The full path of the endpoint to which to post\n @option opts [String] :payload A JSON-parseable string containing a payload as described in http://developer.github.com/v3/activity/events/types/\n @option opts [String] :secret The secret to use when calculating the HMAC for the X-Hub-Signature header"
        ],
        [
            "Finds height of the image relative to provided width"
        ],
        [
            "Iterates over each pixel of resized image to find closest color"
        ],
        [
            "Iterates over the palette to find the most similar color"
        ],
        [
            "Takes in a string of colors and puts them out as background colored spaces\n For example, \"rGK\" creates a light_red square, a green square, and a black square"
        ],
        [
            "build a depth first tree"
        ],
        [
            "Returns APOD info for specified day.\n\n @see https://api.nasa.gov/api.html#apod\n @rate_limited Yes https://api.nasa.gov/api.html#authentication\n @image_permissions http://apod.nasa.gov/apod/lib/about_apod.html#srapply\n @authentication optional NASA api key https://api.nasa.gov/index.html#apply-for-an-api-key\n @option options [String] :api_key Optional. Uses DEMO_KEY as default.\n @option options [String] :date Optional. Returns the APOD results for\n the given date. Date should be formatted as YYYY-MM-DD. Defaults as today.\n @return [NasaApod::SearchResults] Return APOD post for a specified date."
        ],
        [
            "Validates a timeout value, converting to a acceptable value if necessary\n @api private\n @param timeout [nil,Numeric]\n @raise [TypeError] if +timeout+ is not +nil+ or +Numeric+\n @raise [ArgumentError] if +timeout+ is negative\n @return [nil,Numeric]"
        ],
        [
            "If there is already an authorization by this note, use it; otherwise create it"
        ],
        [
            "Initialize passing configuration\n Send a message to grape"
        ],
        [
            "Includes the stylesheets and javescripts into what ever view this is\n called to.\n\n By adding a :datepicker_options hash the options hash, you can change the\n defaults styles that are intially applied to all datepicker instances.\n Those defaults can be overwritten by each instance of the datepicker.\n\n To not include the style sheet into the layout, just pass :style => :none\n (false or nil will also work)"
        ],
        [
            "Initialize an empty OpenStruct to hold configuration options\n To set a config option call the corresponding method with an argument.\n To retrieve a config option call the corresponding method without an argument."
        ],
        [
            "constructor\n return hijri date with month and day names"
        ],
        [
            "Hijri to julian"
        ],
        [
            "Hijri to gregorian"
        ],
        [
            "Add Days - Weeks - Months - Years"
        ],
        [
            "comparison operator\n return hijri date plus n days"
        ],
        [
            "Sets it to an error.\n @raise [Complete] if the it has already completed\n @param exception [nil,Object] +Exception+ class or instance to set, otherwise a +StandardError+ will be set\n @return [void]"
        ],
        [
            "Transform the ruby obj ->  to a Hash"
        ],
        [
            "sets the site for the class in which this module is extended"
        ],
        [
            "def all_attributes_set?\n   site && user && password\n end\n routes to active resource find"
        ],
        [
            "creates an active resource class dynamically. All the attributes are set automatically. Avoid calling\n this method directly"
        ],
        [
            "Run the agent app!\n\n This is the main method. Will boot and configure the agent, connect to the\n server and start the daemon."
        ],
        [
            "Open the WebSocket channel with the Manager\n\n NOTE: this call will not return!"
        ],
        [
            "If running as root, fix ownership of var and etc dirs"
        ]
    ]
}