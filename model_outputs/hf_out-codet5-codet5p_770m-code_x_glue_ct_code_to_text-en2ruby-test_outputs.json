{
    "accuracy": 0.0,
    "bleu": {
        "bleu": 0.07354942308933696,
        "precisions": [
            0.4115520161105771,
            0.13765125875098522,
            0.07074075813800554,
            0.0409348374506164
        ],
        "brevity_penalty": 0.6498862453392215,
        "length_ratio": 0.6988325603710219,
        "translation_length": 21849,
        "reference_length": 31265
    },
    "codebleu": 0.11274361087839627,
    "preds": [
        "def fans\n      result = Turntabler::API::User.fans(@token, @id)\n      result.map { |u| User.new(u) }\n    end",
        "def stickers_purchased\n      stickers = Turntabler::Sticker.list(user_id: id)\n      stickers.map { |s| s.instance_variable_get(:@attributes) }\n    end",
        "def blocks\n      result = Turntabler::API::User.blocks(@bot.token, @id)\n      result.map { |user| User.new(user, @bot) }\n    end",
        "def update_profile(profile)\n      profile_data = profile.to_hash\n      profile_data[:id] = profile.id\n      profile_data[:name] = profile.name\n      profile_data[:avatar_url] = profile.avatar_url\n      profile_data[:created_at] = profile.created_at\n      profile_data[:updated_at] = profile.updated_at\n      profile_data[:profile_url] = profile.profile_url\n      profile_data[:profile_image_url] = profile.profile_image_url\n      profile_data[:profile_link_url] = profile.profile_link_url\n      profile_data[:profile_followers_count] = profile.profile_followers_count\n      profile_data[:profile_following_count] = profile.profile_following_count\n      profile_data[:profile_",
        "def update_laptop\n      return unless laptop_id\n\n      response = self.class.get(\"/laptops/#{laptop_id}\")\n      @id = response['id']\n      @name = response['name']\n      @description = response['description']\n      @created_at = response['created_at']\n      @updated_at = response['updated_at']\n      @laptop_type = response['laptop_type']\n      @laptop_status = response['laptop_status']\n      @laptop_type = response['laptop_type'] if response['laptop_type']\n      @laptop_status = response['laptop_status'] if response['laptop_status']\n    end",
        "def set_status(status)\n      if status == :online\n        self.online = true\n      elsif status == :offline\n        self.online = false\n      end\n    end",
        "def analyze(input)\n      @input = input\n      @selectors = []\n      @weights = []\n      @word_count = 0\n      @sentence_count = 0\n      @passage_count = 0\n      @word_index = 0\n      @sentence_index = 0\n      @passage_index = 0\n      @word_list = []\n      @sentence_list = []\n      @passage_list = []\n      @word_list.each do |word|\n        @word_count += 1\n        if word.is_a?(String)\n          @word_list << word\n        elsif word.is_a?(Symbol)\n          @word_list << word.to_s\n        elsif word.is_a?(Integer)\n          @word_list << word\n        end\n      end\n      @sentence_list.each do |sentence",
        "def weighted_random(type, group)\n      case type\n      when :count\n        count(group)\n      when :first\n        first(group)\n      when :next\n        next_letter(group)\n      when :last\n        last_letter(group)\n      else\n        raise ArgumentError, \"Invalid weighted random type #{type.inspect}\"\n      end\n    end",
        "def call(event)\n      return false unless @once\n      @if.each do |condition, data|\n        return true if condition.call(event, data)\n      end\n      return false\n    end",
        "def matches?(event_data)\n      @conditions.all? { |c| c.matches?(event_data) }\n    end",
        "def add(storable, coordinate = nil)\n      raise IndexError, \"Container is full\" if @size == @max_size\n      raise IndexError, \"Row and column are given but exceed the Container bounds\" if coordinate.nil? && @row > @bounds.right && @column > @bounds.left\n      coordinate ||= @default_coordinate\n      @items[coordinate] = storable\n      self\n    end",
        "def copy_capacity\n      if capacity = @type.capacity\n        @capacity = Capacity.new(capacity)\n        @capacity.container = self\n      end\n    end",
        "def load\n      result = Turntabler::Command.new('preferences load')\n      result.run_async\n      result.success?\n    end",
        "def run\n      @extractor.extract_files(@files)\n      @extractor.process_files\n      @extractor.write_results\n    end",
        "def teams summoner, optional = {}\n      options = { :region => @region }.merge optional\n      teams = JSON.parse API::Summoner.teams(@bot.token, @id, summoner.to_i, options)\n      teams.map { |t| Team.new t }\n    end",
        "def get_document_type(file_path)\n      document_type = nil\n      if File.exist?(file_path)\n        YAML.load_file(file_path).each do |document|\n          document_type = document['type']\n          break if document_type\n        end\n      end\n      document_type\n    end",
        "def execute\n      @key = @rows.map { |r| r.to_s }\n      @rows.each do |r|\n        @columns.each do |c|\n          @key[c] = r.send(c)\n        end\n      end\n    end",
        "def span(spanner)\n      raise ArgumentError, \"Invalid argument 'spanner'. Expected Vector, got #{spanner.class}.\" unless spanner.is_a?(Vector)\n      raise ArgumentError, \"Invalid argument 'spanner'. Expected Vector, got #{spanner.class}.\" unless spanner.length == length\n\n      # Find the first element that is smaller than the second\n      smaller = spanner.min\n      smaller_index = smaller.index\n      smaller_value = smaller.value\n\n      # Find the second element that is larger than the first\n      larger = spanner.max\n      larger_index = larger.index\n      larger_value = larger.value\n\n      # Find the span between the two vectors\n      span = Vector.new\n      span.index = smaller_index\n      span.value = smaller_value\n      span.index = larger_index\n      span.value",
        "def render_all\n      @feed_urls.each do |feed_url|\n        @renderer.render_page(feed_url)\n        @renderer.render_stylesheets(feed_url)\n      end\n    end",
        "def print_config(source, destination)\n      puts \"Configuration file: #{source}\"\n      puts \"Source directory: #{source}\"\n      puts \"Destination directory: #{destination}\"\n      puts \"Run `bundle exec rake config` to generate configuration file\"\n    end",
        "def log_build_time(time)\n      if @options[:verbose]\n        puts \"Build time: #{time.to_s(3)}\"\n      end\n    end",
        "def execute(operation, outfile)\n      result = nil\n      begin\n        result = @client.send(operation)\n      rescue => e\n        raise e unless e.is_a?(Net::HTTPServerException)\n        raise e unless e.response.code == \"404\"\n        @logger.info \"File #{outfile} does not exist\"\n      end\n      write_result(outfile, result)\n    end",
        "def create_operands(operator, left, right)\n      case operator\n      when :+\n        SpreadsheetOperand.new(left, right)\n      when :-\n        SpreadsheetOperand.new(-left, right)\n      when :*\n        SpreadsheetOperand.new(left, right)\n      when :/\n        SpreadsheetOperand.new(-left, right)\n      when :%\n        SpreadsheetOperand.new(left, right)\n      when :==\n        SpreadsheetOperand.new(left, right)\n      when :!=\n        SpreadsheetOperand.new(left, right)\n      when :<\n        SpreadsheetOperand.new(left, right)\n      when :>\n        SpreadsheetOperand.new(right, left)\n      else\n        raise ArgumentError, \"Unknown arithmetic operator: #{operator}\"\n      end\n",
        "def publish(params = {})\n      params = params.dup\n      params[:id] = @next_id\n      @socket.write(JSON.dump(params))\n      @next_id += 1\n    end",
        "def publish(params)\n      @socket.puts JSON.dump(params)\n      @socket.flush\n    end",
        "def publish(params)\n      uri = URI.parse(url)\n      http = Net::HTTP.new(uri.host, uri.port)\n      http.use_ssl = true\n      http.verify_mode = OpenSSL::SSL::VERIFY_NONE\n      req = Net::HTTP::Post.new(uri.path, {\n        'Content-Type' => 'application/json',\n        'Authorization' => \"Bearer #{@access_token}\",\n        'Content-Length' => params.to_json.length.to_s\n      })\n      req.body = params.to_json\n      res = http.request(req)\n      JSON.parse(res.body)\n    end",
        "def receive_message(message)\n      # Check if the message is a response message.\n      if message.is_a?(ResponseMessage)\n        # Get the response data.\n        response = message.response\n        # Check if the response is a success message.\n        if response.success?\n          # Get the response data.\n          data = response.data\n          # Check if the data is a hash.\n          if data.is_a?(Hash)\n            # Check if the response data is a string.\n            if data['type'] == 'result'\n              # Send the response to the client.\n              send_response(data['result'])\n            else\n              # Send the response to the server.\n              send_response(data['error'])\n            end\n          else\n            # Send the response to the server.\n            send_response(data)\n          end\n       ",
        "def add_dimension_defaults\n      one_dimension_label = @dimension_labels.delete('Column')\n      two_dimension_label = @dimension_labels.delete('Row')\n      if one_dimension_label && two_dimension_label\n        @dimension_labels << [one_dimension_label, two_dimension_label]\n      end\n    end",
        "def try_connect\n      return true if connected?\n      sleep(1)\n      begin\n        connect\n        return true\n      rescue Errno::EINPROGRESS\n        sleep(1)\n        try_connect\n      end\n    end",
        "def copy_files_to_host(files, host)\n      files.each do |file|\n        host.copy_file(file, File.join(path, file))\n      end\n    end",
        "def write_host_file(host)\n      File.open(host_file, 'w') do |f|\n        f.write(host)\n      end\n    end",
        "def read_host_file\n      host_file = File.join(config.hosts_dir, @name)\n      if File.exist?(host_file)\n        @hosts = YAML.load_file(host_file)\n      else\n        @hosts = {}\n      end\n    end",
        "def execute_command(command, *args)\n      output = nil\n      Open3.popen3(command, *args) do |i, o, e, t|\n        output = o.read\n      end\n      output\n    end",
        "def is_specimen?(storable)\n      return false unless Storable.is_a?(Specimen)\n      return false unless Storable.specimen_type == self\n      return true\n    end",
        "def process_aggregation(outfile)\n      @key_values.each do |k, v|\n        outfile.puts \"#{k}:#{v.sum}\"\n      end\n    end",
        "def write_results(aggr)\n      aggr.each do |k, v|\n        if v.is_a?(Hash)\n          write_results_for_key(k, v)\n        else\n          write_result(k, v)\n        end\n      end\n    end",
        "def init_sum_row_title_and_position\n      @sum_row_title = []\n      @sum_column_title = []\n      @sum_position = []\n      @sum_row_title << I18n.t('sum.title_row_title', :count => @sum_row_titles.count)\n      @sum_column_title << I18n.t('sum.title_column_title', :count => @sum_column_titles.count)\n      @sum_position << [@sum_row_titles.count, @sum_column_titles.count]\n    end",
        "def attributes(options = {}, &block)\n      options = {\n        optional: true\n      }.merge(options)\n      attributes = []\n      attributes << options[:optional] ? 'optional' : ''\n      attributes << options[:name]\n      attributes << options[:type]\n      attributes << options[:default]\n      attributes << options[:cast]\n      attributes << options[:cast_with]\n      attributes << options[:cast_with_options]\n      attributes << options[:cast_with_default]\n      attributes << options[:cast_with_default_options]\n      attributes << options[:cast_with_options]\n      attributes << options[:cast_with_default_options]\n      instance_eval(&block) if block_given?\n      attributes.join(' ')\n    end",
        "def resolve_dependencies(dep_hashes, repos)\n      dep_hashes.map do |dep_hash|\n        dep_hash[:group_id] = dep_hash[:groupId] if dep_hash[:groupId]\n        dep_hash[:artifact_id] = dep_hash[:artifactId] if dep_hash[:artifactId]\n        dep_hash[:version] = dep_hash[:version] if dep_hash[:version]\n        dep_hash[:extension] = dep_hash[:extension] || 'jar'\n\n        repo = resolve_repo(repos, dep_hash[:groupId], dep_hash[:artifactId])\n        dep_hash[:version] = dep_hash[:version] if dep_hash[:version]\n\n        repo\n      end\n    end",
        "def board\n      @board ||= begin\n        board = []\n        (0...9).each do |row|\n          (0...9).each do |col|\n            board << (row == col ? 0 : 1)\n          end\n        end\n        board\n      end\n    end",
        "def parse_args(argv)\n      @options = {}\n      argv.each do |arg|\n        case arg\n        when '--help'\n          puts help\n          exit\n        when '--version'\n          puts version\n          exit\n        when '--config'\n          @options[:config] = arg\n        when '--config-file'\n          @options[:config_file] = arg\n        when '--config-path'\n          @options[:config_path] = arg\n        when '--config-path=PATH'\n          @options[:config_path] = arg\n        when '--config-file=FILE'\n          @options[:config_file] = arg\n        when '--port'\n          @options[:port] = arg.to_i\n        when '--port=PORT'\n          @options[:port] = arg.to_i\n        when '--host'\n          @options[:host",
        "def clone(bug_id, overrides = {})\n      overrides = {\n        :target_release => nil,\n        :assigned_to => nil\n      }.merge(overrides)\n\n      params = {\n        :bug_id => bug_id\n      }\n\n      params[:target_release] = overrides[:target_release] if overrides[:target_release]\n      params[:assigned_to] = overrides[:assigned_to] if overrides[:assigned_to]\n\n      data = request('Bug.clone', params)\n      data['bug']['id']\n    end",
        "def leagues_of(summoner, optional = {})\n      options = { :region => 'us' }.merge(optional)\n      summoner = summoner.id if summoner.is_a?(Integer)\n      response = get(\"summoner/#{summoner}/leagues\", options)\n      response['leagues'].map { |league| League.new(league) }\n    end",
        "def get_all_entries_for_summoner summoner, optional = {}\n      options = {\n        :region => 'us'\n      }\n      options.merge! optional\n      summoner = Summoner.new(summoner) if summoner.is_a?(Integer)\n      result = call(\"getAllEntriesForSummoner\", summoner, options)\n      result[\"leagueItems\"].map { |league_item| LeagueItem.new(league_item) }\n    end",
        "def place(top, left, angle)\n      return true if top == left\n      return true if top > self.top && left > self.left\n      return true if top < self.top && left < self.left\n\n      raise Turntabler::Error, \"Sticker coordinates must be within 0 and 0 inclusive\"\n    end",
        "def find_feed_uris(uris)\n      uris.map do |uri|\n        begin\n          page = Nokogiri::HTML(open(uri))\n          page.css('a').map { |a| a['href'] }.compact\n        rescue\n          nil\n        end\n      end\n    end",
        "def collection_status=(value)\n      raise JSS::InvalidDataError, 'Value must be a string' unless value.is_a? String\n      raise JSS::InvalidDataError, 'Value must be one of the following: Complete, Pending, Collected' unless value.eql? 'Complete' || 'Pending' || 'Collected'\n      @collection_status = value\n      @need_to_update = true\n    end",
        "def make_consent_status\n      @consent_status = {}\n      @registration_consent.each do |reg_consent|\n        reg_consent.tier_consent_ids.each do |tier_consent_id|\n          @consent_status[tier_consent_id] = {} unless @consent_status[tier_consent_id]\n          @consent_status[tier_consent_id][reg_consent.id] = {} unless @consent_status[tier_consent_id][reg_consent.id]\n          @consent_status[tier_consent_id][reg_consent.id][tier_consent.id] = reg_consent.status\n        end\n      end\n    end",
        "def first_event\n      events = @protocol.events\n      return nil unless events\n      events.first\n    end",
        "def default_receiver\n      @default_receiver ||= begin\n        cp = CaTissue::CollectionProtocolCoordinator.new\n        cp.fetch\n        cp.default_receiver\n      end\n    end",
        "def decrement_quantity_for_child(child)\n      if child.quantity == 0\n        # If the child is the first child, set the quantity to the parent's available quantity.\n        self.quantity = self.quantity - 1\n      elsif self.quantity > child.quantity\n        # If the child is the last child, set the quantity to the parent's available quantity.\n        self.quantity = self.quantity - child.quantity\n      else\n        # If the child is the same, just decrement the quantity.\n        self.quantity -= child.quantity\n      end\n    end",
        "def update_dependent(dependent)\n      raise ArgumentError, \"Invalid argument 'dependent'. Expected CaTissue::Dependent, got #{dependent.class}.\" unless dependent.is_a?(Dependent)\n      # TODO: This is a bit of a hack, but caTissue doesn't seem to handle this correctly.\n      # The only way to handle this is to update the child record.\n      #\n      # The update_changed_dependent method is called by the Hibernate helper method\n      # update_changed_dependent_with_parent, which calls the parent's update_changed_dependent\n      # method, which updates the child record.\n      #\n      # The update_changed_dependent_with_parent method also updates the child record\n      # according to the Hibernate HQL query.\n      #\n      # The update_changed_dependent_with_parent method also updates the child record\n      # according to the",
        "def update_user_address(user, address)\n      response = post(\"/users/#{user.id}/addresses\", address: address.to_hash)\n      user.reload\n    end",
        "def add_to_template(specimen, template)\n      template.add_position(specimen.position)\n      save_with_template(specimen, template)\n    end",
        "def ensure_primary_annotation_hook_exists(annotation)\n      hook_entity = annotation.hooks.where(:entity_id => annotation.hook_entity_id).first\n      raise CaRuby::DatabaseError, \"Annotation hook #{annotation.hook_entity_id} does not exist\" if hook_entity.nil?\n    end",
        "def copy_annotation(obj, template)\n      obj.__java_class__ = template.__java_class__\n      obj.__java_class__.setProperty(\"@link\", template.__java_class__.getProperty(\"@link\"))\n      obj.__java_class__.setProperty(\"@value\", template.__java_class__.getProperty(\"@value\"))\n      obj.__java_class__.setProperty(\"@value.class\", template.__java_class__.getProperty(\"@value.class\"))\n      obj.__java_class__.setProperty(\"@value.class.superclass\", template.__java_class__.getProperty(\"@value.class.superclass\"))\n      obj.__java_class__.setProperty(\"@value.class.superclass.name\", template.__java_class__.getProperty(\"@value.class.superclass.name\"))\n      obj.__java_class__.setProperty(\"@",
        "def create_table(table_name, options = {})\n      options = {\n        :force => false,\n        :force_rename => false,\n        :force_truncate => false,\n        :force_delete => false,\n        :name => table_name\n      }.merge(options)\n\n      if options[:force]\n        force_create_table(table_name)\n      elsif options[:force_rename]\n        force_rename_table(table_name)\n      elsif options[:force_truncate]\n        force_truncate_table(table_name)\n      elsif options[:force_delete]\n        force_delete_table(table_name)\n      else\n        raise ArgumentError, \"Invalid options: #{options.inspect}\"\n      end\n    end",
        "def write_table(outfile)\n      table = @table\n      table.each do |row|\n        outfile.puts row.map { |c| c.to_s }\n      end\n    end",
        "def cast_value(value)\n      if value =~ /^\\d+$/\n        value.to_i\n      elsif value =~ /^\\d+\\.\\d+$/\n        value.to_f\n      else\n        value.to_s.to_i\n      end\n    end",
        "def init_sum_row_patterns(sum_option)\n      @sum_row_pos = []\n      @sum_row = []\n      @sum_row_patterns = []\n      case sum_option\n      when :pos\n        @sum_row_pos = [0]\n        @sum_row = [0]\n      when :pattern\n        @sum_row_patterns = [0]\n        @sum_row = [0]\n      end\n    end",
        "def add_value(column, value)\n      if column.is_a?(Numeric)\n        @sum_row[column] += value\n      elsif column.is_a?(String)\n        @sum_row[column] += value\n      end\n    end",
        "def create_sum_row\n      sum_row = []\n      @files.each do |file|\n        sum_row << file.size\n      end\n      sum_row\n    end",
        "def wrap_enumerable_results(enumerable)\n      if enumerable.respond_to?(:to_enum)\n        enumerable.to_enum.map { |item| wrap_result(item) }\n      elsif enumerable.respond_to?(:to_a)\n        enumerable.to_a.map { |item| wrap_result(item) }\n      else\n        enumerable\n      end\n    end",
        "def add_node(name, dependencies = [], &block)\n      node = Node.new(name, dependencies, &block)\n      @nodes << node\n      node\n    end",
        "def traverse_edges(node, &block)\n      node.edges.each do |edge|\n        if edge.is_a?(GraphQL::Schema::Edge)\n          traverse_edges(edge, &block)\n        elsif edge.is_a?(GraphQL::Schema::Node)\n          traverse_node(edge, &block)\n        end\n      end\n    end",
        "def with_friends\n      result = command(:withFriends)\n      result.map { |room| Room.new(room, @client) }\n    end",
        "def find(query, options = {})\n      options = @options.merge(options)\n      limit = options[:limit] || 20\n      skip = options[:skip] || 0\n      query = query.to_s\n      rooms = []\n      response = api_response(:get, \"/rooms/find.json?limit=#{limit}&skip=#{skip}\", query)\n      response.each do |room|\n        rooms << Room.new(room)\n      end\n      rooms\n    end",
        "def load(options = {})\n      options = @options.merge(options)\n      songs = []\n      @songs.each do |song|\n        songs << song.load(options)\n      end\n      @attributes = songs\n      true\n    end",
        "def update(attributes)\n      raise ArgumentError, \"You must specify an id\" if attributes[:id].nil?\n      attributes = attributes.merge(id: attributes[:id])\n      response = @client.command(:update, id, attributes)\n      true\n    end",
        "def active\n      result = Turntabler::Command.new(\"playlist info #{id}\").execute\n      result.success?\n    rescue Turntabler::Error => e\n      raise e unless e.message =~ /playlist info/\n      true\n    end",
        "def initialize_copy(other)\n      super\n      @attributes = @attributes.dup\n      @attributes.merge!(other.attributes)\n      self\n    end",
        "def add_specimens(*args)\n      raise ArgumentError, \"Invalid argument 'args'. Expected (<Specimen>, {Symbol => Object}), got #{args.class}.\" unless args.is_a?(Array) && args.last.is_a?(Hash)\n      args = args.first if args.first.is_a?(Hash)\n      raise ArgumentError, \"Invalid argument 'args'. Expected (<Specimen>, {Symbol => Object}), got #{args.class}.\" unless args.is_a?(Array) && args.last.is_a?(Specimen)\n      raise ArgumentError, \"Invalid argument 'args'. Expected (<Specimen>, {Symbol => Object}), got #{args.class}.\" unless args.is_a?(Array) && args.last.is_a?(CaTissue::SpecimenCollectionGroup)\n      # Create a new registration if the SCG",
        "def summoner(name_or_id, optional = {})\n      if name_or_id.is_a?(Integer)\n        summoner = Summoner.new(get(\"summoners/#{name_or_id}\", optional))\n      else\n        summoner = Summoner.new(get(\"summoners/new\", optional))\n      end\n      summoner\n    end",
        "def names_for_ids(ids, optional = {})\n      region = optional[:region] || :us\n      ids = ids.map(&:to_i)\n      names = {}\n      ids.each do |id|\n        summoner = Summoner.find_by_id(id)\n        names[id] = summoner.name if summoner.present?\n      end\n      names\n    end",
        "def runebook_of(summoner, optional = {})\n      options = {\n        :region => 'us'\n      }.merge(optional)\n      data = request(\"summoner/runebook\", summoner, options)\n      Runebook.new(data[\"runebook\"])\n    end",
        "def runebooks_for_summoners(summoners, optional = {})\n      summoners = [summoners] unless summoners.is_a?(Array)\n      result = {}\n      summoners.each do |summoner|\n        result[summoner.id] = runebook_for_summoner(summoner, optional)\n      end\n      result\n    end",
        "def zip\n      @entries.each do |entry|\n        entry.zip(File.open(entry.path))\n      end\n    end",
        "def collect!(opts = {})\n      raise Jinx::ValidationError, \"This Collectible has already been received\" if received?\n      @event_parameters = extract_event_parameters(opts)\n      @event_parameters.each do |k, v|\n        @event_parameters[k] = v.is_a?(Array) ? v.first : v\n      end\n      @received_at = Time.now\n      self\n    end",
        "def create_filters(patterns)\n      filters = []\n      patterns.each do |pattern|\n        filter = Filter.new(pattern)\n        filters << filter\n        yield(filter) if block_given?\n      end\n      filters\n    end",
        "def matches?(value)\n      return true if value.nil?\n      return false if value.empty?\n      return false if value.is_a?(Array)\n      return false if value.is_a?(Hash)\n      return false if value.is_a?(Symbol)\n      return false if value.is_a?(String)\n      return false if value.is_a?(Numeric)\n      return false if value.is_a?(TrueClass)\n      return false if value.is_a?(FalseClass)\n      return true\n    end",
        "def filter_matches_column?(column, filter)\n      return false unless column\n      return false unless filter\n      return false unless column.is_a?(ActiveScaffold::DataStructures::Filter)\n      column.value == filter.value\n    end",
        "def filter_for_rows_and_columns(rows, columns)\n      rows.map do |row|\n        row.map do |column|\n          [column, column] if columns.include?(column)\n        end\n      end\n    end",
        "def add_value(value)\n      if value.is_a?(Array)\n        value.each do |v|\n          add_value(v)\n        end\n      else\n        @values << value\n      end\n    end",
        "def add_filter(value, type)\n      if value.is_a?(Hash)\n        value.each do |k, v|\n          add_filter(v, type)\n        end\n      else\n        @filters << [value, type]\n      end\n    end",
        "def add_range(from, to)\n      raise ArgumentError, \"Invalid argument 'from'. Expected Range, got #{from.class}.\" unless from.is_a?(Range)\n      raise ArgumentError, \"Invalid argument 'to'. Expected Range, got #{to.class}.\" unless to.is_a?(Range)\n\n      @ranges << Range.new(from, to)\n    end",
        "def add_range_filter(range, types)\n      @ranges << range\n      @types << types\n      @filter_types[range] = types\n    end",
        "def add_comparisson_filter(field, operator, value)\n      raise ArgumentError, \"Field must be a String\" unless field.is_a?(String)\n      raise ArgumentError, \"Operator must be a String\" unless operator.is_a?(String)\n      raise ArgumentError, \"Value must be a String\" unless value.is_a?(String)\n\n      @filters << ComparissonFilter.new(field, operator, value)\n    end",
        "def add_filter(filter)\n      raise ArgumentError, \"Filter must be a DateFilter\" unless filter.is_a?(DateFilter)\n      @filters << filter\n    end",
        "def add_filter(filter)\n      raise ArgumentError, \"Invalid filter type: #{filter.class}\" unless filter.is_a?(DateFilter)\n      @filters << filter\n    end",
        "def number_filter(filter, options = {})\n      options = {\n        :min => 0,\n        :max => 100,\n        :step => 1,\n        :message => 'Number filter must be between 0 and 100'\n      }.merge(options)\n\n      @filters << {\n        :filter => filter,\n        :options => options\n      }\n    end",
        "def number_filter(filter_name, filter_options = {}, &block)\n      add_filter filter_name, NumberFilter.new(filter_options, &block)\n    end",
        "def create_annotation(hook, annotation)\n      raise AnnotationError, \"The hook #{hook.class} does not have a database identifier\" unless hook.database_identifier\n      raise AnnotationError, \"The annotation #{annotation.class} does not have a database identifier\" unless annotation.database_identifier\n\n      # Create the annotation in the caTissue database.\n      annotation.save!\n\n      # Add the hook to the list of hooks to be annotated.\n      hook.annotations << annotation\n    end",
        "def join(items, options = {})\n      delimiter = options[:delimiter] || ', '\n      final_delimiter = options[:final_delimiter] || ''\n      conjunction = options[:conjunction] || ' and '\n\n      items.map do |item|\n        if item.is_a?(Array)\n          join(item, { delimiter: delimiter, final_delimiter: final_delimiter, conjunction: conjunction })\n        else\n          [delimiter, final_delimiter, conjunction, item].join\n        end\n      end.join\n    end",
        "def awesome_print(string)\n      return string if awesome_print_enabled?\n\n      string.gsub(/\\n/, '  ')\n        .gsub(/\\r/,   '  ')\n        .gsub(/\\t/,   '  ')\n        .gsub(/\\f/,   '  ')\n        .gsub(/\\b/,   '  ')\n        .gsub(/\\v/,   '  ')\n        .gsub(/\\n\\t/,  '  ')\n        .gsub(/\\n/,  '  ')\n        .gsub(/\\r/,  '  ')\n        .gsub(/\\t/,  '  ')\n        .gsub(/\\f/,  '  ')\n        .gsub(/\\b/,  '  ')\n        .gsub(/\\v/",
        "def meta_as_json\n      meta = {\n        'id' => id,\n        'title' => title,\n        'slug' => slug,\n        'meta_language' => meta_language,\n        'meta_permalink' => meta_permalink,\n        'meta_status' => meta_status,\n        'meta_created_at' => meta_created_at,\n        'meta_updated_at' => meta_updated_at,\n        'meta_published' => meta_published,\n        'meta_language_code' => meta_language_code,\n        'meta_permalink_code' => meta_permalink_code,\n        'meta_status_code' => meta_status_code,\n        'meta_created_by' => meta_created_by,\n        'meta_updated_by' => meta_updated_by,\n        '",
        "def run\n      @collector.start\n      while @collector.running?\n        @collector.collect\n        sleep @collector.interval\n      end\n      @collector.stop\n    end",
        "def initialize_collection(collection_name, options = {})\n      collection_name = collection_name.to_s\n      collection_name = 'default' if collection_name.empty?\n      collection_name = 'default' if collection_name.include?(':')\n      collection_name = 'default' if collection_name.include?('/')\n      collection_name = 'default' if collection_name.include?('*')\n      collection_name = 'default' if collection_name.include?('?')\n      collection_name = 'default' if collection_name.include?('*')\n      collection_name = 'default' if collection_name.include?('?')\n      collection_name = 'default' if collection_name.include?('/')\n      collection_name = 'default' if collection_name.include?('*')\n      collection",
        "def logger\n      @logger ||= begin\n        logger = Logger.new(STDOUT)\n        logger.level = @verbose ? Logger::DEBUG : Logger::INFO\n        logger\n      end\n    end",
        "def require_aether(*coords)\n      if coords.size == 1\n        require_aether_coord(*coords)\n      else\n        require_aether_sources(*coords)\n      end\n    end",
        "def create_lookup_table\n      lookup_table = []\n      @source_files.each do |source_file|\n        lookup_table << [source_file.path, source_file.join_column]\n      end\n      lookup_table.sort_by { |path, _| path }\n    end",
        "def init_column_positions\n      @column_positions = []\n      @source_file_lines.each_with_index do |line, index|\n        if line =~ /^\\s*$/\n          @column_positions << index\n        end\n      end\n    end",
        "def positions_for_join(join)\n      positions = []\n      join.split(\",\").each do |position|\n        positions << position.to_i\n      end\n      positions\n    end",
        "def set_defaults\n      self.start_date = DateTime.now.strftime('%Y-%m-%d') if self.start_date.nil?\n      self.title = self.short_title if self.title.nil?\n    end",
        "def subset(row_start, col_start, row_end, col_end)\n      new_spread_sheet = Spreadsheet.new\n      new_spread_sheet.row_labels = row_labels(row_start, col_start, row_end, col_end)\n      new_spread_sheet.column_labels = column_labels(row_start, col_start, row_end, col_end)\n      new_spread_sheet.spread_rows = spread_rows(row_start, col_start, row_end, col_end)\n      new_spread_sheet\n    end",
        "def collect_results(operation)\n      result = []\n      @columns.each do |column|\n        result << column.send(operation)\n      end\n      result\n    end",
        "def rename(rows: nil, cols: nil)\n      if rows.nil? && cols.nil?\n        raise ArgumentError, 'Must provide rows and columns to rename'\n      end\n\n      if rows.nil?\n        rows = rows_to_rename\n      end\n\n      if cols.nil?\n        cols = cols_to_rename\n      end\n\n      if rows.size > cols.size\n        raise ArgumentError, 'Rows and columns must be the same size to rename'\n      end\n\n      if rows.size < cols.size\n        rows.each do |row|\n          cols.each do |col|\n            if @labels[row][col] > @labels[row][col - 1]\n              @labels[row][col] = @labels[row][col - 1]\n              @labels.delete([row, col])\n            end\n          end\n        end",
        "def print_spreadsheet(matrix, options = {})\n      column_labels = []\n      row_labels = []\n      if options[:labels]\n        column_labels = options[:labels].map { |label| label.to_s.capitalize }\n        row_labels = options[:labels].map { |label| label.to_s.capitalize }\n      end\n      print_matrix(matrix, column_labels, row_labels)\n    end",
        "def create_rows(rows, file)\n      if rows.is_a?(String)\n        rows = [rows]\n      end\n      if rows.is_a?(Array)\n        rows = rows.map { |row| row.to_s }\n      end\n      if file\n        rows = read_file(file)\n      end\n      rows.map { |row| row.to_s }\n    end",
        "def fill_missing_columns\n      missing_columns = []\n      @rows.each do |row|\n        row.each_with_index do |cell, index|\n          if cell.nil?\n            missing_columns << index\n          end\n        end\n      end\n      @columns.each do |column|\n        column.fill_with_na\n      end\n      missing_columns\n    end",
        "def same_column_size?\n      rows.each do |row|\n        columns.each do |column|\n          return false unless row.size == column.size\n        end\n      end\n      true\n    end",
        "def coerce_number(value)\n      case value\n      when Array\n        value.map { |v| coerce_number(v) }\n      when Number\n        value\n      else\n        raise ArgumentError, \"Can't coerce #{value.class} into a spread sheet number\"\n      end\n    end",
        "def operator(s)\n      if s.is_a?(Array)\n        s.each do |v|\n          self[v] = self[v] * s\n        end\n      else\n        self[s] = self[s] * s\n      end\n    end",
        "def process_counting(file)\n      file.each do |line|\n        if line =~ /^#/\n          # Skip comments\n          next\n        elsif line =~ /^#\\+$/\n          # Add a new count\n          @count += 1\n        elsif line =~ /^#-$/\n          # Remove a count\n          @count -= 1\n        end\n      end\n    end",
        "def count_results(query, options = {})\n      query = query.to_s\n      options = options.to_hash\n      options[:start] = 0 if options[:start].nil?\n      options[:count] = 10 if options[:count].nil?\n      options[:start] = 0 if options[:start].is_a?(Integer)\n      options[:count] = 10 if options[:count].is_a?(Integer)\n      options[:start] = 0 if options[:start].is_a?(String)\n      options[:count] = 10 if options[:count].is_a?(String)\n      options[:count] = 10 if options[:count].is_a?(Symbol)\n      options[:count] = 10 if options[:count].is_a?(Symbol)\n      options[:count] = 10 if options[:count].is_a?(TrueClass",
        "def init_sum_row_title\n      @sum_row_title = []\n      @sum_row_title << [@row_title_position, @sum_column_title]\n      @sum_row_title << [@row_title_position + @col_title_width, @sum_column_title]\n      @sum_row_title << [@row_title_position + @col_title_width, @sum_column_title]\n      @sum_row_title << [@row_title_position, @sum_column_title]\n      @sum_row_title << [@row_title_position, @sum_column_title]\n      @sum_row_title << [@row_title_position, @sum_column_title]\n      @sum_row_title << [@row_title_position, @sum_column_",
        "def init_key_columns\n      @key_columns = []\n      @key_headers = []\n      @key_columns << [:id, :name]\n      @key_columns << [:value, :value]\n      @key_columns << [:action, :action]\n      @key_columns << [:created_at, :created_at]\n      @key_columns << [:updated_at, :updated_at]\n    end",
        "def arrange_heading\n      return if @original_sequence.empty?\n      @original_sequence.each_with_index do |column, index|\n        if column.conditional_filters.empty?\n          column.heading = index\n        else\n          column.conditional_filters.each do |filter|\n            filter.heading = index\n          end\n        end\n      end\n    end",
        "def process_filter_on_row(row, filter)\n      # Process the filter on the row\n      filter.each do |field, operator, value|\n        # If the value is a string, then we need to convert it to a symbol\n        if value.is_a?(String)\n          value = value.to_sym\n        end\n\n        # If the value is a symbol, then we need to convert it to a string\n        if value.is_a?(Symbol)\n          value = value.to_s\n        end\n\n        # If the value is a date, then we need to convert it to a date\n        if value.is_a?(Date)\n          value = value.to_time\n        end\n\n        # If the value is a date, then we need to convert it to a time\n        if value.is_a?(Time)\n",
        "def messages\n      response = @client.send(:get, \"/users/#{@id}/messages\")\n      messages = response.parsed_response\n      messages.map { |message| Message.new(message) }\n    end",
        "def stalk\n      room = Room.new(self, :name => @name)\n      room.make_fan\n      room\n    end",
        "def boot(reason)\n      result = Turntabler::Command.boot(@bot.token, @id, reason)\n      return true if result.success?\n      raise Turntabler::Error.new(result.error)\n    end",
        "def report(reason)\n      result = Turntabler::API::User.report(@bot.token, @id, reason)\n      return true if result['status'] == 'ok'\n      raise Turntabler::Error.new(result)\n    end",
        "def derived_characteristics\n      return nil unless parent_specimen\n      return nil unless parent_specimen.characteristics\n      return parent_specimen.characteristics.dup unless parent_specimen.characteristics.identifier\n      parent_specimen.characteristics.dup\n    end",
        "def region=(region)\n      raise ArgumentError, \"Invalid region\" unless region.is_a?(CoordinateRegion)\n      @region = region\n      @animated = region[:animated]\n    end",
        "def collection_site\n      site = nil\n      @collection_sites.each do |cs|\n        site = cs if cs.mrn == @mrn\n      end\n      site\n    end",
        "def matches?(other)\n      return false unless other.is_a?(Tissue::SpecimenRequirement)\n      return false unless self.site.id == other.site.id\n      return false unless self.side == other.side\n      return true\n    end",
        "def scg_cp\n      @scg_cp ||= begin\n        if @scg_cp_id\n          coordinator = Coordinator.find(@scg_cp_id)\n          coordinator.scg_cp if coordinator\n        end\n      end\n    end",
        "def export_translations\n      return unless @config.respond_to?(:translations)\n      @config.translations.each do |key, value|\n        if value.is_a?(Hash)\n          export_translations_for_hash(key, value)\n        else\n          export_translations_for_array(key, value)\n        end\n      end\n    end",
        "def save_translations\n      translations = translations_to_json\n      File.open(@file, 'w') do |f|\n        f.write(translations)\n      end\n    end",
        "def translations\n      @translations ||= begin\n        translations = []\n        if @options[:translations]\n          @options[:translations].each do |key, value|\n            translations << { key: key, value: value }\n          end\n        end\n        translations\n      end\n    end",
        "def load_caTissue_classpath\n      if @caTissue_classpath.nil?\n        @caTissue_classpath = [\n          File.join(File.dirname(__FILE__), '..', '..', 'lib', 'caTissue'),\n          File.join(File.dirname(__FILE__), '..', '..', 'lib', 'caTissue', 'classes')\n        ]\n      end\n      @caTissue_classpath\n    end",
        "def parse_file(file)\n      # Open the file\n      file.open\n\n      # Read the file into memory\n      data = file.read\n\n      # Parse the data\n      parser = Parser.new(data)\n      parser.parse\n\n      # Store the output\n      @output = parser.output\n    end",
        "def init_system\n      @status_file = File.join(File.dirname(__FILE__), 'status.txt')\n      @vatsim_file = File.join(File.dirname(__FILE__), 'vatsim.txt')\n      @status = {}\n      @vatsim = {}\n      @vatsim_status = {}\n      @vatsim_data = {}\n      @vatsim_data_status = {}\n      @vatsim_data_status_file = File.join(File.dirname(__FILE__), 'vatsim_status.txt')\n      @vatsim_status_file = File.join(File.dirname(__FILE__), 'vatsim_status.txt')\n      @vatsim_data_status = {}\n      @vatsim_data_status_file = File.join(File.dirname",
        "def download_url(url)\n      uri = URI.parse(url)\n      http = Net::HTTP.new(uri.host, uri.port)\n      http.use_ssl = true\n      http.verify_mode = OpenSSL::SSL::VERIFY_NONE\n      request = Net::HTTP::Get.new(uri.request_uri)\n      response = http.request(request)\n      File.open(uri.path, 'wb') do |f|\n        response.read_body do |chunk|\n          f.write(chunk)\n        end\n      end\n    end",
        "def random_url\n      url = @status_file.read.split(\"\\n\")[0]\n      url = url.split(\"/\").last if url.split(\"/\").last.length > 1\n      url\n    end",
        "def clear\n      @mutex.synchronize do\n        @cache.clear\n        @cache.clear_if { |k, v| v.is_a?(Time) }\n      end\n    end",
        "def writer(writer)\n      @writer = writer\n      if writer.is_a?(String)\n        @writer = JSON::Writer.new(writer)\n      end\n    end",
        "def check_file_existence(file_path)\n      if File.exist?(file_path)\n        File.read(file_path)\n      else\n        raise \"File #{file_path} does not exist\"\n      end\n    end",
        "def common_elements(array)\n      array.inject([]) do |result, element|\n        result << element if element.common_element?\n        result\n      end\n    end",
        "def run\n      @thread_group.run\n      @thread_group.join\n    rescue Interrupt\n      @thread_group.kill\n    rescue Exception => e\n      @thread_group.kill\n      raise e\n    end",
        "def add_watcher(watcher)\n      raise ArgumentError, \"Watcher must be a Watcher\" unless watcher.is_a?(Watcher)\n      @watchers << watcher\n      watcher.on_change do |event|\n        @observers.each do |observer|\n          observer.on_change(event)\n        end\n      end\n    end",
        "def start_listening\n      @listening = true\n      @queue.subscribe(observer_class) do |*args|\n        @queue.push(*args)\n        @queue.shift if @queue.size > 1\n      end\n    end",
        "def unregister_observer(observer)\n      @mutex.synchronize do\n        @observers.delete(observer)\n        if @observers.empty?\n          @cancel_timer.cancel if @cancel_timer\n          @cancel_timer = nil\n        end\n      end\n    end",
        "def observer_queue\n      @observer_queue ||= Queue.new do |queue|\n        queue.subscribe(ModelWatcher, :all) do |*args|\n          # TODO: Handle model events\n        end\n      end\n    end",
        "def to_json(options = {})\n      data = {\n        'id' => id,\n        'name' => name,\n        'type' => type,\n        'attributes' => attributes,\n        'parameters' => parameters,\n        'links' => links,\n        'links_attributes' => links_attributes,\n        'links_parameters' => links_parameters,\n        'links_links' => links_links,\n        'links_links_attributes' => links_links_attributes,\n        'links_links_parameters' => links_links_parameters,\n        'links_links_links' => links_links_links,\n        'created_at' => created_at,\n        'updated_at' => updated_at,\n        'deleted_at' => deleted_at,\n        'deleted' => deleted?\n      }\n      if options[:omit",
        "def action=(action)\n      if action.is_a?(String)\n        action = action.downcase\n        if action == 'post'\n          self.post_id = nil\n        elsif action == 'draft'\n          self.post_id = nil\n        end\n      end\n      self.action = action\n    end",
        "def action=(action)\n      if action.is_a?(String)\n        action = action.downcase\n        if action == 'publish'\n          self.state = 'published'\n        elsif action == 'unpublish'\n          self.state = 'unpublished'\n        end\n      end\n      self.action = action\n    end",
        "def publish(topic, message, options = {})\n      options = {\n        :persistent => true,\n        :no_declare => true,\n        :no_declare_timeout => 30,\n        :no_ack => true,\n        :no_ack_timeout => 30,\n        :no_retry => true,\n        :no_retry_timeout => 30,\n        :no_response => true,\n        :no_response_timeout => 30,\n        :no_timeout => 30\n      }.merge(options)\n\n      if options[:persistent]\n        options[:persistent] = true\n      end\n\n      if options[:no_declare]\n        options[:no_declare] = true\n      end\n\n      if options[:no_declare_timeout]\n        options[:no_declare_timeout] = 30\n      end\n\n      if options[:no_ack]",
        "def resolve_relative_links(text)\n      links = text.scan(RELATIVE_LINKS_REGEX).flatten\n      links.map! do |link|\n        link.gsub(RELATIVE_LINKS_REGEX, '{file:}')\n      end\n      text.gsub(RELATIVE_LINKS_REGEX, links.join(''))\n    end",
        "def build_connection\n      if @ssl\n        ssl_config = @ssl_config\n      else\n        ssl_config = @ssl_config_default\n      end\n\n      if @ssl_verify\n        ssl_config.verify_mode = OpenSSL::SSL::VERIFY_PEER\n      end\n\n      if @ssl_ca_file\n        ssl_config.ca_file = @ssl_ca_file\n      end\n\n      if @ssl_cert_file\n        ssl_config.cert_file = @ssl_cert_file\n      end\n\n      if @ssl_key_file\n        ssl_config.key_file = @ssl_key_file\n      end\n\n      if @ssl_ca_file\n        ssl_config.ca_file = @ssl_ca_file\n      end\n\n      if @ssl_verify_mode\n        ssl_config.verify",
        "def add_entitity(entitity)\n      raise ArgumentError, \"Entitity must be a Hash\" unless entitity.is_a?(Hash)\n      raise ArgumentError, \"Entitity must have a :name key\" unless entitity[:name]\n      raise ArgumentError, \"Entitity must have a :email key\" unless entitity[:email]\n      raise ArgumentError, \"Entitity must have a :phone_number key\" unless entitity[:phone_number]\n      raise ArgumentError, \"Entitity must have a :message key\" unless entitity[:message]\n      raise ArgumentError, \"Entitity must have a :status key\" unless entitity[:status]\n      raise ArgumentError, \"Entitity must have a :created_at key\" unless entitity[:created_at]\n      raise ArgumentError, \"Entitity must have a :updated_at",
        "def delete_entitity(entitity_id)\n      params = {\n          'action' => 'deleteEntitity',\n          'entitityId' => entitity_id\n      }\n      json = send_request(params)\n      json['response']['status'] == 'Success'\n    end",
        "def get_server(id)\n      url = \"#{@xero_url}/Servers/#{id}\"\n      response = connection.get(url)\n      server = Server.new(response.parsed_response)\n      server\n    end",
        "def get_server(name)\n      url = base_api_url + \"/servers/#{name}\"\n      response = self.class.get(url, body: self.options)\n      self.full_response = response\n      self.status = response['status']\n      server = Server.new(response['data'])\n      server\n    end",
        "def list_servers_by_label(label)\n      label = label.to_s\n      begin\n        @servers.list_servers_by_label(label)\n      rescue => ex\n        Util.log_exception(ex, caller_locations(1, 1)[0].label)\n        raise ex\n      end\n    end",
        "def subscribe(client, exchange, queue_name = nil, options = {}, &block)\n      queue_name ||= exchange.queue_name\n      queue = client.queue(queue_name, options, &block)\n      queue.subscribe(exchange, options, &block)\n    end",
        "def consumer(queue_name, exchange_name, routing_keys=[], &block)\n      queue = queue(queue_name)\n      exchange = exchange(exchange_name)\n      consumer = queue.consumer(exchange, routing_keys, &block)\n      consumer.run\n      consumer\n    end",
        "def queue(queue_name, exchange_name, options = {})\n      queue = @channel.queue(queue_name, exchange_name, options)\n      queue.bind\n      queue\n    end",
        "def subscribe(queue, options = {}, &block)\n      queue.subscribe(options, &block)\n    rescue => e\n      raise e unless e.is_a?(RuntimeError)\n      queue.delete(true)\n      raise e\n    end",
        "def open_channel\n      channel = @channel\n      if channel.nil?\n        channel = Bunny.new(\n          :host => Isimud.host,\n          :port => Isimud.port,\n          :v => Isimud.v,\n          :prefetch_count => Isimud.prefetch_count,\n          :persistent => Isimud.persistent,\n          :use_ssl => Isimud.use_ssl,\n          :ssl_ca_file => Isimud.ssl_ca_file,\n          :ssl_cert_file => Isimud.ssl_cert_file,\n          :ssl_key_file => Isimud.ssl_key_file,\n          :ssl_ca_path => Isimud.ssl_ca_path,\n          :ssl_cipher_list => Isimud.ssl_cipher_list,\n",
        "def publish(exchange, routing_key, payload, options = {})\n      message = Message.new(routing_key, payload, options)\n      exchange.publish message.to_json, options\n    end",
        "def timestamp\n      return nil unless post\n      post.created_at.strftime('%Y-%m-%dT%H:%M:%SZ')\n    end",
        "def draft\n      draft = self.class.draft.new\n      draft.user_id = self.user_id\n      draft.org_id = self.org_id\n      draft.draft_text = self.draft_text\n      draft.save\n      draft\n    end",
        "def save_draft(draftpath, options = {})\n      options = {\n        :keep_draft => false,\n        :keep_timestamp => false\n      }.merge(options)\n\n      draftpath = File.join(source_path, draftpath)\n\n      if options[:keep_draft]\n        if File.exist?(draftpath)\n          raise \"Draft already exists at #{draftpath}\"\n        end\n\n        File.open(draftpath, 'w') do |f|\n          f.write(self.draft)\n        end\n      end\n\n      if options[:keep_timestamp]\n        if File.exist?(draftpath)\n          raise \"Draft already exists at #{draftpath}\"\n        end\n\n        File.open(draftpath, 'w') do |f|\n          f.write(Time.now.to_s)\n        end",
        "def get_user_id(email)\n      begin\n        user = User.new(email)\n        user.id\n      rescue\n        nil\n      end\n    end",
        "def convert_to_c_fun(value)\n      case value\n      when Array\n        value.map { |v| convert_to_c_fun(v) }\n      when Hash\n        Hash[value.map { |k, v| [k.to_s, convert_to_c_fun(v)] }]\n      else\n        value\n      end\n    end",
        "def can?(action, *args)\n      if args.empty?\n        super\n      else\n        super(action, *args) && args.first.is_a?(CanCan::Model)\n      end\n    end",
        "def daemonize\n      if @daemonize\n        return\n      end\n\n      if @options[:daemonize]\n        # Daemonize the process\n        Process.daemon(@options[:daemonize])\n\n        # Wait for the process to exit\n        Process.waitpid(@pid)\n\n        # Kill the process\n        Process.kill('TERM', @pid)\n      end\n\n      @daemonize = true\n    end",
        "def run\n      @app.run\n      @app.logger.info \"Application #{@app.name} has been run\"\n      @app.logger.info \"Application #{@app.name} started\"\n      @app.logger.info \"Application #{@app.name} exiting\"\n      @app.logger.info \"Application #{@app.name} exiting\"\n      @app.logger.info \"Application #{@app.name} exiting\"\n      @app.logger.info \"Application #{@app.name} exiting\"\n      @app.logger.info \"Application #{@app.name} exiting\"\n      @app.logger.info \"Application #{@app.name} exiting\"\n      @app.logger.info \"Application #{@app.name} exiting\"\n      @app.logger.info \"Application #{@app.name} exiting\"\n      @app.logger.info \"Application #{@app.name} exiting\"\n",
        "def check_posts_dir\n      posts_dir = File.expand_path(\"_posts\", File.dirname(__FILE__))\n      if File.directory?(posts_dir)\n        return posts_dir\n      end\n\n      config_file = File.expand_path(\"_config.yml\", File.dirname(__FILE__))\n      if File.directory?(config_file)\n        return config_file\n      end\n\n      src_dir = File.expand_path(\"src\", File.dirname(__FILE__))\n      if File.directory?(src_dir)\n        return src_dir\n      end\n\n      puts \"Could not find a _posts directory in current directory.  Please make sure it's in the same directory as the _config.yml file and that it's a directory containing a src directory.\"\n      exit\n    end",
        "def get_layout(layout_path=nil)\n      if layout_path\n        layout_path = File.expand_path(layout_path)\n        if File.exists?(layout_path)\n          layout_contents = File.read(layout_path)\n          layout_contents.sub!(/^#/, '')\n          layout_contents.sub!(/\\.erb$/, '')\n          return layout_contents, layout_path.extname\n        end\n      end\n      return DEFAULT_LAYOUT, DEFAULT_LAYOUT_EXT\n    end",
        "def usage\n      puts \"Usage: rake rake_tasks [options]\"\n      puts \"Options:\"\n      puts \"  -h, --help             Show this help message\"\n      puts \"  -v, --version          Show version and exit\"\n      puts \"  -t, --tasks [tasks]  Run a specific task(s)\"\n      puts \"  -c, --config [config]  Use a specific config file\"\n      puts \"  -t, --tasks [tasks]  Run a specific task(s) with custom config\"\n      puts \"  -p, --port [port]     Use a specific port\"\n      puts \"  -u, --username [username]  Use a specific username\"\n      puts \"  -p, --password [password]  Use a specific password\"\n      puts \"  -t, --host [host]     Use a specific host\"\n",
        "def index\n      @messages = Message.where(user_id: current_user.id, notification_type: 'primary')\n\n      respond_to do |format|\n        format.html # index.html.erb\n        format.json { render json: @messages }\n      end\n    end",
        "def send_message(message)\n      message = message.to_s\n      if @socket.nil?\n        puts \"No socket to send message to\"\n        return\n      end\n      begin\n        @socket.puts(message)\n      rescue Errno::EPIPE\n        puts \"Connection closed by remote host\"\n      end\n    end",
        "def analyze(string, options = {})\n      symbol_sequence = options[:symbol_sequence] || []\n      result = []\n      string.split(//).each do |char|\n        if char =~ /[A-Za-z]/\n          result << char\n        elsif char =~ /[A-Za-z0-9]/\n          result << char\n        elsif char =~ /[A-Za-z0-9_]/\n          result << char\n        elsif char =~ /[A-Za-z]/\n          result << char\n        elsif char =~ /[A-Za-z0-9_]/\n          result << char\n        elsif char =~ /[A-Za-z0-9]/\n          result << char.upcase\n        elsif char =~ /[A-Za-z0-9_]/\n          result << char.downcase\n        elsif char =~ /[",
        "def generate_strings(string)\n      return [] unless string\n      string.split(/\\s+/).map { |s| s.strip }.reject { |s| s.empty? }\n    end",
        "def configure_cli\n      @cli = Cli.new\n      @cli.name = @name\n      @cli.version = @version\n      @cli.description = @description\n      @cli.help = @help\n      @cli.help_text = @help_text\n      @cli.options = @options\n      @cli.config = @config\n      @cli.config_file = @config_file\n      @cli.config_path = @config_path\n      @cli.config_path = @config_path if @config_path\n      @cli.config_path = @config_path if @config_path\n      @cli.config_path = @config_path if @config_path\n      @cli.config_path = @config_path if @config_path\n      @cli.config_path = @config_path if @config_path\n      @",
        "def parse_specs_file(path)\n      specs = []\n      File.open(path, 'r') do |f|\n        f.each do |line|\n          if line =~ /^#\\s*spec\\s+([a-zA-Z0-9_]+)\\s*$/\n            spec_name = $1\n            spec = Spectro::Spec.new(spec_name)\n            specs << spec\n          end\n        end\n      end\n      specs\n    end",
        "def remove_non_reporting_servers\n      @non_reporting_servers.each do |server|\n        if server['status'] != 'Stopped'\n          server['status'] = 'Stopped'\n          server['last_report'] = Time.now\n          server['last_report_id'] = nil\n          server['status_reason'] = nil\n          server['status_message'] = nil\n          server['status_details'] = nil\n          server['status_data'] = nil\n          server['status_data_id'] = nil\n          server['status_type'] = nil\n          server['status_reason'] = nil\n          server['status_message'] = nil\n          server['status_details'] = nil\n          server['status_data'] = nil\n          server['status_data_id'] = nil\n          server['status_type'] = nil\n          server['status_reason",
        "def find_excluded_servers(servers, management_server)\n      excluded_servers = []\n      if management_server\n        excluded_servers = servers.select { |s| !management_server.id.include?(s.id) }\n      else\n        excluded_servers = servers.select { |s| !s.id.include?(management_server.id) }\n      end\n      excluded_servers\n    end",
        "def send_sms(message, options = {})\n      options = {\n        :body => message,\n        :from => @options[:from],\n        :to => @options[:to],\n        :subject => @options[:subject]\n      }.merge(options)\n\n      response = RestClient.post(\n        \"#{@gateway_url}/sms/send\",\n        :query => {\n          :token => @token\n        },\n        :body => options[:body]\n      )\n\n      @options[:response_handler].call(response)\n    end",
        "def send_phone_call(phone_number, options = {})\n      options = {\n        :phone_number => phone_number,\n        :options => {}\n      }.merge(options)\n\n      response = self.class.post(\"/phone_calls\", options)\n      self.full_response = response\n      self.status = response['status']\n      self.response_body = response['response']['body']\n    end",
        "def validate(data)\n      return if data.nil?\n      return if data.empty?\n\n      # Check for valid UTF-8 data\n      if data.respond_to?(:force_encoding)\n        data = data.force_encoding('UTF-8')\n      end\n\n      # Check for valid UTF-16 data\n      if data.respond_to?(:force_encoding)\n        data = data.force_encoding('UTF-16LE')\n      end\n\n      # Check for valid UTF-32 data\n      if data.respond_to?(:force_encoding)\n        data = data.force_encoding('UTF-32BE')\n      end\n\n      # Check for valid UTF-8 data\n      if data.respond_to?(:encode)\n        data = data.encode('UTF-8')\n      end\n\n      # Check for valid UTF-16 data\n",
        "def start\n      raise XFTP::Error, \"Session already started\" if @started\n      @started = true\n      @socket.connect\n      @socket.send(XFTP::Message::SessionStart.new)\n      @socket.recv_message(XFTP::Message::SessionStatus.new)\n      @socket.recv_message(XFTP::Message::SessionStatus.new)\n      @socket.recv_message(XFTP::Message::SessionStatus.new)\n      @socket.recv_message(XFTP::Message::SessionStatus.new)\n      @socket.recv_message(XFTP::Message::SessionStatus.new)\n      @socket.recv_message(XFTP::Message::SessionStatus.new)\n      @socket.recv_message(XFTP::Message::SessionStatus.new)\n      @socket.recv_message(XFTP::Message::SessionStatus.new)\n",
        "def geo_attributes(table, field_name, value)\n      query = \"SELECT #{field_name} FROM #{table} WHERE #{value} LIKE ? \"\n      results = @connection.query(query, [value])\n      results.map { |row| Hash[row.map { |k, v| [k.to_s, v.to_s] }] }\n    end",
        "def apply_adjuster(condition, adjuster)\n      if condition.is_a?(Proc)\n        lambda do |*args|\n          condition.call(*args)\n        end.to_proc\n      elsif condition.is_a?(Method)\n        lambda do |*args|\n          condition.call(*args)\n        end.to_proc\n      else\n        raise ArgumentError, \"Invalid adjuster\"\n      end\n    end",
        "def apply_adjusters(adjuster1, adjuster2, adjusters)\n      lambda do |event|\n        adjusters.call(event)\n        adjuster1.call(event) if adjuster1.respond_to?(:call)\n        adjuster2.call(event) if adjuster2.respond_to?(:call)\n      end\n    end",
        "def on_parser(parser)\n      @parser = parser\n      lambda do |node|\n        case node\n        when :call\n          @parser.call(node)\n        when :call_with_block\n          @parser.call_with_block(node)\n        when :call_without_block\n          @parser.call_without_block(node)\n        when :call_with_block_arg\n          @parser.call_with_block_arg(node)\n        when :call_without_block_arg\n          @parser.call_without_block_arg(node)\n        when :call_with_block_arg_with_value\n          @parser.call_with_block_arg_with_value(node)\n        when :call_without_block_arg_with_value\n          @parser.call_without_block_arg_with_",
        "def class_for(name)\n      name = name.to_s\n      if name =~ /\\A[a-z0-9_]+\\z/\n        name.gsub!(/\\A[a-z0-9_]+\\z/i, '')\n        name.gsub!(/([A-Z])/, '\\1').downcase!\n        name.gsub!(/([a-z])([A-Z])/, '\\1_\\2')\n        name.gsub!(/([a-z])([A-Z])/, '\\1_\\2')\n        name.gsub!(/([a-z])([A-Z])/, '\\1')\n        name.downcase!\n        return name.constantize\n      end\n      return nil\n    end",
        "def make_lazy_connection(host, port, user, password)\n      if @lazy_connection\n        @lazy_connection.close\n      end\n      @lazy_connection = TCPSocket.new(host, port)\n      @lazy_connection.sync = true\n      @lazy_connection.connect\n      @lazy_connection.sync = true\n      @lazy_connection\n    end",
        "def desired_time(start_time, timeout)\n      raise TypeError, 'start_time must be nil or a Time' unless start_time.nil? || start_time.is_a?(Time)\n      raise ArgumentError, 'start_time must be positive' if start_time < 0\n      return start_time if timeout.nil?\n      raise ArgumentError, 'timeout must be positive' if timeout < 0\n      return timeout if timeout == 0\n      return start_time + timeout\n    end",
        "def crud_links(model, name, actions)\n      return '' unless model\n      return '' unless model.respond_to?(:crud_links)\n      return '' unless actions.present?\n\n      if use_crud_icons\n        icon_tag = if model.respond_to?(:crud_icon)\n          model.crud_icon\n        else\n          'fa-fw fa-list-ol'\n        end\n        link_to(icon_tag, crud_path(model, name, actions))\n      else\n        link_to(icon_tag, crud_path(model, name, actions), :class => 'crud_links')\n      end\n    end",
        "def search_engine_spider_link(url, options = {})\n      options = {\n        :rel => 'search',\n        :type => 'application/json',\n        :title => 'Search Engine Spiders'\n      }.merge(options)\n\n      link_to(url, options) do\n        'Search Engine Spiders'\n      end\n    end",
        "def highlight_errors(html)\n      return html unless Rails.application.config.validation_errors_highlight\n\n      html = html.html_safe\n      html = html.gsub(/%\\{(\\w+)\\}/) do |m|\n        m = m.to_s\n        if m =~ /\\A\\{(\\w+)\\}/\n          \"#{m[1].to_s.colorize(:red)} #{m[2].colorize(:red)}\"\n        else\n          m\n        end\n      end\n\n      html = html.gsub(/%\\{(\\w+)\\}/, \"#{Rails.application.config.validation_errors_highlight[m.to_sym]} #{m}\")\n      html\n    end",
        "def select_tag_for_filter(name, filters, params)\n      filters = filters.collect{|f| f[:scope]}.compact\n      if params[:show] && params[:show] != \"all\" && filters.collect{|f| f[:scope]}.include?(params[:show])\n        options = filters.collect{|f| [f[:scope], f[:label]]}.to_h\n        options[:multiple] = true\n        options[:value] = params[:show]\n        select_tag(name, options)\n      else\n        options = filters.collect{|f| [f[:scope], f[:label]]}.to_h\n        select_tag(name, options)\n      end\n    end",
        "def sort_link(resource_name, field, params = {})\n      if resource_name.to_s.include?('_admin')\n        resource_name = resource_name.to_s.split('_').last\n      end\n\n      if resource_name.to_s.include?('admin')\n        resource_name = resource_name.to_s.split('admin_').last\n      end\n\n      if resource_name.to_s.include?('admin')\n        resource_name = resource_name.to_s.split('admin_').last\n      end\n\n      if resource_name.to_s.include?('admin')\n        resource_name = resource_name.to_s.split('admin_').last\n      end\n\n      if resource_name.to_s.include?('admin')\n        resource_name = resource",
        "def tag_for_label_with_inline_help(label, id, help_text, options = {})\n      options = { :class => 'inline_help' }.merge options\n      options[:id] = id\n      options[:onclick] = \"jQuery('##{id}').toggle();\"\n      label_tag label, options\n    end",
        "def key_down(keycode)\n      key = keycode.to_sym\n      if key_map.has_key?(key)\n        @key_state = :down\n        @key_map[key]\n      elsif key_map.has_key?(key_map.keys.first)\n        @key_state = :down\n        @key_map.keys.first\n      else\n        nil\n      end\n    end",
        "def open_file(path, options = {})\n      options = {\n        title: 'Open File',\n        default_ext: 'txt',\n        default_dir: '.',\n        default_file: 'open.txt',\n        default_file_type: :txt,\n        default_title: 'Open File',\n        default_icon: 'file_open',\n        default_callback: nil,\n        default_confirm: 'Do you want to open this file?',\n        default_cancel: 'Cancel',\n        default_width: 600,\n        default_height: 400,\n        default_x: 0,\n        default_y: 0,\n        default_width_callback: nil,\n        default_height_callback: nil,\n        default_x_offset: 0,\n        default_y_offset: 0,\n        default_width_offset: 0",
        "def options\n      @options ||= begin\n        options = {}\n        options[:verbose] = @verbose\n        options[:quiet] = @quiet\n        options[:color] = @color\n        options[:color_output] = @color_output\n        options[:color_error] = @color_error\n        options[:color_warning] = @color_warning\n        options[:color_info] = @color_info\n        options[:color_detailed] = @color_detailed\n        options[:color_pass] = @color_pass\n        options[:color_fail] = @color_fail\n        options[:color_unknown] = @color_unknown\n        options[:color_pass_with_help] = @color_pass_with_help\n        options[:color_fail_with_help] = @color_fail_with_help\n        options[:color_unknown_with_",
        "def add_path(path)\n      path = path.to_s\n      if File.exist?(path)\n        raise GitError, \"Path #{path} already exists\"\n      end\n      @gitattributes << path\n    end",
        "def run\n      if @options[:skip_migration]\n        puts \"Skipping migration #{@options[:migration]}\"\n        return\n      end\n\n      @options[:migration] = @options[:migration].to_sym\n      @options[:migration_class] = @options[:migration].to_s.camelize.constantize\n\n      @options[:migration_class].migration_name = @options[:migration]\n      @options[:migration_class].migration_class_name = @options[:migration_class].to_s.camelize.constantize.name\n\n      @options[:migration_class].migration_class_name.constantize.migration_name = @options[:migration]\n      @options[:migration_class].migration_class_name.constantize.migration_class_name = @options[:migration_class].to_s.camelize.constantize.name\n\n      @options[:migration",
        "def parents_closest_to(furthest)\n      parents.select { |p| p.distance_to(furthest) <= furthest.distance_to(parent) }\n    end",
        "def extract_text(attributes)\n      attributes = attributes.to_s.split(',').map(&:strip)\n      attributes.map! do |attribute|\n        attribute.to_s.gsub(/\\s+/, ' ')\n      end\n      attributes.join(' ')\n    end",
        "def to_query_hash\n      query = {}\n      self.class.query_attributes.each do |attr|\n        query[attr] = send(attr)\n      end\n      query\n    end",
        "def uri\n      uri = 'ws://'\n      uri << @host\n      uri << ':' << @port.to_s\n      uri << @path\n      uri << '?wsdl'\n      uri << '&wsdl' if @use_wsdl\n      uri\n    end",
        "def parse_config_file(config_file)\n      config = {}\n      config_file.each do |line|\n        if line =~ /^#/\n          next\n        end\n        key, value = line.split('=', 2)\n        config[key.strip] = value.strip\n      end\n      config\n    end",
        "def check_script(script, script_hash)\n      return unless script\n      return if script_hash['script'] == script\n      raise ScriptError, \"Script hash mismatch for hook #{script_hash['hook_name']}\"\n    end",
        "def populate_host_table\n      @hosts = []\n      @fqdn_list = []\n      @host_names = []\n      @host_names_by_id = {}\n      @host_names_by_fqdn = {}\n      @host_ports = {}\n      @host_ports_by_id = {}\n      @host_ports_by_fqdn = {}\n      @host_interfaces = {}\n      @host_interfaces_by_id = {}\n      @host_interfaces_by_fqdn = {}\n      @host_interfaces_by_address = {}\n      @host_interfaces_by_address_prefix = {}\n      @host_interfaces_by_address_prefix_list = []\n      @host_interfaces_by_address_prefix_list.push([\"0.0.0.0\", \"0.0.0.0\"",
        "def create_database\n      if @options[:database]\n        @options[:database] = @options[:database].to_s\n        if @options[:database].empty?\n          raise ArgumentError, \"Database name cannot be empty\"\n        end\n        if @options[:database].include?(':')\n          raise ArgumentError, \"Database name cannot contain a colon\"\n        end\n        @options[:database] = @options[:database].to_sym\n        if @options[:database].to_sym != :mysql\n          raise ArgumentError, \"Database name must be :mysql\"\n        end\n        @options[:database] = :mysql\n      end\n      if @options[:user] && @options[:password]\n        raise ArgumentError, \"You must specify both a user and password\"\n      end\n      if @options[:user]\n        @options[:user] = @options[:user].to_s\n       ",
        "def update_database\n      if @foreman_hook\n        @foreman_hook.update_database\n        @foreman_hook.clear_cache\n      end\n    end",
        "def read_list_attribute(node, attribute)\n      value = node.xpath(\"./cda:value/@value\", @ds_namespaces).text\n      value = value.to_s if value.is_a?(String)\n      value\n    end",
        "def read_hash(name)\n      if name =~ /^[a-z0-9_]+$/\n        name = name.to_s.downcase\n      end\n      if name =~ /^[a-z0-9_]+$/\n        name = name.to_s.downcase.gsub(/[^a-z0-9_]/i, '_')\n      end\n      name = name.to_sym\n      if self.class.attribute_map.has_key?(name)\n        return self.class.attribute_map[name]\n      else\n        raise ArgumentError, \"Attribute not found: #{name}\"\n      end\n    end",
        "def write_standard_attribute(name, value)\n      if value.is_a?(Hash)\n        write_standard_attribute_hash(name, value)\n      elsif value.is_a?(Array)\n        write_standard_attribute_array(name, value)\n      else\n        write_standard_attribute_string(name, value)\n      end\n    end",
        "def write_list(value)\n      if value.is_a?(Array)\n        write_array(value)\n      elsif value.is_a?(Hash)\n        write_hash(value)\n      else\n        raise ArgumentError, \"Can't write #{value.class} into list\"\n      end\n    end",
        "def transform_hash(hash)\n      hash.each do |k, v|\n        self[k] = v.is_a?(Hash) ? transform_hash(v) : v\n      end\n    end",
        "def update_fields(fields)\n      fields.each do |field, value|\n        if value.is_a?(Array)\n          value.each do |v|\n            self.send(\"#{field}=\", v)\n          end\n        else\n          self.send(\"#{field}=\", value)\n        end\n      end\n    end",
        "def filter_objects(method, objects, user = nil)\n      objects.select do |object|\n        policy = self.class.policy_class_for(object)\n        policy.send(method, user)\n      end\n    end",
        "def authorize_with_policy(policy, *args)\n      authorize!(policy, *args)\n    rescue ActionController::RoutingError => e\n      raise e unless e.message =~ /^404/\n      false\n    end",
        "def nethash(interval = 500, start = 0, stop = Infinity)\n      options = {\n        :interval => interval,\n        :start => start,\n        :stop => stop\n      }\n      get '/nethash', options\n    end",
        "def first(limit: nil, offset: nil)\n      limit = limit.to_i if limit.is_a?(Symbol)\n      offset = offset.to_i if offset.is_a?(Symbol)\n      ids = ids_with_offset(limit, offset)\n      return nil if ids.empty?\n      ids.first\n    end",
        "def find_by_id(ids)\n      ids = ids.to_a if ids.is_a?(Integer)\n      ids = ids.map(&:to_i) if ids.is_a?(Array)\n      return nil if ids.empty?\n      self.class.where(id: ids).first\n    end",
        "def each(options = {}, &block)\n      if block_given?\n        batch_size = options[:batch_size] || 500\n        start = options[:start] || 0\n        index = 0\n        loop do\n          articles = @client.get_articles(start, batch_size, index)\n          index += batch_size\n          yield articles\n        end\n      else\n        yield []\n      end\n    end",
        "def load_loader(path)\n      return unless File.exist?(path)\n\n      begin\n        require path\n      rescue LoadError\n        raise \"Failed to load #{path}\"\n      end\n    end",
        "def mapped_key(key)\n      key = key.to_s\n      key = key.to_sym if key.is_a?(Symbol)\n      key = key.to_s.to_sym if key.is_a?(String)\n      key\n    end",
        "def processors\n      # This is a bit of a hack, but it works out for some reason.\n      #\n      # On AIX 5+, /proc/cpuinfo returns a string of the form:\n      #\n      #   \"4,000,000,000\"\n      #\n      # On AIX 6+, /proc/cpuinfo returns a string of the form:\n      #\n      #   \"4,000,000,000,000\"\n      #\n      # On AIX 7+, /proc/cpuinfo returns a string of the form:\n      #\n      #   \"4,000,000,000,000\"\n      #\n      # On AIX 10+, /proc/cpuinfo returns a string of the form:\n      #\n      #   \"4,000,000,000,000\"\n      #\n      # On AIX 10.1+",
        "def num_physical_processors\n      # Get the list of all processors on the current system\n      # and return the number of processors in the list\n      #\n      # @return [Integer]\n      #\n      # @example Get the number of physical processors on the current system\n      #   REXML::XPath.first(@xml, 'System/Processor')\n      #   # => 1\n      #\n      # @example Get the number of physical processors on the current system\n      #   REXML::XPath.first(@xml, 'System/Processor[@name=\"Intel\"]')\n      #   # => 1\n      #\n      # @example Get the number of physical processors on the current system\n      #   REXML::XPath.first(@xml, 'System/Processor[@name=\"Intel (R)\"]')\n      #   # => 1\n      #\n      # @example Get the number of",
        "def run\n      @logger.info \"Starting #{name}...\"\n      @logger.info \"Running #{name}...\"\n      @logger.info \"Running #{name} with options: #{options.inspect}\"\n      @logger.info \"Running #{name} with options: #{options.inspect} with env: #{env.inspect}\"\n      @logger.info \"Running #{name} with env: #{env.inspect} with config: #{config.inspect}\"\n      @logger.info \"Running #{name} with config: #{config.inspect} with env: #{env.inspect}\"\n      @logger.info \"Running #{name} with config: #{config.inspect} with config: #{config.inspect} with env: #{env.inspect}\"\n      @logger.info \"Running #{name} with config: #{config.inspect} with config: #{config.inspect} with config: #{config.inspect} with env",
        "def reload\n      @events = []\n      @events = YAML.load_file(@file) if File.exist?(@file)\n      @events = @events.delete_if { |e| e.file == @file } if @file\n      @events\n    end",
        "def followee_of?(other)\n      other = other.to_model if other.respond_to?(:to_model)\n      return false unless other\n      return false unless self.class.following_model_name == other.class.following_model_name\n      self.class.following_model_name.downcase == other.class.following_model_name.downcase\n    end",
        "def ever_followed\n      @ever_followed ||= begin\n        if self.following_user_id\n          Follow.where(user_id: self.following_user_id, model_id: self.id).order('created_at DESC').limit(1).all\n        else\n          Follow.where(model_id: self.id).order('created_at DESC').limit(1).all\n        end\n      end\n    end",
        "def sleep_until(mutex, timeout: nil)\n      raise TypeError, 'timeout must be nil or Numeric' unless timeout.nil? || timeout.is_a?(Numeric)\n      raise ArgumentError, 'timeout must be positive' unless timeout.positive?\n\n      mutex.synchronize do\n        @sleeping = true\n        @cond.wait(mutex, timeout: timeout)\n      end\n\n      self\n    end",
        "def validate_timeout(timeout)\n      if timeout.is_a?(Numeric)\n        raise TypeError, \"timeout must be nil or a Numeric\" unless timeout.nil? || timeout.is_a?(Numeric)\n        raise ArgumentError, \"timeout must be negative\" if timeout < 0\n      end\n    end",
        "def render_template(template, handler)\n      template = template.to_s\n      template = template.gsub('{{handler}}', handler.to_s)\n      template = template.gsub('{{template}}', template)\n      template\n    end",
        "def race_resistant_race_clear(n)\n      # this is a race-resistant attempt to make sure that there is only 1\n      # clear 'winner' among N potential agents attempting to run the same goal on the\n      # same spreadsheet agent's cell\n      #\n      # this call is not thread-safe\n      #\n      # @param n the number of potential agents attempting to run the same goal on the\n      # same spreadsheet agent's cell\n      #\n      # @return the number of potential agents attempting to run the same goal on the\n      # same spreadsheet agent's cell\n      #\n      # @exception ArgumentError if n is negative\n      #\n      # @author Jeffrey Rodger\n      #\n      def race_resistant_clear_n(n)\n        # the number of potential agents attempting to run the same goal on the\n        # same spreadsheet agent's",
        "def pick_from_many(options = {})\n      cards = []\n      cards = options[:cards] if options[:cards]\n      cards = self.class.pick_from_many(self, options) if cards.empty?\n      cards.first\n    end",
        "def discard_card(card)\n      if @hand.size > 1\n        # If you have a card on the hand, you can discard it\n        if @hand.last == card\n          # If you have a card on the hand, you can discard it\n          @hand.pop\n          return card\n        else\n          # If you have a card on the hand, you can discard it\n          return nil\n        end\n      else\n        # If you have a card on the hand, you can discard it\n        return card\n      end\n    end",
        "def on_turn\n      if @game.in_game?\n        @game.move_to_next_move\n      else\n        @game.move_to_previous_move\n      end\n    end",
        "def sleep(timeout = nil)\n      raise TypeError, 'timeout must be nil or Numeric' unless timeout.nil? || timeout.is_a?(Numeric)\n      raise ArgumentError, 'timeout must be positive' unless timeout.positive?\n\n      @mutex.synchronize do\n        begin\n          @cond.wait(@mutex, timeout)\n        rescue ThreadError\n          # ignore\n        end\n      end\n    end",
        "def lock_while(&block)\n      raise ArgumentError, 'block required' unless block_given?\n\n      begin\n        yield\n      rescue => e\n        if e.is_a?(ThreadError)\n          raise e\n        else\n          raise ThreadError, \"Failed to relock #{self} while waiting for #{e.inspect}\"\n        end\n      end\n    end",
        "def elapsed_time\n      return 0.0 if running?\n      return 0.0 if @start_time.nil?\n      elapsed_time = @start_time - @start_time_old\n      elapsed_time = 0.0 if elapsed_time < 0.0\n      elapsed_time = 1.0 if elapsed_time > 1.0\n      elapsed_time\n    end",
        "def wait_until_c_is_hit\n      begin\n        sleep 0.1\n      rescue\n        raise \"sleeping for 1 second\"\n      end\n      begin\n        sleep 0.1\n      rescue\n        raise \"sleeping for 1 second\"\n      end\n      begin\n        sleep 0.1\n      rescue\n        raise \"sleeping for 1 second\"\n      end\n      begin\n        sleep 0.1\n      rescue\n        raise \"sleeping for 1 second\"\n      end\n      begin\n        sleep 0.1\n      rescue\n        raise \"sleeping for 1 second\"\n      end\n      begin\n        sleep 0.1\n      rescue\n        raise \"sleeping for 1 second\"\n      end\n      begin\n        sleep 0.1\n      rescue\n        raise \"sleeping for 1 second\"\n      end\n      begin\n        sleep 0.1\n      rescue\n",
        "def optional(*args, &block)\n      if block_given?\n        options = args.extract_options!\n        options[:block] = block\n        args << options\n        optional(*args, &block)\n      else\n        args << options\n        optional(*args, &block)\n      end\n    end",
        "def extract_ruby_doc(file)\n      doc = REXML::Document.new(File.new(file))\n      doc.elements.each('rdoc') do |rdoc|\n        return rdoc.text\n      end\n      nil\n    end",
        "def select(*fields)\n      fields.flatten.each do |field|\n        define_method(\"#{field}=\") do |value|\n          instance_variable_set(\"@#{field}\", value.is_a?(Array) ? value.first : value)\n        end\n      end\n    end",
        "def set_pagination_info(page, per_page)\n      @page = page\n      @per_page = per_page\n      @total_pages = (@total_entries / @per_page).ceil\n      @current_page = (@page - 1) * @per_page\n      @first_page = (@current_page == 0) ? true : false\n      @last_page = (@total_entries / @per_page) > 1 ? true : false\n    end",
        "def encode_hash(hash)\n      hash.to_json.force_encoding('UTF-8')\n      Base64.strict_encode64(hash.to_json)\n    end",
        "def follower_of?(other)\n      other = other.to_model if other.is_a?(Symbol)\n      return false unless other.respond_to?(:id)\n      return false unless self.id == other.id\n      return true\n    end",
        "def follow(model)\n      if model.respond_to?(:followers)\n        model.followers.where(following_id: id).update_all(following_type: 'follow')\n      elsif model.respond_to?(:following)\n        model.following.where(following_id: id).update_all(following_type: 'follow')\n      end\n    end",
        "def follow(model)\n      if model.respond_to?(:following)\n        model.following.where(following_id: id).update_all(following_type: 'follow')\n      else\n        model.followers.where(follower_id: id).update_all(follower_type: 'follow')\n      end\n    end",
        "def ever_follow\n      return [] unless @jim.following?(@ruby)\n      @jim.followers.where.not(id: @ruby.id).order('created_at DESC').limit(5).map { |f| f.user }\n    end",
        "def get(non_block = false)\n      raise ThreadError, 'Queue is empty' if empty?\n\n      if non_block\n        begin\n          return dequeue(non_block)\n        rescue ThreadError\n          return nil\n        end\n      end\n\n      begin\n        return dequeue\n      rescue ThreadError\n        return nil\n      end\n    end",
        "def lookup(key)\n      if @backend == :http\n        response = @http.get(\n          \"#{@url}/#{key}\",\n          headers: { 'Content-Type' => 'application/json' }\n        )\n      else\n        response = @https.get(\n          \"#{@url}/#{key}\",\n          headers: { 'Content-Type' => 'application/json' }\n        )\n      end\n\n      if response.code == 200\n        JSON.parse(response.body)\n      else\n        raise \"Error while lookup #{key}: #{response.code}\"\n      end\n    end",
        "def announce(key, port, &block)\n      @mutex.synchronize do\n        @services[key] = { port: port, block: block }\n      end\n    end",
        "def build_condition(delegated = :and)\n      lambda do |*args|\n        case delegated\n        when :and\n          [true, *args].flatten.each do |bool|\n            yield bool\n          end\n        when :or\n          [false, *args].flatten.each do |bool|\n            yield bool\n          end\n        when :xor\n          [true, *args].flatten.each do |bool|\n            yield bool\n          end\n        when :xnor\n          [false, *args].flatten.each do |bool|\n            yield bool\n          end\n        else\n          raise ArgumentError, \"Unknown delegated condition: #{delegated}\"\n        end\n      end\n    end",
        "def post(opts = {})\n      opts = {\n        :path => @path,\n        :payload => @payload,\n        :secret => @secret\n      }.merge(opts)\n\n      post_request(opts)\n    end",
        "def height_for_width(width)\n      return 0 if width.nil?\n      width = width.to_i\n      if width < 1\n        raise ArgumentError, \"Width must be greater than 0\"\n      end\n      if width > @image.width\n        raise ArgumentError, \"Width must be less than image width\"\n      end\n      @image.height\n    end",
        "def each_pixel\n      return enum_for(__method__) unless block_given?\n      @image.each_pixel do |x,y|\n        yield(x,y) if (x < @width && y < @height) || (x > @width && y > @height)\n      end\n    end",
        "def find_color(index)\n      index = index.to_i\n      return @colors[index] if @colors[index]\n\n      # Find the index of the color that is the largest\n      index = @colors.length - 1 if index > @colors.length\n      index = 0 if index < 0\n\n      # Find the color that is the smallest\n      @colors.each do |c|\n        if c.index < index\n          index = c.index\n        end\n      end\n\n      # If we didn't find anything, return nil\n      @colors[index]\n    end",
        "def color_string(string)\n      string.split(/\\s+/).each do |color|\n        puts \"  \" + color\n      end\n    end",
        "def build_depth_first_tree\n      return if @root.nil?\n      @root.children.each do |child|\n        build_depth_first_tree(child)\n      end\n    end",
        "def search_for_date(options = {})\n      options = { :date => Date.today.strftime('%Y-%m-%d') }.merge(options)\n      get '/search', options\n    end",
        "def validate_timeout(timeout)\n      return unless timeout.is_a?(Numeric)\n      raise ArgumentError, 'negative timeout value not allowed' if timeout < 0\n      timeout\n    end",
        "def authorize_note(note)\n      if note.author_id\n        note.update_attribute(:author_id, note.author.id)\n        note.save\n      else\n        note.author_id = note.author.id\n        note.save\n      end\n    end",
        "def send_message(message)\n      message = message.to_json\n      if @config.grape_mailer.enabled?\n        @config.grape_mailer.send_message(message)\n      else\n        puts message\n      end\n    end",
        "def include_datepicker_stylesheets(options = {})\n      return if options[:style] == :none\n\n      include_css_file \"bootstrap/datepicker.css\"\n      include_css_file \"bootstrap/datepicker-responsive.css\"\n      include_css_file \"datepicker.css\"\n      include_css_file \"datepicker-responsive.css\"\n\n      include_js_file \"jquery.datepicker.js\"\n      include_js_file \"bootstrap.min.js\"\n      include_js_file \"datepicker.js\"\n      include_js_file \"datepicker-responsive.js\"\n\n      if options[:style] == :inline\n        include_js_file \"datepicker-inline.js\"\n      end\n    end",
        "def method_missing(method, *args)\n      if args.empty?\n        return self.options[method]\n      else\n        return self.options[method] = args.first\n      end\n    end",
        "def hijri_date(year, month, day)\n      hijri_date = Date.new(year, month, day)\n      hijri_date.strftime('%m/%d/%Y')\n    end",
        "def hijri_to_julian(hijri)\n      hijri = hijri.to_s\n      hijri = hijri.gsub(/T/, 'T0')\n      hijri = hijri.gsub(/Z/, 'Z0')\n      hijri = hijri.gsub(/([A-Z])/, '\\1')\n      hijri = hijri.gsub(/([a-z])/, '\\1')\n      hijri = hijri.gsub(/([0-9])/, '\\1')\n      hijri = hijri.gsub(/([A-Z])/, '\\1')\n      hijri = hijri.gsub(/([a-z])/, '\\1')\n      hijri = hijri.gsub(/([0-9",
        "def to_s\n      s = ''\n      s << \"#{year} \" if year != 0\n      s << \"#{month} \" if month != 0\n      s << \"#{day} \" if day != 0\n      s << \"#{hour} \" if hour != 0\n      s << \"#{min} \" if min != 0\n      s << \"#{sec} \" if sec != 0\n      s\n    end",
        "def add_days_to_weeks(days)\n      days.each do |day|\n        if day.weekday == :sunday\n          @days_weeks[day.wday] += 1\n        elsif day.weekday == :monday\n          @days_weeks[day.wday] += 7\n        elsif day.weekday == :tuesday\n          @days_weeks[day.wday] += 30\n        elsif day.weekday == :wednesday\n          @days_weeks[day.wday] += 60\n        elsif day.weekday == :thursday\n          @days_weeks[day.wday] += 120\n        elsif day.weekday == :friday\n          @days_weeks[day.wday] += 180\n        elsif day.weekday == :saturday\n          @days",
        "def plus(date)\n      date = Date.parse(date) unless date.is_a?(Date)\n      date += 24 * 60 * 60\n      self.class.new(date.year, date.month, date.day + 1)\n    end",
        "def error(exception = nil)\n      if @error\n        raise Complete.new(@error) if @error.is_a?(Complete)\n        @error = exception\n      else\n        @error = StandardError.new(exception)\n      end\n    end",
        "def to_hash\n      hash = {}\n      instance_variables.each do |var|\n        hash[var[1..-1].to_sym] = instance_variable_get(var)\n      end\n      hash\n    end",
        "def site=(site)\n      raise ArgumentError, \"Site must be a Site object\" unless site.is_a?(Site)\n      @site = site\n      @site.extend(ModuleExtensions)\n    end",
        "def find_resource(params)\n      resource = params[:id]\n      resource = resource.to_s if resource.is_a?(Symbol)\n      resource = resource.to_i if resource.is_a?(Integer)\n      resource = resource.to_f if resource.is_a?(Float)\n      resource = resource.to_s if resource.is_a?(String)\n      resource = resource.to_i if resource.is_a?(Integer)\n      resource = resource.to_f if resource.is_a?(Float)\n      resource = resource.to_s if resource.is_a?(String)\n      resource = resource.to_i if resource.is_a?(Integer)\n      resource = resource.to_f if resource.is_a?(Float)\n      resource = resource.to_s if resource.is",
        "def create_resource_class(klass, options = {})\n      klass.class_eval do\n        include ActiveResource::Base\n        include ActiveResource::Helpers\n        include ActiveResource::Validations\n        include ActiveResource::Associations\n        include ActiveResource::Callbacks\n        include ActiveResource::Validations::PresenceValidator\n        include ActiveResource::Validations::LengthValidator\n        include ActiveResource::Validations::EmailValidator\n        include ActiveResource::Validations::LengthValidator\n        include ActiveResource::Validations::UrlValidator\n        include ActiveResource::Validations::PresenceOf\n        include ActiveResource::Validations::InclusionOf\n        include ActiveResource::Validations::InclusionOf::ClassMethods\n        include ActiveResource::Validations::InclusionOf::InstanceMethods\n        include ActiveResource::Validations::PresenceOf::ClassMethods\n        include ActiveResource::Validations::InclusionOf::InstanceMethods\n        include Active",
        "def run\n      # boot the agent\n      boot!\n\n      # configure the agent\n      configure!\n\n      # connect to the server\n      connect!\n\n      # start the daemon\n      daemonize!\n    end",
        "def open\n      @manager.connect\n      @manager.on_open do |id|\n        @manager.send_message(id, :open)\n      end\n      @manager.on_error do |id, error|\n        @manager.send_message(id, :error, error)\n      end\n      @manager.on_close do |id|\n        @manager.send_message(id, :close)\n      end\n    end",
        "def fix_ownership\n      if File.exist?(\"/var/run/vagrant\")\n        # If running in a container, we can't fix ownership of\n        # /var/run/vagrant because it is a symlink to /var.\n        return\n      end\n\n      # If running in a container, we can't fix ownership of\n      # /var/lib/vagrant because it is a symlink to /var/lib.\n      return if File.exist?(\"/var/lib/vagrant\")\n\n      # If running in a container, we can't fix ownership of\n      # /var/tmp/vagrant because it is a symlink to /var/tmp.\n      return if File.exist?(\"/var/tmp/vagrant\")\n\n      # If running in a container, we can't fix ownership of\n      # /var/tmp/vagrant/vagrant"
    ],
    "references": [
        [
            "def fans\n      data = api('user.get_fans')\n      data['fans'].map {|id| User.new(client, :_id => id)}\n    end"
        ],
        [
            "def stickers_purchased\n      data = api('sticker.get_purchased_stickers')\n      data['stickers'].map {|sticker_id| Sticker.new(client, :_id => sticker_id)}\n    end"
        ],
        [
            "def blocks\n      data = api('block.list_all')\n      data['blocks'].map {|attrs| User.new(client, attrs['block']['blocked'])}\n    end"
        ],
        [
            "def update_profile(attributes = {})\n      assert_valid_keys(attributes, :name, :twitter_id, :facebook_url, :website, :about, :top_artists, :hangout)\n\n      # Convert attribute names over to their Turntable equivalent\n      {:twitter_id => :twitter, :facebook_url => :facebook, :top_artists => :topartists}.each do |from, to|\n        attributes[to] = attributes.delete(from) if attributes[from]\n      end\n\n      api('user.modify_profile', attributes)\n      self.attributes = attributes\n      true\n    end"
        ],
        [
            "def update_laptop(name)\n      assert_valid_values(name, *%w(mac pc linux chrome iphone cake intel android))\n\n      api('user.modify', :laptop => name)\n      self.attributes = {'laptop' => name}\n      true\n    end"
        ],
        [
            "def update_status(status = self.status)\n      assert_valid_values(status, *%w(available unavailable away))\n\n      now = Time.now.to_i\n      result = api('presence.update', :status => status)\n\n      client.reset_keepalive(result['interval'])\n      client.clock_delta = ((now + Time.now.to_i) / 2 - result['now']).round\n      self.attributes = {'status' => status}\n\n      true\n    end"
        ],
        [
            "def <<(input)\n      if input.index(/\\s+/).nil?\n        word      = normalize_word input\n        self.word = word unless word == ''\n      elsif input.scan(SENTENCE_DELIMITER).length < 2\n        self.sentence = input.gsub(SENTENCE_DELIMITER, '')\n      else\n        self.passage = input\n      end\n    end"
        ],
        [
            "def weighted(type, group)\n      if @weights[type].has_key?(group)\n        selector = WeightedSelect::Selector.new @weights[type][group]\n        selector.select\n      end\n    end"
        ],
        [
            "def run(event)\n      if conditions_match?(event.data)\n        # Run the block for each individual result\n        event.results.each do |args|\n          begin\n            @block.call(*args)\n          rescue StandardError => ex\n            logger.error(([ex.message] + ex.backtrace) * \"\\n\")\n          end\n        end\n\n        true\n      else\n        false\n      end\n    end"
        ],
        [
            "def conditions_match?(data)\n      if conditions\n        conditions.all? {|(key, value)| data[key] == value}\n      else\n        true\n      end\n    end"
        ],
        [
            "def add(storable, *coordinate)\n      validate_type(storable)\n      loc = create_location(coordinate)\n      pos = storable.position || storable.position_class.new\n      pos.location = loc\n      pos.occupant = storable\n      pos.holder = self\n      logger.debug { \"Added #{storable.qp} to #{qp} at #{loc.coordinate}.\" }\n      update_full_flag\n      self\n    end"
        ],
        [
            "def copy_container_type_capacity\n      return unless container_type and container_type.capacity\n      self.capacity = cpc = container_type.capacity.copy(:rows, :columns)\n      logger.debug { \"Initialized #{qp} capacity from #{container_type.qp} capacity #{cpc}.\" }\n      update_full_flag\n      cpc\n    end"
        ],
        [
            "def load\n      data = api('user.get_prefs')\n      self.attributes = data['result'].inject({}) do |result, (preference, value, *)|\n        result[preference] = value\n        result\n      end\n      super\n    end"
        ],
        [
            "def execute\n      File.open(out_file, 'w') do |o|\n        File.new(in_file, 'r').each_with_index do |line, index|\n          extraction = col_filter.process(row_filter.process(line.chomp, row: index))\n          o.puts extraction unless extraction.nil?\n        end\n      end\n    end"
        ],
        [
            "def teams(summoner, optional={})\n    region = optional[:region] || @sightstone.region\n    id = if summoner.is_a? Summoner\n      summoner.id\n    else\n      summoner\n    end\n    \n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v2.2/team/by-summoner/#{id}\"\n\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      teams = []\n      data.each do |team|\n        teams << Team.new(team)\n      end\n      if block_given?\n        yield teams\n      else\n        return teams\n      end\n    }\n  end"
        ],
        [
            "def get_doctype(path)\n      doc_type = nil\n      begin\n        metadata = YAML.load_file(path + 'template.yml')\n        doc_type = metadata['type']\n        if doc_type.nil?\n          say 'Type value not found. Check template.yml in the document directory', :red\n          say 'Make sure there is an entry `type: DOC_TYPE` in the file.'\n          say \"  #{path}\"\n          raise_error('DOC_TYPE not found in template.yml')\n        end\n      rescue Errno::ENOENT # File not found\n        say 'No template.yml found in the document directory. Did you forget to add it?', :red\n        say 'Did you run the command in the directory where the document is located?'\n        say \"  #{path}\"\n        raise_error('template.yml not found')\n      end\n      return doc_type\n    end"
        ],
        [
            "def execute\n      allocation = {}\n      File.open(infile).each_with_index do |line, index|\n        row = row_filter.process(line, row: index)\n        next if row.nil? or row.empty?\n        key = key_filter.process(row)\n        allocation[key] = [] if allocation[key].nil?\n        allocation[key] << col_filter.process(row).split(';') \n      end\n\n      File.open(outfile, 'w') do |out|\n        allocation.each do |key, values|\n          out.puts \"#{key};#{values.flatten.uniq.sort.join(';')}\"\n        end\n      end\n    end"
        ],
        [
            "def span_to(spanner)\n      Vector.new((@x - spanner.x).abs, (@y - spanner.y).abs)\n    end"
        ],
        [
            "def build\n      log_configuration_information\n\n      if subscription_list.empty?\n        Mako.logger.warn 'No feeds were found in your subscriptions file. Please add feeds and try again.'\n        return\n      end\n\n      log_time do\n        request_and_build_feeds\n        renderers.each do |renderer|\n          renderer_instance = renderer.new(bound: self)\n          writer.new(renderer: renderer_instance,\n                     destination: File.expand_path(renderer_instance.file_path, Mako.config.destination)).write\n        end\n      end\n    end"
        ],
        [
            "def log_configuration_information\n      Mako.logger.info \"Configuration File: #{Mako.config.config_file}\"\n      Mako.logger.info \"Theme: #{Mako.config.theme}\"\n      Mako.logger.info \"Destination: #{Mako.config.destination}\"\n    end"
        ],
        [
            "def log_time\n      Mako.logger.info 'Generating...'\n      start_time = Time.now.to_f\n      yield\n      generation_time = Time.now.to_f - start_time\n      Mako.logger.info \"done in #{generation_time} seconds\"\n    end"
        ],
        [
            "def execute\n      result = eval(operation)      \n      if outfile\n        if result.is_a?(SpreadSheet)\n          result.write(outfile)\n        else\n          puts\n          puts \"Warning: Result is no spread sheet and not written to file!\"\n          puts \"         To view the result use -p flag\" unless print\n        end\n      end\n\n      if print\n        puts\n        puts \"Operation\"\n        puts \"---------\"\n        operation.split(';').each { |o| puts o }\n        puts\n        puts \"Result\"\n        puts \"------\"\n        if result.nil? || result.empty?\n          puts result.inspect\n        else\n          puts result\n        end\n        puts\n      end\n    end"
        ],
        [
            "def create_operands(opts)\n        files   = opts[:files].split(',')\n        rlabels = opts[:rlabels].split(',').collect { |l| l.upcase == \"TRUE\" }\n        clabels = opts[:clabels].split(',').collect { |l| l.upcase == \"TRUE\" }\n\n        operands = {}\n        opts[:aliases].split(',').each_with_index do |a,i|\n          operands[a] = SpreadSheet.new(file: files[i], ds: opts[:ds], \n                                        equalize: opts[:equalize],\n                                        r: rlabels[i], c: clabels[i])\n        end\n\n        operands\n      end"
        ],
        [
            "def publish(params)\n      params[:msgid] = message_id = next_message_id\n      params = @default_params.merge(params)\n\n      logger.debug \"Message sent: #{params.inspect}\"\n\n      if HTTP_APIS.include?(params[:api])\n        publish_to_http(params)\n      else\n        publish_to_socket(params)\n      end\n\n      # Add timeout handler\n      EventMachine.add_timer(@timeout) do\n        dispatch('msgid' => message_id, 'command' => 'response_received', 'error' => 'timed out')\n      end if @timeout\n\n      message_id\n    end"
        ],
        [
            "def publish_to_socket(params)\n      message = params.is_a?(String) ? params : params.to_json\n      data = \"~m~#{message.length}~m~#{message}\"\n      @socket.send(data)\n    end"
        ],
        [
            "def publish_to_http(params)\n      api = params.delete(:api)\n      message_id = params[:msgid]\n\n      http = EventMachine::HttpRequest.new(\"http://turntable.fm/api/#{api}\").get(:query => params)\n      if http.response_header.status == 200\n        # Command executed properly: parse the results\n        success, data = JSON.parse(http.response)\n        data = {'result' => data} unless data.is_a?(Hash)\n        message = data.merge('success' => success)\n      else\n        # Command failed to run\n        message = {'success' => false, 'error' => http.error}\n      end\n      message.merge!('msgid' => message_id)\n\n      # Run the message handler\n      event = Faye::WebSocket::API::Event.new('message', :data => \"~m~#{Time.now.to_i}~m~#{JSON.generate(message)}\")\n      on_message(event)\n    end"
        ],
        [
            "def on_message(event)\n      data = event.data\n\n      response = data.match(/~m~\\d*~m~(.*)/)[1]\n      message =\n        case response\n        when /no_session/\n          {'command' => 'no_session'}\n        when /(~h~[0-9]+)/\n          # Send the heartbeat command back to the server\n          publish_to_socket($1)\n          {'command' => 'heartbeat'}\n        else\n          JSON.parse(response)\n        end\n      message['command'] = 'response_received' if message['msgid']\n\n      logger.debug \"Message received: #{message.inspect}\"\n      dispatch(message)\n    end"
        ],
        [
            "def add_defaults_local\n      super\n      self.capacity ||= Capacity.new.add_defaults\n      self.row_label ||= capacity.rows && capacity.rows > 0 ? 'Row' : 'Unused'\n      self.column_label ||= capacity.columns && capacity.columns > 0 ? 'Column' : 'Unused'\n    end"
        ],
        [
            "def ping ()\n      log.debug \"Pinging\"\n      Timeout.timeout(1) do\n        TCPSocket.new(address, 22).close\n      end\n      true\n    rescue Timeout::Error, Errno::ECONNREFUSED\n      fail \"Failed to ping #{self}\"\n    end"
        ],
        [
            "def cp (froms, to, as: nil, quiet: false)\n      as ||= @user\n      output = \"\"\n      synchronize do\n        [froms].flatten.each do |from|\n          if from.is_a?(String)\n            to += \"/\" if to[-1] != \"/\" && from.is_a?(Array)\n            command = [\"rsync\", \"-e\", ssh_command, \"-r\"]\n            command += [*from, \"#{as}@#{@address}:#{to}\"]\n            log.trace command.shelljoin, quiet: quiet\n            IO.popen(command, in: :close, err: %i(child out)) do |io|\n              until io.eof?\n                begin\n                  output << io.read_nonblock(100)\n                rescue IO::WaitReadable\n                  IO.select([io])\n                  retry\n                end\n              end\n              io.close\n              if !$?.success?\n                log.fatal \"exit status #{$?.exitstatus}: #{command}\", quiet: quiet\n                log.fatal output, quiet: quiet\n                fail \"failed to copy files\"\n              end\n            end\n          elsif from.respond_to?(:read)\n            cmd = \"echo #{Base64.strict_encode64(from.read).shellescape} | base64 -d > #{to.shellescape}\"\n            sh cmd, quiet: quiet\n          else\n            fail \"Don't know how to copy a #{from.class}: #{from}\"\n          end\n        end\n      end\n      true\n    end"
        ],
        [
            "def write (string, to, as: nil, quiet: false)\n      cp StringIO.new(string), to, as: as, quiet: quiet\n    end"
        ],
        [
            "def read (filename, as: nil, quiet: false)\n      Base64.decode64 sh(\"cat #{filename.shellescape} | base64\", as: as, quiet: quiet)\n    end"
        ],
        [
            "def sh (command, as: nil, quiet: false)\n      as ||= @user\n      output = \"\"\n      synchronize do\n        log.debug \"sh #{command}\", quiet: quiet\n        result = nil\n        ch = ssh(as).open_channel do |ch|\n          ch.request_pty do |ch, success|\n            \"failed to acquire pty\" unless success\n            ch.exec(command) do |_, success|\n              fail \"failed to execute command\" unless success\n              ch.on_data do |_, data|\n                log.trace \"received #{data.bytesize} bytes stdout\", quiet: quiet\n                output << data\n              end\n              ch.on_extended_data do |_, _, data|\n                log.trace \"received #{data.bytesize} bytes stderr\", quiet: quiet\n                output << data.colorize(:red)\n              end\n              ch.on_request(\"exit-status\") do |_, data|\n                result = data.read_long\n                log.trace \"received exit-status #{result}\", quiet: quiet\n              end\n            end\n          end\n        end\n        ch.wait\n        fail FailedCommand, output if result != 0\n        output\n      end\n    end"
        ],
        [
            "def can_hold_child?(storable)\n      Specimen === storable and storable.specimen_class == specimen_class and specimen_types.include?(storable.specimen_type)\n    end"
        ],
        [
            "def process_aggregation\n      File.new(infile).each_with_index do |line, index|\n        result = col_filter.process(row_filter.process(line.chomp, row: index))\n        unless result.nil? or result.empty?\n          if heading.empty? and not headerless\n            heading << result.split(';')\n            next\n          else\n            @sum_col = [result.split(';').size, sum_col].max \n          end\n          key_values[result]  += 1\n          sums[sum_col_title] += 1\n        end\n      end\n      heading.flatten!\n      heading[sum_col] = sum_col_title\n    end"
        ],
        [
            "def write_result\n      sum_line = [sum_row_title]\n      (heading.size - 2).times { sum_line << \"\" }\n      sum_line << sums[sum_col_title]\n      row = 0;\n      File.open(outfile, 'w') do |out|\n        out.puts sum_line.join(';') if row == sum_row ; row += 1\n        out.puts heading.join(';')\n        key_values.each do |k, v|\n          out.puts sum_line.join(';') if row == sum_row ; row += 1\n          out.puts [k, v].join(';')\n        end\n      end\n    end"
        ],
        [
            "def init_sum_scheme(sum_scheme)\n        row_scheme, col_scheme = sum_scheme.split(',') unless sum_scheme.nil?\n\n        unless row_scheme.nil?\n          @sum_row_title, @sum_row = row_scheme.split(':') unless row_scheme.empty?\n        end\n        \n        @sum_row.nil? ? @sum_row = 0 : @sum_row = @sum_row.to_i\n        @sum_row_title = 'Total' if @sum_row_title.nil? \n\n        col_scheme.nil? ? @sum_col_title = 'Total' : @sum_col_title = col_scheme\n        @sum_col = 0\n      end"
        ],
        [
            "def attributes(&block)\n      raise ArgumentError, \"You should provide block\" unless block_given?\n\n      attributes = Morf::AttributesParser.parse(&block)\n      self.class_variable_set(:@@attributes, attributes)\n    end"
        ],
        [
            "def resolve(dep_hashes, repos)\n      logger.info 'resolving dependencies'\n      \n      session = MavenRepositorySystemSession.new\n      local_repo = LocalRepository.new(local_repository_path)\n      local_manager = @system.newLocalRepositoryManager(local_repo)\n      session.setLocalRepositoryManager(local_manager)\n\n      collect_req = CollectRequest.new\n\n      dep_hashes.each do |hash|\n        dep = Dependency.new new_artifact(hash), 'compile'\n        collect_req.addDependency dep\n        logger.debug 'requested {}', dep\n      end\n\n      repos.each do |uri|\n        repo = RemoteRepository.new(uri.object_id.to_s, 'default', uri)\n        collect_req.addRepository repo\n        logger.info 'added repository {}', repo.getUrl\n        enabled = []\n        enabled << 'releases' if repo.getPolicy(false).isEnabled\n        enabled << 'snapshots' if repo.getPolicy(true).isEnabled\n        logger.debug '{}', enabled.join('+')\n      end\n\n      node = @system.collectDependencies(session, collect_req).getRoot\n        \n      dependency_req = DependencyRequest.new(node, nil)\n      @system.resolveDependencies(session, dependency_req)\n      \n      nlg = PreorderNodeListGenerator.new\n      node.accept nlg\n\n      if logger.isDebugEnabled\n        total_size = 0\n        nlg.getArtifacts(false).each do |artifact|\n          file = artifact.file\n          size = File.stat(artifact.file.absolute_path).size\n          total_size += size\n          \n          logger.debug(\"Using %0.2f %s\" % [size/MiB_PER_BYTE, artifact])\n        end\n        logger.debug('      -----')\n        logger.debug(\"      %0.2f MiB total\" % [total_size/MiB_PER_BYTE])\n      else\n        nlg.getArtifacts(false).each do |artifact|\n          logger.info 'Using {}', artifact\n        end\n      end\n\n      nlg.getFiles.map{|e| e.to_s }\n    end"
        ],
        [
            "def place(stone)\n      x, y = stone.to_coord\n\n      internal_board[y][x] = stone\n    end"
        ],
        [
            "def parse(argv)\n      OptionParser.new do |options|\n        usage_and_help options\n        assign_text_file options\n        assign_weights_file options\n        assign_output_file options\n\n        begin\n          options.parse argv\n        rescue OptionParser::ParseError => error\n          STDERR.puts error.message, \"\\n\", options\n          exit(-1)\n        end\n      end\n    end"
        ],
        [
            "def execute(command, params)\n      params[:Bugzilla_login]    ||= username\n      params[:Bugzilla_password] ||= password\n\n      self.last_command = command_string(command, params)\n      xmlrpc_client.call(command, params)\n    end"
        ],
        [
            "def leagues(summoner, optional={})\n    region = optional[:region] || @sightstone.region\n    id = if summoner.is_a? Summoner\n      summoner.id\n    else\n      summoner\n    end\n    \n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v2.3/league/by-summoner/#{id}\"\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      leagues = []\n      data.each do |league|\n        leagues << League.new(league)\n      end\n      if block_given?\n        yield leagues\n      else\n        return leagues\n      end\n    }\n  end"
        ],
        [
            "def league_entries(summoner, optional={})\n    region = optional[:region] || @sightstone.region\n    id = if summoner.is_a? Summoner\n      summoner.id\n    else\n      summoner\n    end\n    \n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v2.3/league/by-summoner/#{id}/entry\"\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      entries = []\n      data.each do |entry|\n        entries << LeagueItem.new(entry)\n      end\n      if block_given?\n        yield entries\n      else\n        return entries\n      end\n    }\n  end"
        ],
        [
            "def place(top, left, angle)\n      api('sticker.place', :placement => [:sticker_id => id, :top => top, :left => left, :angle => angle], :is_dj => client.user.dj?, :roomid => room.id, :section => room.section)\n      true\n    end"
        ],
        [
            "def find\n      request_uris.map do |request|\n        if request[:body].nil?\n          request[:uri]\n        else\n          html = Nokogiri::HTML(request[:body])\n          potential_feed_uris = html.xpath(XPATHS.detect { |path| !html.xpath(path).empty? })\n          if potential_feed_uris.empty?\n            Mako.errors.add_error \"Could not find feed for #{request[:uri]}\"\n            next\n          end\n          uri_string = potential_feed_uris.first.value\n          feed_uri = URI.parse(uri_string)\n          feed_uri.absolutize!(request[:uri])\n        end\n      end.compact\n    end"
        ],
        [
            "def collection_status=(value)\n      if value == 'Complete' then\n        specimens.each { |spc| spc.collection_status = 'Collected' if spc.pending? }\n      end\n      setCollectionStatus(value)\n    end"
        ],
        [
            "def make_default_consent_tier_statuses\n      return if registration.nil? or registration.consent_tier_responses.empty?\n      \n      # the consent tiers\n      ctses = consent_tier_statuses.map { |cts| cts.consent_tier }\n      # ensure that there is a CT status for each consent tier\n      registration.consent_tier_responses.each do |ctr|\n        ct = ctr.consent_tier\n        # skip if there is a status for the response tier\n        next if ctses.include?(ct)\n        # make a new status\n        cts = CaTissue::ConsentTierStatus.new(:consent_tier => ct)\n        cts.add_defaults\n        consent_tier_statuses << cts\n        logger.debug { \"Made default #{qp} #{cts.qp} for consent tier #{ct.qp}.\" }\n      end\n    end"
        ],
        [
            "def default_collection_event\n      return if registration.nil?\n      pcl = registration.protocol || return\n      # if no protocol event, then add the default event\n      pcl.add_defaults if pcl.events.empty?\n      ev = pcl.sorted_events.first || return\n      logger.debug { \"Default #{qp} collection event is the registration protocol #{pcl.qp} first event #{ev.qp}.\" }\n      ev\n    end"
        ],
        [
            "def default_receiver\n      cep = collection_event_parameters\n      cltr = cep.user if cep\n      return cltr if cltr\n      cp = collection_protocol || return\n      rcv = cp.coordinators.first\n      return rcv if rcv or cp.fetched?\n      # Try to fetch the CP coordinator \n      return cp.coordinators.first if cp.find\n      # CP does not exist; add the CP defaults and retry\n      cp.add_defaults\n      cp.coordinators.first\n    end"
        ],
        [
            "def decrement_derived_quantity(child)\n      return unless specimen_type == child.specimen_type and child.initial_quantity\n      if available_quantity.nil? then\n        raise Jinx::ValidationError.new(\"Derived specimen has an initial quantity #{child.initial_quantity} but the parent is missing an available quantity\")\n      elsif (available_quantity - child.initial_quantity).abs < 0.00000001 then\n        # rounding error\n        self.available_quantity = 0.0\n      elsif child.initial_quantity <= available_quantity then\n        self.available_quantity -= child.initial_quantity\n      else\n        raise Jinx::ValidationError.new(\"Derived specimen initial quantity #{child.initial_quantity} exceeds parent available quantity #{available_quantity}\")\n      end\n    end"
        ],
        [
            "def update_changed_dependent(owner, property, dependent, autogenerated)\n      # Save the changed collectible event parameters directly rather than via a cascade.\n      if CollectibleEventParameters === dependent then\n        logger.debug { \"Work around a caTissue bug by resaving the collected #{owner} #{dependent} directly rather than via a cascade...\" }\n        update_from_template(dependent)\n      elsif CaTissue::User === owner and property.attribute == :address then\n        update_user_address(owner, dependent)\n      elsif CaTissue::Specimen === owner and CaTissue::Specimen === dependent then\n        logger.debug { \"Work around caTissue bug to update #{dependent} separately after the parent #{owner} update...\" }\n        prepare_specimen_for_update(dependent)\n        update_from_template(dependent)\n        logger.debug { \"Updated the #{owner} child #{dependent}.\" }\n      elsif CaTissue::ConsentTierStatus === dependent then\n          update_from_template(owner)\n      else\n        super\n      end\n    end"
        ],
        [
            "def update_user_address(user, address)\n      logger.debug { \"Work around caTissue prohibition of #{user} address #{address} update by creating a new address record for a dummy user...\" }\n      address.identifier = nil\n      perform(:create, address) { create_object(address) }\n      logger.debug { \"Worked around caTissue address update bug by swizzling the #{user} address #{address} identifier.\" }\n      perform(:update, user) { update_object(user) }\n      user\n    end"
        ],
        [
            "def add_position_to_specimen_template(specimen, template)\n      pos = specimen.position\n      # the non-domain position attributes\n      pas = pos.class.nondomain_attributes\n      # the template position reflects the old values, if available\n      ss = pos.snapshot\n      # the attribute => value hash\n      vh = ss ? pas.to_compact_hash { |pas| ss[pas] } : pos.value_hash(pas)\n      vh[:specimen] = template\n      vh[:storage_container] = pos.storage_container.copy\n      # the template position reflects the old values\n      template.position = pos.class.new(vh)\n      logger.debug { \"Work around #{specimen} update anomaly by copying position #{template.position.qp} to update template #{template.qp} as #{template.position.qp} with values #{vh.qp}...\" }\n    end"
        ],
        [
            "def ensure_primary_annotation_has_hook(annotation)\n      hook = annotation.hook\n      if hook.nil? then\n        raise CaRuby::DatabaseError.new(\"Cannot save annotation #{annotation} since it does not reference a hook entity\")\n      end\n      if hook.identifier.nil? then\n        logger.debug { \"Ensuring that the annotation #{annotation.qp} hook entity #{hook.qp} exists in the database...\" }\n        ensure_exists(hook)\n      end\n    end"
        ],
        [
            "def copy_annotation_proxy_owner_to_template(obj, template)\n      prop = obj.class.proxy_property\n      # Ignore the proxy attribute if it is defined by caRuby rather than caTissue.\n      return unless prop and prop.java_property?\n      rdr, wtr = prop.java_accessors\n      pxy = obj.send(rdr)\n      logger.debug { \"Setting #{obj.qp} template #{template.qp} proxy owner to #{pxy}...\" }\n      template.send(wtr, pxy)\n    end"
        ],
        [
            "def create_table_data\n      processed_header = false\n\n      File.open(infile).each_with_index do |line, index|\n        line = line.chomp\n\n        next if line.empty?\n        \n        line = unstring(line).chomp\n\n        header.process line, processed_header\n\n        unless processed_header\n          processed_header = true\n          next\n        end\n\n        next if row_filter.process(line, row: index).nil?\n        \n        @columns = line.split(';')\n\n        create_row(create_key, line)\n      end\n\n    end"
        ],
        [
            "def write_to_file\n      File.open(outfile, 'w') do |out|\n        out.puts header.to_s\n        out.puts create_sum_row if @sum_row_pos == 'TOP'\n        rows.each do |key, row|\n          line = [] << row[:key]\n          header.clear_header_cols.each_with_index do |col, index|\n            next if index < row[:key].size\n            line << row[:cols][col]\n          end\n          out.puts line.flatten.join(';')\n        end\n        out.puts create_sum_row if @sum_row_pos == 'EOF'\n      end\n    end"
        ],
        [
            "def to_number(value)\n        value = convert_to_en(value)\n        return value.to_i unless value =~ /\\./\n        return value.to_f if     value =~ /\\./ \n      end"
        ],
        [
            "def prepare_sum_row(pattern)\n        return if pattern.nil? || pattern.empty?\n        @sum_row_pos, sum_row_pattern = pattern.split(/(?<=^top|^eof):/i)\n        @sum_row_pos.upcase!\n        @sum_row = Hash.new\n        @sum_row_patterns = split_by_comma_regex(sum_row_pattern)\n      end"
        ],
        [
            "def add_to_sum_row(value, column)\n        return unless @sum_row_patterns\n        @sum_row_patterns.each do |pattern|\n          if pattern =~ /^\\(?c\\d+[=~+.]/\n            header_column = evaluate(pattern, \"\")\n          else\n            header_column = pattern\n          end\n\n          if header_column == column\n            @sum_row[header_column] ||= 0\n            @sum_row[header_column] += value\n          end\n        end\n      end"
        ],
        [
            "def create_sum_row\n        line = []\n        header.clear_header_cols.each do |col|\n          line << @sum_row[col] || \"\"\n        end\n        line.flatten.join(';')\n      end"
        ],
        [
            "def _rewrap_array(result)\n      if @wrap_results\n        newcoll = @collection.class.new(result)\n        self.class.new(newcoll, @wrapfunc_in, @wrapfunc_out)\n      else\n        @collection.class.new(result.map(&@wrapfunc_out))\n      end\n    end"
        ],
        [
            "def add_dependency(key, dependencies = [])\n\n      raise SelfDependencyError, \"An object's dependencies cannot contain itself\" if dependencies.include? key\n\n      node = node_for_key_or_new key\n      dependencies.each do |dependency|\n        node.addEdge(node_for_key_or_new(dependency))\n      end\n      resolve_dependencies\n    end"
        ],
        [
            "def resolve_dependency(node)\n      node.seen = true\n      @seen_this_pass << node\n\n      node.edges.each do |edge|\n        unless @resolved.include? edge\n          unless @seen_this_pass.include? edge\n            unless edge.seen?\n              resolve_dependency edge\n            end\n          else\n            raise CircularDependencyError, \"Circular reference detected: #{node.key.to_s} - #{edge.key.to_s}\"\n          end\n        end\n      end\n      @resolved << node\n    end"
        ],
        [
            "def with_friends\n      data = api('room.directory_graph')\n      data['rooms'].map do |(attrs, friends)|\n        Room.new(client, attrs.merge(:friends => friends))\n      end\n    end"
        ],
        [
            "def find(query, options = {})\n      assert_valid_keys(options, :limit, :skip)\n      options = {:limit => 20, :skip => 0}.merge(options)\n\n      data = api('room.search', :query => query, :skip => options[:skip])\n      data['rooms'].map {|(attrs, *)| Room.new(client, attrs)}\n    end"
        ],
        [
            "def load(options = {})\n      assert_valid_keys(options, :minimal)\n      options = {:minimal => false}.merge(options)\n\n      data = api('playlist.all', options)\n      self.attributes = data\n      super()\n    end"
        ],
        [
            "def update(attributes = {})\n      assert_valid_keys(attributes, :id)\n\n      # Update id\n      id = attributes.delete(:id)\n      update_id(id) if id\n\n      true\n    end"
        ],
        [
            "def active\n      @active = client.user.playlists.all.any? {|playlist| playlist == self && playlist.active?} if @active.nil?\n      @active\n    end"
        ],
        [
            "def add(name, options = {}, &coercer)\n      name  = name.to_sym\n      value = Attribute.new(name, options, &coercer)\n      clone_with do\n        @attributes  = attributes.merge(name => value)\n        @transformer = nil\n      end\n    end"
        ],
        [
            "def add_specimens(*args)\n      hash = args.pop\n      spcs = args\n      # validate arguments\n      unless Hash === hash then\n        raise ArgumentError.new(\"Collection parameters are missing when adding specimens to protocol #{self}\")\n      end\n      # Make the default registration, if necessary.\n      unless hash.has_key?(:registration) || hash.has_key?(:collection_protocol_registration) then\n        # the participant\n        pnt = hash.delete(:participant)\n        unless pnt then\n          raise ArgumentError.new(\"Registration or participant missing from collection parameters: #{hash.qp}\")\n        end\n        hash[:registration] = registration(pnt) || make_cpr(pnt)\n      end\n      # the new SCG\n      scg = SpecimenCollectionGroup.new(hash)\n      # set each Specimen SCG\n      spcs.each { |spc| spc.specimen_collection_group = scg }\n      scg\n    end"
        ],
        [
            "def summoner(name_or_id, optional={})\n    region = optional[:region] || @sightstone.region\n    uri = if name_or_id.is_a? Integer\n      \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{name_or_id}\"\n    else\n      \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/by-name/#{URI::encode(name_or_id)}\"\n    end\n    \n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      s = Summoner.new(data.values[0])\n      if block_given?\n        yield s\n      else\n        return s\n      end\n    }\n  end"
        ],
        [
            "def names(ids, optional={})\n    region = optional[:region] || @sightstone.region\n    ids = ids.join(',')\n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{ids}/name\"\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n\n      names_hash = Hash.new\n      data.each do |id, name|\n        names_hash[id.to_i] = name\n      end\n      if block_given?\n        yield names_hash\n      else\n        return names_hash\n      end\n    }\n  end"
        ],
        [
            "def runebook(summoner, optional={})\n    region = optional[:region] || @sightstone.region\n    id = if summoner.is_a? Summoner\n      summoner.id\n    else\n      summoner\n    end\n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{id}/runes\"\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      book = RuneBook.new(data.values[0])\n      if block_given?\n        yield book\n      else\n        return book\n      end\n    }\n  end"
        ],
        [
            "def runebooks(summoners, optional={})\n    return {} if summoners.empty?\n\n    region = optional[:region] || @sightstone.region\n    ids = summoners.collect { |summoner|\n      if summoner.is_a? Summoner\n        summoner.id\n      else\n        summoner\n      end\n    }\n    uri = \"https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{ids.join(',')}/runes\"\n    response = _get_api_response(uri)\n    _parse_response(response) { |resp|\n      data = JSON.parse(resp)\n      books = {}\n      data.each do |key, raw_book|\n        books[key] = RuneBook.new(raw_book)\n      end\n      if block_given?\n        yield books\n      else\n        return books\n      end\n    }\n  end"
        ],
        [
            "def write\n            buffer = create_zip(@entries, @ignore_entries)\n\n            puts \"\\nwrite file #{@output_file}\"\n            File.open(@output_file, \"wb\") {|f| f.write buffer.string }\n        end"
        ],
        [
            "def collect(opts)\n      raise Jinx::ValidationError.new(\"#{self} is already collected\") if received?\n      specimen_event_parameters.merge!(extract_event_parameters(opts))\n    end"
        ],
        [
            "def method_missing(id, *args, &block)\n      boolean_row_regex = %r{\n        BEGIN(\\(*[nsd]\\d+[<!=~>]{1,2}\n         (?:[A-Z][A-Za-z]*\\.new\\(.*?\\)|\\d+|['\"].*?['\"])\n         (?:\\)*(?:&&|\\|\\||$)\n         \\(*[nsd]\\d+[<!=~>]{1,2}\n         (?:[A-Z][A-Za-z]*\\.new\\(.*?\\)|\\d+|['\"].*?['\"])\\)*)*)END\n      }xi\n\n      return boolean_row($1, args, block)          if id =~ boolean_row_regex\n      return equal($1, args, block)                if id =~ /^(\\d+)$/\n      return equal_type($1, $2, args, block)       if id =~ /^(s|n|d):(\\d+)$/\n      return range($1, $2, args, block)            if id =~ /^(\\d+)-(\\d+)$/\n      return range_type($1, $2, $3, args, block)   if id =~ /^(s|n|d):(\\d+)-(\\d+)$/\n      return regex($1, args, block)                if id =~ /^\\/(.*)\\/$/\n      return col_regex($1, $2, args, block)        if id =~ /^(\\d+):\\/(.*)\\/$/\n      return date($1, $2, $3, args, block)         if id =~ /^(\\d+):(<|=|>)(\\d+.\\d+.\\d+)$/\n      return date_range($1, $2, $3, args, block)   if id =~ /^(\\d+):(\\d+.\\d+.\\d+.)-(\\d+.\\d+.\\d+)$/\n      return number($1, $2, $3, args, block)       if id =~ /^(\\d+):(<|=|>)(\\d+)$/\n      return number_range($1, $2, $3, args, block) if id =~ /^(\\d):(\\d+)-(\\d+)$/\n\n      super\n    end"
        ],
        [
            "def match_boolean_filter?(values=[])\n      return false if boolean_filter.empty? or values.empty?\n      expression = boolean_filter\n      columns = expression.scan(/(([nsd])(\\d+))([<!=~>]{1,2})(.*?)(?:[\\|&]{2}|$)/)\n      columns.each do |c|\n        value = case c[1]\n        when 'n'\n          values[c[2].to_i].empty? ? '0' : values[c[2].to_i]\n        when 's'\n          \"\\\"#{values[c[2].to_i]}\\\"\"\n        when 'd'\n          begin\n            Date.strptime(values[c[2].to_i], date_format)\n          rescue Exception => e\n            case c[3]\n            when '<', '<=', '=='\n              \"#{c[4]}+1\"\n            when '>', '>='\n              '0'\n            when '!='\n              c[4]\n            end\n          else\n            \"Date.strptime('#{values[c[2].to_i]}', '#{date_format}')\"\n          end \n        end\n        expression = expression.gsub(c[0], value)\n      end\n      eval(expression)\n    end"
        ],
        [
            "def pivot_each_column(values=[])\n      pivot.each do |column, parameters|\n        value = values[parameters[:col].to_i]\n        value = value.strip.gsub(/^\"|\"$/, \"\") unless value.nil?\n        match = false\n        begin\n          match = eval(parameters[:operation].gsub('[value]', value))\n        rescue Exception => e\n\n        end\n        yield column, match\n      end\n    end"
        ],
        [
            "def create_filter(values)\n        values.scan(/(?<=,|^)(BEGIN.*?END|\\/.*?\\/|.*?)(?=,|$)/i).flatten.each do |value|\n          send(value)\n        end unless values.nil?\n      end"
        ],
        [
            "def equal(value, args, block)\n        filter << value.to_i unless filter.index(value.to_i) \n      end"
        ],
        [
            "def equal_type(type, value, args, block)\n        filter_size_before = filter.size\n        equal(value, args, block)\n        types << type if filter_size_before < filter.size\n      end"
        ],
        [
            "def range(start_value, end_value, args, block)\n        filter << (start_value.to_i..end_value.to_i).to_a\n      end"
        ],
        [
            "def range_type(type, start_value, end_value, args, block)\n        filter_size_before = filter.size\n        range(start_value, end_value, args, block)\n        (filter.size - filter_size_before).times { types << type }\n      end"
        ],
        [
            "def col_regex(col, r, args, block)\n        operation = \"'[value]' =~ Regexp.new('#{r}')\"\n        pivot[r] = { col: col, operation: operation } \n      end"
        ],
        [
            "def date(col, comparator, date, args, block)\n        comparator = '==' if comparator == '='\n        operation = \"Date.strptime(\\\"[value]\\\", \\\"#{date_format}\\\") #{comparator} \" +\n                    \"Date.strptime(\\\"#{date}\\\", \\\"#{date_format}\\\")\"\n        pivot[\"#{comparator}#{date}\"] = { col: col, operation: operation }\n      end"
        ],
        [
            "def date_range(col, start_date, end_date, args, block)\n        operation = \"   Date.strptime(\\\"#{start_date}\\\",  \\\"#{date_format}\\\") \"    +\n                    \"<= Date.strptime(\\\"[value]\\\",        \\\"#{date_format}\\\") && \" +\n                    \"   Date.strptime(\\\"[value]\\\",        \\\"#{date_format}\\\") \"    +\n                    \"<= Date.strptime(\\\"#{end_date}\\\",    \\\"#{date_format}\\\")\"\n        pivot[\"#{start_date}-#{end_date}\"] = { col: col, operation: operation }\n      end"
        ],
        [
            "def number(col, comparator, number, args, block)\n        comparator = '==' if comparator == '='\n        operation = \"[value] #{comparator} #{number}\"\n        pivot[\"#{comparator}#{number}\"] = { col: col, operation: operation }\n      end"
        ],
        [
            "def number_range(col, start_number, end_number, arg, block)\n        operation = \" #{start_number} <= [value] && [value] <= #{end_number}\"\n        pivot[\"#{start_number}-#{end_number}\"] = { col: col, operation: operation }\n      end"
        ],
        [
            "def create_annotation(hook, annotation)\n      # validate the arguments\n      if hook.nil? then raise ArgumentError.new(\"Annotated caTissue object is missing\") end\n      if annotation.nil? then raise ArgumentError.new(\"Annotation caTissue object is missing\") end\n      # the annotated object must exist in the database\n      unless hook.identifier then\n        raise AnnotationError.new(\"Annotation writer does not support annotation of a caTissue object without an identifier: #{hook}\")\n      end\n      # load the caRuby annotations if necessary\n      hook.class.ensure_annotations_loaded\n      # set the annotation hook reference\n      annotation.hook = hook\n      # create the annotation in the database\n      annotation.create\n    end"
        ],
        [
            "def join_as_series(options = {})\n      if defined?(I18n)\n        default_delimiter       = I18n.translate(:'series_joiner.default_delimiter',       :locale => options[:locale])\n        default_final_delimiter = I18n.translate(:'series_joiner.default_final_delimiter', :locale => options[:locale])\n        default_conjunction     = I18n.translate(:'series_joiner.default_conjunction',     :locale => options[:locale])\n      else\n        default_delimiter       = ', '\n        default_final_delimiter = ''\n        default_conjunction     = ' and '\n      end\n\n      delimiter = options[:delimiter] || default_delimiter\n      final_delimiter = options[:final_delimiter] || default_final_delimiter\n      conjunction = options[:conjunction] || default_conjunction\n\n      sz = self.size\n      if sz > 0\n        r = self[0]\n        if sz > 1\n          if sz > 2\n            for i in 1..(sz - 2)\n              r += delimiter + self[i]\n            end\n            r += final_delimiter\n          end\n          r += conjunction + self[sz - 1]\n        end\n      end\n      return r\n    end"
        ],
        [
            "def awesome_string(string)\n      lexers = ::Rouge::Guessers::Source.new(string).filter(R_LEXERS)\n      if !lexers.empty?\n        format_syntax_string(string, lexers.first)\n      elsif string =~ /(?:\\r?\\n)(?!\\z)/\n        format_multiline_string(string)\n      else\n        format_plain_string(string)\n      end\n    end"
        ],
        [
            "def meta=val\n      val = JSON.parse(val) if val.is_a?(String)\n      write_store_attribute(:data, :meta, val)\n    end"
        ],
        [
            "def execute\n      File.new(infile).each_with_index do |line, index|\n        row = row_filter.process(line, row: index)\n        next if row.nil? or row.chomp.empty?\n        collection.each do |category, elements|\n          values = elements[:filter].process(row) \n          values.chomp.split(';').each do |value|\n            elements[:entries] << value.chomp if elements[:entries].index(value.chomp).nil?\n          end\n        end\n      end\n\n      File.open(outfile, 'w') do |out|\n        collection.each do |category, elements|\n          out.puts \"[#{category}]\"\n          elements[:entries].sort.each { |c| out.puts c }\n        end\n      end\n    end"
        ],
        [
            "def init_collection(column_filter)\n        column_filter.split('+').each do |f|\n          category, filter = f.split(':')\n          collection[category] = { entries: [], filter: ColumnFilter.new(filter) }\n        end \n      end"
        ],
        [
            "def log\n      out.sync = true\n      @log ||= Logger.new(out)\n\n      @log.formatter = proc do |severity, datetime, progname, msg|\n        if verbose\n          string = \"#{severity} [#{datetime.strftime('%Y-%m-%d %H:%M:%S.%2N')}]: \"\n        else\n          string = \"[#{datetime.strftime('%H:%M:%S')}]: \"\n        end\n\n        string += \"#{msg}\\n\"\n\n        string\n      end\n      @log\n    end"
        ],
        [
            "def require_aether *deps\n      @mini_aether_require_spec ||= MiniAether::Spec.new\n      @mini_aether_require_resolver ||= MiniAether::Resolver.new\n\n      spec = @mini_aether_require_spec\n      resolver = @mini_aether_require_resolver\n\n      if deps.last.kind_of?(Hash)\n        hash = deps.pop\n        [hash[:source], hash[:sources]].flatten.compact.each do |source|\n          spec.source(source)\n        end\n      end\n\n      deps.each {|coords| spec.jar(coords) }\n      resolver.require(spec.dependencies, spec.sources)\n      nil\n    end"
        ],
        [
            "def create_lookup_table\n        File.open(source).each_with_index do |line|\n          next if line.chomp.empty?\n\n          values = unstring(line).chomp.split(';')\n\n          next if values.empty?\n\n          @joiners.each do |joiner|\n            key = values[joiner.join[0]]\n            joiner.lookup[:rows][key] = []\n\n            joiner.cols.each do |i|\n              joiner.lookup[:rows][key] << values[i]\n            end\n          end\n\n        end\n      end"
        ],
        [
            "def col_positions(pos, cols)\n        if pos.nil? || pos.empty?\n          pos = []\n          cols.each { |c| pos << Array.new(c.size) { |c| c } }\n          pos\n        else\n          pos.split(';').collect { |p| p.split(',').collect { |p| p.to_i } }\n        end\n      end"
        ],
        [
            "def create_joiners(j, c, p)\n        js = j.split(';').collect { |j| j.split('=').collect { |j| j.to_i } }\n        cs = c.split(';').collect { |c| c.split(',').collect { |c| c.to_i } }\n        ps = col_positions(p, cs)\n\n        @joiners = []\n        (0...js.size).each do |i| \n          @joiners << Joiner.new(js[i], ps[i], cs[i], { rows: { } }) \n        end \n\n        ps.flatten\n      end"
        ],
        [
            "def add_defaults_local\n      super\n      self.title ||= short_title\n      self.short_title ||= title\n      self.start_date ||= Java::JavaUtil::Date.new\n    end"
        ],
        [
            "def [](*range)\n      r, c = range\n      r ||= 0..(nrows-1)\n      c ||= 0..(ncols-1)\n \n      row_selection = rows.values_at(*r)\n      col_selection = []\n\n      if rows_are_arrays?(row_selection)\n        row_selection.each do |row|\n          values = row.values_at(*c)\n          col_selection << (values.respond_to?(:to_ary) ? values : [values])\n        end \n      else\n        col_selection << row_selection[*c]\n      end\n\n      SpreadSheet.new(*col_selection, \n                      row_labels: row_labels.values_at(*r),\n                      col_labels: col_labels.values_at(*c))\n    end"
        ],
        [
            "def column_collect(&block)\n      result = []\n      0.upto(ncols-1) { |i| result << block.call(self[nil,i]) }\n      result\n    end"
        ],
        [
            "def rename(opts = {})\n      if opts[:rows]\n        opts[:rows] = opts[:rows][0,nrows]\n        opts[:rows] += row_labels[opts[:rows].size, nrows]\n      end\n\n      if opts[:cols]\n        opts[:cols] = opts[:cols][0,ncols]\n        opts[:cols] += col_labels[opts[:cols].size, ncols]\n      end\n\n      @row_labels = opts[:rows] if opts[:rows]\n      @col_labels = opts[:cols] if opts[:cols]\n    end"
        ],
        [
            "def to_s\n      col_label_sizes = col_labels.collect { |c| c.to_s.size + 2 }\n      row_label_size = row_labels.collect { |r| r.to_s.size + 2 }.max\n\n      row_col_sizes = rows.transpose.collect { |r| r.collect { |c| c.to_s.size } } \n\n      i = -1\n      col_sizes = col_label_sizes.collect do |s| \n        i += 1\n        [row_col_sizes[i],s].flatten.max + 1\n      end\n\n      s = (sprintf(\"%#{row_label_size}s\", \" \"))\n      col_labels.each_with_index { |l,i| s << (sprintf(\"%#{col_sizes[i]}s\", \n                                                       \"[#{l}]\"))           } \n      s << \"\\n\"\n\n      rows.each_with_index do |row, i|\n        s << (sprintf(\"%#{row_label_size}s\", \"[#{row_labels[i]}]\"))\n        row.each_with_index { |c,j| s << (sprintf(\"%#{col_sizes[j]}s\", c)) }\n        s << \"\\n\"\n      end\n\n      s\n    end"
        ],
        [
            "def rows_from_params(opts)\n        col_count = opts[:cols] \n        row_count = opts[:rows]\n        \n        size = row_count * col_count if row_count && col_count\n\n        rows = []\n\n        if values = opts[:values] \n          if size\n            values += [NotAvailable] * (size - values.size)\n          elsif col_count\n            values += [NotAvailable] * ((col_count - values.size) % col_count)\n          elsif row_count\n            values += [NotAvailable] * ((row_count - values.size) % row_count)\n            col_count = values.size / row_count\n          else\n            col_count = Math.sqrt(values.size).ceil\n            values += [NotAvailable] * ((col_count - values.size) % col_count)\n          end\n          values.each_slice(col_count) { |row| rows << row }\n        elsif opts[:file]\n          File.foreach(opts[:file]) do |line| \n            next if line.chomp.empty?\n            values = line.split(SEMICOLON) rescue str2utf8(line).split(SEMICOLON)\n            rows << values.collect { |v| \n              v.strip.empty? ? NotAvailable : str2num(v.chomp, opts[:ds])\n            }\n          end\n        end\n\n        rows\n      end"
        ],
        [
            "def equalize_rows(rows)\n        column_sizes = rows.collect { |r| r.size }\n\n        return rows if column_sizes.uniq.size == 1\n\n        max_size = column_sizes.max\n        small_rows = []\n        column_sizes.each_with_index { |c,i| small_rows << i if c < max_size }\n\n        small_rows.each do |i| \n          rows[i] += [NotAvailable] * (max_size - rows[i].size)\n        end\n\n        rows\n      end"
        ],
        [
            "def same_column_size?(rows)\n        offset = opts[:c] ? 1 : 0\n        return true if rows.size == 1 + offset\n        (0 + offset).upto(rows.size - 2) do |i| \n          return false unless rows[i].size == rows[i+1].size\n        end\n        true\n      end"
        ],
        [
            "def coerce(value)\n        return SpreadSheet.new([value]) if value.is_a?(Numeric)\n        return SpreadSheet.new(value)   if value.is_a?(Array)\n      end"
        ],
        [
            "def process(operator, s)\n        s = coerce(s) || s\n        raise \"operand needs to be a SpreadSheet, \"+\n              \"Numeric or Array\" unless s.is_a?(SpreadSheet)\n        result = []\n        rlabel = []\n        clabel = []\n        s1_row_count, s1_col_count = dim\n        s2_row_count, s2_col_count = s.dim\n        row_count = [s1_row_count, s2_row_count].max\n        col_count = [s1_col_count, s2_col_count].max\n        0.upto(row_count - 1) do |r|\n          r1 = r % s1_row_count\n          r2 = r % s2_row_count\n          rlabel << \"#{row_labels[r1]}#{operator}#{s.row_labels[r2]}\"\n          element = []\n          0.upto(col_count - 1) do |c|\n            c1 = c % s1_col_count\n            c2 = c % s2_col_count\n            clabel << \"#{col_labels[c1]}#{operator}#{s.col_labels[c2]}\"\n            element << rows[r1][c1].send(operator, s.rows[r2][c2])\n          end\n          result << element\n        end\n        SpreadSheet.new(*result, row_labels: rlabel, col_labels: clabel)\n      end"
        ],
        [
            "def process_count\n      File.new(infile).each_with_index do |line, index|\n        result = col_filter.process(row_filter.process(line.chomp, row: index))\n        unless result.nil? or result.empty?\n          key = unstring(line).split(';').values_at(*key_columns)\n          key_value = key_values[key] || key_values[key] = { name: key, \n                                                             elements: Hash.new(0), \n                                                             sum: 0 }\n          result.chomp.split(';').each do |column|\n            heading << column if heading.index(column).nil?\n            key_value[:elements][column] += 1\n            key_value[:sum] += 1\n            sums[column] += 1\n          end\n        end\n      end\n    end"
        ],
        [
            "def write_result\n      sum_line = [sum_row_title] + [''] * (key_titles.size - 1)\n      headline = heading_sort ? heading.sort : original_pivot_sequence_heading\n      headline << add_sum_col unless sum_col_title.nil?\n      headline.each do |h|\n        sum_line << sums[h]\n      end\n      row = 0;\n      File.open(outfile, 'w') do |out|\n        out.puts sum_line.join(';') if row == sum_row ; row += 1\n        out.puts (key_titles + headline).join(';')\n        key_values.each do |k,v|\n          out.puts sum_line.join(';') if row == sum_row ; row += 1\n          line = [k]\n          headline.each do |h|\n            line << v[:elements][h] unless h == sum_col_title\n          end\n          line << v[:sum] unless sum_col_title.nil?\n          out.puts line.join(';')\n        end\n      end\n    end"
        ],
        [
            "def init_sum_scheme(sum_scheme)\n\n        return if sum_scheme.nil?\n\n        re = /(\\w+):(\\d+)|(\\w+)/\n\n        sum_scheme.scan(re).each do |part|\n          if part.compact.size == 2\n            @sum_row_title = part[0]\n            @sum_row       = part[1].to_i\n          else\n            @sum_col_title = part[2]\n          end\n        end\n\n      end"
        ],
        [
            "def init_key_columns(key_scheme)\n\n        @key_titles  = []\n        @key_columns = []\n\n        keys = key_scheme.scan(/(\\d+):(\\w+)/)\n\n        keys.each do |key|\n          @key_titles  << key[1]\n          @key_columns << key[0].to_i\n        end\n\n      end"
        ],
        [
            "def original_pivot_sequence_heading\n        (heading.sort - col_filter.pivot.keys << col_filter.pivot.keys).flatten\n      end"
        ],
        [
            "def process(object, options={})\n      object = unstring(object)\n      return object unless has_filter?\n      filtered = !filter.flatten.uniq.index(options[:row]).nil?\n      pattern.each do |p|\n        filtered = (filtered or !(object =~ Regexp.new(p)).nil?)\n      end\n      filtered = (filtered or match_boolean_filter?(object.split(';')))\n      filtered ? object : nil\n    end"
        ],
        [
            "def messages\n      data = api('pm.history', :receiverid => id)\n      data['history'].map {|attrs| Message.new(client, attrs)}\n    end"
        ],
        [
            "def stalk\n      become_fan unless client.user.fan_of.include?(self)\n      client.rooms.with_friends.detect do |room|\n        room.listener(id)\n      end\n    end"
        ],
        [
            "def boot(reason = '')\n      api('room.boot_user', :roomid => room.id, :section => room.section, :target_userid => id, :reason => reason)\n      true\n    end"
        ],
        [
            "def report(reason = '')\n      api('room.report_user', :roomid => room.id, :section => room.section, :reported => id, :reason => reason)\n      true\n    end"
        ],
        [
            "def default_derived_characteristics\n      chrs = specimen_characteristics || return\n      pas = chrs.class.nondomain_attributes.reject { |pa| pa == :identifier }\n      chrs.copy(pas)\n    end"
        ],
        [
            "def region=(args)\n      case args\n        when Hash\n          self.setRegion(CoordinateRegion.new(args[:region]).api, animated: args[:animated])\n        else\n          self.setRegion(CoordinateRegion.new(args).api, animated: false)\n      end\n    end"
        ],
        [
            "def collection_site\n      return unless medical_identifiers.size == 1\n      site = medical_identifiers.first.site\n      return if site.nil?\n      site.site_type == Site::SiteType::COLLECTION ? site : nil\n    end"
        ],
        [
            "def match_characteristics(other)\n      chr = characteristics\n      ochr = other.characteristics\n      chr and ochr and chr.tissue_side == ochr.tissue_side and chr.tissue_site == ochr.tissue_site\n    end"
        ],
        [
            "def default_user\n      scg = specimen_collection_group || (specimen.specimen_collection_group if specimen) || return\n      cp = scg.collection_protocol || return\n      cp.coordinators.first || (cp.sites.first.coordinator if cp.sites.size === 1)\n    end"
        ],
        [
            "def export!\n      puts \"Exporting translations:\\n\"\n      if config[:split]\n        translations.keys.each do |locale|\n          if translations[:en].nil?\n            puts 'Missing english translation'\n            exit\n          end\n          puts \"\\nLocale: #{locale}\"\n          fallback_english_hash = flat_hash(translations[:en])\n          translations_hash = flat_hash(translations[locale])\n          if locale != :en\n            translations_hash.each do |key, value|\n              english_fallback = fallback_english_hash[key]\n              if value == nil || value == \"\"\n                puts \"  #{key} missing!\"\n                puts \"     taking english default: '#{english_fallback}'\"\n                translations_hash[key] = english_fallback\n              end\n            end\n          end\n          save(translations_hash, File.join(export_dir, \"translations_#{locale}.js\"))\n        end\n      else\n        save(flat_hash(translations), File.join(export_dir, 'translations.js'))\n      end\n    end"
        ],
        [
            "def save(translations, file)\n      file = ::Rails.root.join(file)\n      FileUtils.mkdir_p File.dirname(file)\n\n      variable_to_assign = config.fetch(:variable, 'Ember.I18n.translations')\n\n      File.open(file, 'w+') do |f|\n        f << variable_to_assign\n        f << ' = '\n        f << JSON.pretty_generate(translations).html_safe\n        f << ';'\n      end\n    end"
        ],
        [
            "def translations\n      ::I18n.load_path = default_locales_path\n      ::I18n.backend.instance_eval do\n        init_translations unless initialized?\n        translations\n      end\n    end"
        ],
        [
            "def load_properties\n      # the properties file\n      file = default_properties_file\n      # the access properties\n      props = file && File.exists?(file) ? load_properties_file(file) : {}\n      # Load the Java application jar path.\n      path = props[:classpath] || props[:path] || infer_classpath\n      Java.expand_to_class_path(path) if path\n      # Get the application login properties from the remoteService.xml, if necessary.\n      unless props.has_key?(:host) or props.has_key?(:port) then\n        url = remote_service_url\n        if url then\n          host, port = url.split(':')\n          props[:host] = host\n          props[:port] = port\n        end\n      end\n      unless props.has_key?(:database) then\n        props.merge(infer_database_properties)\n      end\n      props\n    end"
        ],
        [
            "def parse\n      download_files\n\n      parsing_clients = false\n      parsing_prefile = false\n      parsing_general = false\n      parsing_servers = false\n      parsing_voice_servers = false\n\n      File.open(DATA_FILE_PATH, 'r:ascii-8bit').each { |line|\n\n        if line.start_with? \";\"\n          parsing_clients = false\n          parsing_prefile = false\n          parsing_general = false\n          parsing_servers = false\n          parsing_voice_servers = false\n        elsif parsing_clients\n          clienttype = line.split(\":\")[3]\n          if clienttype.eql? \"PILOT\"\n            @pilots << Pilot.new(line)\n          elsif clienttype.eql? \"ATC\"\n            @atc << ATC.new(line)\n          end\n        elsif parsing_prefile\n          @prefiles << Prefile.new(line)\n        elsif parsing_general\n          line_split = line.split(\"=\")\n          @general[line_split[0].strip.downcase.gsub(\" \", \"_\")] = line_split[1].strip\n        elsif parsing_servers\n          @servers << Server.new(line)\n        elsif parsing_voice_servers\n          @voice_servers << VoiceServer.new(line) if line.length > 2 # ignore last, empty line for voice server that contains 2 characters\n        end\n\n        parsing_clients = true if line.start_with? \"!CLIENTS:\"\n        parsing_prefile = true if line.start_with? \"!PREFILE:\"\n        parsing_general = true if line.start_with? \"!GENERAL:\"\n        parsing_servers = true if line.start_with? \"!SERVERS:\"\n        parsing_voice_servers = true if line.start_with? \"!VOICE SERVERS:\"\n      }\n    end"
        ],
        [
            "def download_files\n      if !File.exists?(STATUS_FILE_PATH) or File.mtime(STATUS_FILE_PATH) < Time.now - STATUS_DOWNLOAD_INTERVAL\n       download_to_file STATUS_URL, STATUS_FILE_PATH\n      end\n\n      if !File.exists?(DATA_FILE_PATH) or File.mtime(DATA_FILE_PATH) < Time.now - DATA_DOWNLOAD_INTERVAL\n        download_to_file random_data_url, DATA_FILE_PATH\n      end\n    end"
        ],
        [
            "def download_to_file url, file\n      url = URI.parse(URI.encode(url.strip))\n\n      File.new(file, File::CREAT)\n\n      Net::HTTP.start(url.host) { |http|\n        resp = http.get(url.path)\n        open(file, \"wb\") { |file|\n          file.write(resp.body)\n        }\n      }\n    end"
        ],
        [
            "def random_data_url\n      url0s = Array.new\n      file = File.open(STATUS_FILE_PATH)\n      file.each {|line|\n        if line.start_with? \"url0\"\n          url0s << line.split(\"=\").last\n        end\n      }\n      return url0s[rand(url0s.length)]\n     end"
        ],
        [
            "def cachier!(var = nil)\n      if var && instance_variable_get(\"@#{var}\")\n        # => Clear the Single Variable\n        remove_instance_variable(\"@#{var}\")\n      else\n        # => Clear the Whole Damned Cache\n        instance_variables.each { |x| remove_instance_variable(x) }\n      end\n    end"
        ],
        [
            "def write_json(file, object)\n      return unless file && object\n      begin\n        File.open(file, 'w') { |f| f.write(JSON.pretty_generate(object)) }\n      end\n    end"
        ],
        [
            "def filestring(file, size = 8192)\n      return unless file\n      return file unless file.is_a?(String) && File.file?(file) && File.size(file) <= size\n      File.read(file)\n    end"
        ],
        [
            "def common_array(ary) # rubocop: disable AbcSize\n      return ary unless ary.is_a? Array\n      count = ary.count\n      return ary if count.zero?\n      return ary.flatten.uniq if count == 1\n      common = ary[0] & ary[1]\n      return common if count == 2\n      (count - 2).times { |x| common &= ary[x + 2] } if count > 2\n      common\n    end"
        ],
        [
            "def run\n      bind_queues and return if test_env?\n      start_shutdown_thread\n      start_error_counter_thread\n      client.on_exception do |e|\n        count_error(e)\n      end\n      client.connect\n      start_event_thread\n\n      puts 'EventListener started. Hit Ctrl-C to exit'\n      Thread.stop\n      puts 'Main thread wakeup - exiting.'\n      client.close\n    end"
        ],
        [
            "def register_observer_class(observer_class)\n      @observer_mutex.synchronize do\n        return if @observed_models.include?(observer_class)\n        @observed_models << observer_class\n        log \"EventListener: registering observer class #{observer_class}\"\n        observer_queue.bind(models_exchange, routing_key: \"#{Isimud.model_watcher_schema}.#{observer_class.base_class.name}.*\")\n      end\n    end"
        ],
        [
            "def register_observer(observer)\n      @observer_mutex.synchronize do\n        log \"EventListener: registering observer #{observer.class} #{observer.id}\"\n        @observers[observer_key_for(observer.class, observer.id)] = observer.observe_events(client)\n      end\n    end"
        ],
        [
            "def unregister_observer(observer_class, observer_id)\n      @observer_mutex.synchronize do\n        log \"EventListener: un-registering observer #{observer_class} #{observer_id}\"\n        if (consumer = @observers.delete(observer_key_for(observer_class, observer_id)))\n          consumer.cancel\n        end\n      end\n    end"
        ],
        [
            "def observer_queue\n      @observer_queue ||= client.create_queue([name, 'listener', Socket.gethostname, Process.pid].join('.'),\n                                              models_exchange,\n                                              queue_options:     {exclusive: true},\n                                              subscribe_options: {manual_ack: true})\n    end"
        ],
        [
            "def as_json(options = {})\n      session_id = parameters.delete(:session_id) || Thread.current[:keas_session_id]\n\n      data = {type:          type,\n              action:        action,\n              user_id:       user_id,\n              occurred_at:   occurred_at,\n              eventful_type: eventful_type,\n              eventful_id:   eventful_id,\n              session_id:    session_id}\n      unless options[:omit_parameters]\n        data[:parameters] = parameters\n        data[:attributes] = attributes\n      end\n      data\n    end"
        ],
        [
            "def do_create(action)\n      options = do_creation_options\n      options.title ||= @params.first\n\n      @helper.send(\"#{action}_usage\") unless options.title\n      fn = @commands.send(action, options)\n      puts \"#{@src_dir}/#{fn}\"\n    end"
        ],
        [
            "def do_move(action)\n      options = do_move_options(action)\n      path = @params.first\n\n      @helper.send(\"#{action}_usage\") unless path\n      fn = @commands.send(action, path, options)\n      puts \"#{@src_dir}/#{fn}\"\n    end"
        ],
        [
            "def do_move_options(type)\n      options = OpenStruct.new\n      opt_parser = OptionParser.new do |opts|\n        if type == 'publish'\n          opts.on('-d', '--keep-draft', \"Keep draft post\") do |d|\n            options.keep_draft = d\n          end\n        else\n          opts.on('-p', '--keep-post', \"Do not delete post\") do |p|\n            options.keep_post = p\n          end\n        end\n\n        opts.on('-t', '--keep-timestamp', \"Keep existing timestamp\") do |t|\n          options.keep_timestamp = t\n        end\n      end\n\n      opt_parser.parse! @params\n      options\n    end"
        ],
        [
            "def resolve_links(text)\n      html = Nokogiri::HTML.fragment(text)\n      html.css(\"a[href]\").each do |link|\n        href = URI(link[\"href\"])\n        next unless href.relative? && markup_for_file(nil, href.path) == :markdown\n        link.replace \"{file:#{href} #{link.inner_html}}\"\n      end\n      super(html.to_s)\n    end"
        ],
        [
            "def nr_api\n      # => Build the Faraday Connection\n      @conn ||= Faraday::Connection.new('https://api.newrelic.com', conn_opts) do |client|\n        client.use Faraday::Response::RaiseError\n        client.use FaradayMiddleware::EncodeJson\n        client.use FaradayMiddleware::ParseJson, content_type: /\\bjson$/\n        client.response :logger if Config.environment.to_s.casecmp('development').zero? # => Log Requests to STDOUT\n        client.adapter Faraday.default_adapter #:net_http_persistent\n      end\n    end"
        ],
        [
            "def alert_add_entity(entity_id, condition_id, entity_type = 'Server')\n      nr_api.put do |req|\n        req.url url('alerts_entity_conditions', entity_id)\n        req.params['entity_type'] = entity_type\n        req.params['condition_id'] = condition_id\n      end\n    end"
        ],
        [
            "def alert_delete_entity(entity_id, condition_id, entity_type = 'Server')\n      nr_api.delete do |req|\n        req.url url('alerts_entity_conditions', entity_id)\n        req.params['entity_type'] = entity_type\n        req.params['condition_id'] = condition_id\n      end\n    end"
        ],
        [
            "def get_server_id(server_id)\n      return nil unless server_id =~ /^[0-9]+$/\n      ret = nr_api.get(url('servers', server_id)).body\n      ret['server']\n    rescue Faraday::ResourceNotFound, NoMethodError\n      nil\n    end"
        ],
        [
            "def get_server_name(server, exact = true)\n      ret = nr_api.get(url('servers'), 'filter[name]' => server).body\n      return ret['servers'] unless exact\n      ret['servers'].find { |x| x['name'].casecmp(server).zero? }\n    rescue NoMethodError\n      nil\n    end"
        ],
        [
            "def get_servers_labeled(labels)\n      label_query = Array(labels).reject { |x| !x.include?(':') }.join(';')\n      return [] unless label_query\n      nr_api.get(url('servers'), 'filter[labels]' => label_query).body\n    end"
        ],
        [
            "def observe_events(client)\n      return unless enable_listener?\n      queue = create_queue(client)\n      client.subscribe(queue) do |message|\n        event = Event.parse(message)\n        handle_event(event)\n      end\n    end"
        ],
        [
            "def bind(queue_name, exchange_name, *routing_keys, &block)\n      queue = create_queue(queue_name, exchange_name,\n                           queue_options: {durable: true},\n                           routing_keys:  routing_keys)\n      subscribe(queue, &block) if block_given?\n    end"
        ],
        [
            "def create_queue(queue_name, exchange_name, options = {})\n      queue_options = options[:queue_options] || {durable: true}\n      routing_keys  = options[:routing_keys] || []\n      log \"Isimud::BunnyClient: create_queue #{queue_name}: queue_options=#{queue_options.inspect}\"\n      queue = find_queue(queue_name, queue_options)\n      bind_routing_keys(queue, exchange_name, routing_keys) if routing_keys.any?\n      queue\n    end"
        ],
        [
            "def subscribe(queue, options = {}, &block)\n      queue.subscribe(options.merge(manual_ack: true)) do |delivery_info, properties, payload|\n        current_channel = delivery_info.channel\n        begin\n          log \"Isimud: queue #{queue.name} received #{properties[:message_id]} routing_key: #{delivery_info.routing_key}\", :debug\n          Thread.current['isimud_queue_name']    = queue.name\n          Thread.current['isimud_delivery_info'] = delivery_info\n          Thread.current['isimud_properties']    = properties\n          block.call(payload)\n          if current_channel.open?\n            log \"Isimud: queue #{queue.name} finished with #{properties[:message_id]}, acknowledging\", :debug\n            current_channel.ack(delivery_info.delivery_tag)\n          else\n            log \"Isimud: queue #{queue.name} unable to acknowledge #{properties[:message_id]}\", :warn\n          end\n        rescue => e\n          log(\"Isimud: queue #{queue.name} error processing #{properties[:message_id]} payload #{payload.inspect}: #{e.class.name} #{e.message}\\n  #{e.backtrace.join(\"\\n  \")}\", :warn)\n          retry_status = run_exception_handlers(e)\n          log \"Isimud: rejecting #{properties[:message_id]} requeue=#{retry_status}\", :warn\n          current_channel.open? && current_channel.reject(delivery_info.delivery_tag, retry_status)\n        end\n      end\n    end"
        ],
        [
            "def channel\n      if (channel = Thread.current[CHANNEL_KEY]).try(:open?)\n        channel\n      else\n        new_channel = connection.channel\n        new_channel.confirm_select\n        new_channel.prefetch(Isimud.prefetch_count) if Isimud.prefetch_count\n        Thread.current[CHANNEL_KEY] = new_channel\n      end\n    end"
        ],
        [
            "def publish(exchange, routing_key, payload, options = {})\n      log \"Isimud::BunnyClient#publish: exchange=#{exchange} routing_key=#{routing_key}\", :debug\n      channel.topic(exchange, durable: true).publish(payload, options.merge(routing_key: routing_key, persistent: true))\n    end"
        ],
        [
            "def post(opts)\n      opts = @helper.ensure_open_struct(opts)\n      date = @helper.get_date_stamp\n\n      # still want to escape any garbage in the slug\n      slug = if opts.slug.nil? || opts.slug.empty?\n               opts.title\n             else\n               opts.slug\n             end\n      slug = @helper.get_slug_for(slug)\n\n      # put the metadata into the layout header\n      head, ext = @helper.get_layout(opts.layout)\n      head.sub!(/^title:\\s*$/, \"title: #{opts.title}\")\n      head.sub!(/^date:\\s*$/, \"date: #{date}\")\n      ext ||= @ext\n\n      path = File.join(POSTS_FOLDER, \"#{date}-#{slug}.#{ext}\")\n      f = File.open(path, \"w\")\n      f.write(head)\n      f.close\n      @helper.open_in_editor(path) # open file if config key set\n      path    # return the path, in case we want to do anything useful\n    end"
        ],
        [
            "def draft(opts)\n      opts = @helper.ensure_open_struct(opts)\n\n      # the drafts folder might not exist yet...create it just in case\n      FileUtils.mkdir_p(DRAFTS_FOLDER)\n\n      slug = if opts.slug.nil? || opts.slug.empty?\n               opts.title\n             else\n               opts.slug\n             end\n      slug = @helper.get_slug_for(slug)\n\n      # put the metadata into the layout header\n      head, ext = @helper.get_layout(opts.layout)\n      head.sub!(/^title:\\s*$/, \"title: #{opts.title}\")\n      head.sub!(/^date:\\s*$/, \"date: #{@helper.get_date_stamp}\")\n      ext ||= @ext\n\n      path = File.join(DRAFTS_FOLDER, \"#{slug}.#{ext}\")\n      f = File.open(path, \"w\")\n      f.write(head)\n      f.close\n      @helper.open_in_editor(path) # open file if config key set\n      path    # return the path, in case we want to do anything useful\n    end"
        ],
        [
            "def publish(draftpath, opts={})\n      opts = @helper.ensure_open_struct(opts)\n      tail = File.basename(draftpath)\n\n      begin\n        infile = File.open(draftpath, \"r\")\n      rescue Errno::ENOENT\n        @helper.bad_path(draftpath)\n      end\n\n      date = @helper.get_date_stamp\n      time = @helper.get_time_stamp\n\n      outpath = File.join(POSTS_FOLDER, \"#{date}-#{tail}\")\n      outfile = File.open(outpath, \"w\")\n\n      infile.each_line do |line|\n        line.sub!(/^date:.*$/, \"date: #{date} #{time}\\n\") unless opts.keep_timestamp\n        outfile.write(line)\n      end\n\n      infile.close\n      outfile.close\n      FileUtils.rm(draftpath) unless opts.keep_draft\n\n      outpath\n    end"
        ],
        [
            "def terminal_size\n    rows, cols = 25, 80\n    buf = [0, 0, 0, 0].pack(\"SSSS\")\n    if $stdout.ioctl(TIOCGWINSZ, buf) >= 0 then\n      rows, cols, row_pixels, col_pixels = buf.unpack(\"SSSS\")\n    end\n    return [rows, cols]\n  end"
        ],
        [
            "def prepare_modes\n    buf = [0, 0, 0, 0, 0, 0, ''].pack(\"IIIICCA*\")\n    $stdout.ioctl(TCGETS, buf)\n    @old_modes = buf.unpack(\"IIIICCA*\")\n    new_modes = @old_modes.clone\n    new_modes[3] &= ~ECHO # echo off\n    new_modes[3] &= ~ICANON # one char @ a time\n    $stdout.ioctl(TCSETS, new_modes.pack(\"IIIICCA*\"))\n    print \"\\e[2J\" # clear screen\n    print \"\\e[H\" # go home\n    print \"\\e[?47h\" # kick xterm into the alt screen\n    print \"\\e[?1000h\" # kindly ask for mouse positions to make up for it\n    self.cursor = false\n    flush\n  end"
        ],
        [
            "def extract_subjects(subject)\n      return extract_subjects(subject.to_permission_instance) if subject.respond_to? :to_permission_instance\n\n      return subject[:any] if subject.is_a? Hash and subject.key? :any\n\n      [subject]\n    end"
        ],
        [
            "def daemon # rubocop: disable AbcSize, MethodLength\n      # => Windows Workaround (https://github.com/bdwyertech/newrelic-management/issues/1)\n      ENV['TZ'] = 'UTC' if OS.windows? && !ENV['TZ']\n\n      scheduler = Rufus::Scheduler.new\n      Notifier.msg('Daemonizing Process')\n\n      # => Alerts Management\n      alerts_interval = Config.alert_management_interval\n      scheduler.every alerts_interval, overlap: false do\n        Manager.manage_alerts\n      end\n\n      # => Cleanup Stale Servers\n      if Config.cleanup\n        cleanup_interval = Config.cleanup_interval\n        cleanup_age = Config.cleanup_age\n\n        scheduler.every cleanup_interval, overlap: false do\n          Manager.remove_nonreporting_servers(cleanup_age)\n        end\n      end\n\n      # => Join the Current Thread to the Scheduler Thread\n      scheduler.join\n    end"
        ],
        [
            "def run\n      daemon if Config.daemonize\n\n      # => Manage Alerts\n      Manager.manage_alerts\n\n      # => Manage\n      Manager.remove_nonreporting_servers(Config.cleanup_age) if Config.cleanup\n    end"
        ],
        [
            "def ensure_jekyll_dir\n      @orig_dir = Dir.pwd\n      start_path = Pathname.new(@orig_dir)\n\n      ok = File.exists?('./_posts')\n      new_path = nil\n\n      # if it doesn't exist, check for a custom source dir in _config.yml\n      if !ok\n        check_custom_src_dir!\n        ok = File.exists?('./_posts')\n        new_path = Pathname.new(Dir.pwd)\n      end\n\n      if ok\n        return (new_path ? new_path.relative_path_from(start_path) : '.')\n      else\n        puts 'ERROR: Cannot locate _posts directory. Double check to make sure'\n        puts '       that you are in a jekyll directory.'\n        exit\n      end\n    end"
        ],
        [
            "def get_layout(layout_path)\n\n      if layout_path.nil?\n        contents  = \"---\\n\"\n        contents << \"title:\\n\"\n        contents << \"layout: post\\n\"\n        contents << \"date:\\n\"\n        contents << \"---\\n\"\n        ext = nil\n      else\n        begin\n          contents = File.open(layout_path, \"r\").read()\n          ext = layout_path.match(/\\.(.*?)$/)[1]\n        rescue Errno::ENOENT\n          bad_path(layout_path)\n        end\n      end\n\n      return contents, ext\n    end"
        ],
        [
            "def gen_usage\n      puts 'Usage:'\n      puts '  poole [ACTION] [ARG]'\n      puts ''\n      puts 'Actions:'\n      puts '  draft      Create a new draft in _drafts with title SLUG'\n      puts '  post       Create a new timestamped post in _posts with title SLUG'\n      puts '  publish    Publish the draft with SLUG, timestamping appropriately'\n      puts '  unpublish  Move a post to _drafts, untimestamping appropriately'\n      exit\n    end"
        ],
        [
            "def msg(message, subtitle = message, title = 'NewRelic Management')\n      # => Stdout Messages\n      terminal_notification(message, subtitle)\n\n      return if Config.silent\n\n      # => Pretty GUI Messages\n      osx_notification(message, subtitle, title) if OS.x?\n    end"
        ],
        [
            "def osx_notification(message, subtitle, title)\n      TerminalNotifier.notify(message, title: title, subtitle: subtitle)\n    end"
        ],
        [
            "def analyze(string, options = {})\n      x = []\n      @fst._analyze(string) do |a| \n        if options[:symbol_sequence]\n          x << a.map { |s| s.match(/^<(.*)>$/) ? $1.to_sym : s }\n        else\n          x << a.join\n        end\n      end\n      x\n    end"
        ],
        [
            "def generate(string)\n      x = []\n      @fst._generate(string) { |a| x << a.join }\n      x\n    end"
        ],
        [
            "def configure(argv = ARGV)\n      # => Parse CLI Configuration\n      cli = Options.new\n      cli.parse_options(argv)\n\n      # => Parse JSON Config File (If Specified and Exists)\n      json_config = Util.parse_json(cli.config[:config_file] || Config.config_file)\n\n      # => Merge Configuration (CLI Wins)\n      config = [json_config, cli.config].compact.reduce(:merge)\n\n      # => Apply Configuration\n      config.each { |k, v| Config.send(\"#{k}=\", v) }\n    end"
        ],
        [
            "def missing_specs_from_file(path)\n      Spectro::Spec::Parser.parse(path).select do |spec|\n        index_spec = Spectro::Database.index[path] && Spectro::Database.index[path][spec.signature.name]\n        index_spec.nil? || index_spec['spec_md5'] != spec.md5\n      end\n    end"
        ],
        [
            "def remove_nonreporting_servers(keeptime = nil)\n      list_nonreporting_servers.each do |server|\n        next if keeptime && Time.parse(server[:last_reported_at]) >= Time.now - ChronicDuration.parse(keeptime)\n        Notifier.msg(server[:name], 'Removing Stale, Non-Reporting Server')\n        Client.delete_server(server[:id])\n      end\n    end"
        ],
        [
            "def find_excluded(excluded)\n      result = []\n      Array(excluded).each do |exclude|\n        if exclude.include?(':')\n          find_labeled(exclude).each { |x| result << x }\n          next\n        end\n        res = Client.get_server(exclude)\n        result << res['id'] if res\n      end\n      result\n    end"
        ],
        [
            "def send_sms_confirmation!\n      return false if _TC_sms_blocked\n      return true  if sms_confirmed?\n      return false if _TC_phone_number.blank?\n\n      format_phone_number\n      confirmation_code = TwilioContactable.confirmation_code(self, :sms)\n\n      # Use this class' confirmation_message method if it\n      # exists, otherwise use the generic message\n      message = (self.class.respond_to?(:confirmation_message) ?\n                   self.class :\n                   TwilioContactable).confirmation_message(confirmation_code)\n\n      if message.to_s.size > 160\n        raise ArgumentError, \"SMS Confirmation Message is too long. Limit it to 160 characters of unescaped text.\"\n      end\n\n      response = TwilioContactable::Gateway.deliver_sms(message, _TC_formatted_phone_number)\n\n      if response.success?\n        update_twilio_contactable_sms_confirmation confirmation_code\n      end\n\n      response\n    end"
        ],
        [
            "def send_voice_confirmation!\n      return false if _TC_voice_blocked\n      return true  if voice_confirmed?\n      return false if _TC_phone_number.blank?\n\n      format_phone_number\n      confirmation_code = TwilioContactable.confirmation_code(self, :voice)\n\n      response = TwilioContactable::Gateway.initiate_voice_call(self, _TC_formatted_phone_number)\n\n      if response.success?\n        update_twilio_contactable_voice_confirmation confirmation_code\n      end\n\n      response\n    end"
        ],
        [
            "def validate(value, format, raise_error=false)\n      unless FORMATS.key?(format)\n        raise FormatError, \"Invalid data format: #{format}\"\n      end\n      result = value =~ FORMATS[format] ? true : false\n      if raise_error && !result\n        raise ValidationError, \"Invalid value \\\"#{value}\\\" for #{format}\"\n      end\n      result\n    end"
        ],
        [
            "def call(url, settings, &block)\n      uri = URI.parse(url)\n      klass = adapter_class(uri.scheme)\n      session = klass.new(uri, settings.deep_dup)\n      session.start(&block)\n    end"
        ],
        [
            "def all_fields(table, field_name, value)\n      body = savon.\n             call(:get_all_fields_records_given_a_field_name_and_value,\n                  message: {\n                    'strFeatureClassOrTableName' => table,\n                    'strFieldNameToSearchOn' => field_name,\n                    'strValueOfFieldToSearchOn' => value\n                  }).\n             body\n\n      resp = body[:get_all_fields_records_given_a_field_name_and_value_response]\n      rslt = resp[:get_all_fields_records_given_a_field_name_and_value_result]\n      polys = rslt[:diffgram][:document_element][:municipality_poly]\n\n      poly = if polys.is_a? Array\n               polys.first\n             elsif polys.is_a? Hash\n               polys\n             else\n               fail \"Unexpected polys #{polys.class.name}, wanted Array or Hash\"\n             end\n    end"
        ],
        [
            "def WHEN(condition, adjuster)\n      unless Validation.conditionable? condition\n        raise TypeError, 'wrong object for condition'\n      end\n\n      unless Validation.adjustable? adjuster\n        raise TypeError, 'wrong object for adjuster'\n      end\n\n      ->v{_valid?(condition, v) ? adjuster.call(v) : v}\n    end"
        ],
        [
            "def INJECT(adjuster1, adjuster2, *adjusters)\n      adjusters = [adjuster1, adjuster2, *adjusters]\n\n      unless adjusters.all?{|f|adjustable? f}\n        raise TypeError, 'wrong object for adjuster'\n      end\n\n      ->v{\n        adjusters.reduce(v){|ret, adjuster|adjuster.call ret}\n      }\n    end"
        ],
        [
            "def PARSE(parser)\n      if !::Integer.equal?(parser) and !parser.respond_to?(:parse)\n        raise TypeError, 'wrong object for parser'\n      end\n\n      ->v{\n        if ::Integer.equal? parser\n          ::Kernel.Integer v\n        else\n          parser.parse(\n            case v\n            when String\n              v\n            when ->_{v.respond_to? :to_str}\n              v.to_str\n            when ->_{v.respond_to? :read}\n              v.read\n            else\n              raise TypeError, 'wrong object for parsing source'\n            end\n          )\n        end\n      }\n    end"
        ],
        [
            "def get_class(name)\n      @class_list = get_class_list\n      @class_list.select {|x| x.include?(name)}.collect{|y| y.strip}\n    end"
        ],
        [
            "def connection\n      @options[:path] =API_REST + @options[:path]\n      @options[:headers] = HEADERS.merge({\n        'X-Megam-Date' =>  Time.now.strftime(\"%Y-%m-%d %H:%M\")\n      }).merge(@options[:headers])\n\n      text.info(\"HTTP Request Data:\")\n      text.msg(\"> HTTP #{@options[:scheme]}://#{@options[:host]}\")\n      @options.each do |key, value|\n        text.msg(\"> #{key}: #{value}\")\n      end\n      text.info(\"End HTTP Request Data.\")\n      http = Net::HTTP.new(@options[:host], @options[:port])\n      http\n    end"
        ],
        [
            "def wake_deadline(start_time, timeout)\n      timeout = process_timeout(timeout)\n      deadline = start_time + timeout if timeout\n    end"
        ],
        [
            "def crud_links(model, instance_name, actions, args={})\n      _html = \"\"\n      _options = args.keys.empty? ? '' : \", #{args.map{|k,v| \":#{k} => #{v}\"}}\"\n  \n      if use_crud_icons\n        if actions.include?(:show)\n          _html << eval(\"link_to image_tag('/images/icons/view.png', :class => 'crud_icon'), model, :title => 'View'#{_options}\")\n        end\n        if actions.include?(:edit)\n          _html << eval(\"link_to image_tag('/images/icons/edit.png', :class => 'crud_icon'), edit_#{instance_name}_path(model), :title => 'Edit'#{_options}\")\n        end\n        if actions.include?(:delete)\n          _html << eval(\"link_to image_tag('/images/icons/delete.png', :class => 'crud_icon'), model, :confirm => 'Are you sure? This action cannot be undone.', :method => :delete, :title => 'Delete'#{_options}\")\n        end\n      else\n        if actions.include?(:show)\n          _html << eval(\"link_to 'View', model, :title => 'View', :class => 'crud_link'#{_options}\")\n        end\n        if actions.include?(:edit)\n          _html << eval(\"link_to 'Edit', edit_#{instance_name}_path(model), :title => 'Edit', :class => 'crud_link'#{_options}\")\n        end\n        if actions.include?(:delete)\n          _html << eval(\"link_to 'Delete', model, :confirm => 'Are you sure? This action cannot be undone.', :method => :delete, :title => 'Delete', :class => 'crud_link'#{_options}\")\n        end\n      end\n      _html\n    end"
        ],
        [
            "def obfuscated_link_to(path, image, label, args={})\n      _html = %{<form action=\"#{path}\" method=\"get\" class=\"obfuscated_link\">}\n      _html << %{ <fieldset><input alt=\"#{label}\" src=\"#{image}\" type=\"image\" /></fieldset>}\n      args.each{ |k,v| _html << %{  <div><input id=\"#{k.to_s}\" name=\"#{k}\" type=\"hidden\" value=\"#{v}\" /></div>} }\n      _html << %{</form>}\n      _html\n    end"
        ],
        [
            "def required_field_helper( model, element, html )\n      if model && ! model.errors.empty? && element.is_required\n        return content_tag( :div, html, :class => 'fieldWithErrors' )\n      else\n        return html\n      end\n    end"
        ],
        [
            "def select_tag_for_filter(model, nvpairs, params)\n      return unless model && nvpairs && ! nvpairs.empty?\n      options = { :query => params[:query] }\n      _url = url_for(eval(\"#{model}_url(options)\"))\n      _html = %{<label for=\"show\">Show:</label><br />}\n      _html << %{<select name=\"show\" id=\"show\" onchange=\"window.location='#{_url}' + '?show=' + this.value\">}\n      nvpairs.each do |pair|\n        _html << %{<option value=\"#{pair[:scope]}\"}\n        if params[:show] == pair[:scope] || ((params[:show].nil? || params[:show].empty?) && pair[:scope] == \"all\")\n          _html << %{ selected=\"selected\"}\n        end\n        _html << %{>#{pair[:label]}}\n        _html << %{</option>}\n      end\n      _html << %{</select>}\n    end"
        ],
        [
            "def sort_link(model, field, params, html_options={})\n      if (field.to_sym == params[:by] || field == params[:by]) && params[:dir] == \"ASC\"\n        classname = \"arrow-asc\"\n        dir = \"DESC\"\n      elsif (field.to_sym == params[:by] || field == params[:by])\n        classname = \"arrow-desc\"\n        dir = \"ASC\"\n      else\n        dir = \"ASC\"\n      end\n  \n      options = {\n        :anchor => html_options[:anchor] || nil,\n        :by => field,\n        :dir => dir,\n        :query => params[:query],\n        :show => params[:show]\n      }\n  \n      options[:show] = params[:show] unless params[:show].blank? || params[:show] == 'all'\n  \n      html_options = {\n        :class => \"#{classname} #{html_options[:class]}\",\n        :style => \"color: white; font-weight: #{params[:by] == field ? \"bold\" : \"normal\"}; #{html_options[:style]}\",\n        :title => \"Sort by this field\"\n      }\n  \n      field_name = params[:labels] && params[:labels][field] ? params[:labels][field] : field.titleize\n  \n      _link = model.is_a?(Symbol) ? eval(\"#{model}_url(options)\") : \"/#{model}?#{options.to_params}\"\n      link_to(field_name, _link, html_options)\n    end"
        ],
        [
            "def tag_for_label_with_inline_help( label_text, field_id, help_text )\n      _html = \"\"\n      _html << %{<label for=\"#{field_id}\">#{label_text}}\n      _html << %{<img src=\"/images/icons/help_icon.png\" onclick=\"$('#{field_id}_help').toggle();\" class='inline_icon' />}\n      _html << %{</label><br />}\n      _html << %{<div class=\"inline_help\" id=\"#{field_id}_help\" style=\"display: none;\">}\n      _html << %{<p>#{help_text}</p>}\n      _html << %{</div>}\n      _html\n    end"
        ],
        [
            "def key_press(keys)\n      dump_caller_stack\n      \n      if keys =~ /^Ctrl\\+([A-Z])$/\n        filtered_keys = \"^+#{$1}\"\n      elsif keys =~ /^Ctrl\\+Shift\\+([A-Z])$/\n        filtered_keys = \"^+#{$1.downcase}\"\n      elsif keys =~ /^Alt+([A-Z])$/\n        filtered_keys = \"!+#{$1}\"\n      elsif keys =~ /^Alt\\+Shift\\+([a-z])$/\n        filtered_keys = \"!+#{$1.downcase}\"\n      else\n        filtered_keys = keys\n      end\n      filtered_keys = keys.gsub(\"Alt+\", \"!+\").gsub(\"Ctrl+\", \"^+\")\n      RFormSpec::Keyboard.press(filtered_keys)\n      sleep 0.5\n    end"
        ],
        [
            "def open_file_dialog(title, filepath, text=\"\")\n      wait_and_focus_window(title)\n      dialog = RFormSpec::OpenFileDialog.new(title, text)\n      dialog.enter_filepath(filepath)\n      sleep 1\n      dialog.click_open\n    end"
        ],
        [
            "def parse(args)\n      # The options specified on the command line will be collected in\n      # *options*.\n      @options = Options.new\n      opt_parser = OptionParser.new do |parser|\n        @options.define_options(parser)\n      end\n      opt_parser.parse!(args)\n\n      @options\n    end"
        ],
        [
            "def add(path)\n      str = \"#{path} filter=rgc diff=rgc\"\n      if content.include?(str)\n        abort \"`#{str}\\n` is already included in #{@location}.\"\n      end\n\n      File.open(@location, 'a') do |f|\n        f.write(\"#{str}\\n\")\n      end\n    rescue Errno::ENOENT\n      abort \"File #{@location} does not exists.\"\n    rescue Errno::EACCES\n      abort \"File #{@location} is not accessible for writing.\"\n    end"
        ],
        [
            "def run\n      logger.info(\"#{self.class.to_s} is starting.\")\n      count_options = self.class.legacy_find_options.dup\n      count_options.delete(:order)\n      count_options.delete(:group)\n      count_options.delete(:limit)\n      count_options.delete(:offset)\n      @num_of_records = self.class.legacy_model.count(count_options)\n      if self.class.legacy_find_options[:limit] && (@num_of_records > self.class.legacy_find_options[:limit])\n        run_in_batches @num_of_records\n      else\n        run_normal\n      end\n      logger.info(\"#{self.class.to_s} migrated all #{@num_of_records} records successfully.\")\n    end"
        ],
        [
            "def parents\n      page, parents = self, Array.new\n      while page.parent\n        page = page.parent\n        parents << page\n      end\n      parents\n    end"
        ],
        [
            "def extract_search_text(*attributes)\n      Array(attributes).map { |meth|\n        Nokogiri::HTML(self.send(meth)).xpath(\"//text()\").\n          map {|node| text = node.text; text.try(:strip!); text}.join(\" \")\n      }.reject(&:blank?).join(\"\\n\")\n    end"
        ],
        [
            "def set_query_attributes!\n      attr_names = self.class.search_query_attributes.map(&:to_s)\n      self.query = attr_names.inject({}) { |memo, attr|\n        memo[attr] = self.send(attr)\n        memo\n      }\n    end"
        ],
        [
            "def manager_ws_uri\n    # convert manager uri to websocket\n    uri = URI.parse(manager_uri)\n    uri.scheme = (uri.scheme == \"https\" ? \"wss\" : \"ws\")\n    uri.path = \"/wsapi\"\n    return uri.to_s\n  end"
        ],
        [
            "def parse_config(conffile = nil)\n      conffile ||= Dir.glob([\n\t  \"/etc/foreman_hooks-host_rename/settings.yaml\",\n\t  \"#{confdir}/settings.yaml\"])[0]\n      raise \"Could not locate the configuration file\" if conffile.nil?\n    \n      # Parse the configuration file\n      config = {\n          hook_user: 'foreman',\n          database_path: '/var/tmp/foreman_hooks-host_rename.db',\n          log_path: '/var/tmp/foreman_hooks-host_rename.log',\n          log_level: 'warn',\n          rename_hook_command: '/bin/true',\n      }.merge(symbolize(YAML.load(File.read(conffile))))\n      config.each do |k,v|\n        instance_variable_set(\"@#{k}\",v)\n      end\n    \n      # Validate the schema\n      document = Kwalify::Yaml.load_file(conffile)\n      schema = Kwalify::Yaml.load_file(\"#{confdir}/schema.yaml\")\n      validator = Kwalify::Validator.new(schema)\n      errors = validator.validate(document)\n      if errors && !errors.empty?\n        puts \"WARNING: The following errors were found in #{conffile}:\"\n        for e in errors\n          puts \"[#{e.path}] #{e.message}\"\n        end\n        raise \"Errors in the configuration file\"\n      end\n    \n      check_script @rename_hook_command\n    end"
        ],
        [
            "def check_script(path)\n      binary=path.split(' ')[0]\n      raise \"#{path} does not exist\" unless File.exist? binary\n      raise \"#{path} is not executable\" unless File.executable? binary\n      path\n    end"
        ],
        [
            "def sync_host_table\n      uri = foreman_uri('/hosts?per_page=9999999')\n      debug \"Loading hosts from #{uri}\"\n      json = RestClient.get uri\n      debug \"Got JSON: #{json}\"\n      JSON.parse(json)['results'].each do |rec|\n        @db.execute \"insert into host (id,name) values ( ?, ? )\",\n                   rec['id'], rec['name']\n      end\n    end"
        ],
        [
            "def initialize_database\n      @db = SQLite3::Database.new @database_path\n      File.chmod 0600, @database_path\n      begin\n        @db.execute 'drop table if exists host;'\n        @db.execute <<-SQL\n            create table host (\n              id INT,\n              name varchar(254)\n            );\n        SQL\n        sync_host_table\n      rescue\n        File.unlink @database_path\n        raise\n      end\n    end"
        ],
        [
            "def execute_hook_action\n      @rename = false\n      name = @rec['host']['name']\n      id = @rec['host']['id']\n    \n      case @action\n      when 'create'\n        sql = \"insert into host (id, name) values (?, ?)\"\n        params = [id, name]\n      when 'update'\n        # Check if we are renaming the host\n        @old_name = @db.get_first_row('select name from host where id = ?', id)\n        @old_name = @old_name[0] unless @old_name.nil?\n        if @old_name.nil?\n          warn 'received an update for a non-existent host'\n        else\n          @rename = @old_name != name\n        end\n        debug \"checking for a rename: old=#{@old_name} new=#{name} rename?=#{@rename}\"\n    \n        sql = 'update host set name = ? where id = ?'\n        params = [name, id]\n      when 'destroy'\n        sql = 'delete from host where id = ?'\n        params = [id]\n      else\n        raise ArgumentError, \"unsupported action: #{ARGV[0]}\"\n      end\n      debug \"updating database; id=#{id} name=#{name} sql=#{sql}\"\n      stm = @db.prepare sql\n      stm.bind_params *params\n      stm.execute\n    end"
        ],
        [
            "def read_list(name)\n      opts = self.class.persisted_attrs[name]\n\n      if !lists[name] && opts[:default]\n        opts[:default]\n      else\n        send(\"#{name}=\", lists[name].value) if lists[name].is_a?(Redis::Future)\n        lists[name]\n      end\n    end"
        ],
        [
            "def read_hash(name)\n      opts = self.class.persisted_attrs[name]\n\n      if !hashes[name] && opts[:default]\n        opts[:default]\n      else\n        self.send(\"#{name}=\", hashes[name].value) if hashes[name].is_a?(Redis::Future)\n        hashes[name]\n      end\n    end"
        ],
        [
            "def write_attribute(name, val)\n      if attributes.is_a?(Redis::Future)\n        value = attributes.value \n        self.attributes = value ? Hash[*self.class.fields.keys.zip(value).flatten] : {}\n      end\n\n      attributes[name] = self.class.transform(:to, name, val)\n    end"
        ],
        [
            "def write_list(name, val)\n      raise \"RedisAssist: tried to store a #{val.class.name} as Array\" unless val.is_a?(Array)\n      lists[name] = val\n    end"
        ],
        [
            "def write_hash(name, val)\n      raise \"RedisAssist: tried to store a #{val.class.name} as Hash\" unless val.is_a?(Hash)\n      hashes[name] = val\n    end"
        ],
        [
            "def update_columns(attrs)\n      redis.multi do\n        attrs.each do |attr, value|\n          if self.class.fields.has_key?(attr)\n            write_attribute(attr, value)  \n            redis.hset(key_for(:attributes), attr, self.class.transform(:to, attr, value)) unless new_record?\n          end\n\n          if self.class.lists.has_key?(attr)\n            write_list(attr, value)       \n\n            unless new_record?\n              redis.del(key_for(attr))\n              redis.rpush(key_for(attr), value) unless value.empty?\n            end\n          end\n\n          if self.class.hashes.has_key?(attr)\n            write_hash(attr, value)       \n\n            unless new_record?\n              hash_as_args = hash_to_redis(value)\n              redis.hmset(key_for(attr), *hash_as_args)\n            end\n          end\n        end\n      end\n    end"
        ],
        [
            "def filter_authorized!(method, objects, user = current_user)\n      object_array = Array(objects)\n\n      object_array.select do |object|\n        policy = policy_for(object)\n        policy.can?(method, user)\n      end\n    end"
        ],
        [
            "def can?(method, object, user = current_user)\n      policy = policy_for(object)\n      policy.can?(method, user)\n    end"
        ],
        [
            "def nethash interval = 500, start = 0, stop = false\n      suffixe = stop ? \"/#{stop}\" : ''\n      JSON.parse(call_blockchain_api(\"nethash/#{interval}/#{start}#{suffixe}?format=json\"))\n    end"
        ],
        [
            "def last(limit=1, offset=0)\n      from    = offset\n      to      = from + limit - 1\n      members = redis.zrange(index_key_for(:id), (to * -1) + -1, (from * -1) + -1).reverse\n\n      find(limit > 1 ? members : members.first)\n    end"
        ],
        [
            "def find(ids, opts={})\n      ids.is_a?(Array) ? find_by_ids(ids, opts) : find_by_id(ids, opts)\n    end"
        ],
        [
            "def find_in_batches(options={})\n      start       = options[:start]      || 0\n      marker      = start\n      batch_size  = options[:batch_size] || 500\n      record_ids  = redis.zrange(index_key_for(:id), marker, marker + batch_size - 1)\n\n      while record_ids.length > 0\n        records_count   = record_ids.length\n        marker          += records_count\n        records         = find(record_ids)\n\n        yield records\n\n        break if records_count < batch_size\n\n        record_ids = redis.zrange(index_key_for(:id), marker, marker + batch_size - 1)\n      end\n    end"
        ],
        [
            "def load_keymap(map) #:nodoc:\n      @maps ||= Hash.new\n      if @maps[map].nil? && File.file?(File.join(self.storage_path, map.to_s + \"_map.yml\"))\n        @maps[map] = YAML.load(File.open(File.join(self.storage_path, map.to_s + \"_map.yml\")))\n        logger.debug(\"#{self.class.to_s} lazy loaded #{map} successfully.\")\n      end\n    end"
        ],
        [
            "def mapped_key(map, key)\n      load_keymap(map.to_s)\n      @maps[map.to_s][handle_composite(key)]\n    end"
        ],
        [
            "def processor_count\n      @processor_count ||= begin\n        os_name = RbConfig::CONFIG[\"target_os\"]\n        if os_name =~ /mingw|mswin/\n          require 'win32ole'\n          result = WIN32OLE.connect(\"winmgmts://\").ExecQuery(\n            \"select NumberOfLogicalProcessors from Win32_Processor\")\n          result.to_enum.collect(&:NumberOfLogicalProcessors).reduce(:+)\n        elsif File.readable?(\"/proc/cpuinfo\")\n          IO.read(\"/proc/cpuinfo\").scan(/^processor/).size\n        elsif File.executable?(\"/usr/bin/hwprefs\")\n          IO.popen(\"/usr/bin/hwprefs thread_count\").read.to_i\n        elsif File.executable?(\"/usr/sbin/psrinfo\")\n          IO.popen(\"/usr/sbin/psrinfo\").read.scan(/^.*on-*line/).size\n        elsif File.executable?(\"/usr/sbin/ioscan\")\n          IO.popen(\"/usr/sbin/ioscan -kC processor\") do |out|\n            out.read.scan(/^.*processor/).size\n          end\n        elsif File.executable?(\"/usr/sbin/pmcycles\")\n          IO.popen(\"/usr/sbin/pmcycles -m\").read.count(\"\\n\")\n        elsif File.executable?(\"/usr/sbin/lsdev\")\n          IO.popen(\"/usr/sbin/lsdev -Cc processor -S 1\").read.count(\"\\n\")\n        elsif File.executable?(\"/usr/sbin/sysconf\") and os_name =~ /irix/i\n          IO.popen(\"/usr/sbin/sysconf NPROC_ONLN\").read.to_i\n        elsif File.executable?(\"/usr/sbin/sysctl\")\n          IO.popen(\"/usr/sbin/sysctl -n hw.ncpu\").read.to_i\n        elsif File.executable?(\"/sbin/sysctl\")\n          IO.popen(\"/sbin/sysctl -n hw.ncpu\").read.to_i\n        else\n          $stderr.puts \"Unknown platform: \" + RbConfig::CONFIG[\"target_os\"]\n          $stderr.puts \"Assuming 1 processor.\"\n          1\n        end\n      end\n    end"
        ],
        [
            "def physical_processor_count\n      @physical_processor_count ||= begin\n        ppc = case RbConfig::CONFIG[\"target_os\"]\n        when /darwin1/\n          IO.popen(\"/usr/sbin/sysctl -n hw.physicalcpu\").read.to_i\n        when /linux/\n          cores = {}  # unique physical ID / core ID combinations\n          phy = 0\n          IO.read(\"/proc/cpuinfo\").scan(/^physical id.*|^core id.*/) do |ln|\n            if ln.start_with?(\"physical\")\n              phy = ln[/\\d+/]\n            elsif ln.start_with?(\"core\")\n              cid = phy + \":\" + ln[/\\d+/]\n              cores[cid] = true if not cores[cid]\n            end\n          end\n          cores.count\n        when /mswin|mingw/\n          require 'win32ole'\n          result_set = WIN32OLE.connect(\"winmgmts://\").ExecQuery(\n            \"select NumberOfCores from Win32_Processor\")\n          result_set.to_enum.collect(&:NumberOfCores).reduce(:+)\n        else\n          processor_count\n        end\n        # fall back to logical count if physical info is invalid\n        ppc > 0 ? ppc : processor_count\n      end\n    end"
        ],
        [
            "def valid?(options = {})\n      options = {:input => {}}.merge(options)\n      errors = []\n\n      # initial sandbox\n      sandbox = _source(options)\n\n      # add in inputs\n      sandbox[:inputs] = options[:input]\n\n      validity = @filters.map do |filter_name, filter|\n\n        # find input for given filter\n        sandbox[:input] = options[:input][filter[:key]] if options[:input].is_a?(Hash)\n\n        filter_validity = filter[:valid].nil? || sandbox.instance_eval(&filter[:valid])\n\n        if filter_validity == false\n          # Ignore an empty filter unless it's required\n          if !sandbox[:input].to_s.blank?\n            errors << \"#{filter_name} is invalid.\"\n            false\n          else\n            if sandbox[:input].to_s.blank? && !filter[:require].blank?\n              errors << \"#{filter_name} is required.\"\n              false\n            else\n              true\n            end\n          end\n        elsif filter_validity == true\n          if sandbox[:input].to_s.blank? && !filter[:require].blank?\n            errors << \"#{filter_name} is required.\"\n            false\n          else\n            true\n          end\n        elsif !filter_validity.nil? && !filter_validity[:status].nil? && filter_validity[:status] == false\n          # Ignore an empty filter unless it's required or the error is forced.\n          if !sandbox[:input].to_s.blank? || filter_validity[:force_error] == true\n            errors << filter_validity[:errors]\n            false\n          else\n            if sandbox[:input].to_s.blank? && !filter[:require].blank?\n              errors << \"#{filter_name} is required.\"\n              false\n            else\n              true\n            end\n          end\n        end\n      end\n\n      return {:status => !validity.include?(false), :errors => errors}\n\n    end"
        ],
        [
            "def reload()\n      self.clear\n      self.concat File.read(event_file).split(/\\r?\\n/).map{|e| Event.new(e)}\n    end"
        ],
        [
            "def followee_of?(model)\n      0 < self.followers.by_model(model).limit(1).count * model.followees.by_model(self).limit(1).count\n    end"
        ],
        [
            "def ever_followed\n      follow = []\n      self.followed_history.each do |h|\n        follow << h.split('_')[0].constantize.find(h.split('_')[1])\n      end\n      follow\n    end"
        ],
        [
            "def wait(mutex, timeout = nil)\n      validate_mutex(mutex)\n      validate_timeout(timeout)\n      waitable = waitable_for_current_thread\n      @mutex.synchronize do\n        @waitables.push(waitable)\n        @waitables_to_resume.push(waitable)\n      end\n      waitable.wait(mutex, timeout)\n      self\n    end"
        ],
        [
            "def validate_timeout(timeout)\n      unless timeout == nil\n        raise TypeError, \"'timeout' must be nil or a Numeric\" unless timeout.is_a?(Numeric)\n        raise ArgumentError, \"'timeout' must not be negative\" if timeout.negative?\n      end\n    end"
        ],
        [
            "def render(template_name, view_handler, locals, &content)\n      self.erb_source.render(template_name, render_locals(view_handler, locals), &content)\n    end"
        ],
        [
            "def run_entry\n      entry = get_entry()\n      output = '';\n      @keys.keys.select { |k| @config['key_fields'][k] && @keys[k] }.each do |key|\n        output += [ key, @keys[key] ].join(' ') + \" \"\n      end\n\n      unless entry\n        $stderr.puts \"#{ output } is not supported on #{ @page_name }\" if @debug\n        return\n      end\n\n      unless entry['ready'] == \"1\"\n        $stderr.puts \"#{ output } is not ready to run #{ @agent_name }\" if @debug\n        return false, entry\n      end\n\n      if entry['complete'] == \"1\"\n        $stderr.puts \"All goals are completed for #{ output }\" if @debug\n        return false, entry\n      end\n\n      if entry[@agent_name]\n        (status, running_hostname) = entry[@agent_name].split(':')\n\n        case status\n        when 'r'\n          $stderr.puts \" #{ output } is already running #{ @agent_name } on #{ running_hostname }\" if @debug\n          return false, entry\n        \n        when \"1\"\n          $stderr.puts \" #{ output } has already run #{ @agent_name }\" if @debug\n          return false, entry\n\n        when 'F'\n          $stderr.puts \" #{ output } has already Failed  #{ @agent_name }\" if @debug\n          return false, entry\n        end\n      end\n\n      if @prerequisites\n        @prerequisites.each do |prereq_field|\n          unless entry[prereq_field] == \"1\"\n            $stderr.puts \" #{ output } has not finished #{ prereq_field }\" if @debug\n            return false, entry\n          end\n        end\n      end\n\n      # first attempt to set the hostname of the machine as the value of the agent\n      hostname = Socket.gethostname;\n      begin\n        entry.update @agent_name => \"r:#{ hostname }\"\n        @worksheet.save\n\n      rescue GoogleDrive::Error\n        # this is a collision, which is to be treated as if it is not runnable\n        $stderr.puts \" #{ output } lost #{ @agent_name } on #{hostname}\" if @debug\n        return false, entry\n      end\n\n      sleep 3\n      begin\n        @worksheet.reload\n      rescue GoogleDrive::Error\n        # this is a collision, which is to be treated as if it is not runnable\n        $stderr.puts \" #{ output } lost #{ @agent_name } on #{hostname}\" if @debug\n        return false, entry\n      end\n\n      check = entry[@agent_name]\n      (status, running_hostname) = check.split(':')\n      if hostname == running_hostname\n        return true, entry\n      end\n      $stderr.puts \" #{ output } lost #{ @agent_name } on #{hostname}\" if @debug\n      return false, entry\n    end"
        ],
        [
            "def pick(number, *cards)\n      ordered = cards.flatten.map do |card|\n        i = card_preference.map { |preference| card.type == preference }.index(true)\n        {card: card, index: i}\n      end\n      ordered.sort_by { |h| h[:index] || 99 }.first(number).map {|h| h[:card] }\n    end"
        ],
        [
            "def discard\n      ordered = player.hand.map do |card|\n        i = card_preference.map { |preference| card.type == preference }.index(true)\n        {card: card, index: i}\n      end\n      ordered.sort_by { |h| h[:index] || 99 }.last.try(:fetch, :card)\n    end"
        ],
        [
            "def play\n      bangs_played = 0\n      while !player.hand.find_all(&:draws_cards?).empty?\n        player.hand.find_all(&:draws_cards?).each {|card| player.play_card(card)}\n      end\n      play_guns\n      player.hand.each do |card|\n        target = find_target(card)\n        next if skippable?(card, target, bangs_played)\n        bangs_played += 1 if card.type == Card.bang_card\n        player.play_card(card, target, :hand)\n      end\n    end"
        ],
        [
            "def sleep(timeout = nil)\n      validate_timeout(timeout)\n      unlock do\n        if timeout == nil || timeout == Float::INFINITY\n          elapsed_time = (timer { Thread.stop }).round\n        else\n          elapsed_time = Kernel.sleep(timeout)\n        end\n      end\n    end"
        ],
        [
            "def temporarily_release(&block)\n      raise ArgumentError, 'no block given' unless block_given?\n      unlock\n      begin\n        return_value = yield\n        lock\n      rescue Exception\n        lock_immediately\n        raise\n      end\n      return_value\n    end"
        ],
        [
            "def timer(&block)\n      start_time = Time.now\n      yield(start_time)\n      time_elapsed = Time.now - start_time\n    end"
        ],
        [
            "def wait\n      continue = false\n      trap \"SIGINT\" do\n        puts \"Continuing...\"\n        continue = true\n      end\n      puts \"Waiting. Press ^C to continue test...\"\n      wait_until(3600) { continue }\n      trap \"SIGINT\", \"DEFAULT\"\n    end"
        ],
        [
            "def optional_args_block_call(block, args)\n      if RUBY_VERSION >= \"1.9.0\"\n        if block.arity == 0\n          block.call\n        else\n          block.call(*args)\n        end\n      else\n        block.call(*args)\n      end\n    end"
        ],
        [
            "def extract_file_rdoc(file, from = nil, reverse = false)\n      lines = File.readlines(file)\n      if from.nil? and reverse\n        lines = lines.reverse\n      elsif !reverse\n        lines = lines[(from || 0)..-1]\n      else\n        lines = lines[0...(from || -1)].reverse\n      end\n      \n      doc, started = [], false\n      lines.each{|line|\n        if /^\\s*[#]/ =~ line\n          doc << line\n          started = true\n        elsif started\n          break\n        end \n      }\n      \n      doc = reverse ? doc.reverse[0..-1] : doc[0..-1]\n      doc = doc.join(\"\\n\")\n      doc.gsub(/^\\s*[#] ?/, \"\")\n    end"
        ],
        [
            "def select(fields)\n      if (fields == []) || (fields.nil?)\n        fields = [:_id]\n      end\n      clone.tap {|q| q.options[:fields] = fields}\n    end"
        ],
        [
            "def set_pagination_info(page_no, page_size, record_count)\n      @current_page = page_no\n      @per_page = page_size\n      @total_count = record_count\n      @total_pages = (record_count / page_size.to_f).ceil\n    \n      extend PaginationMethods\n\n      self\n    end"
        ],
        [
            "def echo_uploads_data=(data)\n      parsed = JSON.parse Base64.decode64(data)\n      # parsed will look like:\n      # { 'attr1' => [ {'id' => 1, 'key' => 'abc...'} ] }\n      unless parsed.is_a? Hash\n        raise ArgumentError, \"Invalid JSON structure in: #{parsed.inspect}\"\n      end\n      parsed.each do |attr, attr_data|\n        # If the :map option was passed, there may be multiple variants of the uploaded\n        # file. Even if not, attr_data is still a one-element array.\n        unless attr_data.is_a? Array\n          raise ArgumentError, \"Invalid JSON structure in: #{parsed.inspect}\"\n        end\n        attr_data.each do |variant_data|\n          unless variant_data.is_a? Hash\n            raise ArgumentError, \"Invalid JSON structure in: #{parsed.inspect}\"\n          end\n          if meta = ::EchoUploads::File.where(\n            id: variant_data['id'], key: variant_data['key'], temporary: true\n          ).first\n            if send(\"#{attr}_tmp_metadata\").nil?\n              send \"#{attr}_tmp_metadata=\", []\n            end\n            send(\"#{attr}_tmp_metadata\") << meta\n          end\n        end\n      end\n    end"
        ],
        [
            "def follower_of?(model)\n      0 < self.followees.by_model(model).limit(1).count * model.followers.by_model(self).limit(1).count\n    end"
        ],
        [
            "def follow(*models)\n      models.each do |model|\n        unless model == self or self.follower_of?(model) or model.followee_of?(self) or self.cannot_follow.include?(model.class.name) or model.cannot_followed.include?(self.class.name)\n          model.followers.create!(:f_type => self.class.name, :f_id => self.id.to_s)\n          model.followed_history << self.class.name + '_' + self.id.to_s\n          model.save\n          self.followees.create!(:f_type => model.class.name, :f_id => model.id.to_s)\n          self.follow_history << model.class.name + '_' + model.id.to_s\n          self.save\n        end\n      end\n    end"
        ],
        [
            "def unfollow(*models)\n      models.each do |model|\n        unless model == self or !self.follower_of?(model) or !model.followee_of?(self) or self.cannot_follow.include?(model.class.name) or model.cannot_followed.include?(self.class.name)\n          model.followers.by_model(self).first.destroy\n          self.followees.by_model(model).first.destroy\n        end\n      end\n    end"
        ],
        [
            "def ever_follow\n      follow = []\n      self.follow_history.each do |h|\n        follow << h.split('_')[0].constantize.find(h.split('_')[1])\n      end\n      follow\n    end"
        ],
        [
            "def pop(non_block = false)\n      @pop_mutex.lock do\n        @mutex.synchronize do\n          if empty?\n            return if closed?\n            raise ThreadError if non_block\n            @mutex.unlock\n            @waiter.wait\n            @mutex.lock\n            return if closed?\n          end\n          @items.shift\n        end\n      end\n    end"
        ],
        [
            "def lookup(key, opts={}, &block)\n      unless addr = cache.has?(key)\n        addr = link.send('lookup', key, opts, &block)\n        cache.save(key, addr)\n      end\n      yield addr if block_given?\n      addr\n    end"
        ],
        [
            "def announce(key, port, opts={}, &block)\n      payload = [key,port]\n      link.send 'announce', payload, opts, &block\n      if config.auto_announce\n        periodically(config.auto_announce_interval) do\n          link.send 'announce', payload, opts, &block\n        end\n      end\n    end"
        ],
        [
            "def _logical_operator(delegated, *conditions)\n      unless conditions.all?{|c|conditionable? c}\n        raise TypeError, 'wrong object for condition'\n      end\n\n      ->v{\n        conditions.__send__(delegated) {|condition|\n          _valid? condition, v\n        }\n      }\n    end"
        ],
        [
            "def post_with_signature(opts)\n      path = opts.fetch(:path)\n      payload = opts.fetch(:payload)\n      secret = opts.fetch(:secret)\n\n      post path, {payload: payload}, generate_secret_header(secret, URI.encode_www_form(payload: payload))\n    end"
        ],
        [
            "def get_height(img)\n      new_height = (img.height / (img.width.to_f / self.width.to_f)).ceil\n    end"
        ],
        [
            "def create_color_string\n      (0...img.height).map do |y|\n        (0...img.width).map do |x|\n          pix = self.img[x,y]\n          pix_vals = [r(pix), g(pix), b(pix)]\n          find_closest_term_color(pix_vals)\n        end\n      end.join\n    end"
        ],
        [
            "def find_closest_term_color(pixel_values)\n      color = \"\"\n      lil_dist = 195075\n      @@palette.each do |col_name, col_values|\n        dist = find_distance(col_values, pixel_values)\n        if dist < lil_dist\n          lil_dist = dist\n          color = col_name\n        end\n      end\n      color\n    end"
        ],
        [
            "def draw_line(pixels)\n      pix_line = \"\"\n      pixels.each do |pixel|\n        pix_line = pix_line + \"  \".colorize(:background => find_color(pixel))\n      end\n      puts pix_line\n    end"
        ],
        [
            "def tree\n      @tree and return @tree \n      @tree = []\n      file_set = version_files\n\n      while child = file_set.shift\n        tree << child #if child.dir?\n\n        if child.type == \"dir\"\n          file_set.unshift( github.where(child.path).contents ).flatten!\n        end\n      end\n\n      @tree\n    end"
        ],
        [
            "def search(options = {})\n      self.date = options[:date] || date\n      self.hd = options[:hd] || hd\n      response = HTTParty.get(DEFAULT_URL, query: attributes)\n      handle_response(response)\n    end"
        ],
        [
            "def process_timeout(timeout)\n      unless timeout == nil\n        raise TypeError, \"'timeout' must be nil or a Numeric\" unless timeout.is_a?(Numeric)\n        raise ArgumentError, \"'timeout' must not be negative\" if timeout.negative?\n      end\n      timeout = nil if timeout == Float::INFINITY\n      timeout\n    end"
        ],
        [
            "def find_or_create_authorization_by_note(note)\n      found_auth = list_authorizations.find {|auth| auth.note == note}\n      if found_auth\n        found_auth.token\n      else\n        create_authorization(note)\n      end\n    end"
        ],
        [
            "def send(type, payload, opts = {}, &block)\n      res = http_send type, Oj.dump({\"rid\" => uuid, \"data\" => payload})\n      block.call(res) if block\n      res\n    end"
        ],
        [
            "def jquids_includes(options = {})\n\n      # Set the format for the datepickers\n      Jquids.format = options[:format] if options.has_key?(:format)\n      html_out = \"\"\n\n      if options.has_key?(:style)\n        html_out <<  stylesheet_link_tag(jq_ui_stylesheet(options[:style])) + \"\\n\" unless options[:style] == nil or options[:style] == :none or options[:style] == false\n      else\n        html_out << stylesheet_link_tag(jq_ui_stylesheet) + \"\\n\"\n      end\n\n      jq_vrs = options.has_key?(:jQuery) ? options[:jQuery] : Jquids::JQVersions.last\n      ui_vrs = options.has_key?(:jQueryUI) ? options[:jQueryUI] : Jquids::UIVersions.last\n      trtp_vrs = options.has_key?(:TRTimepicker) ? options[:TRTimepicker] : :none\n\n      # A little bit of css of the timepicker, and it is not added if the\n      # timepicker javascript file is not included\n      unless trtp_vrs == :none or trtp_vrs == false or trtp_vrs == nil\n        html_out << \"<style type=\\\"text/css\\\">.ui-timepicker-div .ui-widget-header{margin-bottom:8px;}.ui-timepicker-div dl{text-align:left;}.ui-timepicker-div dl dt{height:25px;}.ui-timepicker-div dl dd{margin:-25px 0 10px 65px;}.ui-timepicker-div td{font-size:90%;}</style>\\n\"\n      end\n\n      html_out << javascript_include_tag(jq_ui_javascripts(jq_vrs, ui_vrs, trtp_vrs)) + \"\\n\"\n\n      options[:datepicker_options] ||= {}\n      \n      # Some opiniated defaults (basically an attempt to make the jQuery\n      # datepicker similar to the calendar_date_select with out making\n      # modifications or having local dependencies)\n      options[:datepicker_options][:showOtherMonths] = true if options[:datepicker_options][:showOtherMonths].nil?\n      options[:datepicker_options][:selectOtherMonths] = true if options[:datepicker_options][:selectOtherMonths].nil?\n      options[:datepicker_options][:changeMonth] = true if options[:datepicker_options][:changeMonth].nil?\n      options[:datepicker_options][:changeYear] = true if options[:datepicker_options][:changeYear].nil?\n      options[:datepicker_options][:dateFormat] = Jquids.format[:js_date]\n\n      Jquids.jquids_process_options(options)\n\n      # Decides whether the 'to_json' method exists (part of rails 3) or if the\n      # gem needs to us the json gem\n      datepicker_options = \n        if options[:datepicker_options].respond_to?(:to_json)\n            options.delete(:datepicker_options).to_json\n        else\n          begin\n            JSON.unparse(options.delete(:datepicker_options))\n          rescue\n            \"\"\n          end\n        end\n\n      html_out << '<script type=\"text/javascript\">$.datepicker.setDefaults(' + datepicker_options + ');'\n\n\n      unless trtp_vrs == :none or trtp_vrs == false or trtp_vrs == nil\n        options[:timepicker_options] ||= {}\n        \n        # Some opiniated defaults (basically an attempt to make the jQuery\n        # datepicker similar to the calendar_date_select with out making\n        # modifications or having local dependencies)\n        # Sets the time format based off of the current format\n        options[:timepicker_options][:ampm] = Jquids.format[:ampm]\n        options[:timepicker_options][:timeFormat] = Jquids.format[:tr_js_time]\n\n        timepicker_options = \n          if options[:timepicker_options].respond_to?(:to_json)\n              options.delete(:timepicker_options).to_json\n          else\n            begin\n              JSON.unparse(options.delete(:timepicker_options))\n            rescue\n              \"\"\n            end\n          end\n\n        html_out << '$.timepicker.setDefaults(' + timepicker_options + ');'\n      end\n\n      # A minified version of this javascript.\n      #   <script type=\"text/javascript\">\n      #     $(document).ready(function(){\n      #       $(\".jquids_dp\").each(function(){\n      #         var s = $(this).attr(\"data-jquipicker\");\n      #         $(this).attr(\"data-jquipicker\") ? $(this).datepicker(JSON.parse(s)) : $(this).datepicker();\n      #       });\n      #       $(\".jquids_tp\").each(function(){\n      #         var s = $(this).attr(\"data-jquipicker\");\n      #         $(this).attr(\"data-jquipicker\") ? $(this).timepicker(JSON.parse(s)) : $(this).timepicker();\n      #       });\n      #       $(\".jquids_dtp\").each(function(){\n      #         var s=$(this).attr(\"data-jquipicker\");\n      #         $(this).attr(\"data-jquipicker\")?$(this).datetimepicker(JSON.parse(s)) : $(this).datetimepicker()\n      #       })\n      #     });\n      #   </script>\n      #\n      # Used to parse out options for each datepicker instance\n      html_out << '$(document).ready(function(){$(\".jquids_dp\").each(function(){var s=$(this).attr(\"data-jquipicker\");$(this).attr(\"data-jquipicker\")?$(this).datepicker(JSON.parse(s)):$(this).datepicker()});$(\".jquids_tp\").each(function(){var s=$(this).attr(\"data-jquipicker\");$(this).attr(\"data-jquipicker\")?$(this).timepicker(JSON.parse(s)):$(this).timepicker()});$(\".jquids_dtp\").each(function(){var s=$(this).attr(\"data-jquipicker\");$(this).attr(\"data-jquipicker\")?$(this).datetimepicker(JSON.parse(s)):$(this).datetimepicker()})});</script>'\n\n      if html_out.respond_to?(:html_safe)\n        return html_out.html_safe\n      else\n        return html_out\n      end\n    end"
        ],
        [
            "def method_missing method, *args, &block\n      if args.empty?\n        @config.send(method)\n      else\n        @config.send(\"#{method}=\", args.first)\n      end\n    end"
        ],
        [
            "def to_s\n      today = arabno_to_hindi(day)  + \" \"\n      today = today + HijriUmmAlqura::MONTHNAMES[month] + \" \"\n      today = today + arabno_to_hindi(year) + \" \u0647\u0640\" \n    end"
        ],
        [
            "def jd(date = self)\n      index = (12 * (date.year - 1)) + date.month - 16260\n      mcjdn = date.day + HijriUmmAlqura::UMMALQURA_DAT[index - 1] - 1\n      mcjdn = mcjdn + 2400000 - 0.5\n      return mcjdn\n    end"
        ],
        [
            "def gd(date = self)        \n      j_date = jd(date)\n      g_date = HijriUmmAlqura.jd_to_gd(j_date)\n      return g_date\n    end"
        ],
        [
            "def add(date = self, offset, period)\n      y = period == 'y' ? (date.year + offset) : date.year \n      m = period == 'm' ? (month_of_year(date.year, date.month) + offset) : month_of_year(date.year, date.month) \n      d = date.day\n      begin\n        if (period == 'd' || period == 'w') \n          week_days = period == 'w' ? 7 : 1\n          j_date = jd\n          j_date = j_date + offset * week_days \n          result = HijriUmmAlqura.jd(j_date)\n          return result\n        elsif (period == 'm') \n          rys = resync_year_month(y, m)\n          y  = rys[0]\n          m = rys[1]\n          return HijriUmmAlqura.format_date([y, m, d])\n        elsif (period == 'y') \n          return HijriUmmAlqura.format_date([y, m, d])\n        end\n      rescue Exception => e  \n        puts \"Exception details: #{e.class} #{e.message}\" \n      end\n    end"
        ],
        [
            "def + (n)\n      case n\n      when Numeric then  \n        j_date = jd + n * 1 \n        result = HijriUmmAlqura.jd(j_date)\n        return result\n      end\n      raise TypeError, 'expected numeric'\n    end"
        ],
        [
            "def raise(exception = nil)\n      exception = case\n      when exception == nil then StandardError.new\n      when exception.is_a?(Exception) then exception\n      when Exception >= exception then exception.new\n      else\n        Kernel.raise(TypeError, \"'exception' must be nil or an instance of or descendant of Exception\")\n      end\n      @mutex.synchronize do\n        Kernel.raise(Complete) if @complete\n        @complete = true\n        @exception = exception\n        @waiter.resume_all_indefinitely\n      end\n      nil\n    end"
        ],
        [
            "def to_hash\n      index_hash = Hash.new\n      index_hash[\"json_claz\"] = self.class.name\n      index_hash[\"creationDate\"] = creationDate\n      index_hash[\"admin\"] = admin\n      index_hash[\"type\"] = type\n      index_hash[\"password\"] = password\n      index_hash[\"name\"] = name\n      index_hahs[\"mail\"] = mail\n      index_hash[\"displayName\"] = displayName\n      index_hash[\"lastModified\"] = lastModified\n      index_hash[\"active\"] = active\n      index_hash[\"some_msg\"] = some_msg\n      index_hash\n    end"
        ],
        [
            "def site=(site)\n      if site != self.site\n        @site = site\n        uri = URI.parse(site)\n        @user = URI.decode(uri.user) if(uri.user)\n        @password = URI.decode(uri.password) if(uri.password)\n        @resource_class = self.send(:create_resource_class)\n      end\n      @site\n    end"
        ],
        [
            "def find(*args)\n      scope = args.slice!(0)\n      options = args.slice!(0) || {}\n      @resource_class.find(scope, options)\n    end"
        ],
        [
            "def create_resource_class\n      raise \"Please set the site for #{self} class.\" unless(self.site)\n      created_class = Class.new(MingleResource)\n      created_class.format = :xml\n      setup_class(created_class)\n      created_class\n    end"
        ],
        [
            "def run!\n    # load agent from config or cli opts\n    agent = load_agent()\n\n    fix_ownership()\n\n    # debug mode, stay in front\n    if @config[:debug] then\n      Logging::Logger.root.add_appenders(\"stdout\")\n      return start_websocket_client()\n    end\n\n    # start daemon\n    validate_argv()\n    daemon_dir = Bixby.path(\"var\")\n    ensure_state_dir(daemon_dir)\n    close_fds()\n\n    daemon_opts = {\n      :dir        => daemon_dir,\n      :dir_mode   => :normal,\n      :log_output => true,\n      :stop_proc  => lambda { logger.info \"Agent shutdown on service stop command\" }\n    }\n\n    Daemons.run_proc(\"bixby-agent\", daemon_opts) do\n      Logging.logger.root.clear_appenders\n      start_websocket_client()\n    end\n  end"
        ],
        [
            "def start_websocket_client\n    # make sure log level is still set correctly here\n    Bixby::Log.setup_logger(:level => Logging.appenders[\"file\"].level)\n    logger.info \"Started Bixby Agent #{Bixby::Agent::VERSION}\"\n    @client = Bixby::WebSocket::Client.new(Bixby.agent.manager_ws_uri, AgentHandler)\n    trap_signals()\n    @client.start\n  end"
        ],
        [
            "def fix_ownership\n    return if Process.uid != 0\n    begin\n      uid = Etc.getpwnam(\"bixby\").uid\n      gid = Etc.getgrnam(\"bixby\").gid\n      # user/group exists, chown\n      File.chown(uid, gid, Bixby.path(\"var\"), Bixby.path(\"etc\"))\n    rescue ArgumentError\n    end\n  end"
        ]
    ]
}